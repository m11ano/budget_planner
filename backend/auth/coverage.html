
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/m11ano/budget_planner/backend/auth/cmd/main.go (0.0%)</option>
				
				<option value="file1">github.com/m11ano/budget_planner/backend/auth/internal/app/config/config.go (0.0%)</option>
				
				<option value="file2">github.com/m11ano/budget_planner/backend/auth/internal/app/errors/app_error.go (0.0%)</option>
				
				<option value="file3">github.com/m11ano/budget_planner/backend/auth/internal/app/errors/chain_error.go (0.0%)</option>
				
				<option value="file4">github.com/m11ano/budget_planner/backend/auth/internal/app/errors/grpc.go (0.0%)</option>
				
				<option value="file5">github.com/m11ano/budget_planner/backend/auth/internal/app/errors/helpers.go (0.0%)</option>
				
				<option value="file6">github.com/m11ano/budget_planner/backend/auth/internal/app/errors/json_struct.go (0.0%)</option>
				
				<option value="file7">github.com/m11ano/budget_planner/backend/auth/internal/app/errors/mark_error.go (0.0%)</option>
				
				<option value="file8">github.com/m11ano/budget_planner/backend/auth/internal/app/fxboot/backend_app.go (0.0%)</option>
				
				<option value="file9">github.com/m11ano/budget_planner/backend/auth/internal/app/fxboot/fxboot.go (0.0%)</option>
				
				<option value="file10">github.com/m11ano/budget_planner/backend/auth/internal/app/fxboot/providing/backoff.go (0.0%)</option>
				
				<option value="file11">github.com/m11ano/budget_planner/backend/auth/internal/app/fxboot/providing/db_clients.go (0.0%)</option>
				
				<option value="file12">github.com/m11ano/budget_planner/backend/auth/internal/app/fxboot/providing/delivery_grpc.go (0.0%)</option>
				
				<option value="file13">github.com/m11ano/budget_planner/backend/auth/internal/app/fxboot/providing/fx_logger.go (0.0%)</option>
				
				<option value="file14">github.com/m11ano/budget_planner/backend/auth/internal/app/fxboot/providing/logger.go (0.0%)</option>
				
				<option value="file15">github.com/m11ano/budget_planner/backend/auth/internal/delivery/grpc/controller/controller.go (0.0%)</option>
				
				<option value="file16">github.com/m11ano/budget_planner/backend/auth/internal/delivery/grpc/controller/login.go (0.0%)</option>
				
				<option value="file17">github.com/m11ano/budget_planner/backend/auth/internal/delivery/grpc/controller/logout.go (0.0%)</option>
				
				<option value="file18">github.com/m11ano/budget_planner/backend/auth/internal/delivery/grpc/controller/refresh.go (0.0%)</option>
				
				<option value="file19">github.com/m11ano/budget_planner/backend/auth/internal/delivery/grpc/controller/register.go (0.0%)</option>
				
				<option value="file20">github.com/m11ano/budget_planner/backend/auth/internal/delivery/grpc/controller/who_i_am.go (0.0%)</option>
				
				<option value="file21">github.com/m11ano/budget_planner/backend/auth/internal/delivery/grpc/interceptor_auth.go (0.0%)</option>
				
				<option value="file22">github.com/m11ano/budget_planner/backend/auth/internal/delivery/grpc/interceptor_errors.go (0.0%)</option>
				
				<option value="file23">github.com/m11ano/budget_planner/backend/auth/internal/delivery/grpc/interceptor_logger.go (0.0%)</option>
				
				<option value="file24">github.com/m11ano/budget_planner/backend/auth/internal/delivery/grpc/interceptor_request_id.go (0.0%)</option>
				
				<option value="file25">github.com/m11ano/budget_planner/backend/auth/internal/delivery/grpc/interceptor_request_ip.go (0.0%)</option>
				
				<option value="file26">github.com/m11ano/budget_planner/backend/auth/internal/delivery/grpc/interceptor_validate.go (0.0%)</option>
				
				<option value="file27">github.com/m11ano/budget_planner/backend/auth/internal/delivery/grpc/server.go (0.0%)</option>
				
				<option value="file28">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity/account.go (0.0%)</option>
				
				<option value="file29">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity/init_validation.go (0.0%)</option>
				
				<option value="file30">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity/session.go (0.0%)</option>
				
				<option value="file31">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/init.go (0.0%)</option>
				
				<option value="file32">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/repository/pg/account.go (0.0%)</option>
				
				<option value="file33">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/repository/pg/account/commands.go (0.0%)</option>
				
				<option value="file34">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/repository/pg/account/queries.go (0.0%)</option>
				
				<option value="file35">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/repository/pg/account/repository.go (0.0%)</option>
				
				<option value="file36">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/repository/pg/session.go (0.0%)</option>
				
				<option value="file37">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/repository/pg/session/commands.go (0.0%)</option>
				
				<option value="file38">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/repository/pg/session/queries.go (0.0%)</option>
				
				<option value="file39">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/repository/pg/session/repository.go (0.0%)</option>
				
				<option value="file40">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase/account/commands.go (65.3%)</option>
				
				<option value="file41">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase/account/helpers.go (100.0%)</option>
				
				<option value="file42">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase/account/impl.go (100.0%)</option>
				
				<option value="file43">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase/account/queries.go (84.8%)</option>
				
				<option value="file44">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase/auth/commands.go (71.7%)</option>
				
				<option value="file45">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase/auth/helpers.go (100.0%)</option>
				
				<option value="file46">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase/auth/impl.go (100.0%)</option>
				
				<option value="file47">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase/auth/queries.go (83.3%)</option>
				
				<option value="file48">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase/facade.go (0.0%)</option>
				
				<option value="file49">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase/mocks/account_repository.go (0.0%)</option>
				
				<option value="file50">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase/mocks/account_usecase.go (0.0%)</option>
				
				<option value="file51">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase/mocks/auth_usecase.go (0.0%)</option>
				
				<option value="file52">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase/mocks/session_repository.go (0.0%)</option>
				
				<option value="file53">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase/mocks/session_usecase.go (0.0%)</option>
				
				<option value="file54">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase/session/commands.go (82.9%)</option>
				
				<option value="file55">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase/session/helpers.go (100.0%)</option>
				
				<option value="file56">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase/session/impl.go (100.0%)</option>
				
				<option value="file57">github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase/session/queries.go (100.0%)</option>
				
				<option value="file58">github.com/m11ano/budget_planner/backend/auth/internal/infra/db/migrations.go (0.0%)</option>
				
				<option value="file59">github.com/m11ano/budget_planner/backend/auth/internal/infra/loghandler/context.go (0.0%)</option>
				
				<option value="file60">github.com/m11ano/budget_planner/backend/auth/internal/infra/loghandler/handler.go (0.0%)</option>
				
				<option value="file61">github.com/m11ano/budget_planner/backend/auth/pkg/auth/access_token.go (0.0%)</option>
				
				<option value="file62">github.com/m11ano/budget_planner/backend/auth/pkg/auth/auth_data.go (0.0%)</option>
				
				<option value="file63">github.com/m11ano/budget_planner/backend/auth/pkg/auth/claims.go (0.0%)</option>
				
				<option value="file64">github.com/m11ano/budget_planner/backend/auth/pkg/auth/context.go (0.0%)</option>
				
				<option value="file65">github.com/m11ano/budget_planner/backend/auth/pkg/backoff/controller.go (0.0%)</option>
				
				<option value="file66">github.com/m11ano/budget_planner/backend/auth/pkg/backoff/heap.go (0.0%)</option>
				
				<option value="file67">github.com/m11ano/budget_planner/backend/auth/pkg/backoff/options.go (0.0%)</option>
				
				<option value="file68">github.com/m11ano/budget_planner/backend/auth/pkg/backoff/session.go (0.0%)</option>
				
				<option value="file69">github.com/m11ano/budget_planner/backend/auth/pkg/dbhelper/helpers.go (72.7%)</option>
				
				<option value="file70">github.com/m11ano/budget_planner/backend/auth/pkg/emailnormalize/emailnormalize.go (0.0%)</option>
				
				<option value="file71">github.com/m11ano/budget_planner/backend/auth/pkg/pgclient/impl.go (98.5%)</option>
				
				<option value="file72">github.com/m11ano/budget_planner/backend/auth/pkg/pgclient/mock.go (0.0%)</option>
				
				<option value="file73">github.com/m11ano/budget_planner/backend/auth/pkg/pgclient/test_connection.go (100.0%)</option>
				
				<option value="file74">github.com/m11ano/budget_planner/backend/auth/pkg/pgclient/tracer.go (0.0%)</option>
				
				<option value="file75">github.com/m11ano/budget_planner/backend/auth/pkg/prettylog/prettylog.go (71.0%)</option>
				
				<option value="file76">github.com/m11ano/budget_planner/backend/auth/pkg/proto_pb/access_claims/access_claims.pb.go (0.0%)</option>
				
				<option value="file77">github.com/m11ano/budget_planner/backend/auth/pkg/proto_pb/access_claims/access_claims.pb.validate.go (0.0%)</option>
				
				<option value="file78">github.com/m11ano/budget_planner/backend/auth/pkg/proto_pb/auth_service/service.pb.go (0.0%)</option>
				
				<option value="file79">github.com/m11ano/budget_planner/backend/auth/pkg/proto_pb/auth_service/service.pb.validate.go (0.0%)</option>
				
				<option value="file80">github.com/m11ano/budget_planner/backend/auth/pkg/proto_pb/auth_service/service_grpc.pb.go (0.0%)</option>
				
				<option value="file81">github.com/m11ano/budget_planner/backend/auth/pkg/validation/format_errors.go (0.0%)</option>
				
				<option value="file82">github.com/m11ano/budget_planner/backend/auth/pkg/validation/validator.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "github.com/m11ano/budget_planner/backend/auth/internal/app"
        "github.com/m11ano/budget_planner/backend/auth/internal/app/config"
        "github.com/m11ano/budget_planner/backend/auth/internal/app/fxboot"
        "go.uber.org/fx"
)

func main() <span class="cov0" title="0">{
        cfg := config.LoadConfig("configs/base.yml", "configs/base.local.yml")

        appOptions := fxboot.BackendAppGetOptionsMap(app.IDBackend, cfg)

        app := fx.New(
                fxboot.OptionsMapToSlice(appOptions)...,
        )

        app.Run()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "log"
        "os"

        "github.com/ilyakaznacheev/cleanenv"
)

type Config struct {
        BackendApp struct {
                Name    string `yaml:"name" env:"BACKEND_APP_NAME" env-default:"backend"`
                Version string `yaml:"version" env:"BACKEND_APP_VERSION" env-default:"1.0.0"`
                Base    struct {
                        StartTimeoutSec int  `yaml:"start_timeout_sec" env:"BACKEND_APP_BASE_START_TIMEOUT_SEC" env-default:"10"`
                        StopTimeoutSec  int  `yaml:"stop_timeout_sec" env:"BACKEND_APP_BASE_STOP_TIMEOUT_SEC" env-default:"2"`
                        IsProd          bool `yaml:"is_prod" env:"BACKEND_APP_BASE_IS_PROD" env-default:"false"`
                        UseFxLogger     bool `yaml:"use_fx_logger" env:"BACKEND_APP_BASE_USE_FX_LOGGER" env-default:"true"`
                        UseLogger       bool `yaml:"use_logger" env:"BACKEND_APP_BASE_USE_LOGGER" env-default:"true"`
                        LogSQLQueries   bool `yaml:"log_sql_queries" env:"BACKEND_APP_BASE_LOG_SQL_QUERIES" env-default:"true"`
                        LogHTTP         bool `yaml:"log_http" env:"BACKEND_APP_BASE_LOG_HTTP" env-default:"true"`
                } `yaml:"base"`
                GRPC struct {
                        Port       int  `yaml:"port" env:"BACKEND_APP_GRPC_PORT" env-default:"50051"`
                        LogQueries bool `yaml:"log_queries" env:"BACKEND_APP_GRPC_LOG_QUERIES" env-default:"false"`
                } `yaml:"grpc"`
        } `yaml:"backend_app"`
        Postgres struct {
                MaxAttempts         int    `yaml:"max_attempts" env:"POSTGRES_MAX_ATTEMPTS" env-default:"3"`
                AttemptSleepSeconds int    `yaml:"attempt_sleep_seconds" env:"POSTGRES_ATTEMPT_SLEEP_SECONDS" env-default:"1"`
                MigrationsPath      string `yaml:"migrations_path" env:"POSTGRES_MIGRATIONS_PATH" env-default:"migrations"`
                Master              struct {
                        DSN string `yaml:"dsn" env:"POSTGRES_MASTER_DSN"`
                } `yaml:"master"`
        } `yaml:"postgres"`
        Auth struct {
                AccessTokenLifetimeSec int `yaml:"access_token_lifetime_sec" env:"AUTH_ACCESS_TOKEN_LIFETIME_SEC" env-default:"300"`
                // nolint
                RefreshTokenLifetimeHrs int    `yaml:"refresh_token_lifetime_hours" env:"AUTH_REFRESH_TOKEN_LIFETIME_HRS" env-default:"720"`
                JwtAccessSecret         string `yaml:"jwt_access_secret" env:"AUTH_JWT_ACCESS_SECRET"`
                JwtRefreshSecret        string `yaml:"jwt_refresh_secret" env:"AUTH_JWT_REFRESH_SECRET"`
        }
}

func LoadConfig(files ...string) Config <span class="cov0" title="0">{
        var Config Config

        for _, file := range files </span><span class="cov0" title="0">{
                if _, err := os.Stat(file); err == nil </span><span class="cov0" title="0">{
                        err := cleanenv.ReadConfig(file, &amp;Config)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal("config file error ", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return Config</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package errors contains app error struct and helpers
package errors

import (
        "errors"
        "fmt"
        "log/slog"
        "maps"
        "strings"
)

type appErrorDetail struct {
        Value    any
        IsHidden bool
}

// AppError - структура для оборачивания сторонних ошибок в цепочку вызовов и хранения метаданных
type AppError struct {
        parent   error
        is       error
        chainMsg []string
        errMsg   string
        hints    []string
        meta     ErrorMeta
        details  map[string]appErrorDetail
}

// ErrorMeta - структура для хранения метаданных
type ErrorMeta struct {
        Code     errorCode
        TextCode string
}

// NewError - создает новую ошибку
func NewError(msg string, code errorCode, textCode string, hints []string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                chainMsg: []string{msg},
                errMsg:   msg,
                hints:    hints,
                meta: ErrorMeta{
                        Code:     code,
                        TextCode: textCode,
                },
        }
}</span>

// Copy - создает копию ошибки
func (e *AppError) Copy() *AppError <span class="cov0" title="0">{
        cp := &amp;AppError{
                parent: e,
                is:     e.is,
                errMsg: e.errMsg,
                hints:  e.hints,
                meta: ErrorMeta{
                        Code:     e.meta.Code,
                        TextCode: e.meta.TextCode,
                },
                details: nil,
        }

        if e.chainMsg != nil </span><span class="cov0" title="0">{
                cp.chainMsg = make([]string, len(e.chainMsg))
                copy(cp.chainMsg, e.chainMsg)
        }</span>

        <span class="cov0" title="0">if e.details != nil </span><span class="cov0" title="0">{
                cp.details = make(map[string]appErrorDetail, len(e.details))
                maps.Copy(cp.details, e.details)
        }</span>

        <span class="cov0" title="0">return cp</span>
}

func (e *AppError) chain(chainMsg string) *AppError <span class="cov0" title="0">{
        cp := e.Copy()
        if chainMsg != "" </span><span class="cov0" title="0">{
                cp.chainMsg = append(cp.chainMsg, fmt.Sprintf("[%s]", chainMsg))
        }</span>

        <span class="cov0" title="0">return cp</span>
}

// WithParent - создает копию ошибки с измененной ссылкой на родительскую ошибку и цепочку вызовов
func (e *AppError) WithParent(err error) *AppError <span class="cov0" title="0">{
        cp := e.Copy()

        cp.parent = err
        cp.is = e
        curChainMsh := e.chainMsg
        cp.chainMsg = make([]string, 0, len(curChainMsh)+1)
        cp.chainMsg = append(cp.chainMsg, err.Error())
        cp.chainMsg = append(cp.chainMsg, curChainMsh...)

        return cp
}</span>

// WithWrap - создает обертку для текущей ошибки на основе переданной ошибки
func (e *AppError) WithWrap(err error) *AppError <span class="cov0" title="0">{
        cp := e.Copy()

        cp.is = err
        cp.chainMsg = make([]string, 0, len(e.chainMsg)+1)
        cp.chainMsg = append(cp.chainMsg, e.chainMsg...)

        newChainMsg := getChainMsg(err)
        if newChainMsg != nil </span><span class="cov0" title="0">{
                cp.chainMsg = append(cp.chainMsg, newChainMsg...)
        }</span>

        <span class="cov0" title="0">if newErrMsg, ok := NearestErrMsg(err); ok </span><span class="cov0" title="0">{
                cp.errMsg = newErrMsg
        }</span> else<span class="cov0" title="0"> {
                cp.errMsg = err.Error()
        }</span>

        <span class="cov0" title="0">var appErr *AppError
        if errors.As(err, &amp;appErr) </span><span class="cov0" title="0">{
                cp.meta = appErr.meta
        }</span>

        <span class="cov0" title="0">return cp</span>
}

// Is - реализация интерфейса error, проверка идентификации
func (e *AppError) Is(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if e == err || e.is == err </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// Unwrap - реализация интерфейса error, возвращает родительскую ошибку
func (e *AppError) Unwrap() error <span class="cov0" title="0">{
        return e.parent
}</span>

// Error - реализация интерфейса error, возвращает строку с цепочкой вызовов
func (e *AppError) Error() string <span class="cov0" title="0">{
        var bldr strings.Builder
        for i := len(e.chainMsg) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                bldr.WriteString(e.chainMsg[i])
                if i != 0 </span><span class="cov0" title="0">{
                        bldr.WriteString(" : ")
                }</span>
        }

        <span class="cov0" title="0">return bldr.String()</span>
}

// Extend - наследовать ошибку без цепочки вызовов
func (e *AppError) Extend(errMsg string) *AppError <span class="cov0" title="0">{
        newErr := e.Copy()

        newErr.errMsg = errMsg
        newErr.chainMsg = []string{errMsg}

        return newErr
}</span>

// ExtendWithChain - наследовать ошибку вместе с цепочкой
func (e *AppError) ExtendWithChain(errMsg string) *AppError <span class="cov0" title="0">{
        newErr := e.Copy()

        newErr.errMsg = errMsg
        newErr.chainMsg = append(newErr.chainMsg, errMsg)

        return newErr
}</span>

// WithMeta - создает копию ошибки с измененным метаданными
func (e *AppError) WithMeta(meta ErrorMeta) *AppError <span class="cov0" title="0">{
        newErr := e.Copy()

        newErr.meta = meta

        return newErr
}</span>

// WithCode - создает копию ошибки с измененным кодом
func (e *AppError) WithCode(code errorCode) *AppError <span class="cov0" title="0">{
        newErr := e.Copy()

        newErr.meta.Code = code

        return newErr
}</span>

// WithTextCode - создает копию ошибки с измененным текстовым кодом
func (e *AppError) WithTextCode(textCode string) *AppError <span class="cov0" title="0">{
        newErr := e.Copy()

        newErr.meta.TextCode = textCode

        return newErr
}</span>

// WithDetail - создает копию ошибки с измененным детализацией
func (e *AppError) WithDetail(key string, isHidden bool, value any) *AppError <span class="cov0" title="0">{
        newErr := e.Copy()

        if newErr.details == nil </span><span class="cov0" title="0">{
                newErr.details = make(map[string]appErrorDetail, 1)
        }</span>

        <span class="cov0" title="0">newErr.details[key] = appErrorDetail{
                Value:    value,
                IsHidden: isHidden,
        }

        return newErr</span>
}

// WithHints - создает копию ошибки с измененными подсказками для пользователей
func (e *AppError) WithHints(hints ...string) *AppError <span class="cov0" title="0">{
        newErr := e.Copy()

        newErr.hints = hints

        return newErr
}</span>

// Hints - получить подсказки для пользователей
func (e *AppError) Hints() []string <span class="cov0" title="0">{
        return e.hints
}</span>

// HintsStr - получить подсказки для пользователей в виде одной строки
func (e *AppError) HintsStr(delimiter string) string <span class="cov0" title="0">{
        return strings.Join(e.hints, delimiter)
}</span>

// Meta - получить метаданные ошибки
func (e *AppError) Meta() ErrorMeta <span class="cov0" title="0">{
        return e.meta
}</span>

// Detail - получить деталь ошибки
func (e *AppError) Detail(key string) (appErrorDetail, bool) <span class="cov0" title="0">{
        item, ok := e.details[key]

        return item, ok
}</span>

// Details - получить детали ошибки
func (e *AppError) Details(withHidden bool) map[string]any <span class="cov0" title="0">{
        result := make(map[string]any, len(e.details))

        for k, v := range e.details </span><span class="cov0" title="0">{
                if withHidden || !v.IsHidden </span><span class="cov0" title="0">{
                        result[k] = v.Value
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// ErrMsg - получить текст ошибки без цепочки вызовов
func (e *AppError) ErrMsg() string <span class="cov0" title="0">{
        return e.errMsg
}</span>

// LogValue - интерфейс для логеров
func (e *AppError) LogValue() slog.Value <span class="cov0" title="0">{
        jsonStruct := ToJSONStruct(e, true, false)
        return jsonStruct.ToSlogValue()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package errors

import (
        "fmt"
        "strings"
)

// ChainError - структура для оборачивания сторонних ошибок в цепочку вызовов
type ChainError struct {
        parent   error
        chainMsg []string
}

func (e *ChainError) copy() *ChainError <span class="cov0" title="0">{
        cp := &amp;ChainError{
                parent: e.parent,
        }

        if e.chainMsg != nil </span><span class="cov0" title="0">{
                cp.chainMsg = make([]string, len(e.chainMsg))
                copy(cp.chainMsg, e.chainMsg)
        }</span>

        <span class="cov0" title="0">return cp</span>
}

// Error - реализация интерфейса error, возвращает строку с цепочкой вызовов
func (e *ChainError) Error() string <span class="cov0" title="0">{
        var bldr strings.Builder
        for i := len(e.chainMsg) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                bldr.WriteString(e.chainMsg[i])
                if i != 0 </span><span class="cov0" title="0">{
                        bldr.WriteString(" : ")
                }</span>
        }

        <span class="cov0" title="0">return bldr.String()</span>
}

// Is - реализация интерфейса error, проверка идентификации
func (e *ChainError) Is(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if e == err </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// Unwrap - реализация интерфейса error, возвращает родительскую ошибку
func (e *ChainError) Unwrap() error <span class="cov0" title="0">{
        return e.parent
}</span>

// Chain - оборачивает ошибку в цепочку
func Chain(err error, chainMsg string) error <span class="cov0" title="0">{
        if appErr, ok := err.(*AppError); ok </span><span class="cov0" title="0">{
                return appErr.chain(chainMsg)
        }</span>

        <span class="cov0" title="0">if chainErr, ok := err.(*ChainError); ok </span><span class="cov0" title="0">{
                cp := chainErr.copy()
                if chainMsg != "" </span><span class="cov0" title="0">{
                        cp.chainMsg = append(cp.chainMsg, fmt.Sprintf("[%s]", chainMsg))
                }</span>
                <span class="cov0" title="0">return cp</span>
        }

        <span class="cov0" title="0">return &amp;ChainError{
                parent:   err,
                chainMsg: []string{fmt.Sprintf("[%s]", chainMsg)},
        }</span>
}

// Chainf - оборачивает ошибку в цепочку с форматированием
func Chainf(err error, format string, args ...interface{}) error <span class="cov0" title="0">{
        chainMsg := fmt.Sprintf(format, args...)

        return Chain(err, chainMsg)
}</span>

func getChainMsg(err error) []string <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if chainErr, ok := err.(*ChainError); ok </span><span class="cov0" title="0">{
                return chainErr.chainMsg
        }</span>

        <span class="cov0" title="0">if appErr, ok := err.(*AppError); ok </span><span class="cov0" title="0">{
                return appErr.chainMsg
        }</span>

        <span class="cov0" title="0">return []string{err.Error()}</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package errors

import (
        "cmp"
        "fmt"
        "slices"
        "strconv"
        "strings"

        "google.golang.org/genproto/googleapis/rpc/errdetails"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// ToGrpcStatus - преобразует error в GrpcStatus
func ToGrpcStatus(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">appErr, ok := ExtractError(err)
        if !ok </span><span class="cov0" title="0">{
                st, ok := status.FromError(err)
                if !ok </span><span class="cov0" title="0">{
                        return status.Error(codes.Unknown, err.Error())
                }</span>

                <span class="cov0" title="0">return st.Err()</span>
        }

        <span class="cov0" title="0">code := mapToGrpcCode(appErr.Meta().Code)
        textCode := appErr.Meta().TextCode

        meta := make(map[string]string)

        errMsg := textCode

        hints, ok := NearestHints(err)
        if ok </span><span class="cov0" title="0">{
                hitText := strings.Join(hints, "; ")

                if errMsg != "" </span><span class="cov0" title="0">{
                        errMsg = fmt.Sprintf("%s: %s", errMsg, hitText)
                }</span> else<span class="cov0" title="0"> {
                        errMsg = hitText
                }</span>

                <span class="cov0" title="0">for i, hint := range hints </span><span class="cov0" title="0">{
                        meta[fmt.Sprintf("hint_%d", i)] = hint
                }</span>
        }

        <span class="cov0" title="0">details := appErr.Details(false)
        for k, v := range details </span><span class="cov0" title="0">{
                var value string

                switch v := v.(type) </span>{
                case string:<span class="cov0" title="0">
                        value = v</span>
                case []byte:<span class="cov0" title="0">
                        value = string(v)</span>
                case int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                        value = fmt.Sprintf("%d", v)</span>
                case float32, float64:<span class="cov0" title="0">
                        value = fmt.Sprintf("%d", v)</span>
                default:<span class="cov0" title="0">
                        value = fmt.Sprintf("%v", v)</span>
                }

                <span class="cov0" title="0">meta[fmt.Sprintf("detail_%s", k)] = value</span>
        }

        <span class="cov0" title="0">detail := &amp;errdetails.ErrorInfo{
                Reason:   textCode,
                Metadata: meta,
        }

        st, stErr := status.New(code, errMsg).WithDetails(detail)
        if stErr != nil </span><span class="cov0" title="0">{
                return status.Error(codes.Unknown, stErr.Error())
        }</span>

        <span class="cov0" title="0">return st.Err()</span>
}

var grpcCodeByAppCode = map[errorCode]codes.Code{
        errorCodeBadRequest:    codes.InvalidArgument,
        errorCodeUnauthorized:  codes.Unauthenticated,
        errorCodeForbidden:     codes.PermissionDenied,
        errorCodeNotFound:      codes.NotFound,
        errorCodeConflict:      codes.Aborted,
        errorCodeUnprocessable: codes.FailedPrecondition,
        errorTooManyRequests:   codes.ResourceExhausted,
        errorCodeInternal:      codes.Internal,
}

func mapToGrpcCode(app errorCode) codes.Code <span class="cov0" title="0">{
        if c, ok := grpcCodeByAppCode[app]; ok </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return codes.Unknown</span>
}

func FromGRPCError(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">st, ok := status.FromError(err)
        if !ok </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var info *errdetails.ErrorInfo
        for _, d := range st.Details() </span><span class="cov0" title="0">{
                if v, ok := d.(*errdetails.ErrorInfo); ok </span><span class="cov0" title="0">{
                        info = v
                        break</span>
                }
        }

        <span class="cov0" title="0">textCode := ""
        if info != nil &amp;&amp; info.Reason != "" </span><span class="cov0" title="0">{
                textCode = info.Reason
        }</span>

        <span class="cov0" title="0">var base *AppError
        if textCode != "" </span><span class="cov0" title="0">{
                if ae := appErrorByTextCode(textCode); ae != nil </span><span class="cov0" title="0">{
                        base = ae
                }</span>
        }
        <span class="cov0" title="0">if base == nil </span><span class="cov0" title="0">{
                base = appErrorByGrpcCode(st.Code())
        }</span>
        <span class="cov0" title="0">if base == nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var hints []string
        details := map[string]any{}

        if info != nil &amp;&amp; info.Metadata != nil </span><span class="cov0" title="0">{
                type pair struct {
                        i int
                        v string
                }

                hp := make([]pair, 0, len(info.Metadata))

                for k, v := range info.Metadata </span><span class="cov0" title="0">{
                        switch </span>{
                        case strings.HasPrefix(k, "hint_"):<span class="cov0" title="0">
                                if idx, err := strconv.Atoi(strings.TrimPrefix(k, "hint_")); err == nil </span><span class="cov0" title="0">{
                                        hp = append(hp, pair{i: idx, v: v})
                                }</span>

                        case strings.HasPrefix(k, "detail_"):<span class="cov0" title="0">
                                key := strings.TrimPrefix(k, "detail_")
                                if key != "" </span><span class="cov0" title="0">{
                                        details[key] = v
                                }</span>
                        }
                }

                <span class="cov0" title="0">slices.SortFunc(hp, func(a, b pair) int </span><span class="cov0" title="0">{
                        return cmp.Compare(a.i, b.i)
                }</span>)

                <span class="cov0" title="0">hints = make([]string, 0, len(hp))
                for _, p := range hp </span><span class="cov0" title="0">{
                        if p.v != "" </span><span class="cov0" title="0">{
                                hints = append(hints, p.v)
                        }</span>
                }
        }

        <span class="cov0" title="0">cp := base.Extend(st.Message())

        if textCode != "" </span><span class="cov0" title="0">{
                cp = cp.WithTextCode(textCode)
        }</span>

        <span class="cov0" title="0">if len(hints) &gt; 0 </span><span class="cov0" title="0">{
                cp = cp.WithHints(hints...)
        }</span>

        <span class="cov0" title="0">for k, v := range details </span><span class="cov0" title="0">{
                cp = cp.WithDetail(k, false, v)
        }</span>

        <span class="cov0" title="0">return cp</span>
}

func appErrorByTextCode(textCode string) *AppError <span class="cov0" title="0">{
        switch textCode </span>{
        case "BAD_REQUEST":<span class="cov0" title="0">
                return ErrBadRequest</span>
        case "UNAUTHORIZED":<span class="cov0" title="0">
                return ErrUnauthorized</span>
        case "FORBIDDEN":<span class="cov0" title="0">
                return ErrForbidden</span>
        case "NOT_FOUND":<span class="cov0" title="0">
                return ErrNotFound</span>
        case "CONFLICT":<span class="cov0" title="0">
                return ErrConflict</span>
        case "TOO_MANY_REQUESTS":<span class="cov0" title="0">
                return ErrTooManyRequests</span>
        case "UNPROCESSABLE":<span class="cov0" title="0">
                return ErrUnprocessable</span>
        case "INTERNAL_ERROR":<span class="cov0" title="0">
                return ErrInternal</span>
        case "UNIQUE_VIOLATION":<span class="cov0" title="0">
                return ErrUniqueViolation</span>
        case "VERSION_CONFLICT":<span class="cov0" title="0">
                return ErrVersionConflict</span>
        case "BACKOFF":<span class="cov0" title="0">
                return ErrBackoff</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

func appErrorByGrpcCode(code codes.Code) *AppError <span class="cov0" title="0">{
        switch code </span>{
        case codes.InvalidArgument:<span class="cov0" title="0">
                return ErrBadRequest</span>
        case codes.Unauthenticated:<span class="cov0" title="0">
                return ErrUnauthorized</span>
        case codes.PermissionDenied:<span class="cov0" title="0">
                return ErrForbidden</span>
        case codes.NotFound:<span class="cov0" title="0">
                return ErrNotFound</span>
        case codes.Aborted:<span class="cov0" title="0">
                return ErrConflict</span>
        case codes.ResourceExhausted:<span class="cov0" title="0">
                return ErrTooManyRequests</span>
        case codes.FailedPrecondition:<span class="cov0" title="0">
                return ErrUnprocessable</span>
        case codes.Internal:<span class="cov0" title="0">
                return ErrInternal</span>
        default:<span class="cov0" title="0">
                return ErrInternal</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package errors

import (
        "errors"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

// ExtractError - ищет ближайшую ошибку AppError
func ExtractError(err error) (*AppError, bool) <span class="cov0" title="0">{
        var appErr *AppError
        if errors.As(err, &amp;appErr) </span><span class="cov0" title="0">{
                return appErr, true
        }</span>

        <span class="cov0" title="0">return nil, false</span>
}

// NearestHints - ищет ближайший непустой слайс подсказок
func NearestHints(err error) ([]string, bool) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        return nil, false
                }</span>
                <span class="cov0" title="0">if appErr, ok := err.(*AppError); ok </span><span class="cov0" title="0">{
                        if len(appErr.hints) &gt; 0 </span><span class="cov0" title="0">{
                                return appErr.hints, true
                        }</span>
                        <span class="cov0" title="0">err = appErr.Unwrap()
                        continue</span>
                }
                <span class="cov0" title="0">if chainErr, ok := err.(*ChainError); ok </span><span class="cov0" title="0">{
                        err = chainErr.Unwrap()
                        continue</span>
                }
                <span class="cov0" title="0">err = errors.Unwrap(err)</span>
        }
}

// NearestErrMsg - ищет только сообщение об ошибке в AppError
func NearestErrMsg(err error) (string, bool) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        return "", false
                }</span>
                <span class="cov0" title="0">if appErr, ok := err.(*AppError); ok </span><span class="cov0" title="0">{
                        if len(appErr.errMsg) &gt; 0 </span><span class="cov0" title="0">{
                                return appErr.errMsg, true
                        }</span>
                        <span class="cov0" title="0">err = appErr.Unwrap()
                        continue</span>
                }
                <span class="cov0" title="0">if chainErr, ok := err.(*ChainError); ok </span><span class="cov0" title="0">{
                        err = chainErr.Unwrap()
                        continue</span>
                }
                <span class="cov0" title="0">err = errors.Unwrap(err)</span>
        }
}

// NearestError - ищет либо сообщение об ошибке в Error, либо текст сторонней ошибки
func NearestError(err error) (string, bool) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        return "", false
                }</span>
                <span class="cov0" title="0">if appErr, ok := err.(*AppError); ok </span><span class="cov0" title="0">{
                        if len(appErr.errMsg) &gt; 0 </span><span class="cov0" title="0">{
                                return appErr.errMsg, true
                        }</span>
                        <span class="cov0" title="0">err = appErr.Unwrap()
                        continue</span>
                }
                <span class="cov0" title="0">if chainErr, ok := err.(*ChainError); ok </span><span class="cov0" title="0">{
                        err = chainErr.Unwrap()
                        continue</span>
                }
                <span class="cov0" title="0">if err.Error() != "" </span><span class="cov0" title="0">{
                        return err.Error(), true
                }</span>
                <span class="cov0" title="0">err = errors.Unwrap(err)</span>
        }
}

// WithHints - добавляет подсказки к error.
// Ищет ближайший AppError и копируется. Если не найдено - создается копия ErrInternal
func WithHints(err error, hints ...string) *AppError <span class="cov0" title="0">{
        var foundAppErr *AppError

        lookingErr := err
        for lookingErr != nil </span><span class="cov0" title="0">{

                if appErr, ok := lookingErr.(*AppError); ok </span><span class="cov0" title="0">{
                        foundAppErr = appErr
                        break</span>
                }
                <span class="cov0" title="0">if chainErr, ok := lookingErr.(*ChainError); ok </span><span class="cov0" title="0">{
                        lookingErr = chainErr.Unwrap()
                        continue</span>
                }
                <span class="cov0" title="0">lookingErr = errors.Unwrap(lookingErr)</span>
        }

        <span class="cov0" title="0">var cp *AppError
        if foundAppErr != nil </span><span class="cov0" title="0">{
                cp = foundAppErr.Copy()
        }</span> else<span class="cov0" title="0"> {
                cp = ErrInternal.Copy()
        }</span>
        <span class="cov0" title="0">cp.parent = err
        cp.hints = hints

        return cp</span>
}

// CheckIsTxСoncurrentExec - проверяет, является ли ошибка pgx о конкурентном выполнении транзакции
func CheckIsTxСoncurrentExec(err error) bool <span class="cov0" title="0">{
        var pgErr *pgconn.PgError
        if errors.As(err, &amp;pgErr) &amp;&amp; (pgErr.Code == "40001" || pgErr.Code == "25P02") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return errors.Is(err, ErrTxСoncurrentExec)</span>
}

// ConvertPgxToAppErr - конвертирует ошибку pgx в ошибку приложения
func ConvertPgxToAppErr(err error) (error, bool) <span class="cov0" title="0">{
        if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                return ErrStoreNoRows.WithWrap(err), true
        }</span>
        <span class="cov0" title="0">var pgErr *pgconn.PgError
        if errors.As(err, &amp;pgErr) </span><span class="cov0" title="0">{
                switch pgErr.Code </span>{
                case "40001":<span class="cov0" title="0">
                        return ErrTxСoncurrentExec.WithWrap(err), true</span>
                case "25P02":<span class="cov0" title="0">
                        return ErrTxСoncurrentExec.WithWrap(err), true</span>
                case "23505":<span class="cov0" title="0">
                        return ErrStoreUniqueViolation.WithWrap(err).WithDetail("column", true, pgErr.ColumnName), true</span>
                case "23503":<span class="cov0" title="0">
                        return ErrStoreForeignKeyViolation.WithWrap(err).WithDetail("column", true, pgErr.ColumnName), true</span>
                case "23502":<span class="cov0" title="0">
                        return ErrStoreNotNullViolation.WithWrap(err).WithDetail("column", true, pgErr.ColumnName), true</span>
                case "23514":<span class="cov0" title="0">
                        return ErrStoreCheckViolation.WithWrap(err).WithDetail("constraint", true, pgErr.ConstraintName), true</span>
                case "23001":<span class="cov0" title="0">
                        return ErrStoreRestrictViolation.WithWrap(err).WithDetail("constraint", true, pgErr.ConstraintName), true</span>
                case "23000":<span class="cov0" title="0">
                        return ErrStoreIntegrityViolation.WithWrap(err).WithDetail("constraint", true, pgErr.ConstraintName), true</span>
                default:<span class="cov0" title="0">
                        return ErrInternal.WithWrap(err), false</span>
                }
        }
        <span class="cov0" title="0">return err, false</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package errors

import "log/slog"

// JSONStruct - структура для json
type JSONStruct struct {
        Message  string         `json:"message"`
        ChainMsg string         `json:"chainMsg,omitempty"`
        TextCode string         `json:"textCode,omitempty"`
        Code     int            `json:"code,omitempty"`
        Hints    []string       `json:"hints,omitempty"`
        Details  map[string]any `json:"details,omitempty"`
}

// ToSlogValue - преобразует error в slog.Value
func (e *JSONStruct) ToSlogValue() slog.Value <span class="cov0" title="0">{
        attrs := []slog.Attr{
                slog.String("message", e.Message),
                slog.String("textCode", e.TextCode),
                slog.Int("code", e.Code),
        }

        if e.ChainMsg != e.Message </span><span class="cov0" title="0">{
                attrs = append(attrs, slog.String("chainMsg", e.ChainMsg))
        }</span>

        <span class="cov0" title="0">if len(e.Hints) &gt; 0 </span><span class="cov0" title="0">{
                attrs = append(attrs, slog.Any("hints", e.Hints))
        }</span>

        <span class="cov0" title="0">if len(e.Details) &gt; 0 </span><span class="cov0" title="0">{
                attrs = append(attrs, slog.Any("details", e.Details))
        }</span>

        <span class="cov0" title="0">return slog.GroupValue(attrs...)</span>
}

// ToJSONStruct - преобразует error в ErrorJsonStruct
func ToJSONStruct(err error, addHiddenDetails bool, addHints bool) JSONStruct <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return JSONStruct{}
        }</span>

        <span class="cov0" title="0">appErr, ok := ExtractError(err)
        if !ok </span><span class="cov0" title="0">{
                return JSONStruct{
                        Message: err.Error(),
                }
        }</span>

        <span class="cov0" title="0">errStruct := JSONStruct{
                Message:  appErr.ErrMsg(),
                ChainMsg: appErr.Error(),
                TextCode: appErr.meta.TextCode,
                Code:     int(appErr.meta.Code),
                Details:  appErr.Details(addHiddenDetails),
        }

        if addHints </span><span class="cov0" title="0">{
                errStruct.Hints = appErr.Hints()
        }</span>

        <span class="cov0" title="0">return errStruct</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package errors

type markError struct {
        source error
        mark   error
}

// Error - реализация интерфейса error
func (e *markError) Error() string <span class="cov0" title="0">{
        return e.source.Error()
}</span>

// Unwrap - реализация интерфейса error, возвращает родительскую ошибку
func (e *markError) Unwrap() error <span class="cov0" title="0">{
        return e.source
}</span>

// Is - реализация интерфейса error, проверка идентификации
func (e *markError) Is(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return e.source == err || e.mark == err</span>
}

// Mark - поменить source ошибку mark ошибкой (для errors.Is)
func Mark(source error, mark error) error <span class="cov0" title="0">{
        return &amp;markError{source: source, mark: mark}
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package fxboot

import (
        "context"
        "log/slog"
        "time"

        "github.com/m11ano/budget_planner/backend/auth/internal/app"
        "github.com/m11ano/budget_planner/backend/auth/internal/app/config"
        "github.com/m11ano/budget_planner/backend/auth/internal/app/fxboot/invoking"
        "github.com/m11ano/budget_planner/backend/auth/internal/app/fxboot/providing"
        deliveryGRPC "github.com/m11ano/budget_planner/backend/auth/internal/delivery/grpc"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth"
        "github.com/m11ano/budget_planner/backend/auth/internal/infra/db"
        "github.com/m11ano/budget_planner/backend/auth/pkg/backoff"
        "github.com/m11ano/budget_planner/backend/auth/pkg/pgclient"
        "go.uber.org/fx"
        "go.uber.org/fx/fxevent"
        "google.golang.org/grpc"
)

func BackendAppGetOptionsMap(appID app.ID, cfg config.Config) OptionsMap <span class="cov0" title="0">{
        return OptionsMap{
                Providing: map[ProvidingID]fx.Option{
                        ProvidingAppID: fx.Provide(func() app.ID </span><span class="cov0" title="0">{
                                return appID
                        }</span>),
                        ProvidingIDFXTimeouts: fx.Options(
                                fx.StartTimeout(time.Second*time.Duration(cfg.BackendApp.Base.StartTimeoutSec)),
                                fx.StopTimeout(time.Second*time.Duration(cfg.BackendApp.Base.StopTimeoutSec)),
                        ),
                        ProvidingIDConfig: fx.Provide(func() config.Config <span class="cov0" title="0">{
                                return cfg
                        }</span>),
                        ProvidingIDLogger: fx.Provide(func(cfg config.Config) *slog.Logger <span class="cov0" title="0">{
                                return providing.NewLogger(
                                        cfg.BackendApp.Name,
                                        cfg.BackendApp.Version,
                                        cfg.BackendApp.Base.UseLogger,
                                        cfg.BackendApp.Base.IsProd,
                                )
                        }</span>),
                        ProvidingIDFXLogger: fx.WithLogger(func(cfg config.Config) fxevent.Logger <span class="cov0" title="0">{
                                return providing.NewFXLogger(cfg.BackendApp.Base.UseFxLogger)
                        }</span>),
                        ProvidingIDDBClients: fx.Provide(
                                func(logger *slog.Logger, cfg config.Config, shutdown fx.Shutdowner) db.MasterClient <span class="cov0" title="0">{
                                        return providing.NewDBClients(
                                                cfg.Postgres.Master.DSN,
                                                cfg.BackendApp.Base.LogSQLQueries,
                                                logger,
                                                shutdown,
                                        )
                                }</span>,
                        ),
                        ProvidingIDBackoff:    fx.Provide(providing.NewBackoff),
                        ProvidingGRPCServer:   providing.DeliveryGRPC,
                        ProvidingIDAuthModule: auth.FxModule,
                },
                Invokes: []fx.Option{
                        fx.Invoke(BackendAppInitInvoke),
                },
        }
}

type BAckendInvokeInput struct {
        fx.In

        LC             fx.Lifecycle
        Shutdowner     fx.Shutdowner
        Invokes        []invoking.InvokeInit `group:"InvokeInit"`
        Logger         *slog.Logger
        Cfg            config.Config
        DBMasterClient db.MasterClient
        BackoffCtrl    *backoff.Controller
        GRPCServer     *grpc.Server
}

func BackendAppInitInvoke(
        in BAckendInvokeInput,
) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        go func() </span><span class="cov0" title="0">{
                &lt;-ctx.Done()
                err := in.Shutdowner.Shutdown()
                if err != nil </span><span class="cov0" title="0">{
                        in.Logger.Error("failed to shutdown", slog.Any("error", err))
                }</span>
        }()

        <span class="cov0" title="0">in.LC.Append(fx.Hook{
                OnStart: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        // Тестирование соединения с мастером postgress
                        err := pgclient.TestConnection(
                                ctx,
                                in.DBMasterClient,
                                in.Logger,
                                in.Cfg.Postgres.MaxAttempts,
                                in.Cfg.Postgres.AttemptSleepSeconds,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                in.Logger.ErrorContext(ctx, "failed to test master db connection", slog.Any("error", err))
                                return err
                        }</span>

                        <span class="cov0" title="0">in.Logger.InfoContext(
                                ctx,
                                "successfully connected to Postgress",
                                slog.String("serverID", in.DBMasterClient.ServerID()),
                        )

                        // Миграции goose
                        err = db.UpMigrations(in.Cfg.Postgres.Master.DSN, in.Cfg.Postgres.MigrationsPath, in.Logger)
                        if err != nil </span><span class="cov0" title="0">{
                                in.Logger.ErrorContext(ctx, "failed to run migrations", slog.Any("error", err))
                                return err
                        }</span>

                        // Запускаем invoke функции до открытия
                        <span class="cov0" title="0">for _, invokeItem := range in.Invokes </span><span class="cov0" title="0">{
                                if invokeItem.StartBeforeOpen != nil </span><span class="cov0" title="0">{
                                        err := invokeItem.StartBeforeOpen(ctx)
                                        if err != nil </span><span class="cov0" title="0">{
                                                in.Logger.ErrorContext(ctx, "failed to execute invoke fn start before open", slog.Any("error", err))
                                                return err
                                        }</span>
                                }
                        }

                        // Запускаем grpc сервер
                        <span class="cov0" title="0">if in.Cfg.BackendApp.GRPC.Port &gt; 0 </span><span class="cov0" title="0">{
                                in.Logger.InfoContext(ctx, "starting gRPC server", slog.Int("port", in.Cfg.BackendApp.GRPC.Port))
                                go func() </span><span class="cov0" title="0">{
                                        err := deliveryGRPC.Start(in.GRPCServer, in.Cfg.BackendApp.GRPC.Port)
                                        if err != nil </span><span class="cov0" title="0">{
                                                in.Logger.ErrorContext(ctx, "failed to start gRPC server", slog.Any("error", err.Error()))
                                                cancel()
                                        }</span>
                                }()
                        }

                        // Запускаем invoke функции после открытия
                        <span class="cov0" title="0">for _, invokeItem := range in.Invokes </span><span class="cov0" title="0">{
                                if invokeItem.StartAfterOpen != nil </span><span class="cov0" title="0">{
                                        err := invokeItem.StartAfterOpen(ctx)
                                        if err != nil </span><span class="cov0" title="0">{
                                                in.Logger.ErrorContext(ctx, "failed to execute invoke fn start after open", slog.Any("error", err))
                                                return err
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">return nil</span>
                },
                OnStop: func(ctx context.Context) error <span class="cov0" title="0">{
                        for _, invokeItem := range in.Invokes </span><span class="cov0" title="0">{
                                if invokeItem.Stop != nil </span><span class="cov0" title="0">{
                                        err := invokeItem.Stop(ctx)
                                        if err != nil </span><span class="cov0" title="0">{
                                                in.Logger.ErrorContext(ctx, "failed to execute invoke fn stop", slog.Any("error", err))
                                                return err
                                        }</span>
                                }
                        }

                        // Останавливаем gRPC
                        <span class="cov0" title="0">if in.Cfg.BackendApp.GRPC.Port &gt; 0 </span><span class="cov0" title="0">{
                                in.Logger.InfoContext(ctx, "stopping gRPC server")
                                in.GRPCServer.GracefulStop()
                        }</span>

                        // Закрываем postgress
                        <span class="cov0" title="0">in.DBMasterClient.Close()
                        in.Logger.InfoContext(ctx, "closing db clients")

                        // Останавливаем backoff
                        in.BackoffCtrl.Stop(ctx)

                        return nil</span>
                },
        })
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package fxboot

import (
        "go.uber.org/fx"
)

type ProvidingID int

const (
        // ProvidingAppID - app id
        ProvidingAppID ProvidingID = iota

        // ProvidingIDFXTimeouts - fx timeouts
        ProvidingIDFXTimeouts

        // ProvidingIDConfig - app config
        ProvidingIDConfig

        // ProvidingIDLogger - logger
        ProvidingIDLogger

        // ProvidingIDFXLogger - fx logger
        ProvidingIDFXLogger

        // ProvidingIDDBClients - db clients
        ProvidingIDDBClients

        // ProvidingIDBackoff - backoff
        ProvidingIDBackoff

        // ProvidingGRPCServer - grpc
        ProvidingGRPCServer

        // ProvidingIDAuthModule - tenant
        ProvidingIDAuthModule
)

type OptionsMap struct {
        Providing map[ProvidingID]fx.Option
        Invokes   []fx.Option
}

func OptionsMapToSlice(optionsMap OptionsMap) []fx.Option <span class="cov0" title="0">{
        result := make([]fx.Option, 0)

        for _, option := range optionsMap.Providing </span><span class="cov0" title="0">{
                result = append(result, option)
        }</span>

        <span class="cov0" title="0">result = append(result, optionsMap.Invokes...)

        return result</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package providing

import "github.com/m11ano/budget_planner/backend/auth/pkg/backoff"

func NewBackoff() *backoff.Controller <span class="cov0" title="0">{
        return backoff.NewController()
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package providing

import (
        "context"
        "log/slog"

        "github.com/m11ano/budget_planner/backend/auth/internal/infra/db"
        "github.com/m11ano/budget_planner/backend/auth/pkg/pgclient"
        "go.uber.org/fx"
)

func NewDBClients(masterDSN string, logQueries bool, logger *slog.Logger, shutdown fx.Shutdowner) db.MasterClient <span class="cov0" title="0">{
        master, err := pgclient.NewClient(
                context.Background(),
                "master",
                masterDSN,
                pgclient.NewClientOpts{
                        Logger:     logger,
                        LogQueries: logQueries,
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create master client", slog.Any("error", err))
                // nolint
                _ = shutdown.Shutdown()
        }</span>

        <span class="cov0" title="0">return master</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package providing

import (
        "io"
        "log/slog"

        "github.com/m11ano/budget_planner/backend/auth/internal/app/config"
        deliveryGRPC "github.com/m11ano/budget_planner/backend/auth/internal/delivery/grpc"
        controllerGRPC "github.com/m11ano/budget_planner/backend/auth/internal/delivery/grpc/controller"
        "go.uber.org/fx"
        "google.golang.org/grpc"
)

var DeliveryGRPC = fx.Options(
        fx.Provide(func(logger *slog.Logger, cfg config.Config) *grpc.Server <span class="cov0" title="0">{
                if !cfg.BackendApp.GRPC.LogQueries </span><span class="cov0" title="0">{
                        logger = slog.New(slog.NewTextHandler(io.Discard, nil))
                }</span>
                <span class="cov0" title="0">return deliveryGRPC.New(logger, cfg)</span>
        }),
        fx.Invoke(controllerGRPC.Register),
)
</pre>
		
		<pre class="file" id="file13" style="display: none">package providing

import (
        "os"

        "go.uber.org/fx/fxevent"
)

func NewFXLogger(useLogger bool) fxevent.Logger <span class="cov0" title="0">{
        if !useLogger </span><span class="cov0" title="0">{
                return fxevent.NopLogger
        }</span>
        <span class="cov0" title="0">return &amp;fxevent.ConsoleLogger{
                W: os.Stdout,
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package providing

import (
        "io"
        "log/slog"
        "os"

        "github.com/m11ano/budget_planner/backend/auth/internal/infra/loghandler"
        "github.com/m11ano/budget_planner/backend/auth/pkg/prettylog"
)

func NewLogger(appName string, appVersion string, useLogger bool, isProd bool) *slog.Logger <span class="cov0" title="0">{
        var appLogger *slog.Logger

        switch </span>{
        case !useLogger:<span class="cov0" title="0">
                appLogger = slog.New(loghandler.NewHandlerMiddleware(slog.NewTextHandler(io.Discard, nil)))</span>
        case isProd:<span class="cov0" title="0">
                appLogger = slog.New(loghandler.NewHandlerMiddleware(slog.NewJSONHandler(os.Stdout, nil)))</span>
        default:<span class="cov0" title="0">
                appLogger = slog.New(loghandler.NewHandlerMiddleware(prettylog.NewHandler(nil)))</span>
        }

        <span class="cov0" title="0">appLogger = appLogger.With("app_name", appName).With("app_version", appVersion)

        return appLogger</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package controller

import (
        "time"

        "github.com/m11ano/budget_planner/backend/auth/internal/app/config"
        authUC "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
        "github.com/m11ano/budget_planner/backend/auth/pkg/backoff"
        desc "github.com/m11ano/budget_planner/backend/auth/pkg/proto_pb/auth_service"
        "google.golang.org/grpc"
)

type controller struct {
        desc.UnimplementedAuthServer
        pkg        string
        cfg        config.Config
        backoff    *backoff.Controller
        authFacade *authUC.Facade
}

const (
        backoffConfigLoginGroupID    = "grpc.login"
        backoffConfigRegisterGroupID = "grpc.register"
)

func Register(
        gRPCServer *grpc.Server,
        cfg config.Config,
        backoffCtrl *backoff.Controller,
        authFacade *authUC.Facade,
) <span class="cov0" title="0">{
        ctrl := &amp;controller{
                pkg:        "grpc.Controller",
                cfg:        cfg,
                backoff:    backoffCtrl,
                authFacade: authFacade,
        }

        desc.RegisterAuthServer(gRPCServer, ctrl)

        ctrl.backoff.SetConfigForGroup(
                backoffConfigLoginGroupID,
                backoff.WithTtl(time.Minute*10),
                backoff.WithInitialInterval(time.Second*5),
                backoff.WithMultiplier(2),
                backoff.WithMaxInterval(time.Minute*1),
        )

        ctrl.backoff.SetConfigForGroup(
                backoffConfigRegisterGroupID,
                backoff.WithTtl(time.Minute*10),
                backoff.WithInitialInterval(time.Second*5),
                backoff.WithMultiplier(2),
                backoff.WithMaxInterval(time.Minute*1),
        )
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package controller

import (
        "context"
        "errors"
        "net"

        appErrors "github.com/m11ano/budget_planner/backend/auth/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/auth/internal/delivery/grpc"
        desc "github.com/m11ano/budget_planner/backend/auth/pkg/proto_pb/auth_service"
)

func (c *controller) Login(ctx context.Context, req *desc.LoginRequest) (*desc.LoginResponse, error) <span class="cov0" title="0">{
        const op = "Login"

        clientIPStr := grpc.GetClientIP(ctx)

        backoffSession, ok := c.backoff.GetIfExists(clientIPStr, backoffConfigLoginGroupID)

        if ok &amp;&amp; !backoffSession.IsAllowed() </span><span class="cov0" title="0">{
                tryAfter := backoffSession.NextAllowedUntilSeconds()
                return nil, appErrors.Chainf(
                        appErrors.ErrBackoff.WithDetail("try_after_sec", false, tryAfter),
                        "%s.%s", c.pkg, op,
                )
        }</span>

        <span class="cov0" title="0">clientIP := net.ParseIP(clientIPStr)

        authDTO, err := c.authFacade.Auth.LoginByEmail(
                ctx,
                req.Email,
                req.Password,
                clientIP,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, appErrors.ErrUnauthorized) </span><span class="cov0" title="0">{
                        backoffSession = c.backoff.Get(clientIPStr, backoffConfigLoginGroupID)
                        backoffSession.AddCounter()
                        if backoffSession.Counter() &gt; 1 </span><span class="cov0" title="0">{
                                _ = backoffSession.AddBackoff()
                        }</span>
                }

                <span class="cov0" title="0">return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)</span>
        }

        <span class="cov0" title="0">accessJWT, err := c.authFacade.Auth.IssueAccessJWT(authDTO.AccessClaims)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">refreshJWT, err := c.authFacade.Auth.IssueRefreshJWT(authDTO.RefreshClaims)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">out := &amp;desc.LoginResponse{
                SessionId: authDTO.Session.ID.String(),
                Tokens: &amp;desc.Tokens{
                        RefreshJwt: refreshJWT,
                        AccessJwt:  accessJWT,
                },
                Account: &amp;desc.Account{
                        Id:             authDTO.AccountDTO.Account.ID.String(),
                        Email:          authDTO.AccountDTO.Account.Email,
                        ProfileName:    authDTO.AccountDTO.Account.ProfileName,
                        ProfileSurname: authDTO.AccountDTO.Account.ProfileSurname,
                },
        }

        return out, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package controller

import (
        "context"

        appErrors "github.com/m11ano/budget_planner/backend/auth/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        desc "github.com/m11ano/budget_planner/backend/auth/pkg/proto_pb/auth_service"
)

func (c *controller) Logout(ctx context.Context, req *desc.LogoutRequest) (*desc.LogoutResponse, error) <span class="cov0" title="0">{
        const op = "Logout"

        authData := auth.GetAuthData(ctx)
        if authData == nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrUnauthorized, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">err := c.authFacade.Session.RevokeSessionByID(ctx, authData.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">return &amp;desc.LogoutResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package controller

import (
        "context"
        "errors"
        "net"

        appErrors "github.com/m11ano/budget_planner/backend/auth/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/auth/internal/delivery/grpc"
        authUC "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
        desc "github.com/m11ano/budget_planner/backend/auth/pkg/proto_pb/auth_service"
)

func (c *controller) Refresh(ctx context.Context, req *desc.RefreshRequest) (*desc.RefreshResponse, error) <span class="cov0" title="0">{
        const op = "Refresh"

        clientIPStr := grpc.GetClientIP(ctx)
        clientIP := net.ParseIP(clientIPStr)

        claims, err := c.authFacade.Auth.ParseRefreshToken(req.RefreshJwt, true)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, authUC.ErrInvalidToken) </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(appErrors.ErrUnauthorized, "%s.%s", c.pkg, op)
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)</span>
        }

        <span class="cov0" title="0">authDTO, err := c.authFacade.Auth.GenerateNewClaims(ctx, claims, clientIP)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">accessJWT, err := c.authFacade.Auth.IssueAccessJWT(authDTO.AccessClaims)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">refreshJWT, err := c.authFacade.Auth.IssueRefreshJWT(authDTO.RefreshClaims)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">out := &amp;desc.RefreshResponse{
                Tokens: &amp;desc.Tokens{
                        RefreshJwt: refreshJWT,
                        AccessJwt:  accessJWT,
                },
        }

        return out, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package controller

import (
        "context"
        "net"

        appErrors "github.com/m11ano/budget_planner/backend/auth/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/auth/internal/delivery/grpc"
        authUC "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
        desc "github.com/m11ano/budget_planner/backend/auth/pkg/proto_pb/auth_service"
)

func (c *controller) Register(ctx context.Context, req *desc.RegisterRequest) (*desc.RegisterResponse, error) <span class="cov0" title="0">{
        const op = "Register"

        clientIPStr := grpc.GetClientIP(ctx)

        backoffSession, ok := c.backoff.GetIfExists(clientIPStr, backoffConfigRegisterGroupID)

        if ok &amp;&amp; !backoffSession.IsAllowed() </span><span class="cov0" title="0">{
                tryAfter := backoffSession.NextAllowedUntilSeconds()

                return nil, appErrors.Chainf(
                        appErrors.ErrBackoff.WithDetail("try_after_sec", false, tryAfter),
                        "%s.%s", c.pkg, op,
                )
        }</span>

        <span class="cov0" title="0">clientIP := net.ParseIP(clientIPStr)

        _, err := c.authFacade.Account.CreateAccountByDTO(
                ctx,
                authUC.CreateAccountDataInput{
                        Email:          req.Email,
                        Password:       req.Password,
                        IsConfirmed:    true,
                        ProfileName:    req.ProfileName,
                        ProfileSurname: req.ProfileSurname,
                },
                &amp;clientIP,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">backoffSession = c.backoff.Get(clientIPStr, backoffConfigLoginGroupID)
        backoffSession.AddCounter()
        _ = backoffSession.AddBackoff()

        return &amp;desc.RegisterResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package controller

import (
        "context"

        appErrors "github.com/m11ano/budget_planner/backend/auth/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        desc "github.com/m11ano/budget_planner/backend/auth/pkg/proto_pb/auth_service"
)

func (c *controller) WhoIAm(ctx context.Context, req *desc.WhoIAmRequest) (*desc.WhoIAmResponse, error) <span class="cov0" title="0">{
        const op = "WhoIAm"

        authData := auth.GetAuthData(ctx)
        if authData == nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrUnauthorized, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">accountDTO, err := c.authFacade.Account.FindOneByID(
                ctx,
                authData.AccountID,
                nil,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">out := &amp;desc.WhoIAmResponse{
                Account: &amp;desc.Account{
                        Id:             accountDTO.Account.ID.String(),
                        Email:          accountDTO.Account.Email,
                        ProfileName:    accountDTO.Account.ProfileName,
                        ProfileSurname: accountDTO.Account.ProfileSurname,
                },
        }

        return out, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package grpc

import (
        "context"
        "errors"
        "strings"

        "github.com/m11ano/budget_planner/backend/auth/internal/app/config"
        "github.com/m11ano/budget_planner/backend/auth/internal/infra/loghandler"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        "google.golang.org/grpc"
        "google.golang.org/grpc/metadata"
)

func interceptorAuth(cfg config.Config) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                req any,
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (any, error) </span><span class="cov0" title="0">{
                md, ok := metadata.FromIncomingContext(ctx)
                if !ok </span><span class="cov0" title="0">{
                        return handler(ctx, req)
                }</span>

                <span class="cov0" title="0">authHeaders := md.Get("authorization")
                if len(authHeaders) == 0 </span><span class="cov0" title="0">{
                        return handler(ctx, req)
                }</span>

                <span class="cov0" title="0">authHeader := authHeaders[0]
                accessToken := strings.TrimPrefix(authHeader, "Bearer ")

                if accessToken == "" </span><span class="cov0" title="0">{
                        return handler(ctx, req)
                }</span>

                <span class="cov0" title="0">claims, err := auth.ParseAccessToken(accessToken, true, []byte(cfg.Auth.JwtAccessSecret))
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, auth.ErrInvalidToken) </span><span class="cov0" title="0">{
                                return handler(ctx, req)
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }

                <span class="cov0" title="0">authData, err := auth.ClaimsToAuthData(claims)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">ctx = auth.SetAuthData(ctx, authData)

                ctx = loghandler.SetContextData(ctx, "request.account.id", claims.AccountId)

                return handler(ctx, req)</span>
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package grpc

import (
        "context"

        appErrors "github.com/m11ano/budget_planner/backend/auth/internal/app/errors"
        "google.golang.org/grpc"
)

func interceptorErrors() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                req any,
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (any, error) </span><span class="cov0" title="0">{
                data, err := handler(ctx, req)

                return data, appErrors.ToGrpcStatus(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package grpc

import (
        "context"
        "log/slog"

        "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging"
)

func interceptorLogger(logger *slog.Logger) logging.Logger <span class="cov0" title="0">{
        return logging.LoggerFunc(func(ctx context.Context, lvl logging.Level, msg string, fields ...any) </span><span class="cov0" title="0">{
                logger.Log(ctx, slog.Level(lvl), msg, fields...)
        }</span>)
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package grpc

import (
        "context"

        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/auth/internal/infra/loghandler"
        "google.golang.org/grpc"
        "google.golang.org/grpc/metadata"
)

type contextReqIDKey string

const (
        requestIDKey         contextReqIDKey = "x-request-id"
        metadataRequestIDKey string          = "x-request-id"
)

func interceptorRequestID() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                req any,
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (any, error) </span><span class="cov0" title="0">{
                var reqID string
                if md, ok := metadata.FromIncomingContext(ctx); ok </span><span class="cov0" title="0">{
                        if vals := md.Get(metadataRequestIDKey); len(vals) &gt; 0 </span><span class="cov0" title="0">{
                                reqID = vals[0]
                        }</span>
                }

                <span class="cov0" title="0">if reqID == "" </span><span class="cov0" title="0">{
                        reqID = uuid.New().String()
                }</span>

                <span class="cov0" title="0">ctx = context.WithValue(ctx, requestIDKey, reqID)
                ctx = loghandler.SetContextData(ctx, "request.id", reqID)

                return handler(ctx, req)</span>
        }
}

func GetRequestID(ctx context.Context) string <span class="cov0" title="0">{
        if v := ctx.Value(requestIDKey); v != nil </span><span class="cov0" title="0">{
                if id, ok := v.(string); ok </span><span class="cov0" title="0">{
                        return id
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package grpc

import (
        "context"
        "net"
        "strings"

        "github.com/m11ano/budget_planner/backend/auth/internal/infra/loghandler"
        "google.golang.org/grpc"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/peer"
)

func getClientIPFromGRPCRequest(ctx context.Context) string <span class="cov0" title="0">{
        if md, ok := metadata.FromIncomingContext(ctx); ok </span><span class="cov0" title="0">{
                if xff := md.Get("x-forwarded-for"); len(xff) &gt; 0 </span><span class="cov0" title="0">{
                        parts := strings.Split(xff[0], ",")
                        ip := strings.TrimSpace(parts[0])
                        if net.ParseIP(ip) != nil </span><span class="cov0" title="0">{
                                return ip
                        }</span>
                }

                <span class="cov0" title="0">if xri := md.Get("x-real-ip"); len(xri) &gt; 0 </span><span class="cov0" title="0">{
                        ip := strings.TrimSpace(xri[0])
                        if net.ParseIP(ip) != nil </span><span class="cov0" title="0">{
                                return ip
                        }</span>
                }
        }

        <span class="cov0" title="0">if p, ok := peer.FromContext(ctx); ok </span><span class="cov0" title="0">{
                host, _, err := net.SplitHostPort(p.Addr.String())
                if err == nil </span><span class="cov0" title="0">{
                        return host
                }</span>
                <span class="cov0" title="0">return p.Addr.String()</span>
        }

        <span class="cov0" title="0">return ""</span>
}

type contextReqIPKey string

const (
        contextReqIPKeyValue contextReqIPKey = "x-request-ip"
)

func interceptorRequestIP() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                req any,
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (any, error) </span><span class="cov0" title="0">{
                requestIP := getClientIPFromGRPCRequest(ctx)

                ctx = context.WithValue(ctx, contextReqIPKeyValue, requestIP)
                ctx = loghandler.SetContextData(ctx, "request.ip", requestIP)

                return handler(ctx, req)
        }</span>
}

func GetClientIP(ctx context.Context) string <span class="cov0" title="0">{
        if v := ctx.Value(contextReqIPKeyValue); v != nil </span><span class="cov0" title="0">{
                if id, ok := v.(string); ok </span><span class="cov0" title="0">{
                        return id
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package grpc

import (
        "context"

        appErrors "github.com/m11ano/budget_planner/backend/auth/internal/app/errors"
        "google.golang.org/grpc"
)

func interceptorValidate(
        ctx context.Context,
        req any,
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
) (resp any, err error) <span class="cov0" title="0">{
        if reqV, ok := req.(interface{ ValidateAll() error }); ok </span><span class="cov0" title="0">{
                if err := reqV.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.ErrBadRequest.WithWrap(err).WithHints(err.Error())
                }</span>
        }
        <span class="cov0" title="0">return handler(ctx, req)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package grpc

import (
        "fmt"
        "log/slog"
        "net"

        "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging"
        "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/recovery"
        "github.com/m11ano/budget_planner/backend/auth/internal/app/config"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/reflection"
        "google.golang.org/grpc/status"
)

func New(logger *slog.Logger, cfg config.Config) *grpc.Server <span class="cov0" title="0">{
        loggingOpts := []logging.Option{
                logging.WithLogOnEvents(
                        logging.FinishCall,
                        logging.PayloadReceived,
                        logging.PayloadSent,
                ),
        }

        recoveryOpts := []recovery.Option{
                recovery.WithRecoveryHandler(func(p interface{}) (err error) </span><span class="cov0" title="0">{
                        logger.Error("recovered from panic", slog.Any("panic", p))
                        return status.Errorf(codes.Internal, "internal error")
                }</span>),
        }

        <span class="cov0" title="0">unaryInterceptors := []grpc.UnaryServerInterceptor{
                interceptorErrors(),
                recovery.UnaryServerInterceptor(recoveryOpts...),
                interceptorRequestIP(),
                interceptorRequestID(),
                interceptorAuth(cfg),
                interceptorValidate,
                logging.UnaryServerInterceptor(interceptorLogger(logger), loggingOpts...),
        }

        streamInterceptors := []grpc.StreamServerInterceptor{}

        gRPCServer := grpc.NewServer(
                grpc.ChainUnaryInterceptor(unaryInterceptors...),
                grpc.ChainStreamInterceptor(streamInterceptors...),
        )

        reflection.Register(gRPCServer)

        return gRPCServer</span>
}

func Start(grpcServer *grpc.Server, port int) error <span class="cov0" title="0">{
        lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen gRPC: %w", err)
        }</span>

        <span class="cov0" title="0">if err := grpcServer.Serve(lis); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to serve gRPC: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package entity

import (
        "net"
        "strings"
        "time"
        "unicode"

        "github.com/google/uuid"
        appErrors "github.com/m11ano/budget_planner/backend/auth/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/auth/pkg/emailnormalize"
        "github.com/samber/lo"
        "golang.org/x/crypto/bcrypt"
)

var ErrAccountInvalidEmail = appErrors.ErrBadRequest.Extend("invalid email").WithTextCode("INVALID_EMAIL")

var ErrAccountInvalidPassword = appErrors.ErrBadRequest.Extend("invalid password").WithTextCode("INVALID_PASSWORD")

var ErrAccountProfileInvalidName = appErrors.ErrBadRequest.Extend("invalid name").WithTextCode("INVALID_NAME")

var ErrAccountProfileInvalidSurname = appErrors.ErrBadRequest.Extend("invalid surname").WithTextCode("INVALID_SURNAME")

type Account struct {
        ID             uuid.UUID
        Email          string
        PasswordHash   string
        IsConfirmed    bool
        IsBlocked      bool
        LastLoginAt    *time.Time
        LastRequestAt  *time.Time
        LastRequestIP  *net.IP
        ProfileName    string
        ProfileSurname string

        CreatedAt time.Time
        UpdatedAt time.Time
        DeletedAt *time.Time
}

func (item *Account) Version() int64 <span class="cov0" title="0">{
        return item.UpdatedAt.UnixMicro()
}</span>

func (item *Account) SetPassword(password string, skipStrongCheck bool) error <span class="cov0" title="0">{
        if !skipStrongCheck </span><span class="cov0" title="0">{

                if len(password) &lt; 8 </span><span class="cov0" title="0">{
                        return ErrAccountInvalidPassword
                }</span>

                <span class="cov0" title="0">var hasLetter, hasDigit, hasSpecial bool
                for _, r := range password </span><span class="cov0" title="0">{
                        switch </span>{
                        case unicode.IsLetter(r):<span class="cov0" title="0">
                                hasLetter = true</span>
                        case unicode.IsDigit(r):<span class="cov0" title="0">
                                hasDigit = true</span>
                        default:<span class="cov0" title="0">
                                hasSpecial = true</span>
                        }
                }

                <span class="cov0" title="0">count := 0
                if hasLetter </span><span class="cov0" title="0">{
                        count++
                }</span>
                <span class="cov0" title="0">if hasDigit </span><span class="cov0" title="0">{
                        count++
                }</span>
                <span class="cov0" title="0">if hasSpecial </span><span class="cov0" title="0">{
                        count++
                }</span>

                <span class="cov0" title="0">if count &lt; 2 </span><span class="cov0" title="0">{
                        return ErrAccountInvalidPassword
                }</span>
        }

        <span class="cov0" title="0">hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">item.PasswordHash = string(hash)

        return nil</span>
}

func (item *Account) VerifyPassword(password string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(item.PasswordHash), []byte(password))
        return err == nil
}</span>

func (item *Account) SetEmail(email string) error <span class="cov0" title="0">{
        email = strings.TrimSpace(email)

        err := validate.Var(email, "required,email")
        if err != nil </span><span class="cov0" title="0">{
                return ErrAccountInvalidEmail
        }</span>

        <span class="cov0" title="0">res, err := emailnormalize.Normalize(email)
        if err != nil </span><span class="cov0" title="0">{
                return ErrAccountInvalidEmail
        }</span>

        <span class="cov0" title="0">item.Email = res.NormalizedAddress

        return nil</span>
}

func (item *Account) SetLastLoginAt(value *time.Time) <span class="cov0" title="0">{
        if value != nil </span><span class="cov0" title="0">{
                value = lo.ToPtr(value.Truncate(time.Microsecond))
        }</span>

        <span class="cov0" title="0">item.LastLoginAt = value</span>
}

func (item *Account) SetLastRequestAt(value *time.Time) <span class="cov0" title="0">{
        if value != nil </span><span class="cov0" title="0">{
                value = lo.ToPtr(value.Truncate(time.Microsecond))
        }</span>

        <span class="cov0" title="0">item.LastRequestAt = value</span>
}

func (item *Account) SetLastRequestIP(value *net.IP) <span class="cov0" title="0">{
        item.LastRequestIP = value
}</span>

func (item *Account) SetProfileName(value string) error <span class="cov0" title="0">{
        value = strings.TrimSpace(value)

        if value == "" </span><span class="cov0" title="0">{
                return ErrAccountProfileInvalidName
        }</span>

        <span class="cov0" title="0">item.ProfileName = value

        return nil</span>
}

func (item *Account) SetProfileSurname(value string) error <span class="cov0" title="0">{
        value = strings.TrimSpace(value)

        if value == "" </span><span class="cov0" title="0">{
                return ErrAccountProfileInvalidSurname
        }</span>

        <span class="cov0" title="0">item.ProfileSurname = value

        return nil</span>
}

func NewAccount(
        email string,
        password string,
        skipPasswordCheck bool,
        isConfirmed bool,
) (*Account, error) <span class="cov0" title="0">{
        timeNow := time.Now().Truncate(time.Microsecond)

        account := &amp;Account{
                ID:          uuid.New(),
                IsConfirmed: isConfirmed,
                CreatedAt:   timeNow,
                UpdatedAt:   timeNow,
        }

        err := account.SetEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = account.SetPassword(password, skipPasswordCheck)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return account, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package entity

import (
        "github.com/go-playground/validator/v10"
)

var validate *validator.Validate

func init() <span class="cov0" title="0">{
        validate = validator.New()
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package entity

import (
        "net"
        "time"

        "github.com/google/uuid"
)

type Session struct {
        ID                    uuid.UUID
        AccountID             uuid.UUID
        RefreshToken          uuid.UUID
        RefreshVersion        uint64
        RefreshTokenIssuedAt  time.Time
        RefreshTokenExpiresAt time.Time
        RefreshTokenRequestIP net.IP
        CreateRequestIP       net.IP

        CreatedAt time.Time
        UpdatedAt time.Time
        DeletedAt *time.Time
}

func (item *Session) Version() int64 <span class="cov0" title="0">{
        return item.UpdatedAt.UnixMicro()
}</span>

func (item *Session) GenerateNewRefresh(timeIssuedAt time.Time, duration time.Duration, ip net.IP) <span class="cov0" title="0">{
        item.RefreshTokenIssuedAt = timeIssuedAt.Truncate(time.Microsecond)
        item.RefreshTokenExpiresAt = item.RefreshTokenIssuedAt.Add(duration)
        item.RefreshTokenRequestIP = ip
        item.RefreshToken = uuid.New()
        item.RefreshVersion++
}</span>

func (item *Session) IsAlive(timeForCheck time.Time) bool <span class="cov0" title="0">{
        return item.RefreshTokenExpiresAt.Before(timeForCheck)
}</span>

func NewSession(accountID uuid.UUID, ip net.IP, timeIssuedAt time.Time, refreshDuration time.Duration) *Session <span class="cov0" title="0">{
        timeNow := time.Now().Truncate(time.Microsecond)

        item := &amp;Session{
                ID:              uuid.New(),
                AccountID:       accountID,
                CreateRequestIP: ip,

                CreatedAt: timeNow,
                UpdatedAt: timeNow,
        }

        item.GenerateNewRefresh(timeIssuedAt, refreshDuration, ip)

        return item
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package auth

import (
        "log/slog"

        "github.com/m11ano/budget_planner/backend/auth/internal/app"
        "github.com/m11ano/budget_planner/backend/auth/internal/app/fxboot/invoking"
)

func Init(_ app.ID, logger *slog.Logger) invoking.InvokeInit <span class="cov0" title="0">{
        return invoking.InvokeInit{}
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package pg

import (
        "net"
        "time"

        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
        "github.com/m11ano/budget_planner/backend/auth/pkg/dbhelper"
)

const (
        AccountTable = "account"
)

var AccountTableFields = []string{}

func init() <span class="cov0" title="0">{
        AccountTableFields = dbhelper.ExtractDBFields(&amp;AccountDBModel{})
}</span>

type AccountDBModel struct {
        ID             uuid.UUID  `db:"id"`
        Email          string     `db:"email"`
        PasswordHash   string     `db:"password_hash"`
        IsConfirmed    bool       `db:"is_confirmed"`
        IsBlocked      bool       `db:"is_blocked"`
        LastLoginAt    *time.Time `db:"last_login_at"`
        LastRequestAt  *time.Time `db:"last_request_at"`
        LastRequestIP  *net.IP    `db:"last_request_ip"`
        ProfileName    string     `db:"profile_name"`
        ProfileSurname string     `db:"profile_surname"`

        CreatedAt time.Time  `db:"created_at"`
        UpdatedAt time.Time  `db:"updated_at"`
        DeletedAt *time.Time `db:"deleted_at"`
}

func (db *AccountDBModel) ToEntity() *entity.Account <span class="cov0" title="0">{
        return &amp;entity.Account{
                ID:             db.ID,
                Email:          db.Email,
                PasswordHash:   db.PasswordHash,
                IsConfirmed:    db.IsConfirmed,
                IsBlocked:      db.IsBlocked,
                LastLoginAt:    db.LastLoginAt,
                LastRequestAt:  db.LastRequestAt,
                LastRequestIP:  db.LastRequestIP,
                ProfileName:    db.ProfileName,
                ProfileSurname: db.ProfileSurname,

                CreatedAt: db.CreatedAt,
                UpdatedAt: db.UpdatedAt,
                DeletedAt: db.DeletedAt,
        }
}</span>

func MapAccountEntityToDBModel(entity *entity.Account) *AccountDBModel <span class="cov0" title="0">{
        return &amp;AccountDBModel{
                ID:             entity.ID,
                Email:          entity.Email,
                PasswordHash:   entity.PasswordHash,
                IsConfirmed:    entity.IsConfirmed,
                IsBlocked:      entity.IsBlocked,
                LastLoginAt:    entity.LastLoginAt,
                LastRequestAt:  entity.LastRequestAt,
                LastRequestIP:  entity.LastRequestIP,
                ProfileName:    entity.ProfileName,
                ProfileSurname: entity.ProfileSurname,

                CreatedAt: entity.CreatedAt,
                UpdatedAt: entity.UpdatedAt,
                DeletedAt: entity.DeletedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package account

import (
        "context"
        "log/slog"
        "time"

        "github.com/Masterminds/squirrel"
        "github.com/google/uuid"
        appErrors "github.com/m11ano/budget_planner/backend/auth/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/repository/pg"
        "github.com/m11ano/budget_planner/backend/auth/internal/infra/loghandler"
        "github.com/m11ano/budget_planner/backend/auth/pkg/dbhelper"
)

func (r *Repository) Create(ctx context.Context, item *entity.Account) error <span class="cov0" title="0">{
        const op = "Create"

        dataMap, err := dbhelper.DBModelToMap(pg.MapAccountEntityToDBModel(item))
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "convert struct to db map", slog.Any("error", err))
                return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">query, args, err := r.qb.Insert(pg.AccountTable).SetMap(dataMap).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">_, err = r.pgClient.GetConn(ctx).Exec(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *Repository) Update(ctx context.Context, item *entity.Account) error <span class="cov0" title="0">{
        const op = "Update"

        currentUpdatedAt := item.UpdatedAt
        timeNow := time.Now().Truncate(time.Microsecond)

        dataMap, err := dbhelper.DBModelToMap(pg.MapAccountEntityToDBModel(item))
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "convert struct to db map", slog.Any("error", err))
                return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>
        <span class="cov0" title="0">delete(dataMap, "id")
        dataMap["updated_at"] = timeNow

        err = r.pgClient.Do(ctx, func(ctx context.Context) error </span><span class="cov0" title="0">{
                checkQuery, checkArgs, err := r.qb.Select("id").From(pg.AccountTable).Where(squirrel.Eq{"id": item.ID}).ToSql()
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "building check query", slog.Any("error", err))
                        return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
                }</span>

                <span class="cov0" title="0">var checkID uuid.UUID
                err = r.pgClient.GetConn(ctx).QueryRow(ctx, checkQuery, checkArgs...).Scan(&amp;checkID)
                if err != nil </span><span class="cov0" title="0">{
                        convErr, ok := appErrors.ConvertPgxToAppErr(err)
                        if !ok </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(loghandler.WithSource(ctx), "executing check query", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
                }

                <span class="cov0" title="0">updQuery, updArgs, err := r.qb.Update(pg.AccountTable).Where(
                        squirrel.Eq{"id": item.ID, "updated_at": currentUpdatedAt}).SetMap(dataMap).ToSql()
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                        return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
                }</span>

                <span class="cov0" title="0">cmdTag, err := r.pgClient.GetConn(ctx).Exec(ctx, updQuery, updArgs...)
                if err != nil </span><span class="cov0" title="0">{
                        convErr, ok := appErrors.ConvertPgxToAppErr(err)
                        if !ok </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(loghandler.WithSource(ctx), "executing query", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
                }

                <span class="cov0" title="0">if cmdTag.RowsAffected() == 0 </span><span class="cov0" title="0">{
                        return appErrors.Chainf(appErrors.ErrConflict, "%s.%s", r.pkg, op)
                }</span>

                <span class="cov0" title="0">item.UpdatedAt = timeNow

                return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package account

import (
        "context"
        "log/slog"

        "github.com/Masterminds/squirrel"
        "github.com/georgysavva/scany/v2/pgxscan"
        "github.com/google/uuid"
        appErrors "github.com/m11ano/budget_planner/backend/auth/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/auth/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/repository/pg"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
        "github.com/m11ano/budget_planner/backend/auth/internal/infra/loghandler"
        "github.com/samber/lo"
)

func (r *Repository) buildWhereForList(listOptions *usecase.AccountListOptions, withDeleted bool) (where squirrel.And) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if !withDeleted </span><span class="cov0" title="0">{
                        where = append(where, squirrel.Expr("deleted_at IS NULL"))
                }</span>
        }()

        <span class="cov0" title="0">if listOptions == nil </span><span class="cov0" title="0">{
                return where
        }</span>

        <span class="cov0" title="0">if listOptions.FilterIDs != nil </span><span class="cov0" title="0">{
                where = append(where, squirrel.Eq{"id": lo.Uniq(*listOptions.FilterIDs)})
        }</span>

        <span class="cov0" title="0">return where</span>
}

func (r *Repository) buildSortForList(listOptions *usecase.AccountListOptions) []string <span class="cov0" title="0">{
        if listOptions == nil || len(listOptions.Sort) == 0 </span><span class="cov0" title="0">{
                return []string{"created_at DESC"}
        }</span>

        <span class="cov0" title="0">sort := make([]string, 0, len(listOptions.Sort))

        for _, sortOption := range listOptions.Sort </span><span class="cov0" title="0">{
                switch sortOption.Field </span>{
                case usecase.AccountListOptionsSortFieldCreatedAt:<span class="cov0" title="0">
                        if sortOption.IsDesc </span><span class="cov0" title="0">{
                                sort = append(sort, "created_at DESC")
                        }</span> else<span class="cov0" title="0"> {
                                sort = append(sort, "created_at ASC")
                        }</span>
                }
        }

        <span class="cov0" title="0">return sort</span>
}

func (r *Repository) FindList(
        ctx context.Context,
        listOptions *usecase.AccountListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]*entity.Account, error) <span class="cov0" title="0">{
        const op = "FindList"

        withDeleted := queryParams != nil &amp;&amp; queryParams.WithDeleted

        where := r.buildWhereForList(listOptions, withDeleted)

        fields := pg.AccountTableFields

        q := r.qb.Select(fields...).From(pg.AccountTable).Where(where)

        sort := r.buildSortForList(listOptions)
        if len(sort) &gt; 0 </span><span class="cov0" title="0">{
                q = q.OrderBy(sort...)
        }</span>

        <span class="cov0" title="0">if queryParams != nil </span><span class="cov0" title="0">{
                if queryParams.ForUpdateSkipLocked </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE SKIP LOCKED")
                }</span> else<span class="cov0" title="0"> if queryParams.ForUpdate </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE")
                }</span> else<span class="cov0" title="0"> if queryParams.ForShare </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR SHARE")
                }</span>

                <span class="cov0" title="0">if queryParams.Limit &gt; 0 </span><span class="cov0" title="0">{
                        q = q.Limit(queryParams.Limit)
                }</span>

                <span class="cov0" title="0">if queryParams.Offset &gt; 0 </span><span class="cov0" title="0">{
                        q = q.Offset(queryParams.Offset)
                }</span>
        }

        <span class="cov0" title="0">query, args, err := q.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                return nil, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">rows, err := r.pgClient.GetConn(ctx).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "query row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        dbData := []*pg.AccountDBModel{}

        if err := pgxscan.ScanAll(&amp;dbData, rows); err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "scan row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">result := make([]*entity.Account, 0, len(dbData))
        for _, dbItem := range dbData </span><span class="cov0" title="0">{
                result = append(result, dbItem.ToEntity())
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (r *Repository) FindPagedList(
        ctx context.Context,
        listOptions *usecase.AccountListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]*entity.Account, uint64, error) <span class="cov0" title="0">{
        const op = "FindPagedList"

        withDeleted := queryParams != nil &amp;&amp; queryParams.WithDeleted

        where := r.buildWhereForList(listOptions, withDeleted)

        fields := pg.AccountTableFields

        q := r.qb.Select(fields...).From(pg.AccountTable).Where(where)

        sort := r.buildSortForList(listOptions)
        if len(sort) &gt; 0 </span><span class="cov0" title="0">{
                q = q.OrderBy(sort...)
        }</span>

        <span class="cov0" title="0">if queryParams != nil </span><span class="cov0" title="0">{
                if queryParams.ForUpdateSkipLocked </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE SKIP LOCKED")
                }</span> else<span class="cov0" title="0"> if queryParams.ForUpdate </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE")
                }</span> else<span class="cov0" title="0"> if queryParams.ForShare </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR SHARE")
                }</span>

                <span class="cov0" title="0">if queryParams.Limit &gt; 0 </span><span class="cov0" title="0">{
                        q = q.Limit(queryParams.Limit)
                }</span>

                <span class="cov0" title="0">if queryParams.Offset &gt; 0 </span><span class="cov0" title="0">{
                        q = q.Offset(queryParams.Offset)
                }</span>
        }

        <span class="cov0" title="0">query, args, err := q.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                return nil, 0, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">totalQ := r.qb.Select("COUNT(*) as total").From(pg.AccountTable).Where(where)
        totalQuery, totalArgs, err := totalQ.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query for total", slog.Any("error", err))
                return nil, 0, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">var total uint64
        var result []*entity.Account

        err = r.pgClient.Do(ctx, func(ctx context.Context) error </span><span class="cov0" title="0">{
                rows, err := r.pgClient.GetConn(ctx).Query(ctx, query, args...)
                if err != nil </span><span class="cov0" title="0">{
                        convErr, ok := appErrors.ConvertPgxToAppErr(err)
                        if !ok </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(loghandler.WithSource(ctx), "query row error", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
                }

                <span class="cov0" title="0">defer rows.Close()

                dbData := []*pg.AccountDBModel{}

                if err := pgxscan.ScanAll(&amp;dbData, rows); err != nil </span><span class="cov0" title="0">{
                        convErr, ok := appErrors.ConvertPgxToAppErr(err)
                        if !ok </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(loghandler.WithSource(ctx), "scan row error", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
                }

                <span class="cov0" title="0">result = make([]*entity.Account, 0, len(dbData))
                for _, dbItem := range dbData </span><span class="cov0" title="0">{
                        result = append(result, dbItem.ToEntity())
                }</span>

                <span class="cov0" title="0">row := r.pgClient.GetConn(ctx).QueryRow(ctx, totalQuery, totalArgs...)
                if err := row.Scan(&amp;total); err != nil </span><span class="cov0" title="0">{
                        convErr, ok := appErrors.ConvertPgxToAppErr(err)
                        if !ok </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(loghandler.WithSource(ctx), "scan total error", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return result, total, nil</span>
}

func (r *Repository) FindOneByID(
        ctx context.Context,
        id uuid.UUID,
        queryParams *uctypes.QueryGetOneParams,
) (*entity.Account, error) <span class="cov0" title="0">{
        const op = "FindOneByID"

        withDeleted := queryParams != nil &amp;&amp; queryParams.WithDeleted

        where := squirrel.And{
                squirrel.Eq{"id": id},
        }

        if !withDeleted </span><span class="cov0" title="0">{
                where = append(where, squirrel.Expr("deleted_at IS NULL"))
        }</span>

        <span class="cov0" title="0">q := r.qb.Select(pg.AccountTableFields...).From(pg.AccountTable).Where(where)

        if queryParams != nil </span><span class="cov0" title="0">{
                if queryParams.ForUpdateSkipLocked </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE SKIP LOCKED")
                }</span> else<span class="cov0" title="0"> if queryParams.ForUpdate </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE")
                }</span> else<span class="cov0" title="0"> if queryParams.ForShare </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR SHARE")
                }</span>
        }

        <span class="cov0" title="0">query, args, err := q.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                return nil, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">rows, err := r.pgClient.GetConn(ctx).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "query row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        dbData := &amp;pg.AccountDBModel{}

        if err := pgxscan.ScanOne(dbData, rows); err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "scan row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">return dbData.ToEntity(), nil</span>
}

func (r *Repository) FindOneByEmail(
        ctx context.Context,
        email string,
        queryParams *uctypes.QueryGetOneParams,
) (*entity.Account, error) <span class="cov0" title="0">{
        const op = "FindOneByEmail"

        withDeleted := queryParams != nil &amp;&amp; queryParams.WithDeleted

        where := squirrel.And{
                squirrel.Eq{"email": email},
        }

        if !withDeleted </span><span class="cov0" title="0">{
                where = append(where, squirrel.Expr("deleted_at IS NULL"))
        }</span>

        <span class="cov0" title="0">q := r.qb.Select(pg.AccountTableFields...).From(pg.AccountTable).Where(where)

        if queryParams != nil </span><span class="cov0" title="0">{
                if queryParams.ForUpdateSkipLocked </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE SKIP LOCKED")
                }</span> else<span class="cov0" title="0"> if queryParams.ForUpdate </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE")
                }</span> else<span class="cov0" title="0"> if queryParams.ForShare </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR SHARE")
                }</span>
        }

        <span class="cov0" title="0">query, args, err := q.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                return nil, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">rows, err := r.pgClient.GetConn(ctx).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "query row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        dbData := &amp;pg.AccountDBModel{}

        if err := pgxscan.ScanOne(dbData, rows); err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "scan row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">return dbData.ToEntity(), nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package account

import (
        "log/slog"

        "github.com/Masterminds/squirrel"
        "github.com/m11ano/budget_planner/backend/auth/internal/infra/db"
)

type Repository struct {
        pkg      string
        logger   *slog.Logger
        pgClient db.MasterClient
        qb       squirrel.StatementBuilderType
}

func NewRepository(logger *slog.Logger, pgClient db.MasterClient) *Repository <span class="cov0" title="0">{
        return &amp;Repository{
                pkg:      "Auth.repository.Account",
                logger:   logger,
                pgClient: pgClient,
                qb:       squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar),
        }
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package pg

import (
        "net"
        "time"

        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
        "github.com/m11ano/budget_planner/backend/auth/pkg/dbhelper"
)

const (
        SessionTable = "auth_session"
)

var SessionTableFields = []string{}

func init() <span class="cov0" title="0">{
        SessionTableFields = dbhelper.ExtractDBFields(&amp;SessionDBModel{})
}</span>

type SessionDBModel struct {
        ID                    uuid.UUID `db:"id"`
        AccountID             uuid.UUID `db:"account_id"`
        RefreshToken          uuid.UUID `db:"refresh_token"`
        RefreshVersion        uint64    `db:"refresh_version"`
        RefreshTokenIssuedAt  time.Time `db:"refresh_token_issued_at"`
        RefreshTokenExpiresAt time.Time `db:"refresh_token_expires_at"`
        RefreshTokenRequestIP net.IP    `db:"refresh_token_request_ip"`
        CreateRequestIP       net.IP    `db:"create_request_ip"`

        CreatedAt time.Time  `db:"created_at"`
        UpdatedAt time.Time  `db:"updated_at"`
        DeletedAt *time.Time `db:"deleted_at"`
}

func (db *SessionDBModel) ToEntity() *entity.Session <span class="cov0" title="0">{
        return &amp;entity.Session{
                ID:                    db.ID,
                AccountID:             db.AccountID,
                RefreshToken:          db.RefreshToken,
                RefreshVersion:        db.RefreshVersion,
                RefreshTokenIssuedAt:  db.RefreshTokenIssuedAt,
                RefreshTokenExpiresAt: db.RefreshTokenExpiresAt,
                RefreshTokenRequestIP: db.RefreshTokenRequestIP,
                CreateRequestIP:       db.CreateRequestIP,

                CreatedAt: db.CreatedAt,
                UpdatedAt: db.UpdatedAt,
                DeletedAt: db.DeletedAt,
        }
}</span>

func MapSessionEntityToDBModel(entity *entity.Session) *SessionDBModel <span class="cov0" title="0">{
        return &amp;SessionDBModel{
                ID:                    entity.ID,
                AccountID:             entity.AccountID,
                RefreshToken:          entity.RefreshToken,
                RefreshVersion:        entity.RefreshVersion,
                RefreshTokenIssuedAt:  entity.RefreshTokenIssuedAt,
                RefreshTokenExpiresAt: entity.RefreshTokenExpiresAt,
                RefreshTokenRequestIP: entity.RefreshTokenRequestIP,
                CreateRequestIP:       entity.CreateRequestIP,

                CreatedAt: entity.CreatedAt,
                UpdatedAt: entity.UpdatedAt,
                DeletedAt: entity.DeletedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package session

import (
        "context"
        "log/slog"
        "time"

        "github.com/Masterminds/squirrel"
        "github.com/google/uuid"
        appErrors "github.com/m11ano/budget_planner/backend/auth/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/repository/pg"
        "github.com/m11ano/budget_planner/backend/auth/internal/infra/loghandler"
        "github.com/m11ano/budget_planner/backend/auth/pkg/dbhelper"
)

func (r *Repository) Create(ctx context.Context, item *entity.Session) error <span class="cov0" title="0">{
        const op = "Create"

        dataMap, err := dbhelper.DBModelToMap(pg.MapSessionEntityToDBModel(item))
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "convert struct to db map", slog.Any("error", err))
                return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">query, args, err := r.qb.Insert(pg.SessionTable).SetMap(dataMap).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">_, err = r.pgClient.GetConn(ctx).Exec(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *Repository) Update(ctx context.Context, item *entity.Session) error <span class="cov0" title="0">{
        const op = "Update"

        currentUpdatedAt := item.UpdatedAt
        timeNow := time.Now().Truncate(time.Microsecond)

        dataMap, err := dbhelper.DBModelToMap(pg.MapSessionEntityToDBModel(item))
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "convert struct to db map", slog.Any("error", err))
                return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>
        <span class="cov0" title="0">delete(dataMap, "id")
        dataMap["updated_at"] = timeNow

        err = r.pgClient.Do(ctx, func(ctx context.Context) error </span><span class="cov0" title="0">{
                checkQuery, checkArgs, err := r.qb.Select("id").From(pg.SessionTable).Where(squirrel.Eq{"id": item.ID}).ToSql()
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "building check query", slog.Any("error", err))
                        return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
                }</span>

                <span class="cov0" title="0">var checkID uuid.UUID
                err = r.pgClient.GetConn(ctx).QueryRow(ctx, checkQuery, checkArgs...).Scan(&amp;checkID)
                if err != nil </span><span class="cov0" title="0">{
                        convErr, ok := appErrors.ConvertPgxToAppErr(err)
                        if !ok </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(loghandler.WithSource(ctx), "executing check query", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
                }

                <span class="cov0" title="0">updQuery, updArgs, err := r.qb.Update(pg.SessionTable).Where(
                        squirrel.Eq{"id": item.ID, "updated_at": currentUpdatedAt}).SetMap(dataMap).ToSql()
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                        return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
                }</span>

                <span class="cov0" title="0">cmdTag, err := r.pgClient.GetConn(ctx).Exec(ctx, updQuery, updArgs...)
                if err != nil </span><span class="cov0" title="0">{
                        convErr, ok := appErrors.ConvertPgxToAppErr(err)
                        if !ok </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(loghandler.WithSource(ctx), "executing query", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
                }

                <span class="cov0" title="0">if cmdTag.RowsAffected() == 0 </span><span class="cov0" title="0">{
                        return appErrors.Chainf(appErrors.ErrConflict, "%s.%s", r.pkg, op)
                }</span>

                <span class="cov0" title="0">item.UpdatedAt = timeNow

                return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package session

import (
        "context"
        "log/slog"

        "github.com/Masterminds/squirrel"
        "github.com/georgysavva/scany/v2/pgxscan"
        "github.com/google/uuid"
        appErrors "github.com/m11ano/budget_planner/backend/auth/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/auth/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/repository/pg"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
        "github.com/m11ano/budget_planner/backend/auth/internal/infra/loghandler"
)

func (r *Repository) buildWhereForList(listOptions *usecase.SessionListOptions, withDeleted bool) (where squirrel.And) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if !withDeleted </span><span class="cov0" title="0">{
                        where = append(where, squirrel.Expr("deleted_at IS NULL"))
                }</span>
        }()

        <span class="cov0" title="0">if listOptions == nil </span><span class="cov0" title="0">{
                return where
        }</span>

        <span class="cov0" title="0">if listOptions.FilterAccountID != nil </span><span class="cov0" title="0">{
                where = append(where, squirrel.Eq{"account_id": *listOptions.FilterAccountID})
        }</span>

        <span class="cov0" title="0">return where</span>
}

func (r *Repository) buildSortForList(_ *usecase.SessionListOptions) []string <span class="cov0" title="0">{
        return []string{"created_at DESC"}
}</span>

func (r *Repository) FindList(
        ctx context.Context,
        listOptions *usecase.SessionListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]*entity.Session, error) <span class="cov0" title="0">{
        const op = "FindList"

        withDeleted := queryParams != nil &amp;&amp; queryParams.WithDeleted

        where := r.buildWhereForList(listOptions, withDeleted)

        fields := pg.SessionTableFields

        q := r.qb.Select(fields...).From(pg.SessionTable).Where(where)

        sort := r.buildSortForList(listOptions)
        if len(sort) &gt; 0 </span><span class="cov0" title="0">{
                q = q.OrderBy(sort...)
        }</span>

        <span class="cov0" title="0">if queryParams != nil </span><span class="cov0" title="0">{
                if queryParams.ForUpdateSkipLocked </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE SKIP LOCKED")
                }</span> else<span class="cov0" title="0"> if queryParams.ForUpdate </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE")
                }</span> else<span class="cov0" title="0"> if queryParams.ForShare </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR SHARE")
                }</span>

                <span class="cov0" title="0">if queryParams.Limit &gt; 0 </span><span class="cov0" title="0">{
                        q = q.Limit(queryParams.Limit)
                }</span>

                <span class="cov0" title="0">if queryParams.Offset &gt; 0 </span><span class="cov0" title="0">{
                        q = q.Offset(queryParams.Offset)
                }</span>
        }

        <span class="cov0" title="0">query, args, err := q.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                return nil, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">rows, err := r.pgClient.GetConn(ctx).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "query row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        dbData := []*pg.SessionDBModel{}

        if err := pgxscan.ScanAll(&amp;dbData, rows); err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "scan row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">result := make([]*entity.Session, 0, len(dbData))
        for _, dbItem := range dbData </span><span class="cov0" title="0">{
                result = append(result, dbItem.ToEntity())
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (r *Repository) FindOneByID(
        ctx context.Context,
        id uuid.UUID,
        queryParams *uctypes.QueryGetOneParams,
) (*entity.Session, error) <span class="cov0" title="0">{
        const op = "FindOneByID"

        withDeleted := queryParams != nil &amp;&amp; queryParams.WithDeleted

        where := squirrel.And{
                squirrel.Eq{"id": id},
        }

        if !withDeleted </span><span class="cov0" title="0">{
                where = append(where, squirrel.Expr("deleted_at IS NULL"))
        }</span>

        <span class="cov0" title="0">q := r.qb.Select(pg.SessionTableFields...).From(pg.SessionTable).Where(where)

        if queryParams != nil </span><span class="cov0" title="0">{
                if queryParams.ForUpdateSkipLocked </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE SKIP LOCKED")
                }</span> else<span class="cov0" title="0"> if queryParams.ForUpdate </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE")
                }</span> else<span class="cov0" title="0"> if queryParams.ForShare </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR SHARE")
                }</span>
        }

        <span class="cov0" title="0">query, args, err := q.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                return nil, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">rows, err := r.pgClient.GetConn(ctx).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "query row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        dbData := &amp;pg.SessionDBModel{}

        if err := pgxscan.ScanOne(dbData, rows); err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "scan row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">return dbData.ToEntity(), nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package session

import (
        "log/slog"

        "github.com/Masterminds/squirrel"
        "github.com/m11ano/budget_planner/backend/auth/internal/infra/db"
)

type Repository struct {
        pkg      string
        logger   *slog.Logger
        pgClient db.MasterClient
        qb       squirrel.StatementBuilderType
}

func NewRepository(logger *slog.Logger, pgClient db.MasterClient) *Repository <span class="cov0" title="0">{
        return &amp;Repository{
                pkg:      "Auth.repository.Session",
                logger:   logger,
                pgClient: pgClient,
                qb:       squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar),
        }
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package account

import (
        "context"
        "errors"
        "net"

        "github.com/google/uuid"
        appErrors "github.com/m11ano/budget_planner/backend/auth/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/auth/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
        "github.com/m11ano/budget_planner/backend/auth/internal/infra/loghandler"
)

func (uc *UsecaseImpl) CreateAccountByDTO(
        ctx context.Context,
        in usecase.CreateAccountDataInput,
        requestIP *net.IP,
) (*usecase.AccountDTO, error) <span class="cov1" title="1">{
        const op = "CreateAccountByDTO"

        account, err := entity.NewAccount(
                in.Email,
                in.Password,
                in.SkipPasswordCheck,
                in.IsConfirmed,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">err = account.SetProfileName(in.ProfileName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">err = account.SetProfileSurname(in.ProfileSurname)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">err = uc.dbMasterClient.Do(ctx, func(ctx context.Context) error </span><span class="cov1" title="1">{
                _, err := uc.accountRepo.FindOneByEmail(ctx, account.Email, nil)
                if err == nil </span><span class="cov0" title="0">{
                        return appErrors.ErrUniqueViolation.WithDetail("field", false, "email").WithHints("email is already in use")
                }</span> else<span class="cov1" title="1"> if !errors.Is(err, appErrors.ErrNotFound) </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">err = uc.accountRepo.Create(ctx, account)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">return nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">accountDTO, err := uc.entitiesToDTO(ctx, []*entity.Account{account})
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">if len(accountDTO) == 0 </span><span class="cov0" title="0">{
                uc.logger.ErrorContext(loghandler.WithSource(ctx), "unpredicted empty account dto")
                return nil, appErrors.Chainf(appErrors.ErrInternal, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return accountDTO[0], nil</span>
}

func (uc *UsecaseImpl) PatchAccountByDTO(
        ctx context.Context,
        id uuid.UUID,
        in usecase.PatchAccountDataInput,
        skipVersionCheck bool,
) error <span class="cov10" title="2">{
        const op = "PatchAccountByDTO"

        err := uc.dbMasterClient.Do(ctx, func(ctx context.Context) error </span><span class="cov10" title="2">{
                account, err := uc.accountRepo.FindOneByID(ctx, id, &amp;uctypes.QueryGetOneParams{
                        ForUpdate: true,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov10" title="2">if !skipVersionCheck &amp;&amp; account.Version() != in.Version </span><span class="cov0" title="0">{
                        return appErrors.ErrVersionConflict.
                                WithDetail("last_version", false, account.Version()).
                                WithDetail("last_updated_at", false, account.UpdatedAt)
                }</span>

                <span class="cov10" title="2">if in.Email != nil </span><span class="cov1" title="1">{
                        err = account.SetEmail(*in.Email)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov1" title="1">checkAccount, err := uc.accountRepo.FindOneByEmail(ctx, account.Email, nil)
                        if err == nil &amp;&amp; checkAccount.ID != account.ID </span><span class="cov0" title="0">{
                                return appErrors.ErrUniqueViolation.WithDetail("field", false, "email")
                        }</span> else<span class="cov1" title="1"> if err != nil &amp;&amp; !errors.Is(err, appErrors.ErrNotFound) </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov10" title="2">if in.Password != nil </span><span class="cov1" title="1">{
                        err = account.SetPassword(*in.Password, in.SkipPasswordCheck)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov10" title="2">if in.IsBlocked != nil </span><span class="cov0" title="0">{
                        account.IsBlocked = *in.IsBlocked
                }</span>

                <span class="cov10" title="2">if in.ProfileName != nil </span><span class="cov0" title="0">{
                        err := account.SetProfileName(*in.ProfileName)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov10" title="2">if in.ProfileSurname != nil </span><span class="cov0" title="0">{
                        err := account.SetProfileSurname(*in.ProfileSurname)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov10" title="2">err = uc.accountRepo.Update(ctx, account)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov10" title="2">if in.Password != nil </span><span class="cov1" title="1">{
                        err = uc.sessionUC.RevokeSessionsByAccountID(ctx, id)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov10" title="2">return nil</span>
        })
        <span class="cov10" title="2">if err != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov10" title="2">return nil</span>
}

func (uc *UsecaseImpl) UpdateAccount(ctx context.Context, item *entity.Account) error <span class="cov10" title="2">{
        const op = "UpdateAccount"

        err := uc.accountRepo.Update(ctx, item)
        if err != nil </span><span class="cov1" title="1">{
                return appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package account

import (
        "context"

        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
)

func (uc *UsecaseImpl) entitiesToDTO(
        _ context.Context,
        items []*entity.Account,
) ([]*usecase.AccountDTO, error) <span class="cov9" title="8">{
        out := make([]*usecase.AccountDTO, 0, len(items))

        for _, item := range items </span><span class="cov10" title="9">{
                resItem := &amp;usecase.AccountDTO{
                        Account: item,
                }

                out = append(out, resItem)
        }</span>

        <span class="cov9" title="8">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package account

import (
        "log/slog"

        "github.com/m11ano/budget_planner/backend/auth/internal/app/config"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
        "github.com/m11ano/budget_planner/backend/auth/internal/infra/db"
)

type UsecaseImpl struct {
        pkg            string
        logger         *slog.Logger
        cfg            config.Config
        dbMasterClient db.MasterClient
        accountRepo    usecase.AccountRepository
        sessionUC      usecase.SessionUsecase
}

func NewUsecaseImpl(
        logger *slog.Logger,
        cfg config.Config,
        dbMasterClient db.MasterClient,
        accountRepo usecase.AccountRepository,
        sessionUC usecase.SessionUsecase,
) *UsecaseImpl <span class="cov10" title="17">{
        uc := &amp;UsecaseImpl{
                pkg:            "Auth.Usecase.Account",
                logger:         logger,
                cfg:            cfg,
                dbMasterClient: dbMasterClient,
                accountRepo:    accountRepo,
                sessionUC:      sessionUC,
        }
        return uc
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package account

import (
        "context"

        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/auth/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
        "github.com/samber/lo"

        appErrors "github.com/m11ano/budget_planner/backend/auth/internal/app/errors"
)

func (uc *UsecaseImpl) FindOneByEmail(
        ctx context.Context,
        email string,
        queryParams *uctypes.QueryGetOneParams,
) (*usecase.AccountDTO, error) <span class="cov6" title="2">{
        const op = "FindOneByEmail"

        item, err := uc.accountRepo.FindOneByEmail(ctx, email, queryParams)
        if err != nil </span><span class="cov1" title="1">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">dto, err := uc.entitiesToDTO(ctx, []*entity.Account{item})
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">if len(dto) == 0 </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrInternal, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return dto[0], nil</span>
}

func (uc *UsecaseImpl) FindOneByID(
        ctx context.Context,
        id uuid.UUID,
        queryParams *uctypes.QueryGetOneParams,
) (*usecase.AccountDTO, error) <span class="cov6" title="2">{
        const op = "FindOneByID"

        item, err := uc.accountRepo.FindOneByID(ctx, id, queryParams)
        if err != nil </span><span class="cov1" title="1">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">dto, err := uc.entitiesToDTO(ctx, []*entity.Account{item})
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">if len(dto) == 0 </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrInternal, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return dto[0], nil</span>
}

func (uc *UsecaseImpl) FindList(
        ctx context.Context,
        listOptions *usecase.AccountListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]*usecase.AccountDTO, error) <span class="cov10" title="3">{
        const op = "FindList"

        items, err := uc.accountRepo.FindList(ctx, listOptions, queryParams)
        if err != nil </span><span class="cov1" title="1">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov6" title="2">out, err := uc.entitiesToDTO(ctx, items)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov6" title="2">return out, nil</span>
}

func (uc *UsecaseImpl) FindPagedList(
        ctx context.Context,
        listOptions *usecase.AccountListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]*usecase.AccountDTO, uint64, error) <span class="cov6" title="2">{
        const op = "FindPagedList"

        items, total, err := uc.accountRepo.FindPagedList(ctx, listOptions, queryParams)
        if err != nil </span><span class="cov1" title="1">{
                return nil, 0, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">out, err := uc.entitiesToDTO(ctx, items)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return out, total, nil</span>
}

func (uc *UsecaseImpl) FindListInMap(
        ctx context.Context,
        listOptions *usecase.AccountListOptions,
        queryParams *uctypes.QueryGetListParams,
) (map[uuid.UUID]*usecase.AccountDTO, error) <span class="cov10" title="3">{
        const op = "FindListInMap"

        items, err := uc.accountRepo.FindList(ctx, listOptions, queryParams)
        if err != nil </span><span class="cov1" title="1">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov6" title="2">out, err := uc.entitiesToDTO(ctx, items)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov6" title="2">result := lo.SliceToMap(out, func(item *usecase.AccountDTO) (uuid.UUID, *usecase.AccountDTO) </span><span class="cov6" title="2">{
                return item.Account.ID, item
        }</span>)

        <span class="cov6" title="2">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package auth

import (
        "context"
        "errors"
        "net"
        "strings"
        "time"

        "github.com/golang-jwt/jwt/v5"
        appErrors "github.com/m11ano/budget_planner/backend/auth/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/auth/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        "github.com/m11ano/budget_planner/backend/auth/pkg/emailnormalize"
)

func (uc *UsecaseImpl) LoginByEmail(
        ctx context.Context,
        email string,
        password string,
        ip net.IP,
) (*usecase.AuthSessionDTO, error) <span class="cov1" title="1">{
        const op = "LoginByEmail"

        res, err := emailnormalize.Normalize(strings.TrimSpace(email))
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrUnauthorized, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">email = res.NormalizedAddress

        out := &amp;usecase.AuthSessionDTO{}

        timeNow := time.Now()

        err = uc.dbMasterClient.Do(ctx, func(ctx context.Context) error </span><span class="cov1" title="1">{
                var err error

                out.AccountDTO, err = uc.accountUC.FindOneByEmail(ctx, email, &amp;uctypes.QueryGetOneParams{
                        ForUpdate: true,
                })
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, appErrors.ErrNotFound) </span><span class="cov0" title="0">{
                                return appErrors.ErrUnauthorized
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov1" title="1">if !out.AccountDTO.Account.VerifyPassword(password) </span><span class="cov0" title="0">{
                        return usecase.ErrPasswordIncorrect
                }</span>

                <span class="cov1" title="1">if !out.AccountDTO.Account.IsConfirmed </span><span class="cov0" title="0">{
                        return usecase.ErrAccountNotConfirmed
                }</span>

                <span class="cov1" title="1">if out.AccountDTO.Account.IsBlocked </span><span class="cov0" title="0">{
                        return usecase.ErrAccountBlocked
                }</span>

                <span class="cov1" title="1">out.Session = entity.NewSession(
                        out.AccountDTO.Account.ID,
                        ip,
                        timeNow,
                        time.Duration(uc.cfg.Auth.RefreshTokenLifetimeHrs)*time.Hour,
                )
                if err := uc.sessionUC.Create(ctx, out.Session); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">out.AccountDTO.Account.SetLastRequestAt(&amp;timeNow)
                out.AccountDTO.Account.SetLastLoginAt(&amp;timeNow)
                out.AccountDTO.Account.SetLastRequestIP(&amp;ip)

                err = uc.accountUC.UpdateAccount(ctx, out.AccountDTO.Account)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">return nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">out.RefreshClaims = uc.makeRefreshClaims(out.Session)
        out.AccessClaims = uc.makeAccessClaims(
                out.Session.ID,
                out.AccountDTO.Account.ID,
                nil,
                timeNow,
                time.Duration(uc.cfg.Auth.AccessTokenLifetimeSec)*time.Second,
        )

        return out, nil</span>
}

func (uc *UsecaseImpl) IssueAccessJWT(access *auth.SessionAccessClaims) (string, error) <span class="cov1" title="1">{
        const op = "IssueAccessJWT"

        signed, err := auth.IssueAccessJWT(access, []byte(uc.cfg.Auth.JwtAccessSecret))
        if err != nil </span><span class="cov0" title="0">{
                return "", appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return signed, nil</span>
}

func (uc *UsecaseImpl) IssueRefreshJWT(refresh *entity.SessionRefreshClaims) (string, error) <span class="cov1" title="1">{
        const op = "IssueRefreshJWT"

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, refresh)

        signed, err := token.SignedString([]byte(uc.cfg.Auth.JwtRefreshSecret))
        if err != nil </span><span class="cov0" title="0">{
                return "", appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return signed, nil</span>
}

// func (uc *UsecaseImpl) ParseAccessToken(tokenStr string, validate bool) (*auth.SessionAccessClaims, error) {
//         const op = "ParseAccessToken"

//         claims, err := auth.ParseAccessToken(tokenStr, validate, []byte(uc.cfg.Auth.JwtAccessSecret))
//         if err != nil {
//                 if errors.Is(err, auth.ErrInvalidToken) {
//                         return nil, appErrors.Chainf(usecase.ErrInvalidToken, "%s.%s", uc.pkg, op)
//                 }
//                 return nil, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", uc.pkg, op)
//         }

//         return claims, nil
// }

func (uc *UsecaseImpl) ParseRefreshToken(tokenStr string, validate bool) (*entity.SessionRefreshClaims, error) <span class="cov10" title="2">{
        const op = "ParseRefreshToken"

        ops := []jwt.ParserOption{
                jwt.WithValidMethods([]string{jwt.SigningMethodHS256.Name}),
        }

        if !validate </span><span class="cov0" title="0">{
                ops = append(ops, jwt.WithoutClaimsValidation())
        }</span>

        <span class="cov10" title="2">token, err := jwt.ParseWithClaims(tokenStr, &amp;entity.SessionRefreshClaims{}, func(token *jwt.Token) (any, error) </span><span class="cov1" title="1">{
                return []byte(uc.cfg.Auth.JwtRefreshSecret), nil
        }</span>, ops...)
        <span class="cov10" title="2">if err != nil || !token.Valid </span><span class="cov1" title="1">{
                return nil, appErrors.Chainf(usecase.ErrInvalidToken, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">claims, ok := token.Claims.(*entity.SessionRefreshClaims)
        if !ok </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(usecase.ErrInvalidToken, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return claims, nil</span>
}

func (uc *UsecaseImpl) GenerateNewClaims(
        ctx context.Context,
        refreshClaims *entity.SessionRefreshClaims,
        ip net.IP,
) (*usecase.AuthSessionDTO, error) <span class="cov1" title="1">{
        const op = "GenerateNewClaims"

        out := &amp;usecase.AuthSessionDTO{}

        timeNow := time.Now()

        err := uc.dbMasterClient.Do(ctx, func(ctx context.Context) error </span><span class="cov1" title="1">{
                var err error

                out.Session, err = uc.sessionUC.FindOneByID(ctx, refreshClaims.SessionID, &amp;uctypes.QueryGetOneParams{
                        ForUpdate: true,
                })
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, appErrors.ErrNotFound) </span><span class="cov0" title="0">{
                                return appErrors.ErrUnauthorized
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov1" title="1">if out.Session.RefreshToken != refreshClaims.RefreshKey </span><span class="cov0" title="0">{
                        return appErrors.ErrUnauthorized
                }</span>

                <span class="cov1" title="1">if out.Session.RefreshVersion != refreshClaims.RefreshVersion </span><span class="cov0" title="0">{
                        return appErrors.ErrUnauthorized
                }</span>

                <span class="cov1" title="1">if out.Session.RefreshTokenExpiresAt.Before(timeNow) </span><span class="cov0" title="0">{
                        return appErrors.ErrUnauthorized
                }</span>

                <span class="cov1" title="1">out.AccountDTO, err = uc.accountUC.FindOneByID(ctx, out.Session.AccountID, &amp;uctypes.QueryGetOneParams{
                        ForUpdate: true,
                })
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, appErrors.ErrNotFound) </span><span class="cov0" title="0">{
                                return appErrors.ErrUnauthorized
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov1" title="1">if !out.AccountDTO.Account.IsConfirmed </span><span class="cov0" title="0">{
                        return usecase.ErrAccountNotConfirmed
                }</span>

                <span class="cov1" title="1">if out.AccountDTO.Account.IsBlocked </span><span class="cov0" title="0">{
                        return usecase.ErrAccountBlocked
                }</span>

                <span class="cov1" title="1">out.Session.GenerateNewRefresh(timeNow, time.Duration(uc.cfg.Auth.RefreshTokenLifetimeHrs)*time.Hour, ip)

                err = uc.sessionUC.Update(ctx, out.Session)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">out.AccountDTO.Account.SetLastRequestAt(&amp;timeNow)
                out.AccountDTO.Account.SetLastLoginAt(&amp;timeNow)
                out.AccountDTO.Account.SetLastRequestIP(&amp;ip)

                err = uc.accountUC.UpdateAccount(ctx, out.AccountDTO.Account)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">return nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">out.RefreshClaims = uc.makeRefreshClaims(out.Session)
        out.AccessClaims = uc.makeAccessClaims(
                out.Session.ID,
                out.AccountDTO.Account.ID,
                nil,
                timeNow,
                time.Duration(uc.cfg.Auth.AccessTokenLifetimeSec)*time.Second,
        )

        return out, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package auth

import (
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        authpb "github.com/m11ano/budget_planner/backend/auth/pkg/proto_pb/access_claims"
)

func (uc *UsecaseImpl) makeRefreshClaims(session *entity.Session) *entity.SessionRefreshClaims <span class="cov10" title="2">{
        return &amp;entity.SessionRefreshClaims{
                SessionID:      session.ID,
                RefreshKey:     session.RefreshToken,
                RefreshVersion: session.RefreshVersion,
                RegisteredClaims: jwt.RegisteredClaims{
                        IssuedAt:  jwt.NewNumericDate(session.RefreshTokenIssuedAt),
                        ExpiresAt: jwt.NewNumericDate(session.RefreshTokenExpiresAt),
                },
        }
}</span>

func (uc *UsecaseImpl) makeAccessClaims(
        sessionID uuid.UUID,
        accountID uuid.UUID,
        meta map[string]string,
        issuedAt time.Time,
        duration time.Duration,
) *auth.SessionAccessClaims <span class="cov10" title="2">{
        return &amp;auth.SessionAccessClaims{
                AccessClaims: authpb.AccessClaims{
                        AccountId: accountID.String(),
                        SessionId: sessionID.String(),
                        Meta:      meta,
                },
                RegisteredClaims: jwt.RegisteredClaims{
                        IssuedAt:  jwt.NewNumericDate(issuedAt),
                        ExpiresAt: jwt.NewNumericDate(issuedAt.Add(duration)),
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package auth

import (
        "log/slog"

        "github.com/m11ano/budget_planner/backend/auth/internal/app/config"
        "github.com/m11ano/budget_planner/backend/auth/internal/infra/db"

        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
)

type UsecaseImpl struct {
        pkg            string
        logger         *slog.Logger
        cfg            config.Config
        dbMasterClient db.MasterClient
        accountUC      usecase.AccountUsecase
        sessionUC      usecase.SessionUsecase
}

func NewUsecaseImpl(
        logger *slog.Logger,
        cfg config.Config,
        dbMasterClient db.MasterClient,
        accountUC usecase.AccountUsecase,
        sessionUC usecase.SessionUsecase,
) *UsecaseImpl <span class="cov10" title="8">{
        uc := &amp;UsecaseImpl{
                pkg:            "Auth.usecase.Auth",
                logger:         logger,
                cfg:            cfg,
                dbMasterClient: dbMasterClient,
                accountUC:      accountUC,
                sessionUC:      sessionUC,
        }

        return uc
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package auth

import (
        "context"
        "errors"

        "github.com/google/uuid"
        appErrors "github.com/m11ano/budget_planner/backend/auth/internal/app/errors"
)

func (uc *UsecaseImpl) IsSessionConfirmed(
        ctx context.Context,
        id uuid.UUID,
) (bool, error) <span class="cov10" title="3">{
        const op = "IsSessionConfirmed"

        session, err := uc.sessionUC.FindOneByID(ctx, id, nil)
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, appErrors.ErrNotFound) </span><span class="cov1" title="1">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, appErrors.Chainf(err, "%s.%s", uc.pkg, op)</span>
        }

        <span class="cov6" title="2">accountDTO, err := uc.accountUC.FindOneByID(ctx, session.AccountID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return false, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov6" title="2">if !accountDTO.Account.IsConfirmed || accountDTO.Account.IsBlocked </span><span class="cov1" title="1">{
                return false, nil
        }</span>

        <span class="cov1" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package usecase

type Facade struct {
        Account AccountUsecase
        Session SessionUsecase
        Auth    AuthUsecase
}

func NewFacade(
        accountUC AccountUsecase,
        sessionUC SessionUsecase,
        authUC AuthUsecase,
) *Facade <span class="cov0" title="0">{
        return &amp;Facade{
                Account: accountUC,
                Session: sessionUC,
                Auth:    authUC,
        }
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase.AccountRepository -o account_repository.go -n AccountRepositoryMock -p mocks

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/auth/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
        mm_usecase "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
)

// AccountRepositoryMock implements mm_usecase.AccountRepository
type AccountRepositoryMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcCreate          func(ctx context.Context, item *entity.Account) (err error)
        funcCreateOrigin    string
        inspectFuncCreate   func(ctx context.Context, item *entity.Account)
        afterCreateCounter  uint64
        beforeCreateCounter uint64
        CreateMock          mAccountRepositoryMockCreate

        funcFindList          func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Account, err error)
        funcFindListOrigin    string
        inspectFuncFindList   func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams)
        afterFindListCounter  uint64
        beforeFindListCounter uint64
        FindListMock          mAccountRepositoryMockFindList

        funcFindOneByEmail          func(ctx context.Context, email string, queryParams *uctypes.QueryGetOneParams) (account *entity.Account, err error)
        funcFindOneByEmailOrigin    string
        inspectFuncFindOneByEmail   func(ctx context.Context, email string, queryParams *uctypes.QueryGetOneParams)
        afterFindOneByEmailCounter  uint64
        beforeFindOneByEmailCounter uint64
        FindOneByEmailMock          mAccountRepositoryMockFindOneByEmail

        funcFindOneByID          func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (account *entity.Account, err error)
        funcFindOneByIDOrigin    string
        inspectFuncFindOneByID   func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)
        afterFindOneByIDCounter  uint64
        beforeFindOneByIDCounter uint64
        FindOneByIDMock          mAccountRepositoryMockFindOneByID

        funcFindPagedList          func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Account, total uint64, err error)
        funcFindPagedListOrigin    string
        inspectFuncFindPagedList   func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams)
        afterFindPagedListCounter  uint64
        beforeFindPagedListCounter uint64
        FindPagedListMock          mAccountRepositoryMockFindPagedList

        funcUpdate          func(ctx context.Context, item *entity.Account) (err error)
        funcUpdateOrigin    string
        inspectFuncUpdate   func(ctx context.Context, item *entity.Account)
        afterUpdateCounter  uint64
        beforeUpdateCounter uint64
        UpdateMock          mAccountRepositoryMockUpdate
}

// NewAccountRepositoryMock returns a mock for mm_usecase.AccountRepository
func NewAccountRepositoryMock(t minimock.Tester) *AccountRepositoryMock <span class="cov0" title="0">{
        m := &amp;AccountRepositoryMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.CreateMock = mAccountRepositoryMockCreate{mock: m}
        m.CreateMock.callArgs = []*AccountRepositoryMockCreateParams{}

        m.FindListMock = mAccountRepositoryMockFindList{mock: m}
        m.FindListMock.callArgs = []*AccountRepositoryMockFindListParams{}

        m.FindOneByEmailMock = mAccountRepositoryMockFindOneByEmail{mock: m}
        m.FindOneByEmailMock.callArgs = []*AccountRepositoryMockFindOneByEmailParams{}

        m.FindOneByIDMock = mAccountRepositoryMockFindOneByID{mock: m}
        m.FindOneByIDMock.callArgs = []*AccountRepositoryMockFindOneByIDParams{}

        m.FindPagedListMock = mAccountRepositoryMockFindPagedList{mock: m}
        m.FindPagedListMock.callArgs = []*AccountRepositoryMockFindPagedListParams{}

        m.UpdateMock = mAccountRepositoryMockUpdate{mock: m}
        m.UpdateMock.callArgs = []*AccountRepositoryMockUpdateParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mAccountRepositoryMockCreate struct {
        optional           bool
        mock               *AccountRepositoryMock
        defaultExpectation *AccountRepositoryMockCreateExpectation
        expectations       []*AccountRepositoryMockCreateExpectation

        callArgs []*AccountRepositoryMockCreateParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// AccountRepositoryMockCreateExpectation specifies expectation struct of the AccountRepository.Create
type AccountRepositoryMockCreateExpectation struct {
        mock               *AccountRepositoryMock
        params             *AccountRepositoryMockCreateParams
        paramPtrs          *AccountRepositoryMockCreateParamPtrs
        expectationOrigins AccountRepositoryMockCreateExpectationOrigins
        results            *AccountRepositoryMockCreateResults
        returnOrigin       string
        Counter            uint64
}

// AccountRepositoryMockCreateParams contains parameters of the AccountRepository.Create
type AccountRepositoryMockCreateParams struct {
        ctx  context.Context
        item *entity.Account
}

// AccountRepositoryMockCreateParamPtrs contains pointers to parameters of the AccountRepository.Create
type AccountRepositoryMockCreateParamPtrs struct {
        ctx  *context.Context
        item **entity.Account
}

// AccountRepositoryMockCreateResults contains results of the AccountRepository.Create
type AccountRepositoryMockCreateResults struct {
        err error
}

// AccountRepositoryMockCreateOrigins contains origins of expectations of the AccountRepository.Create
type AccountRepositoryMockCreateExpectationOrigins struct {
        origin     string
        originCtx  string
        originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mAccountRepositoryMockCreate) Optional() *mAccountRepositoryMockCreate <span class="cov0" title="0">{
        mmCreate.optional = true
        return mmCreate
}</span>

// Expect sets up expected params for AccountRepository.Create
func (mmCreate *mAccountRepositoryMockCreate) Expect(ctx context.Context, item *entity.Account) *mAccountRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("AccountRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;AccountRepositoryMockCreateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("AccountRepositoryMock.Create mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmCreate.defaultExpectation.params = &amp;AccountRepositoryMockCreateParams{ctx, item}
        mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmCreate.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmCreate.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmCreate</span>
}

// ExpectCtxParam1 sets up expected param ctx for AccountRepository.Create
func (mmCreate *mAccountRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mAccountRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("AccountRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;AccountRepositoryMockCreateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("AccountRepositoryMock.Create mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation.paramPtrs = &amp;AccountRepositoryMockCreateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreate.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmCreate</span>
}

// ExpectItemParam2 sets up expected param item for AccountRepository.Create
func (mmCreate *mAccountRepositoryMockCreate) ExpectItemParam2(item *entity.Account) *mAccountRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("AccountRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;AccountRepositoryMockCreateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("AccountRepositoryMock.Create mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation.paramPtrs = &amp;AccountRepositoryMockCreateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreate.defaultExpectation.paramPtrs.item = &amp;item
        mmCreate.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

        return mmCreate</span>
}

// Inspect accepts an inspector function that has same arguments as the AccountRepository.Create
func (mmCreate *mAccountRepositoryMockCreate) Inspect(f func(ctx context.Context, item *entity.Account)) *mAccountRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.inspectFuncCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Inspect function is already set for AccountRepositoryMock.Create")
        }</span>

        <span class="cov0" title="0">mmCreate.mock.inspectFuncCreate = f

        return mmCreate</span>
}

// Return sets up results that will be returned by AccountRepository.Create
func (mmCreate *mAccountRepositoryMockCreate) Return(err error) *AccountRepositoryMock <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("AccountRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;AccountRepositoryMockCreateExpectation{mock: mmCreate.mock}
        }</span>
        <span class="cov0" title="0">mmCreate.defaultExpectation.results = &amp;AccountRepositoryMockCreateResults{err}
        mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmCreate.mock</span>
}

// Set uses given function f to mock the AccountRepository.Create method
func (mmCreate *mAccountRepositoryMockCreate) Set(f func(ctx context.Context, item *entity.Account) (err error)) *AccountRepositoryMock <span class="cov0" title="0">{
        if mmCreate.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Default expectation is already set for the AccountRepository.Create method")
        }</span>

        <span class="cov0" title="0">if len(mmCreate.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Some expectations are already set for the AccountRepository.Create method")
        }</span>

        <span class="cov0" title="0">mmCreate.mock.funcCreate = f
        mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
        return mmCreate.mock</span>
}

// When sets expectation for the AccountRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mAccountRepositoryMockCreate) When(ctx context.Context, item *entity.Account) *AccountRepositoryMockCreateExpectation <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("AccountRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;AccountRepositoryMockCreateExpectation{
                mock:               mmCreate.mock,
                params:             &amp;AccountRepositoryMockCreateParams{ctx, item},
                expectationOrigins: AccountRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmCreate.expectations = append(mmCreate.expectations, expectation)
        return expectation</span>
}

// Then sets up AccountRepository.Create return parameters for the expectation previously defined by the When method
func (e *AccountRepositoryMockCreateExpectation) Then(err error) *AccountRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;AccountRepositoryMockCreateResults{err}
        return e.mock
}</span>

// Times sets number of times AccountRepository.Create should be invoked
func (mmCreate *mAccountRepositoryMockCreate) Times(n uint64) *mAccountRepositoryMockCreate <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Times of AccountRepositoryMock.Create mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmCreate.expectedInvocations, n)
        mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmCreate</span>
}

func (mmCreate *mAccountRepositoryMockCreate) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmCreate.expectations) == 0 &amp;&amp; mmCreate.defaultExpectation == nil &amp;&amp; mmCreate.mock.funcCreate == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmCreate.mock.afterCreateCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmCreate.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Create implements mm_usecase.AccountRepository
func (mmCreate *AccountRepositoryMock) Create(ctx context.Context, item *entity.Account) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmCreate.beforeCreateCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmCreate.afterCreateCounter, 1)

        mmCreate.t.Helper()

        if mmCreate.inspectFuncCreate != nil </span><span class="cov0" title="0">{
                mmCreate.inspectFuncCreate(ctx, item)
        }</span>

        <span class="cov0" title="0">mm_params := AccountRepositoryMockCreateParams{ctx, item}

        // Record call args
        mmCreate.CreateMock.mutex.Lock()
        mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &amp;mm_params)
        mmCreate.CreateMock.mutex.Unlock()

        for _, e := range mmCreate.CreateMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmCreate.CreateMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmCreate.CreateMock.defaultExpectation.Counter, 1)
                mm_want := mmCreate.CreateMock.defaultExpectation.params
                mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

                mm_got := AccountRepositoryMockCreateParams{ctx, item}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmCreate.t.Errorf("AccountRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.item != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.item, mm_got.item) </span><span class="cov0" title="0">{
                                mmCreate.t.Errorf("AccountRepositoryMock.Create got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCreate.CreateMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmCreate.t.Errorf("AccountRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmCreate.CreateMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmCreate.t.Fatal("No results are set for the AccountRepositoryMock.Create")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmCreate.funcCreate != nil </span><span class="cov0" title="0">{
                return mmCreate.funcCreate(ctx, item)
        }</span>
        <span class="cov0" title="0">mmCreate.t.Fatalf("Unexpected call to AccountRepositoryMock.Create. %v %v", ctx, item)
        return</span>
}

// CreateAfterCounter returns a count of finished AccountRepositoryMock.Create invocations
func (mmCreate *AccountRepositoryMock) CreateAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreate.afterCreateCounter)
}</span>

// CreateBeforeCounter returns a count of AccountRepositoryMock.Create invocations
func (mmCreate *AccountRepositoryMock) CreateBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreate.beforeCreateCounter)
}</span>

// Calls returns a list of arguments used in each call to AccountRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mAccountRepositoryMockCreate) Calls() []*AccountRepositoryMockCreateParams <span class="cov0" title="0">{
        mmCreate.mutex.RLock()

        argCopy := make([]*AccountRepositoryMockCreateParams, len(mmCreate.callArgs))
        copy(argCopy, mmCreate.callArgs)

        mmCreate.mutex.RUnlock()

        return argCopy
}</span>

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *AccountRepositoryMock) MinimockCreateDone() bool <span class="cov0" title="0">{
        if m.CreateMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.CreateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.CreateMock.invocationsDone()</span>
}

// MinimockCreateInspect logs each unmet expectation
func (m *AccountRepositoryMock) MinimockCreateInspect() <span class="cov0" title="0">{
        for _, e := range m.CreateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterCreateCounter := mm_atomic.LoadUint64(&amp;m.afterCreateCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.CreateMock.defaultExpectation != nil &amp;&amp; afterCreateCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.CreateMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to AccountRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcCreate != nil &amp;&amp; afterCreateCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to AccountRepositoryMock.Create at\n%s", m.funcCreateOrigin)
        }</span>

        <span class="cov0" title="0">if !m.CreateMock.invocationsDone() &amp;&amp; afterCreateCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to AccountRepositoryMock.Create at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
        }</span>
}

type mAccountRepositoryMockFindList struct {
        optional           bool
        mock               *AccountRepositoryMock
        defaultExpectation *AccountRepositoryMockFindListExpectation
        expectations       []*AccountRepositoryMockFindListExpectation

        callArgs []*AccountRepositoryMockFindListParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// AccountRepositoryMockFindListExpectation specifies expectation struct of the AccountRepository.FindList
type AccountRepositoryMockFindListExpectation struct {
        mock               *AccountRepositoryMock
        params             *AccountRepositoryMockFindListParams
        paramPtrs          *AccountRepositoryMockFindListParamPtrs
        expectationOrigins AccountRepositoryMockFindListExpectationOrigins
        results            *AccountRepositoryMockFindListResults
        returnOrigin       string
        Counter            uint64
}

// AccountRepositoryMockFindListParams contains parameters of the AccountRepository.FindList
type AccountRepositoryMockFindListParams struct {
        ctx         context.Context
        listOptions *mm_usecase.AccountListOptions
        queryParams *uctypes.QueryGetListParams
}

// AccountRepositoryMockFindListParamPtrs contains pointers to parameters of the AccountRepository.FindList
type AccountRepositoryMockFindListParamPtrs struct {
        ctx         *context.Context
        listOptions **mm_usecase.AccountListOptions
        queryParams **uctypes.QueryGetListParams
}

// AccountRepositoryMockFindListResults contains results of the AccountRepository.FindList
type AccountRepositoryMockFindListResults struct {
        items []*entity.Account
        err   error
}

// AccountRepositoryMockFindListOrigins contains origins of expectations of the AccountRepository.FindList
type AccountRepositoryMockFindListExpectationOrigins struct {
        origin            string
        originCtx         string
        originListOptions string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindList *mAccountRepositoryMockFindList) Optional() *mAccountRepositoryMockFindList <span class="cov0" title="0">{
        mmFindList.optional = true
        return mmFindList
}</span>

// Expect sets up expected params for AccountRepository.FindList
func (mmFindList *mAccountRepositoryMockFindList) Expect(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) *mAccountRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("AccountRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;AccountRepositoryMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("AccountRepositoryMock.FindList mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindList.defaultExpectation.params = &amp;AccountRepositoryMockFindListParams{ctx, listOptions, queryParams}
        mmFindList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindList.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindList.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindList.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindList</span>
}

// ExpectCtxParam1 sets up expected param ctx for AccountRepository.FindList
func (mmFindList *mAccountRepositoryMockFindList) ExpectCtxParam1(ctx context.Context) *mAccountRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("AccountRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;AccountRepositoryMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("AccountRepositoryMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;AccountRepositoryMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindList</span>
}

// ExpectListOptionsParam2 sets up expected param listOptions for AccountRepository.FindList
func (mmFindList *mAccountRepositoryMockFindList) ExpectListOptionsParam2(listOptions *mm_usecase.AccountListOptions) *mAccountRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("AccountRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;AccountRepositoryMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("AccountRepositoryMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;AccountRepositoryMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.listOptions = &amp;listOptions
        mmFindList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

        return mmFindList</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for AccountRepository.FindList
func (mmFindList *mAccountRepositoryMockFindList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mAccountRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("AccountRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;AccountRepositoryMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("AccountRepositoryMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;AccountRepositoryMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindList</span>
}

// Inspect accepts an inspector function that has same arguments as the AccountRepository.FindList
func (mmFindList *mAccountRepositoryMockFindList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams)) *mAccountRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.inspectFuncFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Inspect function is already set for AccountRepositoryMock.FindList")
        }</span>

        <span class="cov0" title="0">mmFindList.mock.inspectFuncFindList = f

        return mmFindList</span>
}

// Return sets up results that will be returned by AccountRepository.FindList
func (mmFindList *mAccountRepositoryMockFindList) Return(items []*entity.Account, err error) *AccountRepositoryMock <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("AccountRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;AccountRepositoryMockFindListExpectation{mock: mmFindList.mock}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.results = &amp;AccountRepositoryMockFindListResults{items, err}
        mmFindList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindList.mock</span>
}

// Set uses given function f to mock the AccountRepository.FindList method
func (mmFindList *mAccountRepositoryMockFindList) Set(f func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Account, err error)) *AccountRepositoryMock <span class="cov0" title="0">{
        if mmFindList.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Default expectation is already set for the AccountRepository.FindList method")
        }</span>

        <span class="cov0" title="0">if len(mmFindList.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Some expectations are already set for the AccountRepository.FindList method")
        }</span>

        <span class="cov0" title="0">mmFindList.mock.funcFindList = f
        mmFindList.mock.funcFindListOrigin = minimock.CallerInfo(1)
        return mmFindList.mock</span>
}

// When sets expectation for the AccountRepository.FindList which will trigger the result defined by the following
// Then helper
func (mmFindList *mAccountRepositoryMockFindList) When(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) *AccountRepositoryMockFindListExpectation <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("AccountRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;AccountRepositoryMockFindListExpectation{
                mock:               mmFindList.mock,
                params:             &amp;AccountRepositoryMockFindListParams{ctx, listOptions, queryParams},
                expectationOrigins: AccountRepositoryMockFindListExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindList.expectations = append(mmFindList.expectations, expectation)
        return expectation</span>
}

// Then sets up AccountRepository.FindList return parameters for the expectation previously defined by the When method
func (e *AccountRepositoryMockFindListExpectation) Then(items []*entity.Account, err error) *AccountRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;AccountRepositoryMockFindListResults{items, err}
        return e.mock
}</span>

// Times sets number of times AccountRepository.FindList should be invoked
func (mmFindList *mAccountRepositoryMockFindList) Times(n uint64) *mAccountRepositoryMockFindList <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Times of AccountRepositoryMock.FindList mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindList.expectedInvocations, n)
        mmFindList.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindList</span>
}

func (mmFindList *mAccountRepositoryMockFindList) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindList.expectations) == 0 &amp;&amp; mmFindList.defaultExpectation == nil &amp;&amp; mmFindList.mock.funcFindList == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindList.mock.afterFindListCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindList.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindList implements mm_usecase.AccountRepository
func (mmFindList *AccountRepositoryMock) FindList(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Account, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindList.beforeFindListCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindList.afterFindListCounter, 1)

        mmFindList.t.Helper()

        if mmFindList.inspectFuncFindList != nil </span><span class="cov0" title="0">{
                mmFindList.inspectFuncFindList(ctx, listOptions, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := AccountRepositoryMockFindListParams{ctx, listOptions, queryParams}

        // Record call args
        mmFindList.FindListMock.mutex.Lock()
        mmFindList.FindListMock.callArgs = append(mmFindList.FindListMock.callArgs, &amp;mm_params)
        mmFindList.FindListMock.mutex.Unlock()

        for _, e := range mmFindList.FindListMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.items, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindList.FindListMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindList.FindListMock.defaultExpectation.Counter, 1)
                mm_want := mmFindList.FindListMock.defaultExpectation.params
                mm_want_ptrs := mmFindList.FindListMock.defaultExpectation.paramPtrs

                mm_got := AccountRepositoryMockFindListParams{ctx, listOptions, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("AccountRepositoryMock.FindList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.listOptions != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("AccountRepositoryMock.FindList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("AccountRepositoryMock.FindList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindList.t.Errorf("AccountRepositoryMock.FindList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindList.FindListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindList.FindListMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindList.t.Fatal("No results are set for the AccountRepositoryMock.FindList")
                }</span>
                <span class="cov0" title="0">return (*mm_results).items, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindList.funcFindList != nil </span><span class="cov0" title="0">{
                return mmFindList.funcFindList(ctx, listOptions, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindList.t.Fatalf("Unexpected call to AccountRepositoryMock.FindList. %v %v %v", ctx, listOptions, queryParams)
        return</span>
}

// FindListAfterCounter returns a count of finished AccountRepositoryMock.FindList invocations
func (mmFindList *AccountRepositoryMock) FindListAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindList.afterFindListCounter)
}</span>

// FindListBeforeCounter returns a count of AccountRepositoryMock.FindList invocations
func (mmFindList *AccountRepositoryMock) FindListBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindList.beforeFindListCounter)
}</span>

// Calls returns a list of arguments used in each call to AccountRepositoryMock.FindList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindList *mAccountRepositoryMockFindList) Calls() []*AccountRepositoryMockFindListParams <span class="cov0" title="0">{
        mmFindList.mutex.RLock()

        argCopy := make([]*AccountRepositoryMockFindListParams, len(mmFindList.callArgs))
        copy(argCopy, mmFindList.callArgs)

        mmFindList.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindListDone returns true if the count of the FindList invocations corresponds
// the number of defined expectations
func (m *AccountRepositoryMock) MinimockFindListDone() bool <span class="cov0" title="0">{
        if m.FindListMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindListMock.invocationsDone()</span>
}

// MinimockFindListInspect logs each unmet expectation
func (m *AccountRepositoryMock) MinimockFindListInspect() <span class="cov0" title="0">{
        for _, e := range m.FindListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountRepositoryMock.FindList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindListCounter := mm_atomic.LoadUint64(&amp;m.afterFindListCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindListMock.defaultExpectation != nil &amp;&amp; afterFindListCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindListMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountRepositoryMock.FindList at\n%s", m.FindListMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to AccountRepositoryMock.FindList at\n%s with params: %#v", m.FindListMock.defaultExpectation.expectationOrigins.origin, *m.FindListMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindList != nil &amp;&amp; afterFindListCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to AccountRepositoryMock.FindList at\n%s", m.funcFindListOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindListMock.invocationsDone() &amp;&amp; afterFindListCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to AccountRepositoryMock.FindList at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindListMock.expectedInvocations), m.FindListMock.expectedInvocationsOrigin, afterFindListCounter)
        }</span>
}

type mAccountRepositoryMockFindOneByEmail struct {
        optional           bool
        mock               *AccountRepositoryMock
        defaultExpectation *AccountRepositoryMockFindOneByEmailExpectation
        expectations       []*AccountRepositoryMockFindOneByEmailExpectation

        callArgs []*AccountRepositoryMockFindOneByEmailParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// AccountRepositoryMockFindOneByEmailExpectation specifies expectation struct of the AccountRepository.FindOneByEmail
type AccountRepositoryMockFindOneByEmailExpectation struct {
        mock               *AccountRepositoryMock
        params             *AccountRepositoryMockFindOneByEmailParams
        paramPtrs          *AccountRepositoryMockFindOneByEmailParamPtrs
        expectationOrigins AccountRepositoryMockFindOneByEmailExpectationOrigins
        results            *AccountRepositoryMockFindOneByEmailResults
        returnOrigin       string
        Counter            uint64
}

// AccountRepositoryMockFindOneByEmailParams contains parameters of the AccountRepository.FindOneByEmail
type AccountRepositoryMockFindOneByEmailParams struct {
        ctx         context.Context
        email       string
        queryParams *uctypes.QueryGetOneParams
}

// AccountRepositoryMockFindOneByEmailParamPtrs contains pointers to parameters of the AccountRepository.FindOneByEmail
type AccountRepositoryMockFindOneByEmailParamPtrs struct {
        ctx         *context.Context
        email       *string
        queryParams **uctypes.QueryGetOneParams
}

// AccountRepositoryMockFindOneByEmailResults contains results of the AccountRepository.FindOneByEmail
type AccountRepositoryMockFindOneByEmailResults struct {
        account *entity.Account
        err     error
}

// AccountRepositoryMockFindOneByEmailOrigins contains origins of expectations of the AccountRepository.FindOneByEmail
type AccountRepositoryMockFindOneByEmailExpectationOrigins struct {
        origin            string
        originCtx         string
        originEmail       string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindOneByEmail *mAccountRepositoryMockFindOneByEmail) Optional() *mAccountRepositoryMockFindOneByEmail <span class="cov0" title="0">{
        mmFindOneByEmail.optional = true
        return mmFindOneByEmail
}</span>

// Expect sets up expected params for AccountRepository.FindOneByEmail
func (mmFindOneByEmail *mAccountRepositoryMockFindOneByEmail) Expect(ctx context.Context, email string, queryParams *uctypes.QueryGetOneParams) *mAccountRepositoryMockFindOneByEmail <span class="cov0" title="0">{
        if mmFindOneByEmail.mock.funcFindOneByEmail != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("AccountRepositoryMock.FindOneByEmail mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.defaultExpectation = &amp;AccountRepositoryMockFindOneByEmailExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("AccountRepositoryMock.FindOneByEmail mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindOneByEmail.defaultExpectation.params = &amp;AccountRepositoryMockFindOneByEmailParams{ctx, email, queryParams}
        mmFindOneByEmail.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindOneByEmail.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindOneByEmail.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindOneByEmail.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindOneByEmail.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindOneByEmail</span>
}

// ExpectCtxParam1 sets up expected param ctx for AccountRepository.FindOneByEmail
func (mmFindOneByEmail *mAccountRepositoryMockFindOneByEmail) ExpectCtxParam1(ctx context.Context) *mAccountRepositoryMockFindOneByEmail <span class="cov0" title="0">{
        if mmFindOneByEmail.mock.funcFindOneByEmail != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("AccountRepositoryMock.FindOneByEmail mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.defaultExpectation = &amp;AccountRepositoryMockFindOneByEmailExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("AccountRepositoryMock.FindOneByEmail mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.defaultExpectation.paramPtrs = &amp;AccountRepositoryMockFindOneByEmailParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByEmail.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindOneByEmail.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindOneByEmail</span>
}

// ExpectEmailParam2 sets up expected param email for AccountRepository.FindOneByEmail
func (mmFindOneByEmail *mAccountRepositoryMockFindOneByEmail) ExpectEmailParam2(email string) *mAccountRepositoryMockFindOneByEmail <span class="cov0" title="0">{
        if mmFindOneByEmail.mock.funcFindOneByEmail != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("AccountRepositoryMock.FindOneByEmail mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.defaultExpectation = &amp;AccountRepositoryMockFindOneByEmailExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("AccountRepositoryMock.FindOneByEmail mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.defaultExpectation.paramPtrs = &amp;AccountRepositoryMockFindOneByEmailParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByEmail.defaultExpectation.paramPtrs.email = &amp;email
        mmFindOneByEmail.defaultExpectation.expectationOrigins.originEmail = minimock.CallerInfo(1)

        return mmFindOneByEmail</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for AccountRepository.FindOneByEmail
func (mmFindOneByEmail *mAccountRepositoryMockFindOneByEmail) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetOneParams) *mAccountRepositoryMockFindOneByEmail <span class="cov0" title="0">{
        if mmFindOneByEmail.mock.funcFindOneByEmail != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("AccountRepositoryMock.FindOneByEmail mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.defaultExpectation = &amp;AccountRepositoryMockFindOneByEmailExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("AccountRepositoryMock.FindOneByEmail mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.defaultExpectation.paramPtrs = &amp;AccountRepositoryMockFindOneByEmailParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByEmail.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindOneByEmail.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindOneByEmail</span>
}

// Inspect accepts an inspector function that has same arguments as the AccountRepository.FindOneByEmail
func (mmFindOneByEmail *mAccountRepositoryMockFindOneByEmail) Inspect(f func(ctx context.Context, email string, queryParams *uctypes.QueryGetOneParams)) *mAccountRepositoryMockFindOneByEmail <span class="cov0" title="0">{
        if mmFindOneByEmail.mock.inspectFuncFindOneByEmail != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("Inspect function is already set for AccountRepositoryMock.FindOneByEmail")
        }</span>

        <span class="cov0" title="0">mmFindOneByEmail.mock.inspectFuncFindOneByEmail = f

        return mmFindOneByEmail</span>
}

// Return sets up results that will be returned by AccountRepository.FindOneByEmail
func (mmFindOneByEmail *mAccountRepositoryMockFindOneByEmail) Return(account *entity.Account, err error) *AccountRepositoryMock <span class="cov0" title="0">{
        if mmFindOneByEmail.mock.funcFindOneByEmail != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("AccountRepositoryMock.FindOneByEmail mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.defaultExpectation = &amp;AccountRepositoryMockFindOneByEmailExpectation{mock: mmFindOneByEmail.mock}
        }</span>
        <span class="cov0" title="0">mmFindOneByEmail.defaultExpectation.results = &amp;AccountRepositoryMockFindOneByEmailResults{account, err}
        mmFindOneByEmail.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindOneByEmail.mock</span>
}

// Set uses given function f to mock the AccountRepository.FindOneByEmail method
func (mmFindOneByEmail *mAccountRepositoryMockFindOneByEmail) Set(f func(ctx context.Context, email string, queryParams *uctypes.QueryGetOneParams) (account *entity.Account, err error)) *AccountRepositoryMock <span class="cov0" title="0">{
        if mmFindOneByEmail.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("Default expectation is already set for the AccountRepository.FindOneByEmail method")
        }</span>

        <span class="cov0" title="0">if len(mmFindOneByEmail.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("Some expectations are already set for the AccountRepository.FindOneByEmail method")
        }</span>

        <span class="cov0" title="0">mmFindOneByEmail.mock.funcFindOneByEmail = f
        mmFindOneByEmail.mock.funcFindOneByEmailOrigin = minimock.CallerInfo(1)
        return mmFindOneByEmail.mock</span>
}

// When sets expectation for the AccountRepository.FindOneByEmail which will trigger the result defined by the following
// Then helper
func (mmFindOneByEmail *mAccountRepositoryMockFindOneByEmail) When(ctx context.Context, email string, queryParams *uctypes.QueryGetOneParams) *AccountRepositoryMockFindOneByEmailExpectation <span class="cov0" title="0">{
        if mmFindOneByEmail.mock.funcFindOneByEmail != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("AccountRepositoryMock.FindOneByEmail mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;AccountRepositoryMockFindOneByEmailExpectation{
                mock:               mmFindOneByEmail.mock,
                params:             &amp;AccountRepositoryMockFindOneByEmailParams{ctx, email, queryParams},
                expectationOrigins: AccountRepositoryMockFindOneByEmailExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindOneByEmail.expectations = append(mmFindOneByEmail.expectations, expectation)
        return expectation</span>
}

// Then sets up AccountRepository.FindOneByEmail return parameters for the expectation previously defined by the When method
func (e *AccountRepositoryMockFindOneByEmailExpectation) Then(account *entity.Account, err error) *AccountRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;AccountRepositoryMockFindOneByEmailResults{account, err}
        return e.mock
}</span>

// Times sets number of times AccountRepository.FindOneByEmail should be invoked
func (mmFindOneByEmail *mAccountRepositoryMockFindOneByEmail) Times(n uint64) *mAccountRepositoryMockFindOneByEmail <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("Times of AccountRepositoryMock.FindOneByEmail mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindOneByEmail.expectedInvocations, n)
        mmFindOneByEmail.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindOneByEmail</span>
}

func (mmFindOneByEmail *mAccountRepositoryMockFindOneByEmail) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindOneByEmail.expectations) == 0 &amp;&amp; mmFindOneByEmail.defaultExpectation == nil &amp;&amp; mmFindOneByEmail.mock.funcFindOneByEmail == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByEmail.mock.afterFindOneByEmailCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByEmail.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindOneByEmail implements mm_usecase.AccountRepository
func (mmFindOneByEmail *AccountRepositoryMock) FindOneByEmail(ctx context.Context, email string, queryParams *uctypes.QueryGetOneParams) (account *entity.Account, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindOneByEmail.beforeFindOneByEmailCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindOneByEmail.afterFindOneByEmailCounter, 1)

        mmFindOneByEmail.t.Helper()

        if mmFindOneByEmail.inspectFuncFindOneByEmail != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.inspectFuncFindOneByEmail(ctx, email, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := AccountRepositoryMockFindOneByEmailParams{ctx, email, queryParams}

        // Record call args
        mmFindOneByEmail.FindOneByEmailMock.mutex.Lock()
        mmFindOneByEmail.FindOneByEmailMock.callArgs = append(mmFindOneByEmail.FindOneByEmailMock.callArgs, &amp;mm_params)
        mmFindOneByEmail.FindOneByEmailMock.mutex.Unlock()

        for _, e := range mmFindOneByEmail.FindOneByEmailMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.account, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindOneByEmail.FindOneByEmailMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.Counter, 1)
                mm_want := mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.params
                mm_want_ptrs := mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.paramPtrs

                mm_got := AccountRepositoryMockFindOneByEmailParams{ctx, email, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindOneByEmail.t.Errorf("AccountRepositoryMock.FindOneByEmail got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.email != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.email, mm_got.email) </span><span class="cov0" title="0">{
                                mmFindOneByEmail.t.Errorf("AccountRepositoryMock.FindOneByEmail got unexpected parameter email, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.expectationOrigins.originEmail, *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindOneByEmail.t.Errorf("AccountRepositoryMock.FindOneByEmail got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindOneByEmail.t.Errorf("AccountRepositoryMock.FindOneByEmail got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindOneByEmail.t.Fatal("No results are set for the AccountRepositoryMock.FindOneByEmail")
                }</span>
                <span class="cov0" title="0">return (*mm_results).account, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindOneByEmail.funcFindOneByEmail != nil </span><span class="cov0" title="0">{
                return mmFindOneByEmail.funcFindOneByEmail(ctx, email, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindOneByEmail.t.Fatalf("Unexpected call to AccountRepositoryMock.FindOneByEmail. %v %v %v", ctx, email, queryParams)
        return</span>
}

// FindOneByEmailAfterCounter returns a count of finished AccountRepositoryMock.FindOneByEmail invocations
func (mmFindOneByEmail *AccountRepositoryMock) FindOneByEmailAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByEmail.afterFindOneByEmailCounter)
}</span>

// FindOneByEmailBeforeCounter returns a count of AccountRepositoryMock.FindOneByEmail invocations
func (mmFindOneByEmail *AccountRepositoryMock) FindOneByEmailBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByEmail.beforeFindOneByEmailCounter)
}</span>

// Calls returns a list of arguments used in each call to AccountRepositoryMock.FindOneByEmail.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindOneByEmail *mAccountRepositoryMockFindOneByEmail) Calls() []*AccountRepositoryMockFindOneByEmailParams <span class="cov0" title="0">{
        mmFindOneByEmail.mutex.RLock()

        argCopy := make([]*AccountRepositoryMockFindOneByEmailParams, len(mmFindOneByEmail.callArgs))
        copy(argCopy, mmFindOneByEmail.callArgs)

        mmFindOneByEmail.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindOneByEmailDone returns true if the count of the FindOneByEmail invocations corresponds
// the number of defined expectations
func (m *AccountRepositoryMock) MinimockFindOneByEmailDone() bool <span class="cov0" title="0">{
        if m.FindOneByEmailMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindOneByEmailMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindOneByEmailMock.invocationsDone()</span>
}

// MinimockFindOneByEmailInspect logs each unmet expectation
func (m *AccountRepositoryMock) MinimockFindOneByEmailInspect() <span class="cov0" title="0">{
        for _, e := range m.FindOneByEmailMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountRepositoryMock.FindOneByEmail at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindOneByEmailCounter := mm_atomic.LoadUint64(&amp;m.afterFindOneByEmailCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindOneByEmailMock.defaultExpectation != nil &amp;&amp; afterFindOneByEmailCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindOneByEmailMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountRepositoryMock.FindOneByEmail at\n%s", m.FindOneByEmailMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to AccountRepositoryMock.FindOneByEmail at\n%s with params: %#v", m.FindOneByEmailMock.defaultExpectation.expectationOrigins.origin, *m.FindOneByEmailMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindOneByEmail != nil &amp;&amp; afterFindOneByEmailCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to AccountRepositoryMock.FindOneByEmail at\n%s", m.funcFindOneByEmailOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindOneByEmailMock.invocationsDone() &amp;&amp; afterFindOneByEmailCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to AccountRepositoryMock.FindOneByEmail at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindOneByEmailMock.expectedInvocations), m.FindOneByEmailMock.expectedInvocationsOrigin, afterFindOneByEmailCounter)
        }</span>
}

type mAccountRepositoryMockFindOneByID struct {
        optional           bool
        mock               *AccountRepositoryMock
        defaultExpectation *AccountRepositoryMockFindOneByIDExpectation
        expectations       []*AccountRepositoryMockFindOneByIDExpectation

        callArgs []*AccountRepositoryMockFindOneByIDParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// AccountRepositoryMockFindOneByIDExpectation specifies expectation struct of the AccountRepository.FindOneByID
type AccountRepositoryMockFindOneByIDExpectation struct {
        mock               *AccountRepositoryMock
        params             *AccountRepositoryMockFindOneByIDParams
        paramPtrs          *AccountRepositoryMockFindOneByIDParamPtrs
        expectationOrigins AccountRepositoryMockFindOneByIDExpectationOrigins
        results            *AccountRepositoryMockFindOneByIDResults
        returnOrigin       string
        Counter            uint64
}

// AccountRepositoryMockFindOneByIDParams contains parameters of the AccountRepository.FindOneByID
type AccountRepositoryMockFindOneByIDParams struct {
        ctx         context.Context
        id          uuid.UUID
        queryParams *uctypes.QueryGetOneParams
}

// AccountRepositoryMockFindOneByIDParamPtrs contains pointers to parameters of the AccountRepository.FindOneByID
type AccountRepositoryMockFindOneByIDParamPtrs struct {
        ctx         *context.Context
        id          *uuid.UUID
        queryParams **uctypes.QueryGetOneParams
}

// AccountRepositoryMockFindOneByIDResults contains results of the AccountRepository.FindOneByID
type AccountRepositoryMockFindOneByIDResults struct {
        account *entity.Account
        err     error
}

// AccountRepositoryMockFindOneByIDOrigins contains origins of expectations of the AccountRepository.FindOneByID
type AccountRepositoryMockFindOneByIDExpectationOrigins struct {
        origin            string
        originCtx         string
        originId          string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindOneByID *mAccountRepositoryMockFindOneByID) Optional() *mAccountRepositoryMockFindOneByID <span class="cov0" title="0">{
        mmFindOneByID.optional = true
        return mmFindOneByID
}</span>

// Expect sets up expected params for AccountRepository.FindOneByID
func (mmFindOneByID *mAccountRepositoryMockFindOneByID) Expect(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *mAccountRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("AccountRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;AccountRepositoryMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("AccountRepositoryMock.FindOneByID mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.params = &amp;AccountRepositoryMockFindOneByIDParams{ctx, id, queryParams}
        mmFindOneByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindOneByID.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindOneByID.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindOneByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindOneByID.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindOneByID</span>
}

// ExpectCtxParam1 sets up expected param ctx for AccountRepository.FindOneByID
func (mmFindOneByID *mAccountRepositoryMockFindOneByID) ExpectCtxParam1(ctx context.Context) *mAccountRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("AccountRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;AccountRepositoryMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("AccountRepositoryMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;AccountRepositoryMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindOneByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// ExpectIdParam2 sets up expected param id for AccountRepository.FindOneByID
func (mmFindOneByID *mAccountRepositoryMockFindOneByID) ExpectIdParam2(id uuid.UUID) *mAccountRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("AccountRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;AccountRepositoryMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("AccountRepositoryMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;AccountRepositoryMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.id = &amp;id
        mmFindOneByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for AccountRepository.FindOneByID
func (mmFindOneByID *mAccountRepositoryMockFindOneByID) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetOneParams) *mAccountRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("AccountRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;AccountRepositoryMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("AccountRepositoryMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;AccountRepositoryMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindOneByID.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// Inspect accepts an inspector function that has same arguments as the AccountRepository.FindOneByID
func (mmFindOneByID *mAccountRepositoryMockFindOneByID) Inspect(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)) *mAccountRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.inspectFuncFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Inspect function is already set for AccountRepositoryMock.FindOneByID")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.mock.inspectFuncFindOneByID = f

        return mmFindOneByID</span>
}

// Return sets up results that will be returned by AccountRepository.FindOneByID
func (mmFindOneByID *mAccountRepositoryMockFindOneByID) Return(account *entity.Account, err error) *AccountRepositoryMock <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("AccountRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;AccountRepositoryMockFindOneByIDExpectation{mock: mmFindOneByID.mock}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.results = &amp;AccountRepositoryMockFindOneByIDResults{account, err}
        mmFindOneByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindOneByID.mock</span>
}

// Set uses given function f to mock the AccountRepository.FindOneByID method
func (mmFindOneByID *mAccountRepositoryMockFindOneByID) Set(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (account *entity.Account, err error)) *AccountRepositoryMock <span class="cov0" title="0">{
        if mmFindOneByID.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Default expectation is already set for the AccountRepository.FindOneByID method")
        }</span>

        <span class="cov0" title="0">if len(mmFindOneByID.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Some expectations are already set for the AccountRepository.FindOneByID method")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.mock.funcFindOneByID = f
        mmFindOneByID.mock.funcFindOneByIDOrigin = minimock.CallerInfo(1)
        return mmFindOneByID.mock</span>
}

// When sets expectation for the AccountRepository.FindOneByID which will trigger the result defined by the following
// Then helper
func (mmFindOneByID *mAccountRepositoryMockFindOneByID) When(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *AccountRepositoryMockFindOneByIDExpectation <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("AccountRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;AccountRepositoryMockFindOneByIDExpectation{
                mock:               mmFindOneByID.mock,
                params:             &amp;AccountRepositoryMockFindOneByIDParams{ctx, id, queryParams},
                expectationOrigins: AccountRepositoryMockFindOneByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindOneByID.expectations = append(mmFindOneByID.expectations, expectation)
        return expectation</span>
}

// Then sets up AccountRepository.FindOneByID return parameters for the expectation previously defined by the When method
func (e *AccountRepositoryMockFindOneByIDExpectation) Then(account *entity.Account, err error) *AccountRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;AccountRepositoryMockFindOneByIDResults{account, err}
        return e.mock
}</span>

// Times sets number of times AccountRepository.FindOneByID should be invoked
func (mmFindOneByID *mAccountRepositoryMockFindOneByID) Times(n uint64) *mAccountRepositoryMockFindOneByID <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Times of AccountRepositoryMock.FindOneByID mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindOneByID.expectedInvocations, n)
        mmFindOneByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindOneByID</span>
}

func (mmFindOneByID *mAccountRepositoryMockFindOneByID) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindOneByID.expectations) == 0 &amp;&amp; mmFindOneByID.defaultExpectation == nil &amp;&amp; mmFindOneByID.mock.funcFindOneByID == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByID.mock.afterFindOneByIDCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByID.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindOneByID implements mm_usecase.AccountRepository
func (mmFindOneByID *AccountRepositoryMock) FindOneByID(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (account *entity.Account, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindOneByID.beforeFindOneByIDCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindOneByID.afterFindOneByIDCounter, 1)

        mmFindOneByID.t.Helper()

        if mmFindOneByID.inspectFuncFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.inspectFuncFindOneByID(ctx, id, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := AccountRepositoryMockFindOneByIDParams{ctx, id, queryParams}

        // Record call args
        mmFindOneByID.FindOneByIDMock.mutex.Lock()
        mmFindOneByID.FindOneByIDMock.callArgs = append(mmFindOneByID.FindOneByIDMock.callArgs, &amp;mm_params)
        mmFindOneByID.FindOneByIDMock.mutex.Unlock()

        for _, e := range mmFindOneByID.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.account, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindOneByID.FindOneByIDMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindOneByID.FindOneByIDMock.defaultExpectation.Counter, 1)
                mm_want := mmFindOneByID.FindOneByIDMock.defaultExpectation.params
                mm_want_ptrs := mmFindOneByID.FindOneByIDMock.defaultExpectation.paramPtrs

                mm_got := AccountRepositoryMockFindOneByIDParams{ctx, id, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("AccountRepositoryMock.FindOneByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("AccountRepositoryMock.FindOneByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("AccountRepositoryMock.FindOneByID got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindOneByID.t.Errorf("AccountRepositoryMock.FindOneByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindOneByID.FindOneByIDMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindOneByID.t.Fatal("No results are set for the AccountRepositoryMock.FindOneByID")
                }</span>
                <span class="cov0" title="0">return (*mm_results).account, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindOneByID.funcFindOneByID != nil </span><span class="cov0" title="0">{
                return mmFindOneByID.funcFindOneByID(ctx, id, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindOneByID.t.Fatalf("Unexpected call to AccountRepositoryMock.FindOneByID. %v %v %v", ctx, id, queryParams)
        return</span>
}

// FindOneByIDAfterCounter returns a count of finished AccountRepositoryMock.FindOneByID invocations
func (mmFindOneByID *AccountRepositoryMock) FindOneByIDAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByID.afterFindOneByIDCounter)
}</span>

// FindOneByIDBeforeCounter returns a count of AccountRepositoryMock.FindOneByID invocations
func (mmFindOneByID *AccountRepositoryMock) FindOneByIDBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByID.beforeFindOneByIDCounter)
}</span>

// Calls returns a list of arguments used in each call to AccountRepositoryMock.FindOneByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindOneByID *mAccountRepositoryMockFindOneByID) Calls() []*AccountRepositoryMockFindOneByIDParams <span class="cov0" title="0">{
        mmFindOneByID.mutex.RLock()

        argCopy := make([]*AccountRepositoryMockFindOneByIDParams, len(mmFindOneByID.callArgs))
        copy(argCopy, mmFindOneByID.callArgs)

        mmFindOneByID.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindOneByIDDone returns true if the count of the FindOneByID invocations corresponds
// the number of defined expectations
func (m *AccountRepositoryMock) MinimockFindOneByIDDone() bool <span class="cov0" title="0">{
        if m.FindOneByIDMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindOneByIDMock.invocationsDone()</span>
}

// MinimockFindOneByIDInspect logs each unmet expectation
func (m *AccountRepositoryMock) MinimockFindOneByIDInspect() <span class="cov0" title="0">{
        for _, e := range m.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountRepositoryMock.FindOneByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindOneByIDCounter := mm_atomic.LoadUint64(&amp;m.afterFindOneByIDCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindOneByIDMock.defaultExpectation != nil &amp;&amp; afterFindOneByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindOneByIDMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountRepositoryMock.FindOneByID at\n%s", m.FindOneByIDMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to AccountRepositoryMock.FindOneByID at\n%s with params: %#v", m.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *m.FindOneByIDMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindOneByID != nil &amp;&amp; afterFindOneByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to AccountRepositoryMock.FindOneByID at\n%s", m.funcFindOneByIDOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindOneByIDMock.invocationsDone() &amp;&amp; afterFindOneByIDCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to AccountRepositoryMock.FindOneByID at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindOneByIDMock.expectedInvocations), m.FindOneByIDMock.expectedInvocationsOrigin, afterFindOneByIDCounter)
        }</span>
}

type mAccountRepositoryMockFindPagedList struct {
        optional           bool
        mock               *AccountRepositoryMock
        defaultExpectation *AccountRepositoryMockFindPagedListExpectation
        expectations       []*AccountRepositoryMockFindPagedListExpectation

        callArgs []*AccountRepositoryMockFindPagedListParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// AccountRepositoryMockFindPagedListExpectation specifies expectation struct of the AccountRepository.FindPagedList
type AccountRepositoryMockFindPagedListExpectation struct {
        mock               *AccountRepositoryMock
        params             *AccountRepositoryMockFindPagedListParams
        paramPtrs          *AccountRepositoryMockFindPagedListParamPtrs
        expectationOrigins AccountRepositoryMockFindPagedListExpectationOrigins
        results            *AccountRepositoryMockFindPagedListResults
        returnOrigin       string
        Counter            uint64
}

// AccountRepositoryMockFindPagedListParams contains parameters of the AccountRepository.FindPagedList
type AccountRepositoryMockFindPagedListParams struct {
        ctx         context.Context
        listOptions *mm_usecase.AccountListOptions
        queryParams *uctypes.QueryGetListParams
}

// AccountRepositoryMockFindPagedListParamPtrs contains pointers to parameters of the AccountRepository.FindPagedList
type AccountRepositoryMockFindPagedListParamPtrs struct {
        ctx         *context.Context
        listOptions **mm_usecase.AccountListOptions
        queryParams **uctypes.QueryGetListParams
}

// AccountRepositoryMockFindPagedListResults contains results of the AccountRepository.FindPagedList
type AccountRepositoryMockFindPagedListResults struct {
        items []*entity.Account
        total uint64
        err   error
}

// AccountRepositoryMockFindPagedListOrigins contains origins of expectations of the AccountRepository.FindPagedList
type AccountRepositoryMockFindPagedListExpectationOrigins struct {
        origin            string
        originCtx         string
        originListOptions string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindPagedList *mAccountRepositoryMockFindPagedList) Optional() *mAccountRepositoryMockFindPagedList <span class="cov0" title="0">{
        mmFindPagedList.optional = true
        return mmFindPagedList
}</span>

// Expect sets up expected params for AccountRepository.FindPagedList
func (mmFindPagedList *mAccountRepositoryMockFindPagedList) Expect(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) *mAccountRepositoryMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("AccountRepositoryMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;AccountRepositoryMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("AccountRepositoryMock.FindPagedList mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.params = &amp;AccountRepositoryMockFindPagedListParams{ctx, listOptions, queryParams}
        mmFindPagedList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindPagedList.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindPagedList.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindPagedList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindPagedList.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindPagedList</span>
}

// ExpectCtxParam1 sets up expected param ctx for AccountRepository.FindPagedList
func (mmFindPagedList *mAccountRepositoryMockFindPagedList) ExpectCtxParam1(ctx context.Context) *mAccountRepositoryMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("AccountRepositoryMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;AccountRepositoryMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("AccountRepositoryMock.FindPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation.paramPtrs = &amp;AccountRepositoryMockFindPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindPagedList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindPagedList</span>
}

// ExpectListOptionsParam2 sets up expected param listOptions for AccountRepository.FindPagedList
func (mmFindPagedList *mAccountRepositoryMockFindPagedList) ExpectListOptionsParam2(listOptions *mm_usecase.AccountListOptions) *mAccountRepositoryMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("AccountRepositoryMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;AccountRepositoryMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("AccountRepositoryMock.FindPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation.paramPtrs = &amp;AccountRepositoryMockFindPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.paramPtrs.listOptions = &amp;listOptions
        mmFindPagedList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

        return mmFindPagedList</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for AccountRepository.FindPagedList
func (mmFindPagedList *mAccountRepositoryMockFindPagedList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mAccountRepositoryMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("AccountRepositoryMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;AccountRepositoryMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("AccountRepositoryMock.FindPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation.paramPtrs = &amp;AccountRepositoryMockFindPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindPagedList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindPagedList</span>
}

// Inspect accepts an inspector function that has same arguments as the AccountRepository.FindPagedList
func (mmFindPagedList *mAccountRepositoryMockFindPagedList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams)) *mAccountRepositoryMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.inspectFuncFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Inspect function is already set for AccountRepositoryMock.FindPagedList")
        }</span>

        <span class="cov0" title="0">mmFindPagedList.mock.inspectFuncFindPagedList = f

        return mmFindPagedList</span>
}

// Return sets up results that will be returned by AccountRepository.FindPagedList
func (mmFindPagedList *mAccountRepositoryMockFindPagedList) Return(items []*entity.Account, total uint64, err error) *AccountRepositoryMock <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("AccountRepositoryMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;AccountRepositoryMockFindPagedListExpectation{mock: mmFindPagedList.mock}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.results = &amp;AccountRepositoryMockFindPagedListResults{items, total, err}
        mmFindPagedList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindPagedList.mock</span>
}

// Set uses given function f to mock the AccountRepository.FindPagedList method
func (mmFindPagedList *mAccountRepositoryMockFindPagedList) Set(f func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Account, total uint64, err error)) *AccountRepositoryMock <span class="cov0" title="0">{
        if mmFindPagedList.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Default expectation is already set for the AccountRepository.FindPagedList method")
        }</span>

        <span class="cov0" title="0">if len(mmFindPagedList.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Some expectations are already set for the AccountRepository.FindPagedList method")
        }</span>

        <span class="cov0" title="0">mmFindPagedList.mock.funcFindPagedList = f
        mmFindPagedList.mock.funcFindPagedListOrigin = minimock.CallerInfo(1)
        return mmFindPagedList.mock</span>
}

// When sets expectation for the AccountRepository.FindPagedList which will trigger the result defined by the following
// Then helper
func (mmFindPagedList *mAccountRepositoryMockFindPagedList) When(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) *AccountRepositoryMockFindPagedListExpectation <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("AccountRepositoryMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;AccountRepositoryMockFindPagedListExpectation{
                mock:               mmFindPagedList.mock,
                params:             &amp;AccountRepositoryMockFindPagedListParams{ctx, listOptions, queryParams},
                expectationOrigins: AccountRepositoryMockFindPagedListExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindPagedList.expectations = append(mmFindPagedList.expectations, expectation)
        return expectation</span>
}

// Then sets up AccountRepository.FindPagedList return parameters for the expectation previously defined by the When method
func (e *AccountRepositoryMockFindPagedListExpectation) Then(items []*entity.Account, total uint64, err error) *AccountRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;AccountRepositoryMockFindPagedListResults{items, total, err}
        return e.mock
}</span>

// Times sets number of times AccountRepository.FindPagedList should be invoked
func (mmFindPagedList *mAccountRepositoryMockFindPagedList) Times(n uint64) *mAccountRepositoryMockFindPagedList <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Times of AccountRepositoryMock.FindPagedList mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindPagedList.expectedInvocations, n)
        mmFindPagedList.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindPagedList</span>
}

func (mmFindPagedList *mAccountRepositoryMockFindPagedList) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindPagedList.expectations) == 0 &amp;&amp; mmFindPagedList.defaultExpectation == nil &amp;&amp; mmFindPagedList.mock.funcFindPagedList == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindPagedList.mock.afterFindPagedListCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindPagedList.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindPagedList implements mm_usecase.AccountRepository
func (mmFindPagedList *AccountRepositoryMock) FindPagedList(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Account, total uint64, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindPagedList.beforeFindPagedListCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindPagedList.afterFindPagedListCounter, 1)

        mmFindPagedList.t.Helper()

        if mmFindPagedList.inspectFuncFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.inspectFuncFindPagedList(ctx, listOptions, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := AccountRepositoryMockFindPagedListParams{ctx, listOptions, queryParams}

        // Record call args
        mmFindPagedList.FindPagedListMock.mutex.Lock()
        mmFindPagedList.FindPagedListMock.callArgs = append(mmFindPagedList.FindPagedListMock.callArgs, &amp;mm_params)
        mmFindPagedList.FindPagedListMock.mutex.Unlock()

        for _, e := range mmFindPagedList.FindPagedListMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.items, e.results.total, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindPagedList.FindPagedListMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindPagedList.FindPagedListMock.defaultExpectation.Counter, 1)
                mm_want := mmFindPagedList.FindPagedListMock.defaultExpectation.params
                mm_want_ptrs := mmFindPagedList.FindPagedListMock.defaultExpectation.paramPtrs

                mm_got := AccountRepositoryMockFindPagedListParams{ctx, listOptions, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindPagedList.t.Errorf("AccountRepositoryMock.FindPagedList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.listOptions != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) </span><span class="cov0" title="0">{
                                mmFindPagedList.t.Errorf("AccountRepositoryMock.FindPagedList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindPagedList.t.Errorf("AccountRepositoryMock.FindPagedList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindPagedList.t.Errorf("AccountRepositoryMock.FindPagedList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindPagedList.FindPagedListMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindPagedList.t.Fatal("No results are set for the AccountRepositoryMock.FindPagedList")
                }</span>
                <span class="cov0" title="0">return (*mm_results).items, (*mm_results).total, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindPagedList.funcFindPagedList != nil </span><span class="cov0" title="0">{
                return mmFindPagedList.funcFindPagedList(ctx, listOptions, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindPagedList.t.Fatalf("Unexpected call to AccountRepositoryMock.FindPagedList. %v %v %v", ctx, listOptions, queryParams)
        return</span>
}

// FindPagedListAfterCounter returns a count of finished AccountRepositoryMock.FindPagedList invocations
func (mmFindPagedList *AccountRepositoryMock) FindPagedListAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindPagedList.afterFindPagedListCounter)
}</span>

// FindPagedListBeforeCounter returns a count of AccountRepositoryMock.FindPagedList invocations
func (mmFindPagedList *AccountRepositoryMock) FindPagedListBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindPagedList.beforeFindPagedListCounter)
}</span>

// Calls returns a list of arguments used in each call to AccountRepositoryMock.FindPagedList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindPagedList *mAccountRepositoryMockFindPagedList) Calls() []*AccountRepositoryMockFindPagedListParams <span class="cov0" title="0">{
        mmFindPagedList.mutex.RLock()

        argCopy := make([]*AccountRepositoryMockFindPagedListParams, len(mmFindPagedList.callArgs))
        copy(argCopy, mmFindPagedList.callArgs)

        mmFindPagedList.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindPagedListDone returns true if the count of the FindPagedList invocations corresponds
// the number of defined expectations
func (m *AccountRepositoryMock) MinimockFindPagedListDone() bool <span class="cov0" title="0">{
        if m.FindPagedListMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindPagedListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindPagedListMock.invocationsDone()</span>
}

// MinimockFindPagedListInspect logs each unmet expectation
func (m *AccountRepositoryMock) MinimockFindPagedListInspect() <span class="cov0" title="0">{
        for _, e := range m.FindPagedListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountRepositoryMock.FindPagedList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindPagedListCounter := mm_atomic.LoadUint64(&amp;m.afterFindPagedListCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindPagedListMock.defaultExpectation != nil &amp;&amp; afterFindPagedListCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindPagedListMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountRepositoryMock.FindPagedList at\n%s", m.FindPagedListMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to AccountRepositoryMock.FindPagedList at\n%s with params: %#v", m.FindPagedListMock.defaultExpectation.expectationOrigins.origin, *m.FindPagedListMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindPagedList != nil &amp;&amp; afterFindPagedListCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to AccountRepositoryMock.FindPagedList at\n%s", m.funcFindPagedListOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindPagedListMock.invocationsDone() &amp;&amp; afterFindPagedListCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to AccountRepositoryMock.FindPagedList at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindPagedListMock.expectedInvocations), m.FindPagedListMock.expectedInvocationsOrigin, afterFindPagedListCounter)
        }</span>
}

type mAccountRepositoryMockUpdate struct {
        optional           bool
        mock               *AccountRepositoryMock
        defaultExpectation *AccountRepositoryMockUpdateExpectation
        expectations       []*AccountRepositoryMockUpdateExpectation

        callArgs []*AccountRepositoryMockUpdateParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// AccountRepositoryMockUpdateExpectation specifies expectation struct of the AccountRepository.Update
type AccountRepositoryMockUpdateExpectation struct {
        mock               *AccountRepositoryMock
        params             *AccountRepositoryMockUpdateParams
        paramPtrs          *AccountRepositoryMockUpdateParamPtrs
        expectationOrigins AccountRepositoryMockUpdateExpectationOrigins
        results            *AccountRepositoryMockUpdateResults
        returnOrigin       string
        Counter            uint64
}

// AccountRepositoryMockUpdateParams contains parameters of the AccountRepository.Update
type AccountRepositoryMockUpdateParams struct {
        ctx  context.Context
        item *entity.Account
}

// AccountRepositoryMockUpdateParamPtrs contains pointers to parameters of the AccountRepository.Update
type AccountRepositoryMockUpdateParamPtrs struct {
        ctx  *context.Context
        item **entity.Account
}

// AccountRepositoryMockUpdateResults contains results of the AccountRepository.Update
type AccountRepositoryMockUpdateResults struct {
        err error
}

// AccountRepositoryMockUpdateOrigins contains origins of expectations of the AccountRepository.Update
type AccountRepositoryMockUpdateExpectationOrigins struct {
        origin     string
        originCtx  string
        originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mAccountRepositoryMockUpdate) Optional() *mAccountRepositoryMockUpdate <span class="cov0" title="0">{
        mmUpdate.optional = true
        return mmUpdate
}</span>

// Expect sets up expected params for AccountRepository.Update
func (mmUpdate *mAccountRepositoryMockUpdate) Expect(ctx context.Context, item *entity.Account) *mAccountRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("AccountRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;AccountRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("AccountRepositoryMock.Update mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmUpdate.defaultExpectation.params = &amp;AccountRepositoryMockUpdateParams{ctx, item}
        mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmUpdate.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmUpdate</span>
}

// ExpectCtxParam1 sets up expected param ctx for AccountRepository.Update
func (mmUpdate *mAccountRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mAccountRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("AccountRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;AccountRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("AccountRepositoryMock.Update mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation.paramPtrs = &amp;AccountRepositoryMockUpdateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmUpdate</span>
}

// ExpectItemParam2 sets up expected param item for AccountRepository.Update
func (mmUpdate *mAccountRepositoryMockUpdate) ExpectItemParam2(item *entity.Account) *mAccountRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("AccountRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;AccountRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("AccountRepositoryMock.Update mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation.paramPtrs = &amp;AccountRepositoryMockUpdateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.paramPtrs.item = &amp;item
        mmUpdate.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

        return mmUpdate</span>
}

// Inspect accepts an inspector function that has same arguments as the AccountRepository.Update
func (mmUpdate *mAccountRepositoryMockUpdate) Inspect(f func(ctx context.Context, item *entity.Account)) *mAccountRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.inspectFuncUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Inspect function is already set for AccountRepositoryMock.Update")
        }</span>

        <span class="cov0" title="0">mmUpdate.mock.inspectFuncUpdate = f

        return mmUpdate</span>
}

// Return sets up results that will be returned by AccountRepository.Update
func (mmUpdate *mAccountRepositoryMockUpdate) Return(err error) *AccountRepositoryMock <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("AccountRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;AccountRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.results = &amp;AccountRepositoryMockUpdateResults{err}
        mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmUpdate.mock</span>
}

// Set uses given function f to mock the AccountRepository.Update method
func (mmUpdate *mAccountRepositoryMockUpdate) Set(f func(ctx context.Context, item *entity.Account) (err error)) *AccountRepositoryMock <span class="cov0" title="0">{
        if mmUpdate.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Default expectation is already set for the AccountRepository.Update method")
        }</span>

        <span class="cov0" title="0">if len(mmUpdate.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Some expectations are already set for the AccountRepository.Update method")
        }</span>

        <span class="cov0" title="0">mmUpdate.mock.funcUpdate = f
        mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
        return mmUpdate.mock</span>
}

// When sets expectation for the AccountRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mAccountRepositoryMockUpdate) When(ctx context.Context, item *entity.Account) *AccountRepositoryMockUpdateExpectation <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("AccountRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;AccountRepositoryMockUpdateExpectation{
                mock:               mmUpdate.mock,
                params:             &amp;AccountRepositoryMockUpdateParams{ctx, item},
                expectationOrigins: AccountRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmUpdate.expectations = append(mmUpdate.expectations, expectation)
        return expectation</span>
}

// Then sets up AccountRepository.Update return parameters for the expectation previously defined by the When method
func (e *AccountRepositoryMockUpdateExpectation) Then(err error) *AccountRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;AccountRepositoryMockUpdateResults{err}
        return e.mock
}</span>

// Times sets number of times AccountRepository.Update should be invoked
func (mmUpdate *mAccountRepositoryMockUpdate) Times(n uint64) *mAccountRepositoryMockUpdate <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Times of AccountRepositoryMock.Update mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmUpdate.expectedInvocations, n)
        mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmUpdate</span>
}

func (mmUpdate *mAccountRepositoryMockUpdate) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmUpdate.expectations) == 0 &amp;&amp; mmUpdate.defaultExpectation == nil &amp;&amp; mmUpdate.mock.funcUpdate == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmUpdate.mock.afterUpdateCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmUpdate.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Update implements mm_usecase.AccountRepository
func (mmUpdate *AccountRepositoryMock) Update(ctx context.Context, item *entity.Account) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmUpdate.beforeUpdateCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmUpdate.afterUpdateCounter, 1)

        mmUpdate.t.Helper()

        if mmUpdate.inspectFuncUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.inspectFuncUpdate(ctx, item)
        }</span>

        <span class="cov0" title="0">mm_params := AccountRepositoryMockUpdateParams{ctx, item}

        // Record call args
        mmUpdate.UpdateMock.mutex.Lock()
        mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &amp;mm_params)
        mmUpdate.UpdateMock.mutex.Unlock()

        for _, e := range mmUpdate.UpdateMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmUpdate.UpdateMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
                mm_want := mmUpdate.UpdateMock.defaultExpectation.params
                mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

                mm_got := AccountRepositoryMockUpdateParams{ctx, item}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmUpdate.t.Errorf("AccountRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.item != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.item, mm_got.item) </span><span class="cov0" title="0">{
                                mmUpdate.t.Errorf("AccountRepositoryMock.Update got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmUpdate.t.Errorf("AccountRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmUpdate.UpdateMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmUpdate.t.Fatal("No results are set for the AccountRepositoryMock.Update")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmUpdate.funcUpdate != nil </span><span class="cov0" title="0">{
                return mmUpdate.funcUpdate(ctx, item)
        }</span>
        <span class="cov0" title="0">mmUpdate.t.Fatalf("Unexpected call to AccountRepositoryMock.Update. %v %v", ctx, item)
        return</span>
}

// UpdateAfterCounter returns a count of finished AccountRepositoryMock.Update invocations
func (mmUpdate *AccountRepositoryMock) UpdateAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdate.afterUpdateCounter)
}</span>

// UpdateBeforeCounter returns a count of AccountRepositoryMock.Update invocations
func (mmUpdate *AccountRepositoryMock) UpdateBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdate.beforeUpdateCounter)
}</span>

// Calls returns a list of arguments used in each call to AccountRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mAccountRepositoryMockUpdate) Calls() []*AccountRepositoryMockUpdateParams <span class="cov0" title="0">{
        mmUpdate.mutex.RLock()

        argCopy := make([]*AccountRepositoryMockUpdateParams, len(mmUpdate.callArgs))
        copy(argCopy, mmUpdate.callArgs)

        mmUpdate.mutex.RUnlock()

        return argCopy
}</span>

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *AccountRepositoryMock) MinimockUpdateDone() bool <span class="cov0" title="0">{
        if m.UpdateMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.UpdateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.UpdateMock.invocationsDone()</span>
}

// MinimockUpdateInspect logs each unmet expectation
func (m *AccountRepositoryMock) MinimockUpdateInspect() <span class="cov0" title="0">{
        for _, e := range m.UpdateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterUpdateCounter := mm_atomic.LoadUint64(&amp;m.afterUpdateCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.UpdateMock.defaultExpectation != nil &amp;&amp; afterUpdateCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.UpdateMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to AccountRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcUpdate != nil &amp;&amp; afterUpdateCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to AccountRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
        }</span>

        <span class="cov0" title="0">if !m.UpdateMock.invocationsDone() &amp;&amp; afterUpdateCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to AccountRepositoryMock.Update at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AccountRepositoryMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockCreateInspect()

                        m.MinimockFindListInspect()

                        m.MinimockFindOneByEmailInspect()

                        m.MinimockFindOneByIDInspect()

                        m.MinimockFindPagedListInspect()

                        m.MinimockUpdateInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AccountRepositoryMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *AccountRepositoryMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockCreateDone() &amp;&amp;
                m.MinimockFindListDone() &amp;&amp;
                m.MinimockFindOneByEmailDone() &amp;&amp;
                m.MinimockFindOneByIDDone() &amp;&amp;
                m.MinimockFindPagedListDone() &amp;&amp;
                m.MinimockUpdateDone()
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase.AccountUsecase -o account_usecase.go -n AccountUsecaseMock -p mocks

import (
        "context"
        "net"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/auth/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
        mm_usecase "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
)

// AccountUsecaseMock implements mm_usecase.AccountUsecase
type AccountUsecaseMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcCreateAccountByDTO          func(ctx context.Context, in mm_usecase.CreateAccountDataInput, requestIP *net.IP) (resAccountDTO *mm_usecase.AccountDTO, err error)
        funcCreateAccountByDTOOrigin    string
        inspectFuncCreateAccountByDTO   func(ctx context.Context, in mm_usecase.CreateAccountDataInput, requestIP *net.IP)
        afterCreateAccountByDTOCounter  uint64
        beforeCreateAccountByDTOCounter uint64
        CreateAccountByDTOMock          mAccountUsecaseMockCreateAccountByDTO

        funcFindList          func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.AccountDTO, err error)
        funcFindListOrigin    string
        inspectFuncFindList   func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams)
        afterFindListCounter  uint64
        beforeFindListCounter uint64
        FindListMock          mAccountUsecaseMockFindList

        funcFindListInMap          func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (resItems map[uuid.UUID]*mm_usecase.AccountDTO, err error)
        funcFindListInMapOrigin    string
        inspectFuncFindListInMap   func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams)
        afterFindListInMapCounter  uint64
        beforeFindListInMapCounter uint64
        FindListInMapMock          mAccountUsecaseMockFindListInMap

        funcFindOneByEmail          func(ctx context.Context, email string, queryParams *uctypes.QueryGetOneParams) (resAccount *mm_usecase.AccountDTO, err error)
        funcFindOneByEmailOrigin    string
        inspectFuncFindOneByEmail   func(ctx context.Context, email string, queryParams *uctypes.QueryGetOneParams)
        afterFindOneByEmailCounter  uint64
        beforeFindOneByEmailCounter uint64
        FindOneByEmailMock          mAccountUsecaseMockFindOneByEmail

        funcFindOneByID          func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (resAccount *mm_usecase.AccountDTO, err error)
        funcFindOneByIDOrigin    string
        inspectFuncFindOneByID   func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)
        afterFindOneByIDCounter  uint64
        beforeFindOneByIDCounter uint64
        FindOneByIDMock          mAccountUsecaseMockFindOneByID

        funcFindPagedList          func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.AccountDTO, total uint64, err error)
        funcFindPagedListOrigin    string
        inspectFuncFindPagedList   func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams)
        afterFindPagedListCounter  uint64
        beforeFindPagedListCounter uint64
        FindPagedListMock          mAccountUsecaseMockFindPagedList

        funcPatchAccountByDTO          func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchAccountDataInput, skipVersionCheck bool) (err error)
        funcPatchAccountByDTOOrigin    string
        inspectFuncPatchAccountByDTO   func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchAccountDataInput, skipVersionCheck bool)
        afterPatchAccountByDTOCounter  uint64
        beforePatchAccountByDTOCounter uint64
        PatchAccountByDTOMock          mAccountUsecaseMockPatchAccountByDTO

        funcUpdateAccount          func(ctx context.Context, item *entity.Account) (err error)
        funcUpdateAccountOrigin    string
        inspectFuncUpdateAccount   func(ctx context.Context, item *entity.Account)
        afterUpdateAccountCounter  uint64
        beforeUpdateAccountCounter uint64
        UpdateAccountMock          mAccountUsecaseMockUpdateAccount
}

// NewAccountUsecaseMock returns a mock for mm_usecase.AccountUsecase
func NewAccountUsecaseMock(t minimock.Tester) *AccountUsecaseMock <span class="cov0" title="0">{
        m := &amp;AccountUsecaseMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.CreateAccountByDTOMock = mAccountUsecaseMockCreateAccountByDTO{mock: m}
        m.CreateAccountByDTOMock.callArgs = []*AccountUsecaseMockCreateAccountByDTOParams{}

        m.FindListMock = mAccountUsecaseMockFindList{mock: m}
        m.FindListMock.callArgs = []*AccountUsecaseMockFindListParams{}

        m.FindListInMapMock = mAccountUsecaseMockFindListInMap{mock: m}
        m.FindListInMapMock.callArgs = []*AccountUsecaseMockFindListInMapParams{}

        m.FindOneByEmailMock = mAccountUsecaseMockFindOneByEmail{mock: m}
        m.FindOneByEmailMock.callArgs = []*AccountUsecaseMockFindOneByEmailParams{}

        m.FindOneByIDMock = mAccountUsecaseMockFindOneByID{mock: m}
        m.FindOneByIDMock.callArgs = []*AccountUsecaseMockFindOneByIDParams{}

        m.FindPagedListMock = mAccountUsecaseMockFindPagedList{mock: m}
        m.FindPagedListMock.callArgs = []*AccountUsecaseMockFindPagedListParams{}

        m.PatchAccountByDTOMock = mAccountUsecaseMockPatchAccountByDTO{mock: m}
        m.PatchAccountByDTOMock.callArgs = []*AccountUsecaseMockPatchAccountByDTOParams{}

        m.UpdateAccountMock = mAccountUsecaseMockUpdateAccount{mock: m}
        m.UpdateAccountMock.callArgs = []*AccountUsecaseMockUpdateAccountParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mAccountUsecaseMockCreateAccountByDTO struct {
        optional           bool
        mock               *AccountUsecaseMock
        defaultExpectation *AccountUsecaseMockCreateAccountByDTOExpectation
        expectations       []*AccountUsecaseMockCreateAccountByDTOExpectation

        callArgs []*AccountUsecaseMockCreateAccountByDTOParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// AccountUsecaseMockCreateAccountByDTOExpectation specifies expectation struct of the AccountUsecase.CreateAccountByDTO
type AccountUsecaseMockCreateAccountByDTOExpectation struct {
        mock               *AccountUsecaseMock
        params             *AccountUsecaseMockCreateAccountByDTOParams
        paramPtrs          *AccountUsecaseMockCreateAccountByDTOParamPtrs
        expectationOrigins AccountUsecaseMockCreateAccountByDTOExpectationOrigins
        results            *AccountUsecaseMockCreateAccountByDTOResults
        returnOrigin       string
        Counter            uint64
}

// AccountUsecaseMockCreateAccountByDTOParams contains parameters of the AccountUsecase.CreateAccountByDTO
type AccountUsecaseMockCreateAccountByDTOParams struct {
        ctx       context.Context
        in        mm_usecase.CreateAccountDataInput
        requestIP *net.IP
}

// AccountUsecaseMockCreateAccountByDTOParamPtrs contains pointers to parameters of the AccountUsecase.CreateAccountByDTO
type AccountUsecaseMockCreateAccountByDTOParamPtrs struct {
        ctx       *context.Context
        in        *mm_usecase.CreateAccountDataInput
        requestIP **net.IP
}

// AccountUsecaseMockCreateAccountByDTOResults contains results of the AccountUsecase.CreateAccountByDTO
type AccountUsecaseMockCreateAccountByDTOResults struct {
        resAccountDTO *mm_usecase.AccountDTO
        err           error
}

// AccountUsecaseMockCreateAccountByDTOOrigins contains origins of expectations of the AccountUsecase.CreateAccountByDTO
type AccountUsecaseMockCreateAccountByDTOExpectationOrigins struct {
        origin          string
        originCtx       string
        originIn        string
        originRequestIP string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) Optional() *mAccountUsecaseMockCreateAccountByDTO <span class="cov0" title="0">{
        mmCreateAccountByDTO.optional = true
        return mmCreateAccountByDTO
}</span>

// Expect sets up expected params for AccountUsecase.CreateAccountByDTO
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) Expect(ctx context.Context, in mm_usecase.CreateAccountDataInput, requestIP *net.IP) *mAccountUsecaseMockCreateAccountByDTO <span class="cov0" title="0">{
        if mmCreateAccountByDTO.mock.funcCreateAccountByDTO != nil </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.CreateAccountByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateAccountByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.defaultExpectation = &amp;AccountUsecaseMockCreateAccountByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateAccountByDTO.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.CreateAccountByDTO mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmCreateAccountByDTO.defaultExpectation.params = &amp;AccountUsecaseMockCreateAccountByDTOParams{ctx, in, requestIP}
        mmCreateAccountByDTO.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmCreateAccountByDTO.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmCreateAccountByDTO.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmCreateAccountByDTO.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateAccountByDTO.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmCreateAccountByDTO</span>
}

// ExpectCtxParam1 sets up expected param ctx for AccountUsecase.CreateAccountByDTO
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) ExpectCtxParam1(ctx context.Context) *mAccountUsecaseMockCreateAccountByDTO <span class="cov0" title="0">{
        if mmCreateAccountByDTO.mock.funcCreateAccountByDTO != nil </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.CreateAccountByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateAccountByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.defaultExpectation = &amp;AccountUsecaseMockCreateAccountByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateAccountByDTO.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.CreateAccountByDTO mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreateAccountByDTO.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockCreateAccountByDTOParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreateAccountByDTO.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmCreateAccountByDTO.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmCreateAccountByDTO</span>
}

// ExpectInParam2 sets up expected param in for AccountUsecase.CreateAccountByDTO
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) ExpectInParam2(in mm_usecase.CreateAccountDataInput) *mAccountUsecaseMockCreateAccountByDTO <span class="cov0" title="0">{
        if mmCreateAccountByDTO.mock.funcCreateAccountByDTO != nil </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.CreateAccountByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateAccountByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.defaultExpectation = &amp;AccountUsecaseMockCreateAccountByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateAccountByDTO.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.CreateAccountByDTO mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreateAccountByDTO.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockCreateAccountByDTOParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreateAccountByDTO.defaultExpectation.paramPtrs.in = &amp;in
        mmCreateAccountByDTO.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

        return mmCreateAccountByDTO</span>
}

// ExpectRequestIPParam3 sets up expected param requestIP for AccountUsecase.CreateAccountByDTO
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) ExpectRequestIPParam3(requestIP *net.IP) *mAccountUsecaseMockCreateAccountByDTO <span class="cov0" title="0">{
        if mmCreateAccountByDTO.mock.funcCreateAccountByDTO != nil </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.CreateAccountByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateAccountByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.defaultExpectation = &amp;AccountUsecaseMockCreateAccountByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateAccountByDTO.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.CreateAccountByDTO mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreateAccountByDTO.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockCreateAccountByDTOParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreateAccountByDTO.defaultExpectation.paramPtrs.requestIP = &amp;requestIP
        mmCreateAccountByDTO.defaultExpectation.expectationOrigins.originRequestIP = minimock.CallerInfo(1)

        return mmCreateAccountByDTO</span>
}

// Inspect accepts an inspector function that has same arguments as the AccountUsecase.CreateAccountByDTO
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) Inspect(f func(ctx context.Context, in mm_usecase.CreateAccountDataInput, requestIP *net.IP)) *mAccountUsecaseMockCreateAccountByDTO <span class="cov0" title="0">{
        if mmCreateAccountByDTO.mock.inspectFuncCreateAccountByDTO != nil </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.mock.t.Fatalf("Inspect function is already set for AccountUsecaseMock.CreateAccountByDTO")
        }</span>

        <span class="cov0" title="0">mmCreateAccountByDTO.mock.inspectFuncCreateAccountByDTO = f

        return mmCreateAccountByDTO</span>
}

// Return sets up results that will be returned by AccountUsecase.CreateAccountByDTO
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) Return(resAccountDTO *mm_usecase.AccountDTO, err error) *AccountUsecaseMock <span class="cov0" title="0">{
        if mmCreateAccountByDTO.mock.funcCreateAccountByDTO != nil </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.CreateAccountByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateAccountByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.defaultExpectation = &amp;AccountUsecaseMockCreateAccountByDTOExpectation{mock: mmCreateAccountByDTO.mock}
        }</span>
        <span class="cov0" title="0">mmCreateAccountByDTO.defaultExpectation.results = &amp;AccountUsecaseMockCreateAccountByDTOResults{resAccountDTO, err}
        mmCreateAccountByDTO.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmCreateAccountByDTO.mock</span>
}

// Set uses given function f to mock the AccountUsecase.CreateAccountByDTO method
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) Set(f func(ctx context.Context, in mm_usecase.CreateAccountDataInput, requestIP *net.IP) (resAccountDTO *mm_usecase.AccountDTO, err error)) *AccountUsecaseMock <span class="cov0" title="0">{
        if mmCreateAccountByDTO.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.mock.t.Fatalf("Default expectation is already set for the AccountUsecase.CreateAccountByDTO method")
        }</span>

        <span class="cov0" title="0">if len(mmCreateAccountByDTO.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.mock.t.Fatalf("Some expectations are already set for the AccountUsecase.CreateAccountByDTO method")
        }</span>

        <span class="cov0" title="0">mmCreateAccountByDTO.mock.funcCreateAccountByDTO = f
        mmCreateAccountByDTO.mock.funcCreateAccountByDTOOrigin = minimock.CallerInfo(1)
        return mmCreateAccountByDTO.mock</span>
}

// When sets expectation for the AccountUsecase.CreateAccountByDTO which will trigger the result defined by the following
// Then helper
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) When(ctx context.Context, in mm_usecase.CreateAccountDataInput, requestIP *net.IP) *AccountUsecaseMockCreateAccountByDTOExpectation <span class="cov0" title="0">{
        if mmCreateAccountByDTO.mock.funcCreateAccountByDTO != nil </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.CreateAccountByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;AccountUsecaseMockCreateAccountByDTOExpectation{
                mock:               mmCreateAccountByDTO.mock,
                params:             &amp;AccountUsecaseMockCreateAccountByDTOParams{ctx, in, requestIP},
                expectationOrigins: AccountUsecaseMockCreateAccountByDTOExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmCreateAccountByDTO.expectations = append(mmCreateAccountByDTO.expectations, expectation)
        return expectation</span>
}

// Then sets up AccountUsecase.CreateAccountByDTO return parameters for the expectation previously defined by the When method
func (e *AccountUsecaseMockCreateAccountByDTOExpectation) Then(resAccountDTO *mm_usecase.AccountDTO, err error) *AccountUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;AccountUsecaseMockCreateAccountByDTOResults{resAccountDTO, err}
        return e.mock
}</span>

// Times sets number of times AccountUsecase.CreateAccountByDTO should be invoked
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) Times(n uint64) *mAccountUsecaseMockCreateAccountByDTO <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.mock.t.Fatalf("Times of AccountUsecaseMock.CreateAccountByDTO mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmCreateAccountByDTO.expectedInvocations, n)
        mmCreateAccountByDTO.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmCreateAccountByDTO</span>
}

func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmCreateAccountByDTO.expectations) == 0 &amp;&amp; mmCreateAccountByDTO.defaultExpectation == nil &amp;&amp; mmCreateAccountByDTO.mock.funcCreateAccountByDTO == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmCreateAccountByDTO.mock.afterCreateAccountByDTOCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmCreateAccountByDTO.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// CreateAccountByDTO implements mm_usecase.AccountUsecase
func (mmCreateAccountByDTO *AccountUsecaseMock) CreateAccountByDTO(ctx context.Context, in mm_usecase.CreateAccountDataInput, requestIP *net.IP) (resAccountDTO *mm_usecase.AccountDTO, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmCreateAccountByDTO.beforeCreateAccountByDTOCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmCreateAccountByDTO.afterCreateAccountByDTOCounter, 1)

        mmCreateAccountByDTO.t.Helper()

        if mmCreateAccountByDTO.inspectFuncCreateAccountByDTO != nil </span><span class="cov0" title="0">{
                mmCreateAccountByDTO.inspectFuncCreateAccountByDTO(ctx, in, requestIP)
        }</span>

        <span class="cov0" title="0">mm_params := AccountUsecaseMockCreateAccountByDTOParams{ctx, in, requestIP}

        // Record call args
        mmCreateAccountByDTO.CreateAccountByDTOMock.mutex.Lock()
        mmCreateAccountByDTO.CreateAccountByDTOMock.callArgs = append(mmCreateAccountByDTO.CreateAccountByDTOMock.callArgs, &amp;mm_params)
        mmCreateAccountByDTO.CreateAccountByDTOMock.mutex.Unlock()

        for _, e := range mmCreateAccountByDTO.CreateAccountByDTOMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.resAccountDTO, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmCreateAccountByDTO.CreateAccountByDTOMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmCreateAccountByDTO.CreateAccountByDTOMock.defaultExpectation.Counter, 1)
                mm_want := mmCreateAccountByDTO.CreateAccountByDTOMock.defaultExpectation.params
                mm_want_ptrs := mmCreateAccountByDTO.CreateAccountByDTOMock.defaultExpectation.paramPtrs

                mm_got := AccountUsecaseMockCreateAccountByDTOParams{ctx, in, requestIP}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmCreateAccountByDTO.t.Errorf("AccountUsecaseMock.CreateAccountByDTO got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCreateAccountByDTO.CreateAccountByDTOMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.in != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.in, mm_got.in) </span><span class="cov0" title="0">{
                                mmCreateAccountByDTO.t.Errorf("AccountUsecaseMock.CreateAccountByDTO got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCreateAccountByDTO.CreateAccountByDTOMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.requestIP != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.requestIP, mm_got.requestIP) </span><span class="cov0" title="0">{
                                mmCreateAccountByDTO.t.Errorf("AccountUsecaseMock.CreateAccountByDTO got unexpected parameter requestIP, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCreateAccountByDTO.CreateAccountByDTOMock.defaultExpectation.expectationOrigins.originRequestIP, *mm_want_ptrs.requestIP, mm_got.requestIP, minimock.Diff(*mm_want_ptrs.requestIP, mm_got.requestIP))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmCreateAccountByDTO.t.Errorf("AccountUsecaseMock.CreateAccountByDTO got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmCreateAccountByDTO.CreateAccountByDTOMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmCreateAccountByDTO.CreateAccountByDTOMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmCreateAccountByDTO.t.Fatal("No results are set for the AccountUsecaseMock.CreateAccountByDTO")
                }</span>
                <span class="cov0" title="0">return (*mm_results).resAccountDTO, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmCreateAccountByDTO.funcCreateAccountByDTO != nil </span><span class="cov0" title="0">{
                return mmCreateAccountByDTO.funcCreateAccountByDTO(ctx, in, requestIP)
        }</span>
        <span class="cov0" title="0">mmCreateAccountByDTO.t.Fatalf("Unexpected call to AccountUsecaseMock.CreateAccountByDTO. %v %v %v", ctx, in, requestIP)
        return</span>
}

// CreateAccountByDTOAfterCounter returns a count of finished AccountUsecaseMock.CreateAccountByDTO invocations
func (mmCreateAccountByDTO *AccountUsecaseMock) CreateAccountByDTOAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreateAccountByDTO.afterCreateAccountByDTOCounter)
}</span>

// CreateAccountByDTOBeforeCounter returns a count of AccountUsecaseMock.CreateAccountByDTO invocations
func (mmCreateAccountByDTO *AccountUsecaseMock) CreateAccountByDTOBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreateAccountByDTO.beforeCreateAccountByDTOCounter)
}</span>

// Calls returns a list of arguments used in each call to AccountUsecaseMock.CreateAccountByDTO.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) Calls() []*AccountUsecaseMockCreateAccountByDTOParams <span class="cov0" title="0">{
        mmCreateAccountByDTO.mutex.RLock()

        argCopy := make([]*AccountUsecaseMockCreateAccountByDTOParams, len(mmCreateAccountByDTO.callArgs))
        copy(argCopy, mmCreateAccountByDTO.callArgs)

        mmCreateAccountByDTO.mutex.RUnlock()

        return argCopy
}</span>

// MinimockCreateAccountByDTODone returns true if the count of the CreateAccountByDTO invocations corresponds
// the number of defined expectations
func (m *AccountUsecaseMock) MinimockCreateAccountByDTODone() bool <span class="cov0" title="0">{
        if m.CreateAccountByDTOMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.CreateAccountByDTOMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.CreateAccountByDTOMock.invocationsDone()</span>
}

// MinimockCreateAccountByDTOInspect logs each unmet expectation
func (m *AccountUsecaseMock) MinimockCreateAccountByDTOInspect() <span class="cov0" title="0">{
        for _, e := range m.CreateAccountByDTOMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountUsecaseMock.CreateAccountByDTO at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterCreateAccountByDTOCounter := mm_atomic.LoadUint64(&amp;m.afterCreateAccountByDTOCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.CreateAccountByDTOMock.defaultExpectation != nil &amp;&amp; afterCreateAccountByDTOCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.CreateAccountByDTOMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountUsecaseMock.CreateAccountByDTO at\n%s", m.CreateAccountByDTOMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to AccountUsecaseMock.CreateAccountByDTO at\n%s with params: %#v", m.CreateAccountByDTOMock.defaultExpectation.expectationOrigins.origin, *m.CreateAccountByDTOMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcCreateAccountByDTO != nil &amp;&amp; afterCreateAccountByDTOCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to AccountUsecaseMock.CreateAccountByDTO at\n%s", m.funcCreateAccountByDTOOrigin)
        }</span>

        <span class="cov0" title="0">if !m.CreateAccountByDTOMock.invocationsDone() &amp;&amp; afterCreateAccountByDTOCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to AccountUsecaseMock.CreateAccountByDTO at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.CreateAccountByDTOMock.expectedInvocations), m.CreateAccountByDTOMock.expectedInvocationsOrigin, afterCreateAccountByDTOCounter)
        }</span>
}

type mAccountUsecaseMockFindList struct {
        optional           bool
        mock               *AccountUsecaseMock
        defaultExpectation *AccountUsecaseMockFindListExpectation
        expectations       []*AccountUsecaseMockFindListExpectation

        callArgs []*AccountUsecaseMockFindListParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// AccountUsecaseMockFindListExpectation specifies expectation struct of the AccountUsecase.FindList
type AccountUsecaseMockFindListExpectation struct {
        mock               *AccountUsecaseMock
        params             *AccountUsecaseMockFindListParams
        paramPtrs          *AccountUsecaseMockFindListParamPtrs
        expectationOrigins AccountUsecaseMockFindListExpectationOrigins
        results            *AccountUsecaseMockFindListResults
        returnOrigin       string
        Counter            uint64
}

// AccountUsecaseMockFindListParams contains parameters of the AccountUsecase.FindList
type AccountUsecaseMockFindListParams struct {
        ctx         context.Context
        listOptions *mm_usecase.AccountListOptions
        queryParams *uctypes.QueryGetListParams
}

// AccountUsecaseMockFindListParamPtrs contains pointers to parameters of the AccountUsecase.FindList
type AccountUsecaseMockFindListParamPtrs struct {
        ctx         *context.Context
        listOptions **mm_usecase.AccountListOptions
        queryParams **uctypes.QueryGetListParams
}

// AccountUsecaseMockFindListResults contains results of the AccountUsecase.FindList
type AccountUsecaseMockFindListResults struct {
        resItems []*mm_usecase.AccountDTO
        err      error
}

// AccountUsecaseMockFindListOrigins contains origins of expectations of the AccountUsecase.FindList
type AccountUsecaseMockFindListExpectationOrigins struct {
        origin            string
        originCtx         string
        originListOptions string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindList *mAccountUsecaseMockFindList) Optional() *mAccountUsecaseMockFindList <span class="cov0" title="0">{
        mmFindList.optional = true
        return mmFindList
}</span>

// Expect sets up expected params for AccountUsecase.FindList
func (mmFindList *mAccountUsecaseMockFindList) Expect(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) *mAccountUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("AccountUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;AccountUsecaseMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("AccountUsecaseMock.FindList mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindList.defaultExpectation.params = &amp;AccountUsecaseMockFindListParams{ctx, listOptions, queryParams}
        mmFindList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindList.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindList.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindList.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindList</span>
}

// ExpectCtxParam1 sets up expected param ctx for AccountUsecase.FindList
func (mmFindList *mAccountUsecaseMockFindList) ExpectCtxParam1(ctx context.Context) *mAccountUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("AccountUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;AccountUsecaseMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("AccountUsecaseMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindList</span>
}

// ExpectListOptionsParam2 sets up expected param listOptions for AccountUsecase.FindList
func (mmFindList *mAccountUsecaseMockFindList) ExpectListOptionsParam2(listOptions *mm_usecase.AccountListOptions) *mAccountUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("AccountUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;AccountUsecaseMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("AccountUsecaseMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.listOptions = &amp;listOptions
        mmFindList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

        return mmFindList</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for AccountUsecase.FindList
func (mmFindList *mAccountUsecaseMockFindList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mAccountUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("AccountUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;AccountUsecaseMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("AccountUsecaseMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindList</span>
}

// Inspect accepts an inspector function that has same arguments as the AccountUsecase.FindList
func (mmFindList *mAccountUsecaseMockFindList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams)) *mAccountUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.inspectFuncFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Inspect function is already set for AccountUsecaseMock.FindList")
        }</span>

        <span class="cov0" title="0">mmFindList.mock.inspectFuncFindList = f

        return mmFindList</span>
}

// Return sets up results that will be returned by AccountUsecase.FindList
func (mmFindList *mAccountUsecaseMockFindList) Return(resItems []*mm_usecase.AccountDTO, err error) *AccountUsecaseMock <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("AccountUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;AccountUsecaseMockFindListExpectation{mock: mmFindList.mock}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.results = &amp;AccountUsecaseMockFindListResults{resItems, err}
        mmFindList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindList.mock</span>
}

// Set uses given function f to mock the AccountUsecase.FindList method
func (mmFindList *mAccountUsecaseMockFindList) Set(f func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.AccountDTO, err error)) *AccountUsecaseMock <span class="cov0" title="0">{
        if mmFindList.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Default expectation is already set for the AccountUsecase.FindList method")
        }</span>

        <span class="cov0" title="0">if len(mmFindList.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Some expectations are already set for the AccountUsecase.FindList method")
        }</span>

        <span class="cov0" title="0">mmFindList.mock.funcFindList = f
        mmFindList.mock.funcFindListOrigin = minimock.CallerInfo(1)
        return mmFindList.mock</span>
}

// When sets expectation for the AccountUsecase.FindList which will trigger the result defined by the following
// Then helper
func (mmFindList *mAccountUsecaseMockFindList) When(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) *AccountUsecaseMockFindListExpectation <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("AccountUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;AccountUsecaseMockFindListExpectation{
                mock:               mmFindList.mock,
                params:             &amp;AccountUsecaseMockFindListParams{ctx, listOptions, queryParams},
                expectationOrigins: AccountUsecaseMockFindListExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindList.expectations = append(mmFindList.expectations, expectation)
        return expectation</span>
}

// Then sets up AccountUsecase.FindList return parameters for the expectation previously defined by the When method
func (e *AccountUsecaseMockFindListExpectation) Then(resItems []*mm_usecase.AccountDTO, err error) *AccountUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;AccountUsecaseMockFindListResults{resItems, err}
        return e.mock
}</span>

// Times sets number of times AccountUsecase.FindList should be invoked
func (mmFindList *mAccountUsecaseMockFindList) Times(n uint64) *mAccountUsecaseMockFindList <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Times of AccountUsecaseMock.FindList mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindList.expectedInvocations, n)
        mmFindList.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindList</span>
}

func (mmFindList *mAccountUsecaseMockFindList) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindList.expectations) == 0 &amp;&amp; mmFindList.defaultExpectation == nil &amp;&amp; mmFindList.mock.funcFindList == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindList.mock.afterFindListCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindList.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindList implements mm_usecase.AccountUsecase
func (mmFindList *AccountUsecaseMock) FindList(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.AccountDTO, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindList.beforeFindListCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindList.afterFindListCounter, 1)

        mmFindList.t.Helper()

        if mmFindList.inspectFuncFindList != nil </span><span class="cov0" title="0">{
                mmFindList.inspectFuncFindList(ctx, listOptions, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := AccountUsecaseMockFindListParams{ctx, listOptions, queryParams}

        // Record call args
        mmFindList.FindListMock.mutex.Lock()
        mmFindList.FindListMock.callArgs = append(mmFindList.FindListMock.callArgs, &amp;mm_params)
        mmFindList.FindListMock.mutex.Unlock()

        for _, e := range mmFindList.FindListMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.resItems, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindList.FindListMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindList.FindListMock.defaultExpectation.Counter, 1)
                mm_want := mmFindList.FindListMock.defaultExpectation.params
                mm_want_ptrs := mmFindList.FindListMock.defaultExpectation.paramPtrs

                mm_got := AccountUsecaseMockFindListParams{ctx, listOptions, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("AccountUsecaseMock.FindList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.listOptions != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("AccountUsecaseMock.FindList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("AccountUsecaseMock.FindList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindList.t.Errorf("AccountUsecaseMock.FindList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindList.FindListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindList.FindListMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindList.t.Fatal("No results are set for the AccountUsecaseMock.FindList")
                }</span>
                <span class="cov0" title="0">return (*mm_results).resItems, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindList.funcFindList != nil </span><span class="cov0" title="0">{
                return mmFindList.funcFindList(ctx, listOptions, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindList.t.Fatalf("Unexpected call to AccountUsecaseMock.FindList. %v %v %v", ctx, listOptions, queryParams)
        return</span>
}

// FindListAfterCounter returns a count of finished AccountUsecaseMock.FindList invocations
func (mmFindList *AccountUsecaseMock) FindListAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindList.afterFindListCounter)
}</span>

// FindListBeforeCounter returns a count of AccountUsecaseMock.FindList invocations
func (mmFindList *AccountUsecaseMock) FindListBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindList.beforeFindListCounter)
}</span>

// Calls returns a list of arguments used in each call to AccountUsecaseMock.FindList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindList *mAccountUsecaseMockFindList) Calls() []*AccountUsecaseMockFindListParams <span class="cov0" title="0">{
        mmFindList.mutex.RLock()

        argCopy := make([]*AccountUsecaseMockFindListParams, len(mmFindList.callArgs))
        copy(argCopy, mmFindList.callArgs)

        mmFindList.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindListDone returns true if the count of the FindList invocations corresponds
// the number of defined expectations
func (m *AccountUsecaseMock) MinimockFindListDone() bool <span class="cov0" title="0">{
        if m.FindListMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindListMock.invocationsDone()</span>
}

// MinimockFindListInspect logs each unmet expectation
func (m *AccountUsecaseMock) MinimockFindListInspect() <span class="cov0" title="0">{
        for _, e := range m.FindListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountUsecaseMock.FindList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindListCounter := mm_atomic.LoadUint64(&amp;m.afterFindListCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindListMock.defaultExpectation != nil &amp;&amp; afterFindListCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindListMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountUsecaseMock.FindList at\n%s", m.FindListMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to AccountUsecaseMock.FindList at\n%s with params: %#v", m.FindListMock.defaultExpectation.expectationOrigins.origin, *m.FindListMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindList != nil &amp;&amp; afterFindListCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to AccountUsecaseMock.FindList at\n%s", m.funcFindListOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindListMock.invocationsDone() &amp;&amp; afterFindListCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to AccountUsecaseMock.FindList at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindListMock.expectedInvocations), m.FindListMock.expectedInvocationsOrigin, afterFindListCounter)
        }</span>
}

type mAccountUsecaseMockFindListInMap struct {
        optional           bool
        mock               *AccountUsecaseMock
        defaultExpectation *AccountUsecaseMockFindListInMapExpectation
        expectations       []*AccountUsecaseMockFindListInMapExpectation

        callArgs []*AccountUsecaseMockFindListInMapParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// AccountUsecaseMockFindListInMapExpectation specifies expectation struct of the AccountUsecase.FindListInMap
type AccountUsecaseMockFindListInMapExpectation struct {
        mock               *AccountUsecaseMock
        params             *AccountUsecaseMockFindListInMapParams
        paramPtrs          *AccountUsecaseMockFindListInMapParamPtrs
        expectationOrigins AccountUsecaseMockFindListInMapExpectationOrigins
        results            *AccountUsecaseMockFindListInMapResults
        returnOrigin       string
        Counter            uint64
}

// AccountUsecaseMockFindListInMapParams contains parameters of the AccountUsecase.FindListInMap
type AccountUsecaseMockFindListInMapParams struct {
        ctx         context.Context
        listOptions *mm_usecase.AccountListOptions
        queryParams *uctypes.QueryGetListParams
}

// AccountUsecaseMockFindListInMapParamPtrs contains pointers to parameters of the AccountUsecase.FindListInMap
type AccountUsecaseMockFindListInMapParamPtrs struct {
        ctx         *context.Context
        listOptions **mm_usecase.AccountListOptions
        queryParams **uctypes.QueryGetListParams
}

// AccountUsecaseMockFindListInMapResults contains results of the AccountUsecase.FindListInMap
type AccountUsecaseMockFindListInMapResults struct {
        resItems map[uuid.UUID]*mm_usecase.AccountDTO
        err      error
}

// AccountUsecaseMockFindListInMapOrigins contains origins of expectations of the AccountUsecase.FindListInMap
type AccountUsecaseMockFindListInMapExpectationOrigins struct {
        origin            string
        originCtx         string
        originListOptions string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) Optional() *mAccountUsecaseMockFindListInMap <span class="cov0" title="0">{
        mmFindListInMap.optional = true
        return mmFindListInMap
}</span>

// Expect sets up expected params for AccountUsecase.FindListInMap
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) Expect(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) *mAccountUsecaseMockFindListInMap <span class="cov0" title="0">{
        if mmFindListInMap.mock.funcFindListInMap != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("AccountUsecaseMock.FindListInMap mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindListInMap.defaultExpectation = &amp;AccountUsecaseMockFindListInMapExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("AccountUsecaseMock.FindListInMap mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindListInMap.defaultExpectation.params = &amp;AccountUsecaseMockFindListInMapParams{ctx, listOptions, queryParams}
        mmFindListInMap.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindListInMap.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindListInMap.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindListInMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindListInMap.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindListInMap</span>
}

// ExpectCtxParam1 sets up expected param ctx for AccountUsecase.FindListInMap
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) ExpectCtxParam1(ctx context.Context) *mAccountUsecaseMockFindListInMap <span class="cov0" title="0">{
        if mmFindListInMap.mock.funcFindListInMap != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("AccountUsecaseMock.FindListInMap mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindListInMap.defaultExpectation = &amp;AccountUsecaseMockFindListInMapExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("AccountUsecaseMock.FindListInMap mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindListInMap.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockFindListInMapParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindListInMap.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindListInMap.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindListInMap</span>
}

// ExpectListOptionsParam2 sets up expected param listOptions for AccountUsecase.FindListInMap
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) ExpectListOptionsParam2(listOptions *mm_usecase.AccountListOptions) *mAccountUsecaseMockFindListInMap <span class="cov0" title="0">{
        if mmFindListInMap.mock.funcFindListInMap != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("AccountUsecaseMock.FindListInMap mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindListInMap.defaultExpectation = &amp;AccountUsecaseMockFindListInMapExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("AccountUsecaseMock.FindListInMap mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindListInMap.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockFindListInMapParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindListInMap.defaultExpectation.paramPtrs.listOptions = &amp;listOptions
        mmFindListInMap.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

        return mmFindListInMap</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for AccountUsecase.FindListInMap
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mAccountUsecaseMockFindListInMap <span class="cov0" title="0">{
        if mmFindListInMap.mock.funcFindListInMap != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("AccountUsecaseMock.FindListInMap mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindListInMap.defaultExpectation = &amp;AccountUsecaseMockFindListInMapExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("AccountUsecaseMock.FindListInMap mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindListInMap.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockFindListInMapParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindListInMap.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindListInMap.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindListInMap</span>
}

// Inspect accepts an inspector function that has same arguments as the AccountUsecase.FindListInMap
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) Inspect(f func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams)) *mAccountUsecaseMockFindListInMap <span class="cov0" title="0">{
        if mmFindListInMap.mock.inspectFuncFindListInMap != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("Inspect function is already set for AccountUsecaseMock.FindListInMap")
        }</span>

        <span class="cov0" title="0">mmFindListInMap.mock.inspectFuncFindListInMap = f

        return mmFindListInMap</span>
}

// Return sets up results that will be returned by AccountUsecase.FindListInMap
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) Return(resItems map[uuid.UUID]*mm_usecase.AccountDTO, err error) *AccountUsecaseMock <span class="cov0" title="0">{
        if mmFindListInMap.mock.funcFindListInMap != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("AccountUsecaseMock.FindListInMap mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindListInMap.defaultExpectation = &amp;AccountUsecaseMockFindListInMapExpectation{mock: mmFindListInMap.mock}
        }</span>
        <span class="cov0" title="0">mmFindListInMap.defaultExpectation.results = &amp;AccountUsecaseMockFindListInMapResults{resItems, err}
        mmFindListInMap.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindListInMap.mock</span>
}

// Set uses given function f to mock the AccountUsecase.FindListInMap method
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) Set(f func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (resItems map[uuid.UUID]*mm_usecase.AccountDTO, err error)) *AccountUsecaseMock <span class="cov0" title="0">{
        if mmFindListInMap.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("Default expectation is already set for the AccountUsecase.FindListInMap method")
        }</span>

        <span class="cov0" title="0">if len(mmFindListInMap.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("Some expectations are already set for the AccountUsecase.FindListInMap method")
        }</span>

        <span class="cov0" title="0">mmFindListInMap.mock.funcFindListInMap = f
        mmFindListInMap.mock.funcFindListInMapOrigin = minimock.CallerInfo(1)
        return mmFindListInMap.mock</span>
}

// When sets expectation for the AccountUsecase.FindListInMap which will trigger the result defined by the following
// Then helper
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) When(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) *AccountUsecaseMockFindListInMapExpectation <span class="cov0" title="0">{
        if mmFindListInMap.mock.funcFindListInMap != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("AccountUsecaseMock.FindListInMap mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;AccountUsecaseMockFindListInMapExpectation{
                mock:               mmFindListInMap.mock,
                params:             &amp;AccountUsecaseMockFindListInMapParams{ctx, listOptions, queryParams},
                expectationOrigins: AccountUsecaseMockFindListInMapExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindListInMap.expectations = append(mmFindListInMap.expectations, expectation)
        return expectation</span>
}

// Then sets up AccountUsecase.FindListInMap return parameters for the expectation previously defined by the When method
func (e *AccountUsecaseMockFindListInMapExpectation) Then(resItems map[uuid.UUID]*mm_usecase.AccountDTO, err error) *AccountUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;AccountUsecaseMockFindListInMapResults{resItems, err}
        return e.mock
}</span>

// Times sets number of times AccountUsecase.FindListInMap should be invoked
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) Times(n uint64) *mAccountUsecaseMockFindListInMap <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("Times of AccountUsecaseMock.FindListInMap mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindListInMap.expectedInvocations, n)
        mmFindListInMap.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindListInMap</span>
}

func (mmFindListInMap *mAccountUsecaseMockFindListInMap) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindListInMap.expectations) == 0 &amp;&amp; mmFindListInMap.defaultExpectation == nil &amp;&amp; mmFindListInMap.mock.funcFindListInMap == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindListInMap.mock.afterFindListInMapCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindListInMap.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindListInMap implements mm_usecase.AccountUsecase
func (mmFindListInMap *AccountUsecaseMock) FindListInMap(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (resItems map[uuid.UUID]*mm_usecase.AccountDTO, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindListInMap.beforeFindListInMapCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindListInMap.afterFindListInMapCounter, 1)

        mmFindListInMap.t.Helper()

        if mmFindListInMap.inspectFuncFindListInMap != nil </span><span class="cov0" title="0">{
                mmFindListInMap.inspectFuncFindListInMap(ctx, listOptions, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := AccountUsecaseMockFindListInMapParams{ctx, listOptions, queryParams}

        // Record call args
        mmFindListInMap.FindListInMapMock.mutex.Lock()
        mmFindListInMap.FindListInMapMock.callArgs = append(mmFindListInMap.FindListInMapMock.callArgs, &amp;mm_params)
        mmFindListInMap.FindListInMapMock.mutex.Unlock()

        for _, e := range mmFindListInMap.FindListInMapMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.resItems, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindListInMap.FindListInMapMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindListInMap.FindListInMapMock.defaultExpectation.Counter, 1)
                mm_want := mmFindListInMap.FindListInMapMock.defaultExpectation.params
                mm_want_ptrs := mmFindListInMap.FindListInMapMock.defaultExpectation.paramPtrs

                mm_got := AccountUsecaseMockFindListInMapParams{ctx, listOptions, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindListInMap.t.Errorf("AccountUsecaseMock.FindListInMap got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindListInMap.FindListInMapMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.listOptions != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) </span><span class="cov0" title="0">{
                                mmFindListInMap.t.Errorf("AccountUsecaseMock.FindListInMap got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindListInMap.FindListInMapMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindListInMap.t.Errorf("AccountUsecaseMock.FindListInMap got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindListInMap.FindListInMapMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindListInMap.t.Errorf("AccountUsecaseMock.FindListInMap got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindListInMap.FindListInMapMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindListInMap.FindListInMapMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindListInMap.t.Fatal("No results are set for the AccountUsecaseMock.FindListInMap")
                }</span>
                <span class="cov0" title="0">return (*mm_results).resItems, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindListInMap.funcFindListInMap != nil </span><span class="cov0" title="0">{
                return mmFindListInMap.funcFindListInMap(ctx, listOptions, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindListInMap.t.Fatalf("Unexpected call to AccountUsecaseMock.FindListInMap. %v %v %v", ctx, listOptions, queryParams)
        return</span>
}

// FindListInMapAfterCounter returns a count of finished AccountUsecaseMock.FindListInMap invocations
func (mmFindListInMap *AccountUsecaseMock) FindListInMapAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindListInMap.afterFindListInMapCounter)
}</span>

// FindListInMapBeforeCounter returns a count of AccountUsecaseMock.FindListInMap invocations
func (mmFindListInMap *AccountUsecaseMock) FindListInMapBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindListInMap.beforeFindListInMapCounter)
}</span>

// Calls returns a list of arguments used in each call to AccountUsecaseMock.FindListInMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) Calls() []*AccountUsecaseMockFindListInMapParams <span class="cov0" title="0">{
        mmFindListInMap.mutex.RLock()

        argCopy := make([]*AccountUsecaseMockFindListInMapParams, len(mmFindListInMap.callArgs))
        copy(argCopy, mmFindListInMap.callArgs)

        mmFindListInMap.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindListInMapDone returns true if the count of the FindListInMap invocations corresponds
// the number of defined expectations
func (m *AccountUsecaseMock) MinimockFindListInMapDone() bool <span class="cov0" title="0">{
        if m.FindListInMapMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindListInMapMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindListInMapMock.invocationsDone()</span>
}

// MinimockFindListInMapInspect logs each unmet expectation
func (m *AccountUsecaseMock) MinimockFindListInMapInspect() <span class="cov0" title="0">{
        for _, e := range m.FindListInMapMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountUsecaseMock.FindListInMap at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindListInMapCounter := mm_atomic.LoadUint64(&amp;m.afterFindListInMapCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindListInMapMock.defaultExpectation != nil &amp;&amp; afterFindListInMapCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindListInMapMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountUsecaseMock.FindListInMap at\n%s", m.FindListInMapMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to AccountUsecaseMock.FindListInMap at\n%s with params: %#v", m.FindListInMapMock.defaultExpectation.expectationOrigins.origin, *m.FindListInMapMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindListInMap != nil &amp;&amp; afterFindListInMapCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to AccountUsecaseMock.FindListInMap at\n%s", m.funcFindListInMapOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindListInMapMock.invocationsDone() &amp;&amp; afterFindListInMapCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to AccountUsecaseMock.FindListInMap at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindListInMapMock.expectedInvocations), m.FindListInMapMock.expectedInvocationsOrigin, afterFindListInMapCounter)
        }</span>
}

type mAccountUsecaseMockFindOneByEmail struct {
        optional           bool
        mock               *AccountUsecaseMock
        defaultExpectation *AccountUsecaseMockFindOneByEmailExpectation
        expectations       []*AccountUsecaseMockFindOneByEmailExpectation

        callArgs []*AccountUsecaseMockFindOneByEmailParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// AccountUsecaseMockFindOneByEmailExpectation specifies expectation struct of the AccountUsecase.FindOneByEmail
type AccountUsecaseMockFindOneByEmailExpectation struct {
        mock               *AccountUsecaseMock
        params             *AccountUsecaseMockFindOneByEmailParams
        paramPtrs          *AccountUsecaseMockFindOneByEmailParamPtrs
        expectationOrigins AccountUsecaseMockFindOneByEmailExpectationOrigins
        results            *AccountUsecaseMockFindOneByEmailResults
        returnOrigin       string
        Counter            uint64
}

// AccountUsecaseMockFindOneByEmailParams contains parameters of the AccountUsecase.FindOneByEmail
type AccountUsecaseMockFindOneByEmailParams struct {
        ctx         context.Context
        email       string
        queryParams *uctypes.QueryGetOneParams
}

// AccountUsecaseMockFindOneByEmailParamPtrs contains pointers to parameters of the AccountUsecase.FindOneByEmail
type AccountUsecaseMockFindOneByEmailParamPtrs struct {
        ctx         *context.Context
        email       *string
        queryParams **uctypes.QueryGetOneParams
}

// AccountUsecaseMockFindOneByEmailResults contains results of the AccountUsecase.FindOneByEmail
type AccountUsecaseMockFindOneByEmailResults struct {
        resAccount *mm_usecase.AccountDTO
        err        error
}

// AccountUsecaseMockFindOneByEmailOrigins contains origins of expectations of the AccountUsecase.FindOneByEmail
type AccountUsecaseMockFindOneByEmailExpectationOrigins struct {
        origin            string
        originCtx         string
        originEmail       string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) Optional() *mAccountUsecaseMockFindOneByEmail <span class="cov0" title="0">{
        mmFindOneByEmail.optional = true
        return mmFindOneByEmail
}</span>

// Expect sets up expected params for AccountUsecase.FindOneByEmail
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) Expect(ctx context.Context, email string, queryParams *uctypes.QueryGetOneParams) *mAccountUsecaseMockFindOneByEmail <span class="cov0" title="0">{
        if mmFindOneByEmail.mock.funcFindOneByEmail != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("AccountUsecaseMock.FindOneByEmail mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.defaultExpectation = &amp;AccountUsecaseMockFindOneByEmailExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("AccountUsecaseMock.FindOneByEmail mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindOneByEmail.defaultExpectation.params = &amp;AccountUsecaseMockFindOneByEmailParams{ctx, email, queryParams}
        mmFindOneByEmail.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindOneByEmail.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindOneByEmail.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindOneByEmail.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindOneByEmail.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindOneByEmail</span>
}

// ExpectCtxParam1 sets up expected param ctx for AccountUsecase.FindOneByEmail
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) ExpectCtxParam1(ctx context.Context) *mAccountUsecaseMockFindOneByEmail <span class="cov0" title="0">{
        if mmFindOneByEmail.mock.funcFindOneByEmail != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("AccountUsecaseMock.FindOneByEmail mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.defaultExpectation = &amp;AccountUsecaseMockFindOneByEmailExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("AccountUsecaseMock.FindOneByEmail mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockFindOneByEmailParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByEmail.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindOneByEmail.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindOneByEmail</span>
}

// ExpectEmailParam2 sets up expected param email for AccountUsecase.FindOneByEmail
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) ExpectEmailParam2(email string) *mAccountUsecaseMockFindOneByEmail <span class="cov0" title="0">{
        if mmFindOneByEmail.mock.funcFindOneByEmail != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("AccountUsecaseMock.FindOneByEmail mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.defaultExpectation = &amp;AccountUsecaseMockFindOneByEmailExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("AccountUsecaseMock.FindOneByEmail mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockFindOneByEmailParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByEmail.defaultExpectation.paramPtrs.email = &amp;email
        mmFindOneByEmail.defaultExpectation.expectationOrigins.originEmail = minimock.CallerInfo(1)

        return mmFindOneByEmail</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for AccountUsecase.FindOneByEmail
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetOneParams) *mAccountUsecaseMockFindOneByEmail <span class="cov0" title="0">{
        if mmFindOneByEmail.mock.funcFindOneByEmail != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("AccountUsecaseMock.FindOneByEmail mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.defaultExpectation = &amp;AccountUsecaseMockFindOneByEmailExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("AccountUsecaseMock.FindOneByEmail mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockFindOneByEmailParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByEmail.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindOneByEmail.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindOneByEmail</span>
}

// Inspect accepts an inspector function that has same arguments as the AccountUsecase.FindOneByEmail
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) Inspect(f func(ctx context.Context, email string, queryParams *uctypes.QueryGetOneParams)) *mAccountUsecaseMockFindOneByEmail <span class="cov0" title="0">{
        if mmFindOneByEmail.mock.inspectFuncFindOneByEmail != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("Inspect function is already set for AccountUsecaseMock.FindOneByEmail")
        }</span>

        <span class="cov0" title="0">mmFindOneByEmail.mock.inspectFuncFindOneByEmail = f

        return mmFindOneByEmail</span>
}

// Return sets up results that will be returned by AccountUsecase.FindOneByEmail
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) Return(resAccount *mm_usecase.AccountDTO, err error) *AccountUsecaseMock <span class="cov0" title="0">{
        if mmFindOneByEmail.mock.funcFindOneByEmail != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("AccountUsecaseMock.FindOneByEmail mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByEmail.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.defaultExpectation = &amp;AccountUsecaseMockFindOneByEmailExpectation{mock: mmFindOneByEmail.mock}
        }</span>
        <span class="cov0" title="0">mmFindOneByEmail.defaultExpectation.results = &amp;AccountUsecaseMockFindOneByEmailResults{resAccount, err}
        mmFindOneByEmail.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindOneByEmail.mock</span>
}

// Set uses given function f to mock the AccountUsecase.FindOneByEmail method
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) Set(f func(ctx context.Context, email string, queryParams *uctypes.QueryGetOneParams) (resAccount *mm_usecase.AccountDTO, err error)) *AccountUsecaseMock <span class="cov0" title="0">{
        if mmFindOneByEmail.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("Default expectation is already set for the AccountUsecase.FindOneByEmail method")
        }</span>

        <span class="cov0" title="0">if len(mmFindOneByEmail.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("Some expectations are already set for the AccountUsecase.FindOneByEmail method")
        }</span>

        <span class="cov0" title="0">mmFindOneByEmail.mock.funcFindOneByEmail = f
        mmFindOneByEmail.mock.funcFindOneByEmailOrigin = minimock.CallerInfo(1)
        return mmFindOneByEmail.mock</span>
}

// When sets expectation for the AccountUsecase.FindOneByEmail which will trigger the result defined by the following
// Then helper
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) When(ctx context.Context, email string, queryParams *uctypes.QueryGetOneParams) *AccountUsecaseMockFindOneByEmailExpectation <span class="cov0" title="0">{
        if mmFindOneByEmail.mock.funcFindOneByEmail != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("AccountUsecaseMock.FindOneByEmail mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;AccountUsecaseMockFindOneByEmailExpectation{
                mock:               mmFindOneByEmail.mock,
                params:             &amp;AccountUsecaseMockFindOneByEmailParams{ctx, email, queryParams},
                expectationOrigins: AccountUsecaseMockFindOneByEmailExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindOneByEmail.expectations = append(mmFindOneByEmail.expectations, expectation)
        return expectation</span>
}

// Then sets up AccountUsecase.FindOneByEmail return parameters for the expectation previously defined by the When method
func (e *AccountUsecaseMockFindOneByEmailExpectation) Then(resAccount *mm_usecase.AccountDTO, err error) *AccountUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;AccountUsecaseMockFindOneByEmailResults{resAccount, err}
        return e.mock
}</span>

// Times sets number of times AccountUsecase.FindOneByEmail should be invoked
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) Times(n uint64) *mAccountUsecaseMockFindOneByEmail <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindOneByEmail.mock.t.Fatalf("Times of AccountUsecaseMock.FindOneByEmail mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindOneByEmail.expectedInvocations, n)
        mmFindOneByEmail.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindOneByEmail</span>
}

func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindOneByEmail.expectations) == 0 &amp;&amp; mmFindOneByEmail.defaultExpectation == nil &amp;&amp; mmFindOneByEmail.mock.funcFindOneByEmail == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByEmail.mock.afterFindOneByEmailCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByEmail.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindOneByEmail implements mm_usecase.AccountUsecase
func (mmFindOneByEmail *AccountUsecaseMock) FindOneByEmail(ctx context.Context, email string, queryParams *uctypes.QueryGetOneParams) (resAccount *mm_usecase.AccountDTO, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindOneByEmail.beforeFindOneByEmailCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindOneByEmail.afterFindOneByEmailCounter, 1)

        mmFindOneByEmail.t.Helper()

        if mmFindOneByEmail.inspectFuncFindOneByEmail != nil </span><span class="cov0" title="0">{
                mmFindOneByEmail.inspectFuncFindOneByEmail(ctx, email, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := AccountUsecaseMockFindOneByEmailParams{ctx, email, queryParams}

        // Record call args
        mmFindOneByEmail.FindOneByEmailMock.mutex.Lock()
        mmFindOneByEmail.FindOneByEmailMock.callArgs = append(mmFindOneByEmail.FindOneByEmailMock.callArgs, &amp;mm_params)
        mmFindOneByEmail.FindOneByEmailMock.mutex.Unlock()

        for _, e := range mmFindOneByEmail.FindOneByEmailMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.resAccount, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindOneByEmail.FindOneByEmailMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.Counter, 1)
                mm_want := mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.params
                mm_want_ptrs := mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.paramPtrs

                mm_got := AccountUsecaseMockFindOneByEmailParams{ctx, email, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindOneByEmail.t.Errorf("AccountUsecaseMock.FindOneByEmail got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.email != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.email, mm_got.email) </span><span class="cov0" title="0">{
                                mmFindOneByEmail.t.Errorf("AccountUsecaseMock.FindOneByEmail got unexpected parameter email, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.expectationOrigins.originEmail, *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindOneByEmail.t.Errorf("AccountUsecaseMock.FindOneByEmail got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindOneByEmail.t.Errorf("AccountUsecaseMock.FindOneByEmail got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindOneByEmail.t.Fatal("No results are set for the AccountUsecaseMock.FindOneByEmail")
                }</span>
                <span class="cov0" title="0">return (*mm_results).resAccount, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindOneByEmail.funcFindOneByEmail != nil </span><span class="cov0" title="0">{
                return mmFindOneByEmail.funcFindOneByEmail(ctx, email, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindOneByEmail.t.Fatalf("Unexpected call to AccountUsecaseMock.FindOneByEmail. %v %v %v", ctx, email, queryParams)
        return</span>
}

// FindOneByEmailAfterCounter returns a count of finished AccountUsecaseMock.FindOneByEmail invocations
func (mmFindOneByEmail *AccountUsecaseMock) FindOneByEmailAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByEmail.afterFindOneByEmailCounter)
}</span>

// FindOneByEmailBeforeCounter returns a count of AccountUsecaseMock.FindOneByEmail invocations
func (mmFindOneByEmail *AccountUsecaseMock) FindOneByEmailBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByEmail.beforeFindOneByEmailCounter)
}</span>

// Calls returns a list of arguments used in each call to AccountUsecaseMock.FindOneByEmail.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) Calls() []*AccountUsecaseMockFindOneByEmailParams <span class="cov0" title="0">{
        mmFindOneByEmail.mutex.RLock()

        argCopy := make([]*AccountUsecaseMockFindOneByEmailParams, len(mmFindOneByEmail.callArgs))
        copy(argCopy, mmFindOneByEmail.callArgs)

        mmFindOneByEmail.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindOneByEmailDone returns true if the count of the FindOneByEmail invocations corresponds
// the number of defined expectations
func (m *AccountUsecaseMock) MinimockFindOneByEmailDone() bool <span class="cov0" title="0">{
        if m.FindOneByEmailMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindOneByEmailMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindOneByEmailMock.invocationsDone()</span>
}

// MinimockFindOneByEmailInspect logs each unmet expectation
func (m *AccountUsecaseMock) MinimockFindOneByEmailInspect() <span class="cov0" title="0">{
        for _, e := range m.FindOneByEmailMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountUsecaseMock.FindOneByEmail at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindOneByEmailCounter := mm_atomic.LoadUint64(&amp;m.afterFindOneByEmailCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindOneByEmailMock.defaultExpectation != nil &amp;&amp; afterFindOneByEmailCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindOneByEmailMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountUsecaseMock.FindOneByEmail at\n%s", m.FindOneByEmailMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to AccountUsecaseMock.FindOneByEmail at\n%s with params: %#v", m.FindOneByEmailMock.defaultExpectation.expectationOrigins.origin, *m.FindOneByEmailMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindOneByEmail != nil &amp;&amp; afterFindOneByEmailCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to AccountUsecaseMock.FindOneByEmail at\n%s", m.funcFindOneByEmailOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindOneByEmailMock.invocationsDone() &amp;&amp; afterFindOneByEmailCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to AccountUsecaseMock.FindOneByEmail at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindOneByEmailMock.expectedInvocations), m.FindOneByEmailMock.expectedInvocationsOrigin, afterFindOneByEmailCounter)
        }</span>
}

type mAccountUsecaseMockFindOneByID struct {
        optional           bool
        mock               *AccountUsecaseMock
        defaultExpectation *AccountUsecaseMockFindOneByIDExpectation
        expectations       []*AccountUsecaseMockFindOneByIDExpectation

        callArgs []*AccountUsecaseMockFindOneByIDParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// AccountUsecaseMockFindOneByIDExpectation specifies expectation struct of the AccountUsecase.FindOneByID
type AccountUsecaseMockFindOneByIDExpectation struct {
        mock               *AccountUsecaseMock
        params             *AccountUsecaseMockFindOneByIDParams
        paramPtrs          *AccountUsecaseMockFindOneByIDParamPtrs
        expectationOrigins AccountUsecaseMockFindOneByIDExpectationOrigins
        results            *AccountUsecaseMockFindOneByIDResults
        returnOrigin       string
        Counter            uint64
}

// AccountUsecaseMockFindOneByIDParams contains parameters of the AccountUsecase.FindOneByID
type AccountUsecaseMockFindOneByIDParams struct {
        ctx         context.Context
        id          uuid.UUID
        queryParams *uctypes.QueryGetOneParams
}

// AccountUsecaseMockFindOneByIDParamPtrs contains pointers to parameters of the AccountUsecase.FindOneByID
type AccountUsecaseMockFindOneByIDParamPtrs struct {
        ctx         *context.Context
        id          *uuid.UUID
        queryParams **uctypes.QueryGetOneParams
}

// AccountUsecaseMockFindOneByIDResults contains results of the AccountUsecase.FindOneByID
type AccountUsecaseMockFindOneByIDResults struct {
        resAccount *mm_usecase.AccountDTO
        err        error
}

// AccountUsecaseMockFindOneByIDOrigins contains origins of expectations of the AccountUsecase.FindOneByID
type AccountUsecaseMockFindOneByIDExpectationOrigins struct {
        origin            string
        originCtx         string
        originId          string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) Optional() *mAccountUsecaseMockFindOneByID <span class="cov0" title="0">{
        mmFindOneByID.optional = true
        return mmFindOneByID
}</span>

// Expect sets up expected params for AccountUsecase.FindOneByID
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) Expect(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *mAccountUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("AccountUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;AccountUsecaseMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("AccountUsecaseMock.FindOneByID mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.params = &amp;AccountUsecaseMockFindOneByIDParams{ctx, id, queryParams}
        mmFindOneByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindOneByID.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindOneByID.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindOneByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindOneByID.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindOneByID</span>
}

// ExpectCtxParam1 sets up expected param ctx for AccountUsecase.FindOneByID
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) ExpectCtxParam1(ctx context.Context) *mAccountUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("AccountUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;AccountUsecaseMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("AccountUsecaseMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindOneByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// ExpectIdParam2 sets up expected param id for AccountUsecase.FindOneByID
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) ExpectIdParam2(id uuid.UUID) *mAccountUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("AccountUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;AccountUsecaseMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("AccountUsecaseMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.id = &amp;id
        mmFindOneByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for AccountUsecase.FindOneByID
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetOneParams) *mAccountUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("AccountUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;AccountUsecaseMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("AccountUsecaseMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindOneByID.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// Inspect accepts an inspector function that has same arguments as the AccountUsecase.FindOneByID
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) Inspect(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)) *mAccountUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.inspectFuncFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Inspect function is already set for AccountUsecaseMock.FindOneByID")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.mock.inspectFuncFindOneByID = f

        return mmFindOneByID</span>
}

// Return sets up results that will be returned by AccountUsecase.FindOneByID
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) Return(resAccount *mm_usecase.AccountDTO, err error) *AccountUsecaseMock <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("AccountUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;AccountUsecaseMockFindOneByIDExpectation{mock: mmFindOneByID.mock}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.results = &amp;AccountUsecaseMockFindOneByIDResults{resAccount, err}
        mmFindOneByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindOneByID.mock</span>
}

// Set uses given function f to mock the AccountUsecase.FindOneByID method
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) Set(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (resAccount *mm_usecase.AccountDTO, err error)) *AccountUsecaseMock <span class="cov0" title="0">{
        if mmFindOneByID.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Default expectation is already set for the AccountUsecase.FindOneByID method")
        }</span>

        <span class="cov0" title="0">if len(mmFindOneByID.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Some expectations are already set for the AccountUsecase.FindOneByID method")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.mock.funcFindOneByID = f
        mmFindOneByID.mock.funcFindOneByIDOrigin = minimock.CallerInfo(1)
        return mmFindOneByID.mock</span>
}

// When sets expectation for the AccountUsecase.FindOneByID which will trigger the result defined by the following
// Then helper
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) When(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *AccountUsecaseMockFindOneByIDExpectation <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("AccountUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;AccountUsecaseMockFindOneByIDExpectation{
                mock:               mmFindOneByID.mock,
                params:             &amp;AccountUsecaseMockFindOneByIDParams{ctx, id, queryParams},
                expectationOrigins: AccountUsecaseMockFindOneByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindOneByID.expectations = append(mmFindOneByID.expectations, expectation)
        return expectation</span>
}

// Then sets up AccountUsecase.FindOneByID return parameters for the expectation previously defined by the When method
func (e *AccountUsecaseMockFindOneByIDExpectation) Then(resAccount *mm_usecase.AccountDTO, err error) *AccountUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;AccountUsecaseMockFindOneByIDResults{resAccount, err}
        return e.mock
}</span>

// Times sets number of times AccountUsecase.FindOneByID should be invoked
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) Times(n uint64) *mAccountUsecaseMockFindOneByID <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Times of AccountUsecaseMock.FindOneByID mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindOneByID.expectedInvocations, n)
        mmFindOneByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindOneByID</span>
}

func (mmFindOneByID *mAccountUsecaseMockFindOneByID) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindOneByID.expectations) == 0 &amp;&amp; mmFindOneByID.defaultExpectation == nil &amp;&amp; mmFindOneByID.mock.funcFindOneByID == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByID.mock.afterFindOneByIDCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByID.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindOneByID implements mm_usecase.AccountUsecase
func (mmFindOneByID *AccountUsecaseMock) FindOneByID(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (resAccount *mm_usecase.AccountDTO, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindOneByID.beforeFindOneByIDCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindOneByID.afterFindOneByIDCounter, 1)

        mmFindOneByID.t.Helper()

        if mmFindOneByID.inspectFuncFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.inspectFuncFindOneByID(ctx, id, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := AccountUsecaseMockFindOneByIDParams{ctx, id, queryParams}

        // Record call args
        mmFindOneByID.FindOneByIDMock.mutex.Lock()
        mmFindOneByID.FindOneByIDMock.callArgs = append(mmFindOneByID.FindOneByIDMock.callArgs, &amp;mm_params)
        mmFindOneByID.FindOneByIDMock.mutex.Unlock()

        for _, e := range mmFindOneByID.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.resAccount, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindOneByID.FindOneByIDMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindOneByID.FindOneByIDMock.defaultExpectation.Counter, 1)
                mm_want := mmFindOneByID.FindOneByIDMock.defaultExpectation.params
                mm_want_ptrs := mmFindOneByID.FindOneByIDMock.defaultExpectation.paramPtrs

                mm_got := AccountUsecaseMockFindOneByIDParams{ctx, id, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("AccountUsecaseMock.FindOneByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("AccountUsecaseMock.FindOneByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("AccountUsecaseMock.FindOneByID got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindOneByID.t.Errorf("AccountUsecaseMock.FindOneByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindOneByID.FindOneByIDMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindOneByID.t.Fatal("No results are set for the AccountUsecaseMock.FindOneByID")
                }</span>
                <span class="cov0" title="0">return (*mm_results).resAccount, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindOneByID.funcFindOneByID != nil </span><span class="cov0" title="0">{
                return mmFindOneByID.funcFindOneByID(ctx, id, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindOneByID.t.Fatalf("Unexpected call to AccountUsecaseMock.FindOneByID. %v %v %v", ctx, id, queryParams)
        return</span>
}

// FindOneByIDAfterCounter returns a count of finished AccountUsecaseMock.FindOneByID invocations
func (mmFindOneByID *AccountUsecaseMock) FindOneByIDAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByID.afterFindOneByIDCounter)
}</span>

// FindOneByIDBeforeCounter returns a count of AccountUsecaseMock.FindOneByID invocations
func (mmFindOneByID *AccountUsecaseMock) FindOneByIDBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByID.beforeFindOneByIDCounter)
}</span>

// Calls returns a list of arguments used in each call to AccountUsecaseMock.FindOneByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) Calls() []*AccountUsecaseMockFindOneByIDParams <span class="cov0" title="0">{
        mmFindOneByID.mutex.RLock()

        argCopy := make([]*AccountUsecaseMockFindOneByIDParams, len(mmFindOneByID.callArgs))
        copy(argCopy, mmFindOneByID.callArgs)

        mmFindOneByID.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindOneByIDDone returns true if the count of the FindOneByID invocations corresponds
// the number of defined expectations
func (m *AccountUsecaseMock) MinimockFindOneByIDDone() bool <span class="cov0" title="0">{
        if m.FindOneByIDMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindOneByIDMock.invocationsDone()</span>
}

// MinimockFindOneByIDInspect logs each unmet expectation
func (m *AccountUsecaseMock) MinimockFindOneByIDInspect() <span class="cov0" title="0">{
        for _, e := range m.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountUsecaseMock.FindOneByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindOneByIDCounter := mm_atomic.LoadUint64(&amp;m.afterFindOneByIDCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindOneByIDMock.defaultExpectation != nil &amp;&amp; afterFindOneByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindOneByIDMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountUsecaseMock.FindOneByID at\n%s", m.FindOneByIDMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to AccountUsecaseMock.FindOneByID at\n%s with params: %#v", m.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *m.FindOneByIDMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindOneByID != nil &amp;&amp; afterFindOneByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to AccountUsecaseMock.FindOneByID at\n%s", m.funcFindOneByIDOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindOneByIDMock.invocationsDone() &amp;&amp; afterFindOneByIDCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to AccountUsecaseMock.FindOneByID at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindOneByIDMock.expectedInvocations), m.FindOneByIDMock.expectedInvocationsOrigin, afterFindOneByIDCounter)
        }</span>
}

type mAccountUsecaseMockFindPagedList struct {
        optional           bool
        mock               *AccountUsecaseMock
        defaultExpectation *AccountUsecaseMockFindPagedListExpectation
        expectations       []*AccountUsecaseMockFindPagedListExpectation

        callArgs []*AccountUsecaseMockFindPagedListParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// AccountUsecaseMockFindPagedListExpectation specifies expectation struct of the AccountUsecase.FindPagedList
type AccountUsecaseMockFindPagedListExpectation struct {
        mock               *AccountUsecaseMock
        params             *AccountUsecaseMockFindPagedListParams
        paramPtrs          *AccountUsecaseMockFindPagedListParamPtrs
        expectationOrigins AccountUsecaseMockFindPagedListExpectationOrigins
        results            *AccountUsecaseMockFindPagedListResults
        returnOrigin       string
        Counter            uint64
}

// AccountUsecaseMockFindPagedListParams contains parameters of the AccountUsecase.FindPagedList
type AccountUsecaseMockFindPagedListParams struct {
        ctx         context.Context
        listOptions *mm_usecase.AccountListOptions
        queryParams *uctypes.QueryGetListParams
}

// AccountUsecaseMockFindPagedListParamPtrs contains pointers to parameters of the AccountUsecase.FindPagedList
type AccountUsecaseMockFindPagedListParamPtrs struct {
        ctx         *context.Context
        listOptions **mm_usecase.AccountListOptions
        queryParams **uctypes.QueryGetListParams
}

// AccountUsecaseMockFindPagedListResults contains results of the AccountUsecase.FindPagedList
type AccountUsecaseMockFindPagedListResults struct {
        resItems []*mm_usecase.AccountDTO
        total    uint64
        err      error
}

// AccountUsecaseMockFindPagedListOrigins contains origins of expectations of the AccountUsecase.FindPagedList
type AccountUsecaseMockFindPagedListExpectationOrigins struct {
        origin            string
        originCtx         string
        originListOptions string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) Optional() *mAccountUsecaseMockFindPagedList <span class="cov0" title="0">{
        mmFindPagedList.optional = true
        return mmFindPagedList
}</span>

// Expect sets up expected params for AccountUsecase.FindPagedList
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) Expect(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) *mAccountUsecaseMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("AccountUsecaseMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;AccountUsecaseMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("AccountUsecaseMock.FindPagedList mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.params = &amp;AccountUsecaseMockFindPagedListParams{ctx, listOptions, queryParams}
        mmFindPagedList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindPagedList.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindPagedList.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindPagedList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindPagedList.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindPagedList</span>
}

// ExpectCtxParam1 sets up expected param ctx for AccountUsecase.FindPagedList
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) ExpectCtxParam1(ctx context.Context) *mAccountUsecaseMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("AccountUsecaseMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;AccountUsecaseMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("AccountUsecaseMock.FindPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockFindPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindPagedList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindPagedList</span>
}

// ExpectListOptionsParam2 sets up expected param listOptions for AccountUsecase.FindPagedList
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) ExpectListOptionsParam2(listOptions *mm_usecase.AccountListOptions) *mAccountUsecaseMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("AccountUsecaseMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;AccountUsecaseMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("AccountUsecaseMock.FindPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockFindPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.paramPtrs.listOptions = &amp;listOptions
        mmFindPagedList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

        return mmFindPagedList</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for AccountUsecase.FindPagedList
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mAccountUsecaseMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("AccountUsecaseMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;AccountUsecaseMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("AccountUsecaseMock.FindPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockFindPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindPagedList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindPagedList</span>
}

// Inspect accepts an inspector function that has same arguments as the AccountUsecase.FindPagedList
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams)) *mAccountUsecaseMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.inspectFuncFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Inspect function is already set for AccountUsecaseMock.FindPagedList")
        }</span>

        <span class="cov0" title="0">mmFindPagedList.mock.inspectFuncFindPagedList = f

        return mmFindPagedList</span>
}

// Return sets up results that will be returned by AccountUsecase.FindPagedList
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) Return(resItems []*mm_usecase.AccountDTO, total uint64, err error) *AccountUsecaseMock <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("AccountUsecaseMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;AccountUsecaseMockFindPagedListExpectation{mock: mmFindPagedList.mock}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.results = &amp;AccountUsecaseMockFindPagedListResults{resItems, total, err}
        mmFindPagedList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindPagedList.mock</span>
}

// Set uses given function f to mock the AccountUsecase.FindPagedList method
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) Set(f func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.AccountDTO, total uint64, err error)) *AccountUsecaseMock <span class="cov0" title="0">{
        if mmFindPagedList.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Default expectation is already set for the AccountUsecase.FindPagedList method")
        }</span>

        <span class="cov0" title="0">if len(mmFindPagedList.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Some expectations are already set for the AccountUsecase.FindPagedList method")
        }</span>

        <span class="cov0" title="0">mmFindPagedList.mock.funcFindPagedList = f
        mmFindPagedList.mock.funcFindPagedListOrigin = minimock.CallerInfo(1)
        return mmFindPagedList.mock</span>
}

// When sets expectation for the AccountUsecase.FindPagedList which will trigger the result defined by the following
// Then helper
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) When(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) *AccountUsecaseMockFindPagedListExpectation <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("AccountUsecaseMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;AccountUsecaseMockFindPagedListExpectation{
                mock:               mmFindPagedList.mock,
                params:             &amp;AccountUsecaseMockFindPagedListParams{ctx, listOptions, queryParams},
                expectationOrigins: AccountUsecaseMockFindPagedListExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindPagedList.expectations = append(mmFindPagedList.expectations, expectation)
        return expectation</span>
}

// Then sets up AccountUsecase.FindPagedList return parameters for the expectation previously defined by the When method
func (e *AccountUsecaseMockFindPagedListExpectation) Then(resItems []*mm_usecase.AccountDTO, total uint64, err error) *AccountUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;AccountUsecaseMockFindPagedListResults{resItems, total, err}
        return e.mock
}</span>

// Times sets number of times AccountUsecase.FindPagedList should be invoked
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) Times(n uint64) *mAccountUsecaseMockFindPagedList <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Times of AccountUsecaseMock.FindPagedList mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindPagedList.expectedInvocations, n)
        mmFindPagedList.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindPagedList</span>
}

func (mmFindPagedList *mAccountUsecaseMockFindPagedList) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindPagedList.expectations) == 0 &amp;&amp; mmFindPagedList.defaultExpectation == nil &amp;&amp; mmFindPagedList.mock.funcFindPagedList == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindPagedList.mock.afterFindPagedListCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindPagedList.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindPagedList implements mm_usecase.AccountUsecase
func (mmFindPagedList *AccountUsecaseMock) FindPagedList(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.AccountDTO, total uint64, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindPagedList.beforeFindPagedListCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindPagedList.afterFindPagedListCounter, 1)

        mmFindPagedList.t.Helper()

        if mmFindPagedList.inspectFuncFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.inspectFuncFindPagedList(ctx, listOptions, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := AccountUsecaseMockFindPagedListParams{ctx, listOptions, queryParams}

        // Record call args
        mmFindPagedList.FindPagedListMock.mutex.Lock()
        mmFindPagedList.FindPagedListMock.callArgs = append(mmFindPagedList.FindPagedListMock.callArgs, &amp;mm_params)
        mmFindPagedList.FindPagedListMock.mutex.Unlock()

        for _, e := range mmFindPagedList.FindPagedListMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.resItems, e.results.total, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindPagedList.FindPagedListMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindPagedList.FindPagedListMock.defaultExpectation.Counter, 1)
                mm_want := mmFindPagedList.FindPagedListMock.defaultExpectation.params
                mm_want_ptrs := mmFindPagedList.FindPagedListMock.defaultExpectation.paramPtrs

                mm_got := AccountUsecaseMockFindPagedListParams{ctx, listOptions, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindPagedList.t.Errorf("AccountUsecaseMock.FindPagedList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.listOptions != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) </span><span class="cov0" title="0">{
                                mmFindPagedList.t.Errorf("AccountUsecaseMock.FindPagedList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindPagedList.t.Errorf("AccountUsecaseMock.FindPagedList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindPagedList.t.Errorf("AccountUsecaseMock.FindPagedList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindPagedList.FindPagedListMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindPagedList.t.Fatal("No results are set for the AccountUsecaseMock.FindPagedList")
                }</span>
                <span class="cov0" title="0">return (*mm_results).resItems, (*mm_results).total, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindPagedList.funcFindPagedList != nil </span><span class="cov0" title="0">{
                return mmFindPagedList.funcFindPagedList(ctx, listOptions, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindPagedList.t.Fatalf("Unexpected call to AccountUsecaseMock.FindPagedList. %v %v %v", ctx, listOptions, queryParams)
        return</span>
}

// FindPagedListAfterCounter returns a count of finished AccountUsecaseMock.FindPagedList invocations
func (mmFindPagedList *AccountUsecaseMock) FindPagedListAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindPagedList.afterFindPagedListCounter)
}</span>

// FindPagedListBeforeCounter returns a count of AccountUsecaseMock.FindPagedList invocations
func (mmFindPagedList *AccountUsecaseMock) FindPagedListBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindPagedList.beforeFindPagedListCounter)
}</span>

// Calls returns a list of arguments used in each call to AccountUsecaseMock.FindPagedList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) Calls() []*AccountUsecaseMockFindPagedListParams <span class="cov0" title="0">{
        mmFindPagedList.mutex.RLock()

        argCopy := make([]*AccountUsecaseMockFindPagedListParams, len(mmFindPagedList.callArgs))
        copy(argCopy, mmFindPagedList.callArgs)

        mmFindPagedList.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindPagedListDone returns true if the count of the FindPagedList invocations corresponds
// the number of defined expectations
func (m *AccountUsecaseMock) MinimockFindPagedListDone() bool <span class="cov0" title="0">{
        if m.FindPagedListMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindPagedListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindPagedListMock.invocationsDone()</span>
}

// MinimockFindPagedListInspect logs each unmet expectation
func (m *AccountUsecaseMock) MinimockFindPagedListInspect() <span class="cov0" title="0">{
        for _, e := range m.FindPagedListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountUsecaseMock.FindPagedList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindPagedListCounter := mm_atomic.LoadUint64(&amp;m.afterFindPagedListCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindPagedListMock.defaultExpectation != nil &amp;&amp; afterFindPagedListCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindPagedListMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountUsecaseMock.FindPagedList at\n%s", m.FindPagedListMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to AccountUsecaseMock.FindPagedList at\n%s with params: %#v", m.FindPagedListMock.defaultExpectation.expectationOrigins.origin, *m.FindPagedListMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindPagedList != nil &amp;&amp; afterFindPagedListCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to AccountUsecaseMock.FindPagedList at\n%s", m.funcFindPagedListOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindPagedListMock.invocationsDone() &amp;&amp; afterFindPagedListCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to AccountUsecaseMock.FindPagedList at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindPagedListMock.expectedInvocations), m.FindPagedListMock.expectedInvocationsOrigin, afterFindPagedListCounter)
        }</span>
}

type mAccountUsecaseMockPatchAccountByDTO struct {
        optional           bool
        mock               *AccountUsecaseMock
        defaultExpectation *AccountUsecaseMockPatchAccountByDTOExpectation
        expectations       []*AccountUsecaseMockPatchAccountByDTOExpectation

        callArgs []*AccountUsecaseMockPatchAccountByDTOParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// AccountUsecaseMockPatchAccountByDTOExpectation specifies expectation struct of the AccountUsecase.PatchAccountByDTO
type AccountUsecaseMockPatchAccountByDTOExpectation struct {
        mock               *AccountUsecaseMock
        params             *AccountUsecaseMockPatchAccountByDTOParams
        paramPtrs          *AccountUsecaseMockPatchAccountByDTOParamPtrs
        expectationOrigins AccountUsecaseMockPatchAccountByDTOExpectationOrigins
        results            *AccountUsecaseMockPatchAccountByDTOResults
        returnOrigin       string
        Counter            uint64
}

// AccountUsecaseMockPatchAccountByDTOParams contains parameters of the AccountUsecase.PatchAccountByDTO
type AccountUsecaseMockPatchAccountByDTOParams struct {
        ctx              context.Context
        id               uuid.UUID
        in               mm_usecase.PatchAccountDataInput
        skipVersionCheck bool
}

// AccountUsecaseMockPatchAccountByDTOParamPtrs contains pointers to parameters of the AccountUsecase.PatchAccountByDTO
type AccountUsecaseMockPatchAccountByDTOParamPtrs struct {
        ctx              *context.Context
        id               *uuid.UUID
        in               *mm_usecase.PatchAccountDataInput
        skipVersionCheck *bool
}

// AccountUsecaseMockPatchAccountByDTOResults contains results of the AccountUsecase.PatchAccountByDTO
type AccountUsecaseMockPatchAccountByDTOResults struct {
        err error
}

// AccountUsecaseMockPatchAccountByDTOOrigins contains origins of expectations of the AccountUsecase.PatchAccountByDTO
type AccountUsecaseMockPatchAccountByDTOExpectationOrigins struct {
        origin                 string
        originCtx              string
        originId               string
        originIn               string
        originSkipVersionCheck string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) Optional() *mAccountUsecaseMockPatchAccountByDTO <span class="cov0" title="0">{
        mmPatchAccountByDTO.optional = true
        return mmPatchAccountByDTO
}</span>

// Expect sets up expected params for AccountUsecase.PatchAccountByDTO
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) Expect(ctx context.Context, id uuid.UUID, in mm_usecase.PatchAccountDataInput, skipVersionCheck bool) *mAccountUsecaseMockPatchAccountByDTO <span class="cov0" title="0">{
        if mmPatchAccountByDTO.mock.funcPatchAccountByDTO != nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmPatchAccountByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.defaultExpectation = &amp;AccountUsecaseMockPatchAccountByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmPatchAccountByDTO.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmPatchAccountByDTO.defaultExpectation.params = &amp;AccountUsecaseMockPatchAccountByDTOParams{ctx, id, in, skipVersionCheck}
        mmPatchAccountByDTO.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmPatchAccountByDTO.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmPatchAccountByDTO.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmPatchAccountByDTO.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPatchAccountByDTO.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmPatchAccountByDTO</span>
}

// ExpectCtxParam1 sets up expected param ctx for AccountUsecase.PatchAccountByDTO
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) ExpectCtxParam1(ctx context.Context) *mAccountUsecaseMockPatchAccountByDTO <span class="cov0" title="0">{
        if mmPatchAccountByDTO.mock.funcPatchAccountByDTO != nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmPatchAccountByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.defaultExpectation = &amp;AccountUsecaseMockPatchAccountByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmPatchAccountByDTO.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmPatchAccountByDTO.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockPatchAccountByDTOParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmPatchAccountByDTO.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmPatchAccountByDTO.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmPatchAccountByDTO</span>
}

// ExpectIdParam2 sets up expected param id for AccountUsecase.PatchAccountByDTO
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) ExpectIdParam2(id uuid.UUID) *mAccountUsecaseMockPatchAccountByDTO <span class="cov0" title="0">{
        if mmPatchAccountByDTO.mock.funcPatchAccountByDTO != nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmPatchAccountByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.defaultExpectation = &amp;AccountUsecaseMockPatchAccountByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmPatchAccountByDTO.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmPatchAccountByDTO.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockPatchAccountByDTOParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmPatchAccountByDTO.defaultExpectation.paramPtrs.id = &amp;id
        mmPatchAccountByDTO.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmPatchAccountByDTO</span>
}

// ExpectInParam3 sets up expected param in for AccountUsecase.PatchAccountByDTO
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) ExpectInParam3(in mm_usecase.PatchAccountDataInput) *mAccountUsecaseMockPatchAccountByDTO <span class="cov0" title="0">{
        if mmPatchAccountByDTO.mock.funcPatchAccountByDTO != nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmPatchAccountByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.defaultExpectation = &amp;AccountUsecaseMockPatchAccountByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmPatchAccountByDTO.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmPatchAccountByDTO.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockPatchAccountByDTOParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmPatchAccountByDTO.defaultExpectation.paramPtrs.in = &amp;in
        mmPatchAccountByDTO.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

        return mmPatchAccountByDTO</span>
}

// ExpectSkipVersionCheckParam4 sets up expected param skipVersionCheck for AccountUsecase.PatchAccountByDTO
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) ExpectSkipVersionCheckParam4(skipVersionCheck bool) *mAccountUsecaseMockPatchAccountByDTO <span class="cov0" title="0">{
        if mmPatchAccountByDTO.mock.funcPatchAccountByDTO != nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmPatchAccountByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.defaultExpectation = &amp;AccountUsecaseMockPatchAccountByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmPatchAccountByDTO.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmPatchAccountByDTO.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockPatchAccountByDTOParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmPatchAccountByDTO.defaultExpectation.paramPtrs.skipVersionCheck = &amp;skipVersionCheck
        mmPatchAccountByDTO.defaultExpectation.expectationOrigins.originSkipVersionCheck = minimock.CallerInfo(1)

        return mmPatchAccountByDTO</span>
}

// Inspect accepts an inspector function that has same arguments as the AccountUsecase.PatchAccountByDTO
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) Inspect(f func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchAccountDataInput, skipVersionCheck bool)) *mAccountUsecaseMockPatchAccountByDTO <span class="cov0" title="0">{
        if mmPatchAccountByDTO.mock.inspectFuncPatchAccountByDTO != nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.mock.t.Fatalf("Inspect function is already set for AccountUsecaseMock.PatchAccountByDTO")
        }</span>

        <span class="cov0" title="0">mmPatchAccountByDTO.mock.inspectFuncPatchAccountByDTO = f

        return mmPatchAccountByDTO</span>
}

// Return sets up results that will be returned by AccountUsecase.PatchAccountByDTO
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) Return(err error) *AccountUsecaseMock <span class="cov0" title="0">{
        if mmPatchAccountByDTO.mock.funcPatchAccountByDTO != nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmPatchAccountByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.defaultExpectation = &amp;AccountUsecaseMockPatchAccountByDTOExpectation{mock: mmPatchAccountByDTO.mock}
        }</span>
        <span class="cov0" title="0">mmPatchAccountByDTO.defaultExpectation.results = &amp;AccountUsecaseMockPatchAccountByDTOResults{err}
        mmPatchAccountByDTO.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmPatchAccountByDTO.mock</span>
}

// Set uses given function f to mock the AccountUsecase.PatchAccountByDTO method
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) Set(f func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchAccountDataInput, skipVersionCheck bool) (err error)) *AccountUsecaseMock <span class="cov0" title="0">{
        if mmPatchAccountByDTO.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.mock.t.Fatalf("Default expectation is already set for the AccountUsecase.PatchAccountByDTO method")
        }</span>

        <span class="cov0" title="0">if len(mmPatchAccountByDTO.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.mock.t.Fatalf("Some expectations are already set for the AccountUsecase.PatchAccountByDTO method")
        }</span>

        <span class="cov0" title="0">mmPatchAccountByDTO.mock.funcPatchAccountByDTO = f
        mmPatchAccountByDTO.mock.funcPatchAccountByDTOOrigin = minimock.CallerInfo(1)
        return mmPatchAccountByDTO.mock</span>
}

// When sets expectation for the AccountUsecase.PatchAccountByDTO which will trigger the result defined by the following
// Then helper
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) When(ctx context.Context, id uuid.UUID, in mm_usecase.PatchAccountDataInput, skipVersionCheck bool) *AccountUsecaseMockPatchAccountByDTOExpectation <span class="cov0" title="0">{
        if mmPatchAccountByDTO.mock.funcPatchAccountByDTO != nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;AccountUsecaseMockPatchAccountByDTOExpectation{
                mock:               mmPatchAccountByDTO.mock,
                params:             &amp;AccountUsecaseMockPatchAccountByDTOParams{ctx, id, in, skipVersionCheck},
                expectationOrigins: AccountUsecaseMockPatchAccountByDTOExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmPatchAccountByDTO.expectations = append(mmPatchAccountByDTO.expectations, expectation)
        return expectation</span>
}

// Then sets up AccountUsecase.PatchAccountByDTO return parameters for the expectation previously defined by the When method
func (e *AccountUsecaseMockPatchAccountByDTOExpectation) Then(err error) *AccountUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;AccountUsecaseMockPatchAccountByDTOResults{err}
        return e.mock
}</span>

// Times sets number of times AccountUsecase.PatchAccountByDTO should be invoked
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) Times(n uint64) *mAccountUsecaseMockPatchAccountByDTO <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.mock.t.Fatalf("Times of AccountUsecaseMock.PatchAccountByDTO mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmPatchAccountByDTO.expectedInvocations, n)
        mmPatchAccountByDTO.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmPatchAccountByDTO</span>
}

func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmPatchAccountByDTO.expectations) == 0 &amp;&amp; mmPatchAccountByDTO.defaultExpectation == nil &amp;&amp; mmPatchAccountByDTO.mock.funcPatchAccountByDTO == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmPatchAccountByDTO.mock.afterPatchAccountByDTOCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmPatchAccountByDTO.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// PatchAccountByDTO implements mm_usecase.AccountUsecase
func (mmPatchAccountByDTO *AccountUsecaseMock) PatchAccountByDTO(ctx context.Context, id uuid.UUID, in mm_usecase.PatchAccountDataInput, skipVersionCheck bool) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmPatchAccountByDTO.beforePatchAccountByDTOCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmPatchAccountByDTO.afterPatchAccountByDTOCounter, 1)

        mmPatchAccountByDTO.t.Helper()

        if mmPatchAccountByDTO.inspectFuncPatchAccountByDTO != nil </span><span class="cov0" title="0">{
                mmPatchAccountByDTO.inspectFuncPatchAccountByDTO(ctx, id, in, skipVersionCheck)
        }</span>

        <span class="cov0" title="0">mm_params := AccountUsecaseMockPatchAccountByDTOParams{ctx, id, in, skipVersionCheck}

        // Record call args
        mmPatchAccountByDTO.PatchAccountByDTOMock.mutex.Lock()
        mmPatchAccountByDTO.PatchAccountByDTOMock.callArgs = append(mmPatchAccountByDTO.PatchAccountByDTOMock.callArgs, &amp;mm_params)
        mmPatchAccountByDTO.PatchAccountByDTOMock.mutex.Unlock()

        for _, e := range mmPatchAccountByDTO.PatchAccountByDTOMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmPatchAccountByDTO.PatchAccountByDTOMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmPatchAccountByDTO.PatchAccountByDTOMock.defaultExpectation.Counter, 1)
                mm_want := mmPatchAccountByDTO.PatchAccountByDTOMock.defaultExpectation.params
                mm_want_ptrs := mmPatchAccountByDTO.PatchAccountByDTOMock.defaultExpectation.paramPtrs

                mm_got := AccountUsecaseMockPatchAccountByDTOParams{ctx, id, in, skipVersionCheck}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmPatchAccountByDTO.t.Errorf("AccountUsecaseMock.PatchAccountByDTO got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmPatchAccountByDTO.PatchAccountByDTOMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmPatchAccountByDTO.t.Errorf("AccountUsecaseMock.PatchAccountByDTO got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmPatchAccountByDTO.PatchAccountByDTOMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.in != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.in, mm_got.in) </span><span class="cov0" title="0">{
                                mmPatchAccountByDTO.t.Errorf("AccountUsecaseMock.PatchAccountByDTO got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmPatchAccountByDTO.PatchAccountByDTOMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.skipVersionCheck != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.skipVersionCheck, mm_got.skipVersionCheck) </span><span class="cov0" title="0">{
                                mmPatchAccountByDTO.t.Errorf("AccountUsecaseMock.PatchAccountByDTO got unexpected parameter skipVersionCheck, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmPatchAccountByDTO.PatchAccountByDTOMock.defaultExpectation.expectationOrigins.originSkipVersionCheck, *mm_want_ptrs.skipVersionCheck, mm_got.skipVersionCheck, minimock.Diff(*mm_want_ptrs.skipVersionCheck, mm_got.skipVersionCheck))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmPatchAccountByDTO.t.Errorf("AccountUsecaseMock.PatchAccountByDTO got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmPatchAccountByDTO.PatchAccountByDTOMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmPatchAccountByDTO.PatchAccountByDTOMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmPatchAccountByDTO.t.Fatal("No results are set for the AccountUsecaseMock.PatchAccountByDTO")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmPatchAccountByDTO.funcPatchAccountByDTO != nil </span><span class="cov0" title="0">{
                return mmPatchAccountByDTO.funcPatchAccountByDTO(ctx, id, in, skipVersionCheck)
        }</span>
        <span class="cov0" title="0">mmPatchAccountByDTO.t.Fatalf("Unexpected call to AccountUsecaseMock.PatchAccountByDTO. %v %v %v %v", ctx, id, in, skipVersionCheck)
        return</span>
}

// PatchAccountByDTOAfterCounter returns a count of finished AccountUsecaseMock.PatchAccountByDTO invocations
func (mmPatchAccountByDTO *AccountUsecaseMock) PatchAccountByDTOAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmPatchAccountByDTO.afterPatchAccountByDTOCounter)
}</span>

// PatchAccountByDTOBeforeCounter returns a count of AccountUsecaseMock.PatchAccountByDTO invocations
func (mmPatchAccountByDTO *AccountUsecaseMock) PatchAccountByDTOBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmPatchAccountByDTO.beforePatchAccountByDTOCounter)
}</span>

// Calls returns a list of arguments used in each call to AccountUsecaseMock.PatchAccountByDTO.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) Calls() []*AccountUsecaseMockPatchAccountByDTOParams <span class="cov0" title="0">{
        mmPatchAccountByDTO.mutex.RLock()

        argCopy := make([]*AccountUsecaseMockPatchAccountByDTOParams, len(mmPatchAccountByDTO.callArgs))
        copy(argCopy, mmPatchAccountByDTO.callArgs)

        mmPatchAccountByDTO.mutex.RUnlock()

        return argCopy
}</span>

// MinimockPatchAccountByDTODone returns true if the count of the PatchAccountByDTO invocations corresponds
// the number of defined expectations
func (m *AccountUsecaseMock) MinimockPatchAccountByDTODone() bool <span class="cov0" title="0">{
        if m.PatchAccountByDTOMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.PatchAccountByDTOMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.PatchAccountByDTOMock.invocationsDone()</span>
}

// MinimockPatchAccountByDTOInspect logs each unmet expectation
func (m *AccountUsecaseMock) MinimockPatchAccountByDTOInspect() <span class="cov0" title="0">{
        for _, e := range m.PatchAccountByDTOMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountUsecaseMock.PatchAccountByDTO at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterPatchAccountByDTOCounter := mm_atomic.LoadUint64(&amp;m.afterPatchAccountByDTOCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.PatchAccountByDTOMock.defaultExpectation != nil &amp;&amp; afterPatchAccountByDTOCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.PatchAccountByDTOMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountUsecaseMock.PatchAccountByDTO at\n%s", m.PatchAccountByDTOMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to AccountUsecaseMock.PatchAccountByDTO at\n%s with params: %#v", m.PatchAccountByDTOMock.defaultExpectation.expectationOrigins.origin, *m.PatchAccountByDTOMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcPatchAccountByDTO != nil &amp;&amp; afterPatchAccountByDTOCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to AccountUsecaseMock.PatchAccountByDTO at\n%s", m.funcPatchAccountByDTOOrigin)
        }</span>

        <span class="cov0" title="0">if !m.PatchAccountByDTOMock.invocationsDone() &amp;&amp; afterPatchAccountByDTOCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to AccountUsecaseMock.PatchAccountByDTO at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.PatchAccountByDTOMock.expectedInvocations), m.PatchAccountByDTOMock.expectedInvocationsOrigin, afterPatchAccountByDTOCounter)
        }</span>
}

type mAccountUsecaseMockUpdateAccount struct {
        optional           bool
        mock               *AccountUsecaseMock
        defaultExpectation *AccountUsecaseMockUpdateAccountExpectation
        expectations       []*AccountUsecaseMockUpdateAccountExpectation

        callArgs []*AccountUsecaseMockUpdateAccountParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// AccountUsecaseMockUpdateAccountExpectation specifies expectation struct of the AccountUsecase.UpdateAccount
type AccountUsecaseMockUpdateAccountExpectation struct {
        mock               *AccountUsecaseMock
        params             *AccountUsecaseMockUpdateAccountParams
        paramPtrs          *AccountUsecaseMockUpdateAccountParamPtrs
        expectationOrigins AccountUsecaseMockUpdateAccountExpectationOrigins
        results            *AccountUsecaseMockUpdateAccountResults
        returnOrigin       string
        Counter            uint64
}

// AccountUsecaseMockUpdateAccountParams contains parameters of the AccountUsecase.UpdateAccount
type AccountUsecaseMockUpdateAccountParams struct {
        ctx  context.Context
        item *entity.Account
}

// AccountUsecaseMockUpdateAccountParamPtrs contains pointers to parameters of the AccountUsecase.UpdateAccount
type AccountUsecaseMockUpdateAccountParamPtrs struct {
        ctx  *context.Context
        item **entity.Account
}

// AccountUsecaseMockUpdateAccountResults contains results of the AccountUsecase.UpdateAccount
type AccountUsecaseMockUpdateAccountResults struct {
        err error
}

// AccountUsecaseMockUpdateAccountOrigins contains origins of expectations of the AccountUsecase.UpdateAccount
type AccountUsecaseMockUpdateAccountExpectationOrigins struct {
        origin     string
        originCtx  string
        originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) Optional() *mAccountUsecaseMockUpdateAccount <span class="cov0" title="0">{
        mmUpdateAccount.optional = true
        return mmUpdateAccount
}</span>

// Expect sets up expected params for AccountUsecase.UpdateAccount
func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) Expect(ctx context.Context, item *entity.Account) *mAccountUsecaseMockUpdateAccount <span class="cov0" title="0">{
        if mmUpdateAccount.mock.funcUpdateAccount != nil </span><span class="cov0" title="0">{
                mmUpdateAccount.mock.t.Fatalf("AccountUsecaseMock.UpdateAccount mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdateAccount.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdateAccount.defaultExpectation = &amp;AccountUsecaseMockUpdateAccountExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdateAccount.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmUpdateAccount.mock.t.Fatalf("AccountUsecaseMock.UpdateAccount mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmUpdateAccount.defaultExpectation.params = &amp;AccountUsecaseMockUpdateAccountParams{ctx, item}
        mmUpdateAccount.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmUpdateAccount.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmUpdateAccount.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmUpdateAccount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateAccount.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmUpdateAccount</span>
}

// ExpectCtxParam1 sets up expected param ctx for AccountUsecase.UpdateAccount
func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) ExpectCtxParam1(ctx context.Context) *mAccountUsecaseMockUpdateAccount <span class="cov0" title="0">{
        if mmUpdateAccount.mock.funcUpdateAccount != nil </span><span class="cov0" title="0">{
                mmUpdateAccount.mock.t.Fatalf("AccountUsecaseMock.UpdateAccount mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdateAccount.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdateAccount.defaultExpectation = &amp;AccountUsecaseMockUpdateAccountExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdateAccount.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdateAccount.mock.t.Fatalf("AccountUsecaseMock.UpdateAccount mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdateAccount.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdateAccount.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockUpdateAccountParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdateAccount.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmUpdateAccount.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmUpdateAccount</span>
}

// ExpectItemParam2 sets up expected param item for AccountUsecase.UpdateAccount
func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) ExpectItemParam2(item *entity.Account) *mAccountUsecaseMockUpdateAccount <span class="cov0" title="0">{
        if mmUpdateAccount.mock.funcUpdateAccount != nil </span><span class="cov0" title="0">{
                mmUpdateAccount.mock.t.Fatalf("AccountUsecaseMock.UpdateAccount mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdateAccount.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdateAccount.defaultExpectation = &amp;AccountUsecaseMockUpdateAccountExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdateAccount.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdateAccount.mock.t.Fatalf("AccountUsecaseMock.UpdateAccount mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdateAccount.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdateAccount.defaultExpectation.paramPtrs = &amp;AccountUsecaseMockUpdateAccountParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdateAccount.defaultExpectation.paramPtrs.item = &amp;item
        mmUpdateAccount.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

        return mmUpdateAccount</span>
}

// Inspect accepts an inspector function that has same arguments as the AccountUsecase.UpdateAccount
func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) Inspect(f func(ctx context.Context, item *entity.Account)) *mAccountUsecaseMockUpdateAccount <span class="cov0" title="0">{
        if mmUpdateAccount.mock.inspectFuncUpdateAccount != nil </span><span class="cov0" title="0">{
                mmUpdateAccount.mock.t.Fatalf("Inspect function is already set for AccountUsecaseMock.UpdateAccount")
        }</span>

        <span class="cov0" title="0">mmUpdateAccount.mock.inspectFuncUpdateAccount = f

        return mmUpdateAccount</span>
}

// Return sets up results that will be returned by AccountUsecase.UpdateAccount
func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) Return(err error) *AccountUsecaseMock <span class="cov0" title="0">{
        if mmUpdateAccount.mock.funcUpdateAccount != nil </span><span class="cov0" title="0">{
                mmUpdateAccount.mock.t.Fatalf("AccountUsecaseMock.UpdateAccount mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdateAccount.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdateAccount.defaultExpectation = &amp;AccountUsecaseMockUpdateAccountExpectation{mock: mmUpdateAccount.mock}
        }</span>
        <span class="cov0" title="0">mmUpdateAccount.defaultExpectation.results = &amp;AccountUsecaseMockUpdateAccountResults{err}
        mmUpdateAccount.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmUpdateAccount.mock</span>
}

// Set uses given function f to mock the AccountUsecase.UpdateAccount method
func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) Set(f func(ctx context.Context, item *entity.Account) (err error)) *AccountUsecaseMock <span class="cov0" title="0">{
        if mmUpdateAccount.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmUpdateAccount.mock.t.Fatalf("Default expectation is already set for the AccountUsecase.UpdateAccount method")
        }</span>

        <span class="cov0" title="0">if len(mmUpdateAccount.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmUpdateAccount.mock.t.Fatalf("Some expectations are already set for the AccountUsecase.UpdateAccount method")
        }</span>

        <span class="cov0" title="0">mmUpdateAccount.mock.funcUpdateAccount = f
        mmUpdateAccount.mock.funcUpdateAccountOrigin = minimock.CallerInfo(1)
        return mmUpdateAccount.mock</span>
}

// When sets expectation for the AccountUsecase.UpdateAccount which will trigger the result defined by the following
// Then helper
func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) When(ctx context.Context, item *entity.Account) *AccountUsecaseMockUpdateAccountExpectation <span class="cov0" title="0">{
        if mmUpdateAccount.mock.funcUpdateAccount != nil </span><span class="cov0" title="0">{
                mmUpdateAccount.mock.t.Fatalf("AccountUsecaseMock.UpdateAccount mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;AccountUsecaseMockUpdateAccountExpectation{
                mock:               mmUpdateAccount.mock,
                params:             &amp;AccountUsecaseMockUpdateAccountParams{ctx, item},
                expectationOrigins: AccountUsecaseMockUpdateAccountExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmUpdateAccount.expectations = append(mmUpdateAccount.expectations, expectation)
        return expectation</span>
}

// Then sets up AccountUsecase.UpdateAccount return parameters for the expectation previously defined by the When method
func (e *AccountUsecaseMockUpdateAccountExpectation) Then(err error) *AccountUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;AccountUsecaseMockUpdateAccountResults{err}
        return e.mock
}</span>

// Times sets number of times AccountUsecase.UpdateAccount should be invoked
func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) Times(n uint64) *mAccountUsecaseMockUpdateAccount <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmUpdateAccount.mock.t.Fatalf("Times of AccountUsecaseMock.UpdateAccount mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmUpdateAccount.expectedInvocations, n)
        mmUpdateAccount.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmUpdateAccount</span>
}

func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmUpdateAccount.expectations) == 0 &amp;&amp; mmUpdateAccount.defaultExpectation == nil &amp;&amp; mmUpdateAccount.mock.funcUpdateAccount == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmUpdateAccount.mock.afterUpdateAccountCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmUpdateAccount.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// UpdateAccount implements mm_usecase.AccountUsecase
func (mmUpdateAccount *AccountUsecaseMock) UpdateAccount(ctx context.Context, item *entity.Account) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmUpdateAccount.beforeUpdateAccountCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmUpdateAccount.afterUpdateAccountCounter, 1)

        mmUpdateAccount.t.Helper()

        if mmUpdateAccount.inspectFuncUpdateAccount != nil </span><span class="cov0" title="0">{
                mmUpdateAccount.inspectFuncUpdateAccount(ctx, item)
        }</span>

        <span class="cov0" title="0">mm_params := AccountUsecaseMockUpdateAccountParams{ctx, item}

        // Record call args
        mmUpdateAccount.UpdateAccountMock.mutex.Lock()
        mmUpdateAccount.UpdateAccountMock.callArgs = append(mmUpdateAccount.UpdateAccountMock.callArgs, &amp;mm_params)
        mmUpdateAccount.UpdateAccountMock.mutex.Unlock()

        for _, e := range mmUpdateAccount.UpdateAccountMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmUpdateAccount.UpdateAccountMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmUpdateAccount.UpdateAccountMock.defaultExpectation.Counter, 1)
                mm_want := mmUpdateAccount.UpdateAccountMock.defaultExpectation.params
                mm_want_ptrs := mmUpdateAccount.UpdateAccountMock.defaultExpectation.paramPtrs

                mm_got := AccountUsecaseMockUpdateAccountParams{ctx, item}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmUpdateAccount.t.Errorf("AccountUsecaseMock.UpdateAccount got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmUpdateAccount.UpdateAccountMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.item != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.item, mm_got.item) </span><span class="cov0" title="0">{
                                mmUpdateAccount.t.Errorf("AccountUsecaseMock.UpdateAccount got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmUpdateAccount.UpdateAccountMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmUpdateAccount.t.Errorf("AccountUsecaseMock.UpdateAccount got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmUpdateAccount.UpdateAccountMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmUpdateAccount.UpdateAccountMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmUpdateAccount.t.Fatal("No results are set for the AccountUsecaseMock.UpdateAccount")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmUpdateAccount.funcUpdateAccount != nil </span><span class="cov0" title="0">{
                return mmUpdateAccount.funcUpdateAccount(ctx, item)
        }</span>
        <span class="cov0" title="0">mmUpdateAccount.t.Fatalf("Unexpected call to AccountUsecaseMock.UpdateAccount. %v %v", ctx, item)
        return</span>
}

// UpdateAccountAfterCounter returns a count of finished AccountUsecaseMock.UpdateAccount invocations
func (mmUpdateAccount *AccountUsecaseMock) UpdateAccountAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdateAccount.afterUpdateAccountCounter)
}</span>

// UpdateAccountBeforeCounter returns a count of AccountUsecaseMock.UpdateAccount invocations
func (mmUpdateAccount *AccountUsecaseMock) UpdateAccountBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdateAccount.beforeUpdateAccountCounter)
}</span>

// Calls returns a list of arguments used in each call to AccountUsecaseMock.UpdateAccount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) Calls() []*AccountUsecaseMockUpdateAccountParams <span class="cov0" title="0">{
        mmUpdateAccount.mutex.RLock()

        argCopy := make([]*AccountUsecaseMockUpdateAccountParams, len(mmUpdateAccount.callArgs))
        copy(argCopy, mmUpdateAccount.callArgs)

        mmUpdateAccount.mutex.RUnlock()

        return argCopy
}</span>

// MinimockUpdateAccountDone returns true if the count of the UpdateAccount invocations corresponds
// the number of defined expectations
func (m *AccountUsecaseMock) MinimockUpdateAccountDone() bool <span class="cov0" title="0">{
        if m.UpdateAccountMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.UpdateAccountMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.UpdateAccountMock.invocationsDone()</span>
}

// MinimockUpdateAccountInspect logs each unmet expectation
func (m *AccountUsecaseMock) MinimockUpdateAccountInspect() <span class="cov0" title="0">{
        for _, e := range m.UpdateAccountMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountUsecaseMock.UpdateAccount at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterUpdateAccountCounter := mm_atomic.LoadUint64(&amp;m.afterUpdateAccountCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.UpdateAccountMock.defaultExpectation != nil &amp;&amp; afterUpdateAccountCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.UpdateAccountMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AccountUsecaseMock.UpdateAccount at\n%s", m.UpdateAccountMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to AccountUsecaseMock.UpdateAccount at\n%s with params: %#v", m.UpdateAccountMock.defaultExpectation.expectationOrigins.origin, *m.UpdateAccountMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcUpdateAccount != nil &amp;&amp; afterUpdateAccountCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to AccountUsecaseMock.UpdateAccount at\n%s", m.funcUpdateAccountOrigin)
        }</span>

        <span class="cov0" title="0">if !m.UpdateAccountMock.invocationsDone() &amp;&amp; afterUpdateAccountCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to AccountUsecaseMock.UpdateAccount at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.UpdateAccountMock.expectedInvocations), m.UpdateAccountMock.expectedInvocationsOrigin, afterUpdateAccountCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AccountUsecaseMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockCreateAccountByDTOInspect()

                        m.MinimockFindListInspect()

                        m.MinimockFindListInMapInspect()

                        m.MinimockFindOneByEmailInspect()

                        m.MinimockFindOneByIDInspect()

                        m.MinimockFindPagedListInspect()

                        m.MinimockPatchAccountByDTOInspect()

                        m.MinimockUpdateAccountInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AccountUsecaseMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *AccountUsecaseMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockCreateAccountByDTODone() &amp;&amp;
                m.MinimockFindListDone() &amp;&amp;
                m.MinimockFindListInMapDone() &amp;&amp;
                m.MinimockFindOneByEmailDone() &amp;&amp;
                m.MinimockFindOneByIDDone() &amp;&amp;
                m.MinimockFindPagedListDone() &amp;&amp;
                m.MinimockPatchAccountByDTODone() &amp;&amp;
                m.MinimockUpdateAccountDone()
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase.AuthUsecase -o auth_usecase.go -n AuthUsecaseMock -p mocks

import (
        "context"
        "net"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
        mm_usecase "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
)

// AuthUsecaseMock implements mm_usecase.AuthUsecase
type AuthUsecaseMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcGenerateNewClaims          func(ctx context.Context, refresh *entity.SessionRefreshClaims, ip net.IP) (res *mm_usecase.AuthSessionDTO, err error)
        funcGenerateNewClaimsOrigin    string
        inspectFuncGenerateNewClaims   func(ctx context.Context, refresh *entity.SessionRefreshClaims, ip net.IP)
        afterGenerateNewClaimsCounter  uint64
        beforeGenerateNewClaimsCounter uint64
        GenerateNewClaimsMock          mAuthUsecaseMockGenerateNewClaims

        funcIsSessionConfirmed          func(ctx context.Context, sessionID uuid.UUID) (res bool, err error)
        funcIsSessionConfirmedOrigin    string
        inspectFuncIsSessionConfirmed   func(ctx context.Context, sessionID uuid.UUID)
        afterIsSessionConfirmedCounter  uint64
        beforeIsSessionConfirmedCounter uint64
        IsSessionConfirmedMock          mAuthUsecaseMockIsSessionConfirmed

        funcIssueAccessJWT          func(access *auth.SessionAccessClaims) (resToken string, err error)
        funcIssueAccessJWTOrigin    string
        inspectFuncIssueAccessJWT   func(access *auth.SessionAccessClaims)
        afterIssueAccessJWTCounter  uint64
        beforeIssueAccessJWTCounter uint64
        IssueAccessJWTMock          mAuthUsecaseMockIssueAccessJWT

        funcIssueRefreshJWT          func(refresh *entity.SessionRefreshClaims) (resToken string, err error)
        funcIssueRefreshJWTOrigin    string
        inspectFuncIssueRefreshJWT   func(refresh *entity.SessionRefreshClaims)
        afterIssueRefreshJWTCounter  uint64
        beforeIssueRefreshJWTCounter uint64
        IssueRefreshJWTMock          mAuthUsecaseMockIssueRefreshJWT

        funcLoginByEmail          func(ctx context.Context, email string, password string, ip net.IP) (res *mm_usecase.AuthSessionDTO, err error)
        funcLoginByEmailOrigin    string
        inspectFuncLoginByEmail   func(ctx context.Context, email string, password string, ip net.IP)
        afterLoginByEmailCounter  uint64
        beforeLoginByEmailCounter uint64
        LoginByEmailMock          mAuthUsecaseMockLoginByEmail

        funcParseRefreshToken          func(token string, validate bool) (res *entity.SessionRefreshClaims, err error)
        funcParseRefreshTokenOrigin    string
        inspectFuncParseRefreshToken   func(token string, validate bool)
        afterParseRefreshTokenCounter  uint64
        beforeParseRefreshTokenCounter uint64
        ParseRefreshTokenMock          mAuthUsecaseMockParseRefreshToken
}

// NewAuthUsecaseMock returns a mock for mm_usecase.AuthUsecase
func NewAuthUsecaseMock(t minimock.Tester) *AuthUsecaseMock <span class="cov0" title="0">{
        m := &amp;AuthUsecaseMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.GenerateNewClaimsMock = mAuthUsecaseMockGenerateNewClaims{mock: m}
        m.GenerateNewClaimsMock.callArgs = []*AuthUsecaseMockGenerateNewClaimsParams{}

        m.IsSessionConfirmedMock = mAuthUsecaseMockIsSessionConfirmed{mock: m}
        m.IsSessionConfirmedMock.callArgs = []*AuthUsecaseMockIsSessionConfirmedParams{}

        m.IssueAccessJWTMock = mAuthUsecaseMockIssueAccessJWT{mock: m}
        m.IssueAccessJWTMock.callArgs = []*AuthUsecaseMockIssueAccessJWTParams{}

        m.IssueRefreshJWTMock = mAuthUsecaseMockIssueRefreshJWT{mock: m}
        m.IssueRefreshJWTMock.callArgs = []*AuthUsecaseMockIssueRefreshJWTParams{}

        m.LoginByEmailMock = mAuthUsecaseMockLoginByEmail{mock: m}
        m.LoginByEmailMock.callArgs = []*AuthUsecaseMockLoginByEmailParams{}

        m.ParseRefreshTokenMock = mAuthUsecaseMockParseRefreshToken{mock: m}
        m.ParseRefreshTokenMock.callArgs = []*AuthUsecaseMockParseRefreshTokenParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mAuthUsecaseMockGenerateNewClaims struct {
        optional           bool
        mock               *AuthUsecaseMock
        defaultExpectation *AuthUsecaseMockGenerateNewClaimsExpectation
        expectations       []*AuthUsecaseMockGenerateNewClaimsExpectation

        callArgs []*AuthUsecaseMockGenerateNewClaimsParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// AuthUsecaseMockGenerateNewClaimsExpectation specifies expectation struct of the AuthUsecase.GenerateNewClaims
type AuthUsecaseMockGenerateNewClaimsExpectation struct {
        mock               *AuthUsecaseMock
        params             *AuthUsecaseMockGenerateNewClaimsParams
        paramPtrs          *AuthUsecaseMockGenerateNewClaimsParamPtrs
        expectationOrigins AuthUsecaseMockGenerateNewClaimsExpectationOrigins
        results            *AuthUsecaseMockGenerateNewClaimsResults
        returnOrigin       string
        Counter            uint64
}

// AuthUsecaseMockGenerateNewClaimsParams contains parameters of the AuthUsecase.GenerateNewClaims
type AuthUsecaseMockGenerateNewClaimsParams struct {
        ctx     context.Context
        refresh *entity.SessionRefreshClaims
        ip      net.IP
}

// AuthUsecaseMockGenerateNewClaimsParamPtrs contains pointers to parameters of the AuthUsecase.GenerateNewClaims
type AuthUsecaseMockGenerateNewClaimsParamPtrs struct {
        ctx     *context.Context
        refresh **entity.SessionRefreshClaims
        ip      *net.IP
}

// AuthUsecaseMockGenerateNewClaimsResults contains results of the AuthUsecase.GenerateNewClaims
type AuthUsecaseMockGenerateNewClaimsResults struct {
        res *mm_usecase.AuthSessionDTO
        err error
}

// AuthUsecaseMockGenerateNewClaimsOrigins contains origins of expectations of the AuthUsecase.GenerateNewClaims
type AuthUsecaseMockGenerateNewClaimsExpectationOrigins struct {
        origin        string
        originCtx     string
        originRefresh string
        originIp      string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) Optional() *mAuthUsecaseMockGenerateNewClaims <span class="cov0" title="0">{
        mmGenerateNewClaims.optional = true
        return mmGenerateNewClaims
}</span>

// Expect sets up expected params for AuthUsecase.GenerateNewClaims
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) Expect(ctx context.Context, refresh *entity.SessionRefreshClaims, ip net.IP) *mAuthUsecaseMockGenerateNewClaims <span class="cov0" title="0">{
        if mmGenerateNewClaims.mock.funcGenerateNewClaims != nil </span><span class="cov0" title="0">{
                mmGenerateNewClaims.mock.t.Fatalf("AuthUsecaseMock.GenerateNewClaims mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGenerateNewClaims.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGenerateNewClaims.defaultExpectation = &amp;AuthUsecaseMockGenerateNewClaimsExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGenerateNewClaims.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGenerateNewClaims.mock.t.Fatalf("AuthUsecaseMock.GenerateNewClaims mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmGenerateNewClaims.defaultExpectation.params = &amp;AuthUsecaseMockGenerateNewClaimsParams{ctx, refresh, ip}
        mmGenerateNewClaims.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmGenerateNewClaims.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGenerateNewClaims.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGenerateNewClaims.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGenerateNewClaims.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmGenerateNewClaims</span>
}

// ExpectCtxParam1 sets up expected param ctx for AuthUsecase.GenerateNewClaims
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) ExpectCtxParam1(ctx context.Context) *mAuthUsecaseMockGenerateNewClaims <span class="cov0" title="0">{
        if mmGenerateNewClaims.mock.funcGenerateNewClaims != nil </span><span class="cov0" title="0">{
                mmGenerateNewClaims.mock.t.Fatalf("AuthUsecaseMock.GenerateNewClaims mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGenerateNewClaims.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGenerateNewClaims.defaultExpectation = &amp;AuthUsecaseMockGenerateNewClaimsExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGenerateNewClaims.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGenerateNewClaims.mock.t.Fatalf("AuthUsecaseMock.GenerateNewClaims mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGenerateNewClaims.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGenerateNewClaims.defaultExpectation.paramPtrs = &amp;AuthUsecaseMockGenerateNewClaimsParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGenerateNewClaims.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmGenerateNewClaims.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmGenerateNewClaims</span>
}

// ExpectRefreshParam2 sets up expected param refresh for AuthUsecase.GenerateNewClaims
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) ExpectRefreshParam2(refresh *entity.SessionRefreshClaims) *mAuthUsecaseMockGenerateNewClaims <span class="cov0" title="0">{
        if mmGenerateNewClaims.mock.funcGenerateNewClaims != nil </span><span class="cov0" title="0">{
                mmGenerateNewClaims.mock.t.Fatalf("AuthUsecaseMock.GenerateNewClaims mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGenerateNewClaims.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGenerateNewClaims.defaultExpectation = &amp;AuthUsecaseMockGenerateNewClaimsExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGenerateNewClaims.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGenerateNewClaims.mock.t.Fatalf("AuthUsecaseMock.GenerateNewClaims mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGenerateNewClaims.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGenerateNewClaims.defaultExpectation.paramPtrs = &amp;AuthUsecaseMockGenerateNewClaimsParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGenerateNewClaims.defaultExpectation.paramPtrs.refresh = &amp;refresh
        mmGenerateNewClaims.defaultExpectation.expectationOrigins.originRefresh = minimock.CallerInfo(1)

        return mmGenerateNewClaims</span>
}

// ExpectIpParam3 sets up expected param ip for AuthUsecase.GenerateNewClaims
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) ExpectIpParam3(ip net.IP) *mAuthUsecaseMockGenerateNewClaims <span class="cov0" title="0">{
        if mmGenerateNewClaims.mock.funcGenerateNewClaims != nil </span><span class="cov0" title="0">{
                mmGenerateNewClaims.mock.t.Fatalf("AuthUsecaseMock.GenerateNewClaims mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGenerateNewClaims.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGenerateNewClaims.defaultExpectation = &amp;AuthUsecaseMockGenerateNewClaimsExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGenerateNewClaims.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGenerateNewClaims.mock.t.Fatalf("AuthUsecaseMock.GenerateNewClaims mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGenerateNewClaims.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGenerateNewClaims.defaultExpectation.paramPtrs = &amp;AuthUsecaseMockGenerateNewClaimsParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGenerateNewClaims.defaultExpectation.paramPtrs.ip = &amp;ip
        mmGenerateNewClaims.defaultExpectation.expectationOrigins.originIp = minimock.CallerInfo(1)

        return mmGenerateNewClaims</span>
}

// Inspect accepts an inspector function that has same arguments as the AuthUsecase.GenerateNewClaims
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) Inspect(f func(ctx context.Context, refresh *entity.SessionRefreshClaims, ip net.IP)) *mAuthUsecaseMockGenerateNewClaims <span class="cov0" title="0">{
        if mmGenerateNewClaims.mock.inspectFuncGenerateNewClaims != nil </span><span class="cov0" title="0">{
                mmGenerateNewClaims.mock.t.Fatalf("Inspect function is already set for AuthUsecaseMock.GenerateNewClaims")
        }</span>

        <span class="cov0" title="0">mmGenerateNewClaims.mock.inspectFuncGenerateNewClaims = f

        return mmGenerateNewClaims</span>
}

// Return sets up results that will be returned by AuthUsecase.GenerateNewClaims
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) Return(res *mm_usecase.AuthSessionDTO, err error) *AuthUsecaseMock <span class="cov0" title="0">{
        if mmGenerateNewClaims.mock.funcGenerateNewClaims != nil </span><span class="cov0" title="0">{
                mmGenerateNewClaims.mock.t.Fatalf("AuthUsecaseMock.GenerateNewClaims mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGenerateNewClaims.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGenerateNewClaims.defaultExpectation = &amp;AuthUsecaseMockGenerateNewClaimsExpectation{mock: mmGenerateNewClaims.mock}
        }</span>
        <span class="cov0" title="0">mmGenerateNewClaims.defaultExpectation.results = &amp;AuthUsecaseMockGenerateNewClaimsResults{res, err}
        mmGenerateNewClaims.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGenerateNewClaims.mock</span>
}

// Set uses given function f to mock the AuthUsecase.GenerateNewClaims method
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) Set(f func(ctx context.Context, refresh *entity.SessionRefreshClaims, ip net.IP) (res *mm_usecase.AuthSessionDTO, err error)) *AuthUsecaseMock <span class="cov0" title="0">{
        if mmGenerateNewClaims.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGenerateNewClaims.mock.t.Fatalf("Default expectation is already set for the AuthUsecase.GenerateNewClaims method")
        }</span>

        <span class="cov0" title="0">if len(mmGenerateNewClaims.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGenerateNewClaims.mock.t.Fatalf("Some expectations are already set for the AuthUsecase.GenerateNewClaims method")
        }</span>

        <span class="cov0" title="0">mmGenerateNewClaims.mock.funcGenerateNewClaims = f
        mmGenerateNewClaims.mock.funcGenerateNewClaimsOrigin = minimock.CallerInfo(1)
        return mmGenerateNewClaims.mock</span>
}

// When sets expectation for the AuthUsecase.GenerateNewClaims which will trigger the result defined by the following
// Then helper
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) When(ctx context.Context, refresh *entity.SessionRefreshClaims, ip net.IP) *AuthUsecaseMockGenerateNewClaimsExpectation <span class="cov0" title="0">{
        if mmGenerateNewClaims.mock.funcGenerateNewClaims != nil </span><span class="cov0" title="0">{
                mmGenerateNewClaims.mock.t.Fatalf("AuthUsecaseMock.GenerateNewClaims mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;AuthUsecaseMockGenerateNewClaimsExpectation{
                mock:               mmGenerateNewClaims.mock,
                params:             &amp;AuthUsecaseMockGenerateNewClaimsParams{ctx, refresh, ip},
                expectationOrigins: AuthUsecaseMockGenerateNewClaimsExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmGenerateNewClaims.expectations = append(mmGenerateNewClaims.expectations, expectation)
        return expectation</span>
}

// Then sets up AuthUsecase.GenerateNewClaims return parameters for the expectation previously defined by the When method
func (e *AuthUsecaseMockGenerateNewClaimsExpectation) Then(res *mm_usecase.AuthSessionDTO, err error) *AuthUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;AuthUsecaseMockGenerateNewClaimsResults{res, err}
        return e.mock
}</span>

// Times sets number of times AuthUsecase.GenerateNewClaims should be invoked
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) Times(n uint64) *mAuthUsecaseMockGenerateNewClaims <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGenerateNewClaims.mock.t.Fatalf("Times of AuthUsecaseMock.GenerateNewClaims mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGenerateNewClaims.expectedInvocations, n)
        mmGenerateNewClaims.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGenerateNewClaims</span>
}

func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmGenerateNewClaims.expectations) == 0 &amp;&amp; mmGenerateNewClaims.defaultExpectation == nil &amp;&amp; mmGenerateNewClaims.mock.funcGenerateNewClaims == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmGenerateNewClaims.mock.afterGenerateNewClaimsCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGenerateNewClaims.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GenerateNewClaims implements mm_usecase.AuthUsecase
func (mmGenerateNewClaims *AuthUsecaseMock) GenerateNewClaims(ctx context.Context, refresh *entity.SessionRefreshClaims, ip net.IP) (res *mm_usecase.AuthSessionDTO, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmGenerateNewClaims.beforeGenerateNewClaimsCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGenerateNewClaims.afterGenerateNewClaimsCounter, 1)

        mmGenerateNewClaims.t.Helper()

        if mmGenerateNewClaims.inspectFuncGenerateNewClaims != nil </span><span class="cov0" title="0">{
                mmGenerateNewClaims.inspectFuncGenerateNewClaims(ctx, refresh, ip)
        }</span>

        <span class="cov0" title="0">mm_params := AuthUsecaseMockGenerateNewClaimsParams{ctx, refresh, ip}

        // Record call args
        mmGenerateNewClaims.GenerateNewClaimsMock.mutex.Lock()
        mmGenerateNewClaims.GenerateNewClaimsMock.callArgs = append(mmGenerateNewClaims.GenerateNewClaimsMock.callArgs, &amp;mm_params)
        mmGenerateNewClaims.GenerateNewClaimsMock.mutex.Unlock()

        for _, e := range mmGenerateNewClaims.GenerateNewClaimsMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.res, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmGenerateNewClaims.GenerateNewClaimsMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmGenerateNewClaims.GenerateNewClaimsMock.defaultExpectation.Counter, 1)
                mm_want := mmGenerateNewClaims.GenerateNewClaimsMock.defaultExpectation.params
                mm_want_ptrs := mmGenerateNewClaims.GenerateNewClaimsMock.defaultExpectation.paramPtrs

                mm_got := AuthUsecaseMockGenerateNewClaimsParams{ctx, refresh, ip}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmGenerateNewClaims.t.Errorf("AuthUsecaseMock.GenerateNewClaims got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGenerateNewClaims.GenerateNewClaimsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.refresh != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.refresh, mm_got.refresh) </span><span class="cov0" title="0">{
                                mmGenerateNewClaims.t.Errorf("AuthUsecaseMock.GenerateNewClaims got unexpected parameter refresh, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGenerateNewClaims.GenerateNewClaimsMock.defaultExpectation.expectationOrigins.originRefresh, *mm_want_ptrs.refresh, mm_got.refresh, minimock.Diff(*mm_want_ptrs.refresh, mm_got.refresh))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.ip != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ip, mm_got.ip) </span><span class="cov0" title="0">{
                                mmGenerateNewClaims.t.Errorf("AuthUsecaseMock.GenerateNewClaims got unexpected parameter ip, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGenerateNewClaims.GenerateNewClaimsMock.defaultExpectation.expectationOrigins.originIp, *mm_want_ptrs.ip, mm_got.ip, minimock.Diff(*mm_want_ptrs.ip, mm_got.ip))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGenerateNewClaims.t.Errorf("AuthUsecaseMock.GenerateNewClaims got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmGenerateNewClaims.GenerateNewClaimsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmGenerateNewClaims.GenerateNewClaimsMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGenerateNewClaims.t.Fatal("No results are set for the AuthUsecaseMock.GenerateNewClaims")
                }</span>
                <span class="cov0" title="0">return (*mm_results).res, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmGenerateNewClaims.funcGenerateNewClaims != nil </span><span class="cov0" title="0">{
                return mmGenerateNewClaims.funcGenerateNewClaims(ctx, refresh, ip)
        }</span>
        <span class="cov0" title="0">mmGenerateNewClaims.t.Fatalf("Unexpected call to AuthUsecaseMock.GenerateNewClaims. %v %v %v", ctx, refresh, ip)
        return</span>
}

// GenerateNewClaimsAfterCounter returns a count of finished AuthUsecaseMock.GenerateNewClaims invocations
func (mmGenerateNewClaims *AuthUsecaseMock) GenerateNewClaimsAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGenerateNewClaims.afterGenerateNewClaimsCounter)
}</span>

// GenerateNewClaimsBeforeCounter returns a count of AuthUsecaseMock.GenerateNewClaims invocations
func (mmGenerateNewClaims *AuthUsecaseMock) GenerateNewClaimsBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGenerateNewClaims.beforeGenerateNewClaimsCounter)
}</span>

// Calls returns a list of arguments used in each call to AuthUsecaseMock.GenerateNewClaims.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) Calls() []*AuthUsecaseMockGenerateNewClaimsParams <span class="cov0" title="0">{
        mmGenerateNewClaims.mutex.RLock()

        argCopy := make([]*AuthUsecaseMockGenerateNewClaimsParams, len(mmGenerateNewClaims.callArgs))
        copy(argCopy, mmGenerateNewClaims.callArgs)

        mmGenerateNewClaims.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGenerateNewClaimsDone returns true if the count of the GenerateNewClaims invocations corresponds
// the number of defined expectations
func (m *AuthUsecaseMock) MinimockGenerateNewClaimsDone() bool <span class="cov0" title="0">{
        if m.GenerateNewClaimsMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.GenerateNewClaimsMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.GenerateNewClaimsMock.invocationsDone()</span>
}

// MinimockGenerateNewClaimsInspect logs each unmet expectation
func (m *AuthUsecaseMock) MinimockGenerateNewClaimsInspect() <span class="cov0" title="0">{
        for _, e := range m.GenerateNewClaimsMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AuthUsecaseMock.GenerateNewClaims at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGenerateNewClaimsCounter := mm_atomic.LoadUint64(&amp;m.afterGenerateNewClaimsCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GenerateNewClaimsMock.defaultExpectation != nil &amp;&amp; afterGenerateNewClaimsCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GenerateNewClaimsMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AuthUsecaseMock.GenerateNewClaims at\n%s", m.GenerateNewClaimsMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to AuthUsecaseMock.GenerateNewClaims at\n%s with params: %#v", m.GenerateNewClaimsMock.defaultExpectation.expectationOrigins.origin, *m.GenerateNewClaimsMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGenerateNewClaims != nil &amp;&amp; afterGenerateNewClaimsCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to AuthUsecaseMock.GenerateNewClaims at\n%s", m.funcGenerateNewClaimsOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GenerateNewClaimsMock.invocationsDone() &amp;&amp; afterGenerateNewClaimsCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to AuthUsecaseMock.GenerateNewClaims at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GenerateNewClaimsMock.expectedInvocations), m.GenerateNewClaimsMock.expectedInvocationsOrigin, afterGenerateNewClaimsCounter)
        }</span>
}

type mAuthUsecaseMockIsSessionConfirmed struct {
        optional           bool
        mock               *AuthUsecaseMock
        defaultExpectation *AuthUsecaseMockIsSessionConfirmedExpectation
        expectations       []*AuthUsecaseMockIsSessionConfirmedExpectation

        callArgs []*AuthUsecaseMockIsSessionConfirmedParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// AuthUsecaseMockIsSessionConfirmedExpectation specifies expectation struct of the AuthUsecase.IsSessionConfirmed
type AuthUsecaseMockIsSessionConfirmedExpectation struct {
        mock               *AuthUsecaseMock
        params             *AuthUsecaseMockIsSessionConfirmedParams
        paramPtrs          *AuthUsecaseMockIsSessionConfirmedParamPtrs
        expectationOrigins AuthUsecaseMockIsSessionConfirmedExpectationOrigins
        results            *AuthUsecaseMockIsSessionConfirmedResults
        returnOrigin       string
        Counter            uint64
}

// AuthUsecaseMockIsSessionConfirmedParams contains parameters of the AuthUsecase.IsSessionConfirmed
type AuthUsecaseMockIsSessionConfirmedParams struct {
        ctx       context.Context
        sessionID uuid.UUID
}

// AuthUsecaseMockIsSessionConfirmedParamPtrs contains pointers to parameters of the AuthUsecase.IsSessionConfirmed
type AuthUsecaseMockIsSessionConfirmedParamPtrs struct {
        ctx       *context.Context
        sessionID *uuid.UUID
}

// AuthUsecaseMockIsSessionConfirmedResults contains results of the AuthUsecase.IsSessionConfirmed
type AuthUsecaseMockIsSessionConfirmedResults struct {
        res bool
        err error
}

// AuthUsecaseMockIsSessionConfirmedOrigins contains origins of expectations of the AuthUsecase.IsSessionConfirmed
type AuthUsecaseMockIsSessionConfirmedExpectationOrigins struct {
        origin          string
        originCtx       string
        originSessionID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) Optional() *mAuthUsecaseMockIsSessionConfirmed <span class="cov0" title="0">{
        mmIsSessionConfirmed.optional = true
        return mmIsSessionConfirmed
}</span>

// Expect sets up expected params for AuthUsecase.IsSessionConfirmed
func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) Expect(ctx context.Context, sessionID uuid.UUID) *mAuthUsecaseMockIsSessionConfirmed <span class="cov0" title="0">{
        if mmIsSessionConfirmed.mock.funcIsSessionConfirmed != nil </span><span class="cov0" title="0">{
                mmIsSessionConfirmed.mock.t.Fatalf("AuthUsecaseMock.IsSessionConfirmed mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmIsSessionConfirmed.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmIsSessionConfirmed.defaultExpectation = &amp;AuthUsecaseMockIsSessionConfirmedExpectation{}
        }</span>

        <span class="cov0" title="0">if mmIsSessionConfirmed.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmIsSessionConfirmed.mock.t.Fatalf("AuthUsecaseMock.IsSessionConfirmed mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmIsSessionConfirmed.defaultExpectation.params = &amp;AuthUsecaseMockIsSessionConfirmedParams{ctx, sessionID}
        mmIsSessionConfirmed.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmIsSessionConfirmed.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmIsSessionConfirmed.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmIsSessionConfirmed.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsSessionConfirmed.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmIsSessionConfirmed</span>
}

// ExpectCtxParam1 sets up expected param ctx for AuthUsecase.IsSessionConfirmed
func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) ExpectCtxParam1(ctx context.Context) *mAuthUsecaseMockIsSessionConfirmed <span class="cov0" title="0">{
        if mmIsSessionConfirmed.mock.funcIsSessionConfirmed != nil </span><span class="cov0" title="0">{
                mmIsSessionConfirmed.mock.t.Fatalf("AuthUsecaseMock.IsSessionConfirmed mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmIsSessionConfirmed.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmIsSessionConfirmed.defaultExpectation = &amp;AuthUsecaseMockIsSessionConfirmedExpectation{}
        }</span>

        <span class="cov0" title="0">if mmIsSessionConfirmed.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmIsSessionConfirmed.mock.t.Fatalf("AuthUsecaseMock.IsSessionConfirmed mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmIsSessionConfirmed.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmIsSessionConfirmed.defaultExpectation.paramPtrs = &amp;AuthUsecaseMockIsSessionConfirmedParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmIsSessionConfirmed.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmIsSessionConfirmed.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmIsSessionConfirmed</span>
}

// ExpectSessionIDParam2 sets up expected param sessionID for AuthUsecase.IsSessionConfirmed
func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) ExpectSessionIDParam2(sessionID uuid.UUID) *mAuthUsecaseMockIsSessionConfirmed <span class="cov0" title="0">{
        if mmIsSessionConfirmed.mock.funcIsSessionConfirmed != nil </span><span class="cov0" title="0">{
                mmIsSessionConfirmed.mock.t.Fatalf("AuthUsecaseMock.IsSessionConfirmed mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmIsSessionConfirmed.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmIsSessionConfirmed.defaultExpectation = &amp;AuthUsecaseMockIsSessionConfirmedExpectation{}
        }</span>

        <span class="cov0" title="0">if mmIsSessionConfirmed.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmIsSessionConfirmed.mock.t.Fatalf("AuthUsecaseMock.IsSessionConfirmed mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmIsSessionConfirmed.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmIsSessionConfirmed.defaultExpectation.paramPtrs = &amp;AuthUsecaseMockIsSessionConfirmedParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmIsSessionConfirmed.defaultExpectation.paramPtrs.sessionID = &amp;sessionID
        mmIsSessionConfirmed.defaultExpectation.expectationOrigins.originSessionID = minimock.CallerInfo(1)

        return mmIsSessionConfirmed</span>
}

// Inspect accepts an inspector function that has same arguments as the AuthUsecase.IsSessionConfirmed
func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) Inspect(f func(ctx context.Context, sessionID uuid.UUID)) *mAuthUsecaseMockIsSessionConfirmed <span class="cov0" title="0">{
        if mmIsSessionConfirmed.mock.inspectFuncIsSessionConfirmed != nil </span><span class="cov0" title="0">{
                mmIsSessionConfirmed.mock.t.Fatalf("Inspect function is already set for AuthUsecaseMock.IsSessionConfirmed")
        }</span>

        <span class="cov0" title="0">mmIsSessionConfirmed.mock.inspectFuncIsSessionConfirmed = f

        return mmIsSessionConfirmed</span>
}

// Return sets up results that will be returned by AuthUsecase.IsSessionConfirmed
func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) Return(res bool, err error) *AuthUsecaseMock <span class="cov0" title="0">{
        if mmIsSessionConfirmed.mock.funcIsSessionConfirmed != nil </span><span class="cov0" title="0">{
                mmIsSessionConfirmed.mock.t.Fatalf("AuthUsecaseMock.IsSessionConfirmed mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmIsSessionConfirmed.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmIsSessionConfirmed.defaultExpectation = &amp;AuthUsecaseMockIsSessionConfirmedExpectation{mock: mmIsSessionConfirmed.mock}
        }</span>
        <span class="cov0" title="0">mmIsSessionConfirmed.defaultExpectation.results = &amp;AuthUsecaseMockIsSessionConfirmedResults{res, err}
        mmIsSessionConfirmed.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmIsSessionConfirmed.mock</span>
}

// Set uses given function f to mock the AuthUsecase.IsSessionConfirmed method
func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) Set(f func(ctx context.Context, sessionID uuid.UUID) (res bool, err error)) *AuthUsecaseMock <span class="cov0" title="0">{
        if mmIsSessionConfirmed.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmIsSessionConfirmed.mock.t.Fatalf("Default expectation is already set for the AuthUsecase.IsSessionConfirmed method")
        }</span>

        <span class="cov0" title="0">if len(mmIsSessionConfirmed.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmIsSessionConfirmed.mock.t.Fatalf("Some expectations are already set for the AuthUsecase.IsSessionConfirmed method")
        }</span>

        <span class="cov0" title="0">mmIsSessionConfirmed.mock.funcIsSessionConfirmed = f
        mmIsSessionConfirmed.mock.funcIsSessionConfirmedOrigin = minimock.CallerInfo(1)
        return mmIsSessionConfirmed.mock</span>
}

// When sets expectation for the AuthUsecase.IsSessionConfirmed which will trigger the result defined by the following
// Then helper
func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) When(ctx context.Context, sessionID uuid.UUID) *AuthUsecaseMockIsSessionConfirmedExpectation <span class="cov0" title="0">{
        if mmIsSessionConfirmed.mock.funcIsSessionConfirmed != nil </span><span class="cov0" title="0">{
                mmIsSessionConfirmed.mock.t.Fatalf("AuthUsecaseMock.IsSessionConfirmed mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;AuthUsecaseMockIsSessionConfirmedExpectation{
                mock:               mmIsSessionConfirmed.mock,
                params:             &amp;AuthUsecaseMockIsSessionConfirmedParams{ctx, sessionID},
                expectationOrigins: AuthUsecaseMockIsSessionConfirmedExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmIsSessionConfirmed.expectations = append(mmIsSessionConfirmed.expectations, expectation)
        return expectation</span>
}

// Then sets up AuthUsecase.IsSessionConfirmed return parameters for the expectation previously defined by the When method
func (e *AuthUsecaseMockIsSessionConfirmedExpectation) Then(res bool, err error) *AuthUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;AuthUsecaseMockIsSessionConfirmedResults{res, err}
        return e.mock
}</span>

// Times sets number of times AuthUsecase.IsSessionConfirmed should be invoked
func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) Times(n uint64) *mAuthUsecaseMockIsSessionConfirmed <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmIsSessionConfirmed.mock.t.Fatalf("Times of AuthUsecaseMock.IsSessionConfirmed mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmIsSessionConfirmed.expectedInvocations, n)
        mmIsSessionConfirmed.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmIsSessionConfirmed</span>
}

func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmIsSessionConfirmed.expectations) == 0 &amp;&amp; mmIsSessionConfirmed.defaultExpectation == nil &amp;&amp; mmIsSessionConfirmed.mock.funcIsSessionConfirmed == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmIsSessionConfirmed.mock.afterIsSessionConfirmedCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmIsSessionConfirmed.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// IsSessionConfirmed implements mm_usecase.AuthUsecase
func (mmIsSessionConfirmed *AuthUsecaseMock) IsSessionConfirmed(ctx context.Context, sessionID uuid.UUID) (res bool, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmIsSessionConfirmed.beforeIsSessionConfirmedCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmIsSessionConfirmed.afterIsSessionConfirmedCounter, 1)

        mmIsSessionConfirmed.t.Helper()

        if mmIsSessionConfirmed.inspectFuncIsSessionConfirmed != nil </span><span class="cov0" title="0">{
                mmIsSessionConfirmed.inspectFuncIsSessionConfirmed(ctx, sessionID)
        }</span>

        <span class="cov0" title="0">mm_params := AuthUsecaseMockIsSessionConfirmedParams{ctx, sessionID}

        // Record call args
        mmIsSessionConfirmed.IsSessionConfirmedMock.mutex.Lock()
        mmIsSessionConfirmed.IsSessionConfirmedMock.callArgs = append(mmIsSessionConfirmed.IsSessionConfirmedMock.callArgs, &amp;mm_params)
        mmIsSessionConfirmed.IsSessionConfirmedMock.mutex.Unlock()

        for _, e := range mmIsSessionConfirmed.IsSessionConfirmedMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.res, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmIsSessionConfirmed.IsSessionConfirmedMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmIsSessionConfirmed.IsSessionConfirmedMock.defaultExpectation.Counter, 1)
                mm_want := mmIsSessionConfirmed.IsSessionConfirmedMock.defaultExpectation.params
                mm_want_ptrs := mmIsSessionConfirmed.IsSessionConfirmedMock.defaultExpectation.paramPtrs

                mm_got := AuthUsecaseMockIsSessionConfirmedParams{ctx, sessionID}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmIsSessionConfirmed.t.Errorf("AuthUsecaseMock.IsSessionConfirmed got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmIsSessionConfirmed.IsSessionConfirmedMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.sessionID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.sessionID, mm_got.sessionID) </span><span class="cov0" title="0">{
                                mmIsSessionConfirmed.t.Errorf("AuthUsecaseMock.IsSessionConfirmed got unexpected parameter sessionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmIsSessionConfirmed.IsSessionConfirmedMock.defaultExpectation.expectationOrigins.originSessionID, *mm_want_ptrs.sessionID, mm_got.sessionID, minimock.Diff(*mm_want_ptrs.sessionID, mm_got.sessionID))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmIsSessionConfirmed.t.Errorf("AuthUsecaseMock.IsSessionConfirmed got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmIsSessionConfirmed.IsSessionConfirmedMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmIsSessionConfirmed.IsSessionConfirmedMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmIsSessionConfirmed.t.Fatal("No results are set for the AuthUsecaseMock.IsSessionConfirmed")
                }</span>
                <span class="cov0" title="0">return (*mm_results).res, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmIsSessionConfirmed.funcIsSessionConfirmed != nil </span><span class="cov0" title="0">{
                return mmIsSessionConfirmed.funcIsSessionConfirmed(ctx, sessionID)
        }</span>
        <span class="cov0" title="0">mmIsSessionConfirmed.t.Fatalf("Unexpected call to AuthUsecaseMock.IsSessionConfirmed. %v %v", ctx, sessionID)
        return</span>
}

// IsSessionConfirmedAfterCounter returns a count of finished AuthUsecaseMock.IsSessionConfirmed invocations
func (mmIsSessionConfirmed *AuthUsecaseMock) IsSessionConfirmedAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmIsSessionConfirmed.afterIsSessionConfirmedCounter)
}</span>

// IsSessionConfirmedBeforeCounter returns a count of AuthUsecaseMock.IsSessionConfirmed invocations
func (mmIsSessionConfirmed *AuthUsecaseMock) IsSessionConfirmedBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmIsSessionConfirmed.beforeIsSessionConfirmedCounter)
}</span>

// Calls returns a list of arguments used in each call to AuthUsecaseMock.IsSessionConfirmed.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) Calls() []*AuthUsecaseMockIsSessionConfirmedParams <span class="cov0" title="0">{
        mmIsSessionConfirmed.mutex.RLock()

        argCopy := make([]*AuthUsecaseMockIsSessionConfirmedParams, len(mmIsSessionConfirmed.callArgs))
        copy(argCopy, mmIsSessionConfirmed.callArgs)

        mmIsSessionConfirmed.mutex.RUnlock()

        return argCopy
}</span>

// MinimockIsSessionConfirmedDone returns true if the count of the IsSessionConfirmed invocations corresponds
// the number of defined expectations
func (m *AuthUsecaseMock) MinimockIsSessionConfirmedDone() bool <span class="cov0" title="0">{
        if m.IsSessionConfirmedMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.IsSessionConfirmedMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.IsSessionConfirmedMock.invocationsDone()</span>
}

// MinimockIsSessionConfirmedInspect logs each unmet expectation
func (m *AuthUsecaseMock) MinimockIsSessionConfirmedInspect() <span class="cov0" title="0">{
        for _, e := range m.IsSessionConfirmedMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AuthUsecaseMock.IsSessionConfirmed at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterIsSessionConfirmedCounter := mm_atomic.LoadUint64(&amp;m.afterIsSessionConfirmedCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.IsSessionConfirmedMock.defaultExpectation != nil &amp;&amp; afterIsSessionConfirmedCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.IsSessionConfirmedMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AuthUsecaseMock.IsSessionConfirmed at\n%s", m.IsSessionConfirmedMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to AuthUsecaseMock.IsSessionConfirmed at\n%s with params: %#v", m.IsSessionConfirmedMock.defaultExpectation.expectationOrigins.origin, *m.IsSessionConfirmedMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcIsSessionConfirmed != nil &amp;&amp; afterIsSessionConfirmedCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to AuthUsecaseMock.IsSessionConfirmed at\n%s", m.funcIsSessionConfirmedOrigin)
        }</span>

        <span class="cov0" title="0">if !m.IsSessionConfirmedMock.invocationsDone() &amp;&amp; afterIsSessionConfirmedCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to AuthUsecaseMock.IsSessionConfirmed at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.IsSessionConfirmedMock.expectedInvocations), m.IsSessionConfirmedMock.expectedInvocationsOrigin, afterIsSessionConfirmedCounter)
        }</span>
}

type mAuthUsecaseMockIssueAccessJWT struct {
        optional           bool
        mock               *AuthUsecaseMock
        defaultExpectation *AuthUsecaseMockIssueAccessJWTExpectation
        expectations       []*AuthUsecaseMockIssueAccessJWTExpectation

        callArgs []*AuthUsecaseMockIssueAccessJWTParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// AuthUsecaseMockIssueAccessJWTExpectation specifies expectation struct of the AuthUsecase.IssueAccessJWT
type AuthUsecaseMockIssueAccessJWTExpectation struct {
        mock               *AuthUsecaseMock
        params             *AuthUsecaseMockIssueAccessJWTParams
        paramPtrs          *AuthUsecaseMockIssueAccessJWTParamPtrs
        expectationOrigins AuthUsecaseMockIssueAccessJWTExpectationOrigins
        results            *AuthUsecaseMockIssueAccessJWTResults
        returnOrigin       string
        Counter            uint64
}

// AuthUsecaseMockIssueAccessJWTParams contains parameters of the AuthUsecase.IssueAccessJWT
type AuthUsecaseMockIssueAccessJWTParams struct {
        access *auth.SessionAccessClaims
}

// AuthUsecaseMockIssueAccessJWTParamPtrs contains pointers to parameters of the AuthUsecase.IssueAccessJWT
type AuthUsecaseMockIssueAccessJWTParamPtrs struct {
        access **auth.SessionAccessClaims
}

// AuthUsecaseMockIssueAccessJWTResults contains results of the AuthUsecase.IssueAccessJWT
type AuthUsecaseMockIssueAccessJWTResults struct {
        resToken string
        err      error
}

// AuthUsecaseMockIssueAccessJWTOrigins contains origins of expectations of the AuthUsecase.IssueAccessJWT
type AuthUsecaseMockIssueAccessJWTExpectationOrigins struct {
        origin       string
        originAccess string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIssueAccessJWT *mAuthUsecaseMockIssueAccessJWT) Optional() *mAuthUsecaseMockIssueAccessJWT <span class="cov0" title="0">{
        mmIssueAccessJWT.optional = true
        return mmIssueAccessJWT
}</span>

// Expect sets up expected params for AuthUsecase.IssueAccessJWT
func (mmIssueAccessJWT *mAuthUsecaseMockIssueAccessJWT) Expect(access *auth.SessionAccessClaims) *mAuthUsecaseMockIssueAccessJWT <span class="cov0" title="0">{
        if mmIssueAccessJWT.mock.funcIssueAccessJWT != nil </span><span class="cov0" title="0">{
                mmIssueAccessJWT.mock.t.Fatalf("AuthUsecaseMock.IssueAccessJWT mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmIssueAccessJWT.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmIssueAccessJWT.defaultExpectation = &amp;AuthUsecaseMockIssueAccessJWTExpectation{}
        }</span>

        <span class="cov0" title="0">if mmIssueAccessJWT.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmIssueAccessJWT.mock.t.Fatalf("AuthUsecaseMock.IssueAccessJWT mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmIssueAccessJWT.defaultExpectation.params = &amp;AuthUsecaseMockIssueAccessJWTParams{access}
        mmIssueAccessJWT.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmIssueAccessJWT.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmIssueAccessJWT.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmIssueAccessJWT.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIssueAccessJWT.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmIssueAccessJWT</span>
}

// ExpectAccessParam1 sets up expected param access for AuthUsecase.IssueAccessJWT
func (mmIssueAccessJWT *mAuthUsecaseMockIssueAccessJWT) ExpectAccessParam1(access *auth.SessionAccessClaims) *mAuthUsecaseMockIssueAccessJWT <span class="cov0" title="0">{
        if mmIssueAccessJWT.mock.funcIssueAccessJWT != nil </span><span class="cov0" title="0">{
                mmIssueAccessJWT.mock.t.Fatalf("AuthUsecaseMock.IssueAccessJWT mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmIssueAccessJWT.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmIssueAccessJWT.defaultExpectation = &amp;AuthUsecaseMockIssueAccessJWTExpectation{}
        }</span>

        <span class="cov0" title="0">if mmIssueAccessJWT.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmIssueAccessJWT.mock.t.Fatalf("AuthUsecaseMock.IssueAccessJWT mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmIssueAccessJWT.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmIssueAccessJWT.defaultExpectation.paramPtrs = &amp;AuthUsecaseMockIssueAccessJWTParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmIssueAccessJWT.defaultExpectation.paramPtrs.access = &amp;access
        mmIssueAccessJWT.defaultExpectation.expectationOrigins.originAccess = minimock.CallerInfo(1)

        return mmIssueAccessJWT</span>
}

// Inspect accepts an inspector function that has same arguments as the AuthUsecase.IssueAccessJWT
func (mmIssueAccessJWT *mAuthUsecaseMockIssueAccessJWT) Inspect(f func(access *auth.SessionAccessClaims)) *mAuthUsecaseMockIssueAccessJWT <span class="cov0" title="0">{
        if mmIssueAccessJWT.mock.inspectFuncIssueAccessJWT != nil </span><span class="cov0" title="0">{
                mmIssueAccessJWT.mock.t.Fatalf("Inspect function is already set for AuthUsecaseMock.IssueAccessJWT")
        }</span>

        <span class="cov0" title="0">mmIssueAccessJWT.mock.inspectFuncIssueAccessJWT = f

        return mmIssueAccessJWT</span>
}

// Return sets up results that will be returned by AuthUsecase.IssueAccessJWT
func (mmIssueAccessJWT *mAuthUsecaseMockIssueAccessJWT) Return(resToken string, err error) *AuthUsecaseMock <span class="cov0" title="0">{
        if mmIssueAccessJWT.mock.funcIssueAccessJWT != nil </span><span class="cov0" title="0">{
                mmIssueAccessJWT.mock.t.Fatalf("AuthUsecaseMock.IssueAccessJWT mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmIssueAccessJWT.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmIssueAccessJWT.defaultExpectation = &amp;AuthUsecaseMockIssueAccessJWTExpectation{mock: mmIssueAccessJWT.mock}
        }</span>
        <span class="cov0" title="0">mmIssueAccessJWT.defaultExpectation.results = &amp;AuthUsecaseMockIssueAccessJWTResults{resToken, err}
        mmIssueAccessJWT.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmIssueAccessJWT.mock</span>
}

// Set uses given function f to mock the AuthUsecase.IssueAccessJWT method
func (mmIssueAccessJWT *mAuthUsecaseMockIssueAccessJWT) Set(f func(access *auth.SessionAccessClaims) (resToken string, err error)) *AuthUsecaseMock <span class="cov0" title="0">{
        if mmIssueAccessJWT.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmIssueAccessJWT.mock.t.Fatalf("Default expectation is already set for the AuthUsecase.IssueAccessJWT method")
        }</span>

        <span class="cov0" title="0">if len(mmIssueAccessJWT.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmIssueAccessJWT.mock.t.Fatalf("Some expectations are already set for the AuthUsecase.IssueAccessJWT method")
        }</span>

        <span class="cov0" title="0">mmIssueAccessJWT.mock.funcIssueAccessJWT = f
        mmIssueAccessJWT.mock.funcIssueAccessJWTOrigin = minimock.CallerInfo(1)
        return mmIssueAccessJWT.mock</span>
}

// When sets expectation for the AuthUsecase.IssueAccessJWT which will trigger the result defined by the following
// Then helper
func (mmIssueAccessJWT *mAuthUsecaseMockIssueAccessJWT) When(access *auth.SessionAccessClaims) *AuthUsecaseMockIssueAccessJWTExpectation <span class="cov0" title="0">{
        if mmIssueAccessJWT.mock.funcIssueAccessJWT != nil </span><span class="cov0" title="0">{
                mmIssueAccessJWT.mock.t.Fatalf("AuthUsecaseMock.IssueAccessJWT mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;AuthUsecaseMockIssueAccessJWTExpectation{
                mock:               mmIssueAccessJWT.mock,
                params:             &amp;AuthUsecaseMockIssueAccessJWTParams{access},
                expectationOrigins: AuthUsecaseMockIssueAccessJWTExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmIssueAccessJWT.expectations = append(mmIssueAccessJWT.expectations, expectation)
        return expectation</span>
}

// Then sets up AuthUsecase.IssueAccessJWT return parameters for the expectation previously defined by the When method
func (e *AuthUsecaseMockIssueAccessJWTExpectation) Then(resToken string, err error) *AuthUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;AuthUsecaseMockIssueAccessJWTResults{resToken, err}
        return e.mock
}</span>

// Times sets number of times AuthUsecase.IssueAccessJWT should be invoked
func (mmIssueAccessJWT *mAuthUsecaseMockIssueAccessJWT) Times(n uint64) *mAuthUsecaseMockIssueAccessJWT <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmIssueAccessJWT.mock.t.Fatalf("Times of AuthUsecaseMock.IssueAccessJWT mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmIssueAccessJWT.expectedInvocations, n)
        mmIssueAccessJWT.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmIssueAccessJWT</span>
}

func (mmIssueAccessJWT *mAuthUsecaseMockIssueAccessJWT) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmIssueAccessJWT.expectations) == 0 &amp;&amp; mmIssueAccessJWT.defaultExpectation == nil &amp;&amp; mmIssueAccessJWT.mock.funcIssueAccessJWT == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmIssueAccessJWT.mock.afterIssueAccessJWTCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmIssueAccessJWT.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// IssueAccessJWT implements mm_usecase.AuthUsecase
func (mmIssueAccessJWT *AuthUsecaseMock) IssueAccessJWT(access *auth.SessionAccessClaims) (resToken string, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmIssueAccessJWT.beforeIssueAccessJWTCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmIssueAccessJWT.afterIssueAccessJWTCounter, 1)

        mmIssueAccessJWT.t.Helper()

        if mmIssueAccessJWT.inspectFuncIssueAccessJWT != nil </span><span class="cov0" title="0">{
                mmIssueAccessJWT.inspectFuncIssueAccessJWT(access)
        }</span>

        <span class="cov0" title="0">mm_params := AuthUsecaseMockIssueAccessJWTParams{access}

        // Record call args
        mmIssueAccessJWT.IssueAccessJWTMock.mutex.Lock()
        mmIssueAccessJWT.IssueAccessJWTMock.callArgs = append(mmIssueAccessJWT.IssueAccessJWTMock.callArgs, &amp;mm_params)
        mmIssueAccessJWT.IssueAccessJWTMock.mutex.Unlock()

        for _, e := range mmIssueAccessJWT.IssueAccessJWTMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.resToken, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmIssueAccessJWT.IssueAccessJWTMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmIssueAccessJWT.IssueAccessJWTMock.defaultExpectation.Counter, 1)
                mm_want := mmIssueAccessJWT.IssueAccessJWTMock.defaultExpectation.params
                mm_want_ptrs := mmIssueAccessJWT.IssueAccessJWTMock.defaultExpectation.paramPtrs

                mm_got := AuthUsecaseMockIssueAccessJWTParams{access}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.access != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.access, mm_got.access) </span><span class="cov0" title="0">{
                                mmIssueAccessJWT.t.Errorf("AuthUsecaseMock.IssueAccessJWT got unexpected parameter access, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmIssueAccessJWT.IssueAccessJWTMock.defaultExpectation.expectationOrigins.originAccess, *mm_want_ptrs.access, mm_got.access, minimock.Diff(*mm_want_ptrs.access, mm_got.access))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmIssueAccessJWT.t.Errorf("AuthUsecaseMock.IssueAccessJWT got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmIssueAccessJWT.IssueAccessJWTMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmIssueAccessJWT.IssueAccessJWTMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmIssueAccessJWT.t.Fatal("No results are set for the AuthUsecaseMock.IssueAccessJWT")
                }</span>
                <span class="cov0" title="0">return (*mm_results).resToken, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmIssueAccessJWT.funcIssueAccessJWT != nil </span><span class="cov0" title="0">{
                return mmIssueAccessJWT.funcIssueAccessJWT(access)
        }</span>
        <span class="cov0" title="0">mmIssueAccessJWT.t.Fatalf("Unexpected call to AuthUsecaseMock.IssueAccessJWT. %v", access)
        return</span>
}

// IssueAccessJWTAfterCounter returns a count of finished AuthUsecaseMock.IssueAccessJWT invocations
func (mmIssueAccessJWT *AuthUsecaseMock) IssueAccessJWTAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmIssueAccessJWT.afterIssueAccessJWTCounter)
}</span>

// IssueAccessJWTBeforeCounter returns a count of AuthUsecaseMock.IssueAccessJWT invocations
func (mmIssueAccessJWT *AuthUsecaseMock) IssueAccessJWTBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmIssueAccessJWT.beforeIssueAccessJWTCounter)
}</span>

// Calls returns a list of arguments used in each call to AuthUsecaseMock.IssueAccessJWT.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIssueAccessJWT *mAuthUsecaseMockIssueAccessJWT) Calls() []*AuthUsecaseMockIssueAccessJWTParams <span class="cov0" title="0">{
        mmIssueAccessJWT.mutex.RLock()

        argCopy := make([]*AuthUsecaseMockIssueAccessJWTParams, len(mmIssueAccessJWT.callArgs))
        copy(argCopy, mmIssueAccessJWT.callArgs)

        mmIssueAccessJWT.mutex.RUnlock()

        return argCopy
}</span>

// MinimockIssueAccessJWTDone returns true if the count of the IssueAccessJWT invocations corresponds
// the number of defined expectations
func (m *AuthUsecaseMock) MinimockIssueAccessJWTDone() bool <span class="cov0" title="0">{
        if m.IssueAccessJWTMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.IssueAccessJWTMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.IssueAccessJWTMock.invocationsDone()</span>
}

// MinimockIssueAccessJWTInspect logs each unmet expectation
func (m *AuthUsecaseMock) MinimockIssueAccessJWTInspect() <span class="cov0" title="0">{
        for _, e := range m.IssueAccessJWTMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AuthUsecaseMock.IssueAccessJWT at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterIssueAccessJWTCounter := mm_atomic.LoadUint64(&amp;m.afterIssueAccessJWTCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.IssueAccessJWTMock.defaultExpectation != nil &amp;&amp; afterIssueAccessJWTCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.IssueAccessJWTMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AuthUsecaseMock.IssueAccessJWT at\n%s", m.IssueAccessJWTMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to AuthUsecaseMock.IssueAccessJWT at\n%s with params: %#v", m.IssueAccessJWTMock.defaultExpectation.expectationOrigins.origin, *m.IssueAccessJWTMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcIssueAccessJWT != nil &amp;&amp; afterIssueAccessJWTCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to AuthUsecaseMock.IssueAccessJWT at\n%s", m.funcIssueAccessJWTOrigin)
        }</span>

        <span class="cov0" title="0">if !m.IssueAccessJWTMock.invocationsDone() &amp;&amp; afterIssueAccessJWTCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to AuthUsecaseMock.IssueAccessJWT at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.IssueAccessJWTMock.expectedInvocations), m.IssueAccessJWTMock.expectedInvocationsOrigin, afterIssueAccessJWTCounter)
        }</span>
}

type mAuthUsecaseMockIssueRefreshJWT struct {
        optional           bool
        mock               *AuthUsecaseMock
        defaultExpectation *AuthUsecaseMockIssueRefreshJWTExpectation
        expectations       []*AuthUsecaseMockIssueRefreshJWTExpectation

        callArgs []*AuthUsecaseMockIssueRefreshJWTParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// AuthUsecaseMockIssueRefreshJWTExpectation specifies expectation struct of the AuthUsecase.IssueRefreshJWT
type AuthUsecaseMockIssueRefreshJWTExpectation struct {
        mock               *AuthUsecaseMock
        params             *AuthUsecaseMockIssueRefreshJWTParams
        paramPtrs          *AuthUsecaseMockIssueRefreshJWTParamPtrs
        expectationOrigins AuthUsecaseMockIssueRefreshJWTExpectationOrigins
        results            *AuthUsecaseMockIssueRefreshJWTResults
        returnOrigin       string
        Counter            uint64
}

// AuthUsecaseMockIssueRefreshJWTParams contains parameters of the AuthUsecase.IssueRefreshJWT
type AuthUsecaseMockIssueRefreshJWTParams struct {
        refresh *entity.SessionRefreshClaims
}

// AuthUsecaseMockIssueRefreshJWTParamPtrs contains pointers to parameters of the AuthUsecase.IssueRefreshJWT
type AuthUsecaseMockIssueRefreshJWTParamPtrs struct {
        refresh **entity.SessionRefreshClaims
}

// AuthUsecaseMockIssueRefreshJWTResults contains results of the AuthUsecase.IssueRefreshJWT
type AuthUsecaseMockIssueRefreshJWTResults struct {
        resToken string
        err      error
}

// AuthUsecaseMockIssueRefreshJWTOrigins contains origins of expectations of the AuthUsecase.IssueRefreshJWT
type AuthUsecaseMockIssueRefreshJWTExpectationOrigins struct {
        origin        string
        originRefresh string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIssueRefreshJWT *mAuthUsecaseMockIssueRefreshJWT) Optional() *mAuthUsecaseMockIssueRefreshJWT <span class="cov0" title="0">{
        mmIssueRefreshJWT.optional = true
        return mmIssueRefreshJWT
}</span>

// Expect sets up expected params for AuthUsecase.IssueRefreshJWT
func (mmIssueRefreshJWT *mAuthUsecaseMockIssueRefreshJWT) Expect(refresh *entity.SessionRefreshClaims) *mAuthUsecaseMockIssueRefreshJWT <span class="cov0" title="0">{
        if mmIssueRefreshJWT.mock.funcIssueRefreshJWT != nil </span><span class="cov0" title="0">{
                mmIssueRefreshJWT.mock.t.Fatalf("AuthUsecaseMock.IssueRefreshJWT mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmIssueRefreshJWT.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmIssueRefreshJWT.defaultExpectation = &amp;AuthUsecaseMockIssueRefreshJWTExpectation{}
        }</span>

        <span class="cov0" title="0">if mmIssueRefreshJWT.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmIssueRefreshJWT.mock.t.Fatalf("AuthUsecaseMock.IssueRefreshJWT mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmIssueRefreshJWT.defaultExpectation.params = &amp;AuthUsecaseMockIssueRefreshJWTParams{refresh}
        mmIssueRefreshJWT.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmIssueRefreshJWT.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmIssueRefreshJWT.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmIssueRefreshJWT.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIssueRefreshJWT.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmIssueRefreshJWT</span>
}

// ExpectRefreshParam1 sets up expected param refresh for AuthUsecase.IssueRefreshJWT
func (mmIssueRefreshJWT *mAuthUsecaseMockIssueRefreshJWT) ExpectRefreshParam1(refresh *entity.SessionRefreshClaims) *mAuthUsecaseMockIssueRefreshJWT <span class="cov0" title="0">{
        if mmIssueRefreshJWT.mock.funcIssueRefreshJWT != nil </span><span class="cov0" title="0">{
                mmIssueRefreshJWT.mock.t.Fatalf("AuthUsecaseMock.IssueRefreshJWT mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmIssueRefreshJWT.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmIssueRefreshJWT.defaultExpectation = &amp;AuthUsecaseMockIssueRefreshJWTExpectation{}
        }</span>

        <span class="cov0" title="0">if mmIssueRefreshJWT.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmIssueRefreshJWT.mock.t.Fatalf("AuthUsecaseMock.IssueRefreshJWT mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmIssueRefreshJWT.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmIssueRefreshJWT.defaultExpectation.paramPtrs = &amp;AuthUsecaseMockIssueRefreshJWTParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmIssueRefreshJWT.defaultExpectation.paramPtrs.refresh = &amp;refresh
        mmIssueRefreshJWT.defaultExpectation.expectationOrigins.originRefresh = minimock.CallerInfo(1)

        return mmIssueRefreshJWT</span>
}

// Inspect accepts an inspector function that has same arguments as the AuthUsecase.IssueRefreshJWT
func (mmIssueRefreshJWT *mAuthUsecaseMockIssueRefreshJWT) Inspect(f func(refresh *entity.SessionRefreshClaims)) *mAuthUsecaseMockIssueRefreshJWT <span class="cov0" title="0">{
        if mmIssueRefreshJWT.mock.inspectFuncIssueRefreshJWT != nil </span><span class="cov0" title="0">{
                mmIssueRefreshJWT.mock.t.Fatalf("Inspect function is already set for AuthUsecaseMock.IssueRefreshJWT")
        }</span>

        <span class="cov0" title="0">mmIssueRefreshJWT.mock.inspectFuncIssueRefreshJWT = f

        return mmIssueRefreshJWT</span>
}

// Return sets up results that will be returned by AuthUsecase.IssueRefreshJWT
func (mmIssueRefreshJWT *mAuthUsecaseMockIssueRefreshJWT) Return(resToken string, err error) *AuthUsecaseMock <span class="cov0" title="0">{
        if mmIssueRefreshJWT.mock.funcIssueRefreshJWT != nil </span><span class="cov0" title="0">{
                mmIssueRefreshJWT.mock.t.Fatalf("AuthUsecaseMock.IssueRefreshJWT mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmIssueRefreshJWT.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmIssueRefreshJWT.defaultExpectation = &amp;AuthUsecaseMockIssueRefreshJWTExpectation{mock: mmIssueRefreshJWT.mock}
        }</span>
        <span class="cov0" title="0">mmIssueRefreshJWT.defaultExpectation.results = &amp;AuthUsecaseMockIssueRefreshJWTResults{resToken, err}
        mmIssueRefreshJWT.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmIssueRefreshJWT.mock</span>
}

// Set uses given function f to mock the AuthUsecase.IssueRefreshJWT method
func (mmIssueRefreshJWT *mAuthUsecaseMockIssueRefreshJWT) Set(f func(refresh *entity.SessionRefreshClaims) (resToken string, err error)) *AuthUsecaseMock <span class="cov0" title="0">{
        if mmIssueRefreshJWT.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmIssueRefreshJWT.mock.t.Fatalf("Default expectation is already set for the AuthUsecase.IssueRefreshJWT method")
        }</span>

        <span class="cov0" title="0">if len(mmIssueRefreshJWT.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmIssueRefreshJWT.mock.t.Fatalf("Some expectations are already set for the AuthUsecase.IssueRefreshJWT method")
        }</span>

        <span class="cov0" title="0">mmIssueRefreshJWT.mock.funcIssueRefreshJWT = f
        mmIssueRefreshJWT.mock.funcIssueRefreshJWTOrigin = minimock.CallerInfo(1)
        return mmIssueRefreshJWT.mock</span>
}

// When sets expectation for the AuthUsecase.IssueRefreshJWT which will trigger the result defined by the following
// Then helper
func (mmIssueRefreshJWT *mAuthUsecaseMockIssueRefreshJWT) When(refresh *entity.SessionRefreshClaims) *AuthUsecaseMockIssueRefreshJWTExpectation <span class="cov0" title="0">{
        if mmIssueRefreshJWT.mock.funcIssueRefreshJWT != nil </span><span class="cov0" title="0">{
                mmIssueRefreshJWT.mock.t.Fatalf("AuthUsecaseMock.IssueRefreshJWT mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;AuthUsecaseMockIssueRefreshJWTExpectation{
                mock:               mmIssueRefreshJWT.mock,
                params:             &amp;AuthUsecaseMockIssueRefreshJWTParams{refresh},
                expectationOrigins: AuthUsecaseMockIssueRefreshJWTExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmIssueRefreshJWT.expectations = append(mmIssueRefreshJWT.expectations, expectation)
        return expectation</span>
}

// Then sets up AuthUsecase.IssueRefreshJWT return parameters for the expectation previously defined by the When method
func (e *AuthUsecaseMockIssueRefreshJWTExpectation) Then(resToken string, err error) *AuthUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;AuthUsecaseMockIssueRefreshJWTResults{resToken, err}
        return e.mock
}</span>

// Times sets number of times AuthUsecase.IssueRefreshJWT should be invoked
func (mmIssueRefreshJWT *mAuthUsecaseMockIssueRefreshJWT) Times(n uint64) *mAuthUsecaseMockIssueRefreshJWT <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmIssueRefreshJWT.mock.t.Fatalf("Times of AuthUsecaseMock.IssueRefreshJWT mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmIssueRefreshJWT.expectedInvocations, n)
        mmIssueRefreshJWT.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmIssueRefreshJWT</span>
}

func (mmIssueRefreshJWT *mAuthUsecaseMockIssueRefreshJWT) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmIssueRefreshJWT.expectations) == 0 &amp;&amp; mmIssueRefreshJWT.defaultExpectation == nil &amp;&amp; mmIssueRefreshJWT.mock.funcIssueRefreshJWT == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmIssueRefreshJWT.mock.afterIssueRefreshJWTCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmIssueRefreshJWT.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// IssueRefreshJWT implements mm_usecase.AuthUsecase
func (mmIssueRefreshJWT *AuthUsecaseMock) IssueRefreshJWT(refresh *entity.SessionRefreshClaims) (resToken string, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmIssueRefreshJWT.beforeIssueRefreshJWTCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmIssueRefreshJWT.afterIssueRefreshJWTCounter, 1)

        mmIssueRefreshJWT.t.Helper()

        if mmIssueRefreshJWT.inspectFuncIssueRefreshJWT != nil </span><span class="cov0" title="0">{
                mmIssueRefreshJWT.inspectFuncIssueRefreshJWT(refresh)
        }</span>

        <span class="cov0" title="0">mm_params := AuthUsecaseMockIssueRefreshJWTParams{refresh}

        // Record call args
        mmIssueRefreshJWT.IssueRefreshJWTMock.mutex.Lock()
        mmIssueRefreshJWT.IssueRefreshJWTMock.callArgs = append(mmIssueRefreshJWT.IssueRefreshJWTMock.callArgs, &amp;mm_params)
        mmIssueRefreshJWT.IssueRefreshJWTMock.mutex.Unlock()

        for _, e := range mmIssueRefreshJWT.IssueRefreshJWTMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.resToken, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmIssueRefreshJWT.IssueRefreshJWTMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmIssueRefreshJWT.IssueRefreshJWTMock.defaultExpectation.Counter, 1)
                mm_want := mmIssueRefreshJWT.IssueRefreshJWTMock.defaultExpectation.params
                mm_want_ptrs := mmIssueRefreshJWT.IssueRefreshJWTMock.defaultExpectation.paramPtrs

                mm_got := AuthUsecaseMockIssueRefreshJWTParams{refresh}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.refresh != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.refresh, mm_got.refresh) </span><span class="cov0" title="0">{
                                mmIssueRefreshJWT.t.Errorf("AuthUsecaseMock.IssueRefreshJWT got unexpected parameter refresh, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmIssueRefreshJWT.IssueRefreshJWTMock.defaultExpectation.expectationOrigins.originRefresh, *mm_want_ptrs.refresh, mm_got.refresh, minimock.Diff(*mm_want_ptrs.refresh, mm_got.refresh))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmIssueRefreshJWT.t.Errorf("AuthUsecaseMock.IssueRefreshJWT got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmIssueRefreshJWT.IssueRefreshJWTMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmIssueRefreshJWT.IssueRefreshJWTMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmIssueRefreshJWT.t.Fatal("No results are set for the AuthUsecaseMock.IssueRefreshJWT")
                }</span>
                <span class="cov0" title="0">return (*mm_results).resToken, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmIssueRefreshJWT.funcIssueRefreshJWT != nil </span><span class="cov0" title="0">{
                return mmIssueRefreshJWT.funcIssueRefreshJWT(refresh)
        }</span>
        <span class="cov0" title="0">mmIssueRefreshJWT.t.Fatalf("Unexpected call to AuthUsecaseMock.IssueRefreshJWT. %v", refresh)
        return</span>
}

// IssueRefreshJWTAfterCounter returns a count of finished AuthUsecaseMock.IssueRefreshJWT invocations
func (mmIssueRefreshJWT *AuthUsecaseMock) IssueRefreshJWTAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmIssueRefreshJWT.afterIssueRefreshJWTCounter)
}</span>

// IssueRefreshJWTBeforeCounter returns a count of AuthUsecaseMock.IssueRefreshJWT invocations
func (mmIssueRefreshJWT *AuthUsecaseMock) IssueRefreshJWTBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmIssueRefreshJWT.beforeIssueRefreshJWTCounter)
}</span>

// Calls returns a list of arguments used in each call to AuthUsecaseMock.IssueRefreshJWT.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIssueRefreshJWT *mAuthUsecaseMockIssueRefreshJWT) Calls() []*AuthUsecaseMockIssueRefreshJWTParams <span class="cov0" title="0">{
        mmIssueRefreshJWT.mutex.RLock()

        argCopy := make([]*AuthUsecaseMockIssueRefreshJWTParams, len(mmIssueRefreshJWT.callArgs))
        copy(argCopy, mmIssueRefreshJWT.callArgs)

        mmIssueRefreshJWT.mutex.RUnlock()

        return argCopy
}</span>

// MinimockIssueRefreshJWTDone returns true if the count of the IssueRefreshJWT invocations corresponds
// the number of defined expectations
func (m *AuthUsecaseMock) MinimockIssueRefreshJWTDone() bool <span class="cov0" title="0">{
        if m.IssueRefreshJWTMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.IssueRefreshJWTMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.IssueRefreshJWTMock.invocationsDone()</span>
}

// MinimockIssueRefreshJWTInspect logs each unmet expectation
func (m *AuthUsecaseMock) MinimockIssueRefreshJWTInspect() <span class="cov0" title="0">{
        for _, e := range m.IssueRefreshJWTMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AuthUsecaseMock.IssueRefreshJWT at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterIssueRefreshJWTCounter := mm_atomic.LoadUint64(&amp;m.afterIssueRefreshJWTCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.IssueRefreshJWTMock.defaultExpectation != nil &amp;&amp; afterIssueRefreshJWTCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.IssueRefreshJWTMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AuthUsecaseMock.IssueRefreshJWT at\n%s", m.IssueRefreshJWTMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to AuthUsecaseMock.IssueRefreshJWT at\n%s with params: %#v", m.IssueRefreshJWTMock.defaultExpectation.expectationOrigins.origin, *m.IssueRefreshJWTMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcIssueRefreshJWT != nil &amp;&amp; afterIssueRefreshJWTCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to AuthUsecaseMock.IssueRefreshJWT at\n%s", m.funcIssueRefreshJWTOrigin)
        }</span>

        <span class="cov0" title="0">if !m.IssueRefreshJWTMock.invocationsDone() &amp;&amp; afterIssueRefreshJWTCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to AuthUsecaseMock.IssueRefreshJWT at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.IssueRefreshJWTMock.expectedInvocations), m.IssueRefreshJWTMock.expectedInvocationsOrigin, afterIssueRefreshJWTCounter)
        }</span>
}

type mAuthUsecaseMockLoginByEmail struct {
        optional           bool
        mock               *AuthUsecaseMock
        defaultExpectation *AuthUsecaseMockLoginByEmailExpectation
        expectations       []*AuthUsecaseMockLoginByEmailExpectation

        callArgs []*AuthUsecaseMockLoginByEmailParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// AuthUsecaseMockLoginByEmailExpectation specifies expectation struct of the AuthUsecase.LoginByEmail
type AuthUsecaseMockLoginByEmailExpectation struct {
        mock               *AuthUsecaseMock
        params             *AuthUsecaseMockLoginByEmailParams
        paramPtrs          *AuthUsecaseMockLoginByEmailParamPtrs
        expectationOrigins AuthUsecaseMockLoginByEmailExpectationOrigins
        results            *AuthUsecaseMockLoginByEmailResults
        returnOrigin       string
        Counter            uint64
}

// AuthUsecaseMockLoginByEmailParams contains parameters of the AuthUsecase.LoginByEmail
type AuthUsecaseMockLoginByEmailParams struct {
        ctx      context.Context
        email    string
        password string
        ip       net.IP
}

// AuthUsecaseMockLoginByEmailParamPtrs contains pointers to parameters of the AuthUsecase.LoginByEmail
type AuthUsecaseMockLoginByEmailParamPtrs struct {
        ctx      *context.Context
        email    *string
        password *string
        ip       *net.IP
}

// AuthUsecaseMockLoginByEmailResults contains results of the AuthUsecase.LoginByEmail
type AuthUsecaseMockLoginByEmailResults struct {
        res *mm_usecase.AuthSessionDTO
        err error
}

// AuthUsecaseMockLoginByEmailOrigins contains origins of expectations of the AuthUsecase.LoginByEmail
type AuthUsecaseMockLoginByEmailExpectationOrigins struct {
        origin         string
        originCtx      string
        originEmail    string
        originPassword string
        originIp       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) Optional() *mAuthUsecaseMockLoginByEmail <span class="cov0" title="0">{
        mmLoginByEmail.optional = true
        return mmLoginByEmail
}</span>

// Expect sets up expected params for AuthUsecase.LoginByEmail
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) Expect(ctx context.Context, email string, password string, ip net.IP) *mAuthUsecaseMockLoginByEmail <span class="cov0" title="0">{
        if mmLoginByEmail.mock.funcLoginByEmail != nil </span><span class="cov0" title="0">{
                mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmLoginByEmail.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmLoginByEmail.defaultExpectation = &amp;AuthUsecaseMockLoginByEmailExpectation{}
        }</span>

        <span class="cov0" title="0">if mmLoginByEmail.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmLoginByEmail.defaultExpectation.params = &amp;AuthUsecaseMockLoginByEmailParams{ctx, email, password, ip}
        mmLoginByEmail.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmLoginByEmail.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmLoginByEmail.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmLoginByEmail.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLoginByEmail.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmLoginByEmail</span>
}

// ExpectCtxParam1 sets up expected param ctx for AuthUsecase.LoginByEmail
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) ExpectCtxParam1(ctx context.Context) *mAuthUsecaseMockLoginByEmail <span class="cov0" title="0">{
        if mmLoginByEmail.mock.funcLoginByEmail != nil </span><span class="cov0" title="0">{
                mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmLoginByEmail.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmLoginByEmail.defaultExpectation = &amp;AuthUsecaseMockLoginByEmailExpectation{}
        }</span>

        <span class="cov0" title="0">if mmLoginByEmail.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmLoginByEmail.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmLoginByEmail.defaultExpectation.paramPtrs = &amp;AuthUsecaseMockLoginByEmailParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmLoginByEmail.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmLoginByEmail.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmLoginByEmail</span>
}

// ExpectEmailParam2 sets up expected param email for AuthUsecase.LoginByEmail
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) ExpectEmailParam2(email string) *mAuthUsecaseMockLoginByEmail <span class="cov0" title="0">{
        if mmLoginByEmail.mock.funcLoginByEmail != nil </span><span class="cov0" title="0">{
                mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmLoginByEmail.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmLoginByEmail.defaultExpectation = &amp;AuthUsecaseMockLoginByEmailExpectation{}
        }</span>

        <span class="cov0" title="0">if mmLoginByEmail.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmLoginByEmail.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmLoginByEmail.defaultExpectation.paramPtrs = &amp;AuthUsecaseMockLoginByEmailParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmLoginByEmail.defaultExpectation.paramPtrs.email = &amp;email
        mmLoginByEmail.defaultExpectation.expectationOrigins.originEmail = minimock.CallerInfo(1)

        return mmLoginByEmail</span>
}

// ExpectPasswordParam3 sets up expected param password for AuthUsecase.LoginByEmail
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) ExpectPasswordParam3(password string) *mAuthUsecaseMockLoginByEmail <span class="cov0" title="0">{
        if mmLoginByEmail.mock.funcLoginByEmail != nil </span><span class="cov0" title="0">{
                mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmLoginByEmail.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmLoginByEmail.defaultExpectation = &amp;AuthUsecaseMockLoginByEmailExpectation{}
        }</span>

        <span class="cov0" title="0">if mmLoginByEmail.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmLoginByEmail.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmLoginByEmail.defaultExpectation.paramPtrs = &amp;AuthUsecaseMockLoginByEmailParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmLoginByEmail.defaultExpectation.paramPtrs.password = &amp;password
        mmLoginByEmail.defaultExpectation.expectationOrigins.originPassword = minimock.CallerInfo(1)

        return mmLoginByEmail</span>
}

// ExpectIpParam4 sets up expected param ip for AuthUsecase.LoginByEmail
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) ExpectIpParam4(ip net.IP) *mAuthUsecaseMockLoginByEmail <span class="cov0" title="0">{
        if mmLoginByEmail.mock.funcLoginByEmail != nil </span><span class="cov0" title="0">{
                mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmLoginByEmail.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmLoginByEmail.defaultExpectation = &amp;AuthUsecaseMockLoginByEmailExpectation{}
        }</span>

        <span class="cov0" title="0">if mmLoginByEmail.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmLoginByEmail.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmLoginByEmail.defaultExpectation.paramPtrs = &amp;AuthUsecaseMockLoginByEmailParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmLoginByEmail.defaultExpectation.paramPtrs.ip = &amp;ip
        mmLoginByEmail.defaultExpectation.expectationOrigins.originIp = minimock.CallerInfo(1)

        return mmLoginByEmail</span>
}

// Inspect accepts an inspector function that has same arguments as the AuthUsecase.LoginByEmail
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) Inspect(f func(ctx context.Context, email string, password string, ip net.IP)) *mAuthUsecaseMockLoginByEmail <span class="cov0" title="0">{
        if mmLoginByEmail.mock.inspectFuncLoginByEmail != nil </span><span class="cov0" title="0">{
                mmLoginByEmail.mock.t.Fatalf("Inspect function is already set for AuthUsecaseMock.LoginByEmail")
        }</span>

        <span class="cov0" title="0">mmLoginByEmail.mock.inspectFuncLoginByEmail = f

        return mmLoginByEmail</span>
}

// Return sets up results that will be returned by AuthUsecase.LoginByEmail
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) Return(res *mm_usecase.AuthSessionDTO, err error) *AuthUsecaseMock <span class="cov0" title="0">{
        if mmLoginByEmail.mock.funcLoginByEmail != nil </span><span class="cov0" title="0">{
                mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmLoginByEmail.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmLoginByEmail.defaultExpectation = &amp;AuthUsecaseMockLoginByEmailExpectation{mock: mmLoginByEmail.mock}
        }</span>
        <span class="cov0" title="0">mmLoginByEmail.defaultExpectation.results = &amp;AuthUsecaseMockLoginByEmailResults{res, err}
        mmLoginByEmail.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmLoginByEmail.mock</span>
}

// Set uses given function f to mock the AuthUsecase.LoginByEmail method
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) Set(f func(ctx context.Context, email string, password string, ip net.IP) (res *mm_usecase.AuthSessionDTO, err error)) *AuthUsecaseMock <span class="cov0" title="0">{
        if mmLoginByEmail.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmLoginByEmail.mock.t.Fatalf("Default expectation is already set for the AuthUsecase.LoginByEmail method")
        }</span>

        <span class="cov0" title="0">if len(mmLoginByEmail.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmLoginByEmail.mock.t.Fatalf("Some expectations are already set for the AuthUsecase.LoginByEmail method")
        }</span>

        <span class="cov0" title="0">mmLoginByEmail.mock.funcLoginByEmail = f
        mmLoginByEmail.mock.funcLoginByEmailOrigin = minimock.CallerInfo(1)
        return mmLoginByEmail.mock</span>
}

// When sets expectation for the AuthUsecase.LoginByEmail which will trigger the result defined by the following
// Then helper
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) When(ctx context.Context, email string, password string, ip net.IP) *AuthUsecaseMockLoginByEmailExpectation <span class="cov0" title="0">{
        if mmLoginByEmail.mock.funcLoginByEmail != nil </span><span class="cov0" title="0">{
                mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;AuthUsecaseMockLoginByEmailExpectation{
                mock:               mmLoginByEmail.mock,
                params:             &amp;AuthUsecaseMockLoginByEmailParams{ctx, email, password, ip},
                expectationOrigins: AuthUsecaseMockLoginByEmailExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmLoginByEmail.expectations = append(mmLoginByEmail.expectations, expectation)
        return expectation</span>
}

// Then sets up AuthUsecase.LoginByEmail return parameters for the expectation previously defined by the When method
func (e *AuthUsecaseMockLoginByEmailExpectation) Then(res *mm_usecase.AuthSessionDTO, err error) *AuthUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;AuthUsecaseMockLoginByEmailResults{res, err}
        return e.mock
}</span>

// Times sets number of times AuthUsecase.LoginByEmail should be invoked
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) Times(n uint64) *mAuthUsecaseMockLoginByEmail <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmLoginByEmail.mock.t.Fatalf("Times of AuthUsecaseMock.LoginByEmail mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmLoginByEmail.expectedInvocations, n)
        mmLoginByEmail.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmLoginByEmail</span>
}

func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmLoginByEmail.expectations) == 0 &amp;&amp; mmLoginByEmail.defaultExpectation == nil &amp;&amp; mmLoginByEmail.mock.funcLoginByEmail == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmLoginByEmail.mock.afterLoginByEmailCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmLoginByEmail.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// LoginByEmail implements mm_usecase.AuthUsecase
func (mmLoginByEmail *AuthUsecaseMock) LoginByEmail(ctx context.Context, email string, password string, ip net.IP) (res *mm_usecase.AuthSessionDTO, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmLoginByEmail.beforeLoginByEmailCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmLoginByEmail.afterLoginByEmailCounter, 1)

        mmLoginByEmail.t.Helper()

        if mmLoginByEmail.inspectFuncLoginByEmail != nil </span><span class="cov0" title="0">{
                mmLoginByEmail.inspectFuncLoginByEmail(ctx, email, password, ip)
        }</span>

        <span class="cov0" title="0">mm_params := AuthUsecaseMockLoginByEmailParams{ctx, email, password, ip}

        // Record call args
        mmLoginByEmail.LoginByEmailMock.mutex.Lock()
        mmLoginByEmail.LoginByEmailMock.callArgs = append(mmLoginByEmail.LoginByEmailMock.callArgs, &amp;mm_params)
        mmLoginByEmail.LoginByEmailMock.mutex.Unlock()

        for _, e := range mmLoginByEmail.LoginByEmailMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.res, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmLoginByEmail.LoginByEmailMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmLoginByEmail.LoginByEmailMock.defaultExpectation.Counter, 1)
                mm_want := mmLoginByEmail.LoginByEmailMock.defaultExpectation.params
                mm_want_ptrs := mmLoginByEmail.LoginByEmailMock.defaultExpectation.paramPtrs

                mm_got := AuthUsecaseMockLoginByEmailParams{ctx, email, password, ip}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmLoginByEmail.t.Errorf("AuthUsecaseMock.LoginByEmail got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmLoginByEmail.LoginByEmailMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.email != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.email, mm_got.email) </span><span class="cov0" title="0">{
                                mmLoginByEmail.t.Errorf("AuthUsecaseMock.LoginByEmail got unexpected parameter email, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmLoginByEmail.LoginByEmailMock.defaultExpectation.expectationOrigins.originEmail, *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.password != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.password, mm_got.password) </span><span class="cov0" title="0">{
                                mmLoginByEmail.t.Errorf("AuthUsecaseMock.LoginByEmail got unexpected parameter password, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmLoginByEmail.LoginByEmailMock.defaultExpectation.expectationOrigins.originPassword, *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.ip != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ip, mm_got.ip) </span><span class="cov0" title="0">{
                                mmLoginByEmail.t.Errorf("AuthUsecaseMock.LoginByEmail got unexpected parameter ip, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmLoginByEmail.LoginByEmailMock.defaultExpectation.expectationOrigins.originIp, *mm_want_ptrs.ip, mm_got.ip, minimock.Diff(*mm_want_ptrs.ip, mm_got.ip))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmLoginByEmail.t.Errorf("AuthUsecaseMock.LoginByEmail got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmLoginByEmail.LoginByEmailMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmLoginByEmail.LoginByEmailMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmLoginByEmail.t.Fatal("No results are set for the AuthUsecaseMock.LoginByEmail")
                }</span>
                <span class="cov0" title="0">return (*mm_results).res, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmLoginByEmail.funcLoginByEmail != nil </span><span class="cov0" title="0">{
                return mmLoginByEmail.funcLoginByEmail(ctx, email, password, ip)
        }</span>
        <span class="cov0" title="0">mmLoginByEmail.t.Fatalf("Unexpected call to AuthUsecaseMock.LoginByEmail. %v %v %v %v", ctx, email, password, ip)
        return</span>
}

// LoginByEmailAfterCounter returns a count of finished AuthUsecaseMock.LoginByEmail invocations
func (mmLoginByEmail *AuthUsecaseMock) LoginByEmailAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmLoginByEmail.afterLoginByEmailCounter)
}</span>

// LoginByEmailBeforeCounter returns a count of AuthUsecaseMock.LoginByEmail invocations
func (mmLoginByEmail *AuthUsecaseMock) LoginByEmailBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmLoginByEmail.beforeLoginByEmailCounter)
}</span>

// Calls returns a list of arguments used in each call to AuthUsecaseMock.LoginByEmail.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) Calls() []*AuthUsecaseMockLoginByEmailParams <span class="cov0" title="0">{
        mmLoginByEmail.mutex.RLock()

        argCopy := make([]*AuthUsecaseMockLoginByEmailParams, len(mmLoginByEmail.callArgs))
        copy(argCopy, mmLoginByEmail.callArgs)

        mmLoginByEmail.mutex.RUnlock()

        return argCopy
}</span>

// MinimockLoginByEmailDone returns true if the count of the LoginByEmail invocations corresponds
// the number of defined expectations
func (m *AuthUsecaseMock) MinimockLoginByEmailDone() bool <span class="cov0" title="0">{
        if m.LoginByEmailMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.LoginByEmailMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.LoginByEmailMock.invocationsDone()</span>
}

// MinimockLoginByEmailInspect logs each unmet expectation
func (m *AuthUsecaseMock) MinimockLoginByEmailInspect() <span class="cov0" title="0">{
        for _, e := range m.LoginByEmailMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AuthUsecaseMock.LoginByEmail at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterLoginByEmailCounter := mm_atomic.LoadUint64(&amp;m.afterLoginByEmailCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.LoginByEmailMock.defaultExpectation != nil &amp;&amp; afterLoginByEmailCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.LoginByEmailMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AuthUsecaseMock.LoginByEmail at\n%s", m.LoginByEmailMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to AuthUsecaseMock.LoginByEmail at\n%s with params: %#v", m.LoginByEmailMock.defaultExpectation.expectationOrigins.origin, *m.LoginByEmailMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcLoginByEmail != nil &amp;&amp; afterLoginByEmailCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to AuthUsecaseMock.LoginByEmail at\n%s", m.funcLoginByEmailOrigin)
        }</span>

        <span class="cov0" title="0">if !m.LoginByEmailMock.invocationsDone() &amp;&amp; afterLoginByEmailCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to AuthUsecaseMock.LoginByEmail at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.LoginByEmailMock.expectedInvocations), m.LoginByEmailMock.expectedInvocationsOrigin, afterLoginByEmailCounter)
        }</span>
}

type mAuthUsecaseMockParseRefreshToken struct {
        optional           bool
        mock               *AuthUsecaseMock
        defaultExpectation *AuthUsecaseMockParseRefreshTokenExpectation
        expectations       []*AuthUsecaseMockParseRefreshTokenExpectation

        callArgs []*AuthUsecaseMockParseRefreshTokenParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// AuthUsecaseMockParseRefreshTokenExpectation specifies expectation struct of the AuthUsecase.ParseRefreshToken
type AuthUsecaseMockParseRefreshTokenExpectation struct {
        mock               *AuthUsecaseMock
        params             *AuthUsecaseMockParseRefreshTokenParams
        paramPtrs          *AuthUsecaseMockParseRefreshTokenParamPtrs
        expectationOrigins AuthUsecaseMockParseRefreshTokenExpectationOrigins
        results            *AuthUsecaseMockParseRefreshTokenResults
        returnOrigin       string
        Counter            uint64
}

// AuthUsecaseMockParseRefreshTokenParams contains parameters of the AuthUsecase.ParseRefreshToken
type AuthUsecaseMockParseRefreshTokenParams struct {
        token    string
        validate bool
}

// AuthUsecaseMockParseRefreshTokenParamPtrs contains pointers to parameters of the AuthUsecase.ParseRefreshToken
type AuthUsecaseMockParseRefreshTokenParamPtrs struct {
        token    *string
        validate *bool
}

// AuthUsecaseMockParseRefreshTokenResults contains results of the AuthUsecase.ParseRefreshToken
type AuthUsecaseMockParseRefreshTokenResults struct {
        res *entity.SessionRefreshClaims
        err error
}

// AuthUsecaseMockParseRefreshTokenOrigins contains origins of expectations of the AuthUsecase.ParseRefreshToken
type AuthUsecaseMockParseRefreshTokenExpectationOrigins struct {
        origin         string
        originToken    string
        originValidate string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) Optional() *mAuthUsecaseMockParseRefreshToken <span class="cov0" title="0">{
        mmParseRefreshToken.optional = true
        return mmParseRefreshToken
}</span>

// Expect sets up expected params for AuthUsecase.ParseRefreshToken
func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) Expect(token string, validate bool) *mAuthUsecaseMockParseRefreshToken <span class="cov0" title="0">{
        if mmParseRefreshToken.mock.funcParseRefreshToken != nil </span><span class="cov0" title="0">{
                mmParseRefreshToken.mock.t.Fatalf("AuthUsecaseMock.ParseRefreshToken mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmParseRefreshToken.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmParseRefreshToken.defaultExpectation = &amp;AuthUsecaseMockParseRefreshTokenExpectation{}
        }</span>

        <span class="cov0" title="0">if mmParseRefreshToken.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmParseRefreshToken.mock.t.Fatalf("AuthUsecaseMock.ParseRefreshToken mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmParseRefreshToken.defaultExpectation.params = &amp;AuthUsecaseMockParseRefreshTokenParams{token, validate}
        mmParseRefreshToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmParseRefreshToken.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmParseRefreshToken.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmParseRefreshToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmParseRefreshToken.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmParseRefreshToken</span>
}

// ExpectTokenParam1 sets up expected param token for AuthUsecase.ParseRefreshToken
func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) ExpectTokenParam1(token string) *mAuthUsecaseMockParseRefreshToken <span class="cov0" title="0">{
        if mmParseRefreshToken.mock.funcParseRefreshToken != nil </span><span class="cov0" title="0">{
                mmParseRefreshToken.mock.t.Fatalf("AuthUsecaseMock.ParseRefreshToken mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmParseRefreshToken.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmParseRefreshToken.defaultExpectation = &amp;AuthUsecaseMockParseRefreshTokenExpectation{}
        }</span>

        <span class="cov0" title="0">if mmParseRefreshToken.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmParseRefreshToken.mock.t.Fatalf("AuthUsecaseMock.ParseRefreshToken mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmParseRefreshToken.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmParseRefreshToken.defaultExpectation.paramPtrs = &amp;AuthUsecaseMockParseRefreshTokenParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmParseRefreshToken.defaultExpectation.paramPtrs.token = &amp;token
        mmParseRefreshToken.defaultExpectation.expectationOrigins.originToken = minimock.CallerInfo(1)

        return mmParseRefreshToken</span>
}

// ExpectValidateParam2 sets up expected param validate for AuthUsecase.ParseRefreshToken
func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) ExpectValidateParam2(validate bool) *mAuthUsecaseMockParseRefreshToken <span class="cov0" title="0">{
        if mmParseRefreshToken.mock.funcParseRefreshToken != nil </span><span class="cov0" title="0">{
                mmParseRefreshToken.mock.t.Fatalf("AuthUsecaseMock.ParseRefreshToken mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmParseRefreshToken.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmParseRefreshToken.defaultExpectation = &amp;AuthUsecaseMockParseRefreshTokenExpectation{}
        }</span>

        <span class="cov0" title="0">if mmParseRefreshToken.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmParseRefreshToken.mock.t.Fatalf("AuthUsecaseMock.ParseRefreshToken mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmParseRefreshToken.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmParseRefreshToken.defaultExpectation.paramPtrs = &amp;AuthUsecaseMockParseRefreshTokenParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmParseRefreshToken.defaultExpectation.paramPtrs.validate = &amp;validate
        mmParseRefreshToken.defaultExpectation.expectationOrigins.originValidate = minimock.CallerInfo(1)

        return mmParseRefreshToken</span>
}

// Inspect accepts an inspector function that has same arguments as the AuthUsecase.ParseRefreshToken
func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) Inspect(f func(token string, validate bool)) *mAuthUsecaseMockParseRefreshToken <span class="cov0" title="0">{
        if mmParseRefreshToken.mock.inspectFuncParseRefreshToken != nil </span><span class="cov0" title="0">{
                mmParseRefreshToken.mock.t.Fatalf("Inspect function is already set for AuthUsecaseMock.ParseRefreshToken")
        }</span>

        <span class="cov0" title="0">mmParseRefreshToken.mock.inspectFuncParseRefreshToken = f

        return mmParseRefreshToken</span>
}

// Return sets up results that will be returned by AuthUsecase.ParseRefreshToken
func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) Return(res *entity.SessionRefreshClaims, err error) *AuthUsecaseMock <span class="cov0" title="0">{
        if mmParseRefreshToken.mock.funcParseRefreshToken != nil </span><span class="cov0" title="0">{
                mmParseRefreshToken.mock.t.Fatalf("AuthUsecaseMock.ParseRefreshToken mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmParseRefreshToken.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmParseRefreshToken.defaultExpectation = &amp;AuthUsecaseMockParseRefreshTokenExpectation{mock: mmParseRefreshToken.mock}
        }</span>
        <span class="cov0" title="0">mmParseRefreshToken.defaultExpectation.results = &amp;AuthUsecaseMockParseRefreshTokenResults{res, err}
        mmParseRefreshToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmParseRefreshToken.mock</span>
}

// Set uses given function f to mock the AuthUsecase.ParseRefreshToken method
func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) Set(f func(token string, validate bool) (res *entity.SessionRefreshClaims, err error)) *AuthUsecaseMock <span class="cov0" title="0">{
        if mmParseRefreshToken.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmParseRefreshToken.mock.t.Fatalf("Default expectation is already set for the AuthUsecase.ParseRefreshToken method")
        }</span>

        <span class="cov0" title="0">if len(mmParseRefreshToken.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmParseRefreshToken.mock.t.Fatalf("Some expectations are already set for the AuthUsecase.ParseRefreshToken method")
        }</span>

        <span class="cov0" title="0">mmParseRefreshToken.mock.funcParseRefreshToken = f
        mmParseRefreshToken.mock.funcParseRefreshTokenOrigin = minimock.CallerInfo(1)
        return mmParseRefreshToken.mock</span>
}

// When sets expectation for the AuthUsecase.ParseRefreshToken which will trigger the result defined by the following
// Then helper
func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) When(token string, validate bool) *AuthUsecaseMockParseRefreshTokenExpectation <span class="cov0" title="0">{
        if mmParseRefreshToken.mock.funcParseRefreshToken != nil </span><span class="cov0" title="0">{
                mmParseRefreshToken.mock.t.Fatalf("AuthUsecaseMock.ParseRefreshToken mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;AuthUsecaseMockParseRefreshTokenExpectation{
                mock:               mmParseRefreshToken.mock,
                params:             &amp;AuthUsecaseMockParseRefreshTokenParams{token, validate},
                expectationOrigins: AuthUsecaseMockParseRefreshTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmParseRefreshToken.expectations = append(mmParseRefreshToken.expectations, expectation)
        return expectation</span>
}

// Then sets up AuthUsecase.ParseRefreshToken return parameters for the expectation previously defined by the When method
func (e *AuthUsecaseMockParseRefreshTokenExpectation) Then(res *entity.SessionRefreshClaims, err error) *AuthUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;AuthUsecaseMockParseRefreshTokenResults{res, err}
        return e.mock
}</span>

// Times sets number of times AuthUsecase.ParseRefreshToken should be invoked
func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) Times(n uint64) *mAuthUsecaseMockParseRefreshToken <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmParseRefreshToken.mock.t.Fatalf("Times of AuthUsecaseMock.ParseRefreshToken mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmParseRefreshToken.expectedInvocations, n)
        mmParseRefreshToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmParseRefreshToken</span>
}

func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmParseRefreshToken.expectations) == 0 &amp;&amp; mmParseRefreshToken.defaultExpectation == nil &amp;&amp; mmParseRefreshToken.mock.funcParseRefreshToken == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmParseRefreshToken.mock.afterParseRefreshTokenCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmParseRefreshToken.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// ParseRefreshToken implements mm_usecase.AuthUsecase
func (mmParseRefreshToken *AuthUsecaseMock) ParseRefreshToken(token string, validate bool) (res *entity.SessionRefreshClaims, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmParseRefreshToken.beforeParseRefreshTokenCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmParseRefreshToken.afterParseRefreshTokenCounter, 1)

        mmParseRefreshToken.t.Helper()

        if mmParseRefreshToken.inspectFuncParseRefreshToken != nil </span><span class="cov0" title="0">{
                mmParseRefreshToken.inspectFuncParseRefreshToken(token, validate)
        }</span>

        <span class="cov0" title="0">mm_params := AuthUsecaseMockParseRefreshTokenParams{token, validate}

        // Record call args
        mmParseRefreshToken.ParseRefreshTokenMock.mutex.Lock()
        mmParseRefreshToken.ParseRefreshTokenMock.callArgs = append(mmParseRefreshToken.ParseRefreshTokenMock.callArgs, &amp;mm_params)
        mmParseRefreshToken.ParseRefreshTokenMock.mutex.Unlock()

        for _, e := range mmParseRefreshToken.ParseRefreshTokenMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.res, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmParseRefreshToken.ParseRefreshTokenMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmParseRefreshToken.ParseRefreshTokenMock.defaultExpectation.Counter, 1)
                mm_want := mmParseRefreshToken.ParseRefreshTokenMock.defaultExpectation.params
                mm_want_ptrs := mmParseRefreshToken.ParseRefreshTokenMock.defaultExpectation.paramPtrs

                mm_got := AuthUsecaseMockParseRefreshTokenParams{token, validate}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.token != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.token, mm_got.token) </span><span class="cov0" title="0">{
                                mmParseRefreshToken.t.Errorf("AuthUsecaseMock.ParseRefreshToken got unexpected parameter token, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmParseRefreshToken.ParseRefreshTokenMock.defaultExpectation.expectationOrigins.originToken, *mm_want_ptrs.token, mm_got.token, minimock.Diff(*mm_want_ptrs.token, mm_got.token))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.validate != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.validate, mm_got.validate) </span><span class="cov0" title="0">{
                                mmParseRefreshToken.t.Errorf("AuthUsecaseMock.ParseRefreshToken got unexpected parameter validate, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmParseRefreshToken.ParseRefreshTokenMock.defaultExpectation.expectationOrigins.originValidate, *mm_want_ptrs.validate, mm_got.validate, minimock.Diff(*mm_want_ptrs.validate, mm_got.validate))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmParseRefreshToken.t.Errorf("AuthUsecaseMock.ParseRefreshToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmParseRefreshToken.ParseRefreshTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmParseRefreshToken.ParseRefreshTokenMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmParseRefreshToken.t.Fatal("No results are set for the AuthUsecaseMock.ParseRefreshToken")
                }</span>
                <span class="cov0" title="0">return (*mm_results).res, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmParseRefreshToken.funcParseRefreshToken != nil </span><span class="cov0" title="0">{
                return mmParseRefreshToken.funcParseRefreshToken(token, validate)
        }</span>
        <span class="cov0" title="0">mmParseRefreshToken.t.Fatalf("Unexpected call to AuthUsecaseMock.ParseRefreshToken. %v %v", token, validate)
        return</span>
}

// ParseRefreshTokenAfterCounter returns a count of finished AuthUsecaseMock.ParseRefreshToken invocations
func (mmParseRefreshToken *AuthUsecaseMock) ParseRefreshTokenAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmParseRefreshToken.afterParseRefreshTokenCounter)
}</span>

// ParseRefreshTokenBeforeCounter returns a count of AuthUsecaseMock.ParseRefreshToken invocations
func (mmParseRefreshToken *AuthUsecaseMock) ParseRefreshTokenBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmParseRefreshToken.beforeParseRefreshTokenCounter)
}</span>

// Calls returns a list of arguments used in each call to AuthUsecaseMock.ParseRefreshToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) Calls() []*AuthUsecaseMockParseRefreshTokenParams <span class="cov0" title="0">{
        mmParseRefreshToken.mutex.RLock()

        argCopy := make([]*AuthUsecaseMockParseRefreshTokenParams, len(mmParseRefreshToken.callArgs))
        copy(argCopy, mmParseRefreshToken.callArgs)

        mmParseRefreshToken.mutex.RUnlock()

        return argCopy
}</span>

// MinimockParseRefreshTokenDone returns true if the count of the ParseRefreshToken invocations corresponds
// the number of defined expectations
func (m *AuthUsecaseMock) MinimockParseRefreshTokenDone() bool <span class="cov0" title="0">{
        if m.ParseRefreshTokenMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.ParseRefreshTokenMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.ParseRefreshTokenMock.invocationsDone()</span>
}

// MinimockParseRefreshTokenInspect logs each unmet expectation
func (m *AuthUsecaseMock) MinimockParseRefreshTokenInspect() <span class="cov0" title="0">{
        for _, e := range m.ParseRefreshTokenMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AuthUsecaseMock.ParseRefreshToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterParseRefreshTokenCounter := mm_atomic.LoadUint64(&amp;m.afterParseRefreshTokenCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.ParseRefreshTokenMock.defaultExpectation != nil &amp;&amp; afterParseRefreshTokenCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.ParseRefreshTokenMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to AuthUsecaseMock.ParseRefreshToken at\n%s", m.ParseRefreshTokenMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to AuthUsecaseMock.ParseRefreshToken at\n%s with params: %#v", m.ParseRefreshTokenMock.defaultExpectation.expectationOrigins.origin, *m.ParseRefreshTokenMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcParseRefreshToken != nil &amp;&amp; afterParseRefreshTokenCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to AuthUsecaseMock.ParseRefreshToken at\n%s", m.funcParseRefreshTokenOrigin)
        }</span>

        <span class="cov0" title="0">if !m.ParseRefreshTokenMock.invocationsDone() &amp;&amp; afterParseRefreshTokenCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to AuthUsecaseMock.ParseRefreshToken at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.ParseRefreshTokenMock.expectedInvocations), m.ParseRefreshTokenMock.expectedInvocationsOrigin, afterParseRefreshTokenCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthUsecaseMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockGenerateNewClaimsInspect()

                        m.MinimockIsSessionConfirmedInspect()

                        m.MinimockIssueAccessJWTInspect()

                        m.MinimockIssueRefreshJWTInspect()

                        m.MinimockLoginByEmailInspect()

                        m.MinimockParseRefreshTokenInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthUsecaseMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *AuthUsecaseMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockGenerateNewClaimsDone() &amp;&amp;
                m.MinimockIsSessionConfirmedDone() &amp;&amp;
                m.MinimockIssueAccessJWTDone() &amp;&amp;
                m.MinimockIssueRefreshJWTDone() &amp;&amp;
                m.MinimockLoginByEmailDone() &amp;&amp;
                m.MinimockParseRefreshTokenDone()
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase.SessionRepository -o session_repository.go -n SessionRepositoryMock -p mocks

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/auth/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
        mm_usecase "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
)

// SessionRepositoryMock implements mm_usecase.SessionRepository
type SessionRepositoryMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcCreate          func(ctx context.Context, item *entity.Session) (err error)
        funcCreateOrigin    string
        inspectFuncCreate   func(ctx context.Context, item *entity.Session)
        afterCreateCounter  uint64
        beforeCreateCounter uint64
        CreateMock          mSessionRepositoryMockCreate

        funcFindList          func(ctx context.Context, listOptions *mm_usecase.SessionListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Session, err error)
        funcFindListOrigin    string
        inspectFuncFindList   func(ctx context.Context, listOptions *mm_usecase.SessionListOptions, queryParams *uctypes.QueryGetListParams)
        afterFindListCounter  uint64
        beforeFindListCounter uint64
        FindListMock          mSessionRepositoryMockFindList

        funcFindOneByID          func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (session *entity.Session, err error)
        funcFindOneByIDOrigin    string
        inspectFuncFindOneByID   func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)
        afterFindOneByIDCounter  uint64
        beforeFindOneByIDCounter uint64
        FindOneByIDMock          mSessionRepositoryMockFindOneByID

        funcUpdate          func(ctx context.Context, item *entity.Session) (err error)
        funcUpdateOrigin    string
        inspectFuncUpdate   func(ctx context.Context, item *entity.Session)
        afterUpdateCounter  uint64
        beforeUpdateCounter uint64
        UpdateMock          mSessionRepositoryMockUpdate
}

// NewSessionRepositoryMock returns a mock for mm_usecase.SessionRepository
func NewSessionRepositoryMock(t minimock.Tester) *SessionRepositoryMock <span class="cov0" title="0">{
        m := &amp;SessionRepositoryMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.CreateMock = mSessionRepositoryMockCreate{mock: m}
        m.CreateMock.callArgs = []*SessionRepositoryMockCreateParams{}

        m.FindListMock = mSessionRepositoryMockFindList{mock: m}
        m.FindListMock.callArgs = []*SessionRepositoryMockFindListParams{}

        m.FindOneByIDMock = mSessionRepositoryMockFindOneByID{mock: m}
        m.FindOneByIDMock.callArgs = []*SessionRepositoryMockFindOneByIDParams{}

        m.UpdateMock = mSessionRepositoryMockUpdate{mock: m}
        m.UpdateMock.callArgs = []*SessionRepositoryMockUpdateParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mSessionRepositoryMockCreate struct {
        optional           bool
        mock               *SessionRepositoryMock
        defaultExpectation *SessionRepositoryMockCreateExpectation
        expectations       []*SessionRepositoryMockCreateExpectation

        callArgs []*SessionRepositoryMockCreateParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// SessionRepositoryMockCreateExpectation specifies expectation struct of the SessionRepository.Create
type SessionRepositoryMockCreateExpectation struct {
        mock               *SessionRepositoryMock
        params             *SessionRepositoryMockCreateParams
        paramPtrs          *SessionRepositoryMockCreateParamPtrs
        expectationOrigins SessionRepositoryMockCreateExpectationOrigins
        results            *SessionRepositoryMockCreateResults
        returnOrigin       string
        Counter            uint64
}

// SessionRepositoryMockCreateParams contains parameters of the SessionRepository.Create
type SessionRepositoryMockCreateParams struct {
        ctx  context.Context
        item *entity.Session
}

// SessionRepositoryMockCreateParamPtrs contains pointers to parameters of the SessionRepository.Create
type SessionRepositoryMockCreateParamPtrs struct {
        ctx  *context.Context
        item **entity.Session
}

// SessionRepositoryMockCreateResults contains results of the SessionRepository.Create
type SessionRepositoryMockCreateResults struct {
        err error
}

// SessionRepositoryMockCreateOrigins contains origins of expectations of the SessionRepository.Create
type SessionRepositoryMockCreateExpectationOrigins struct {
        origin     string
        originCtx  string
        originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mSessionRepositoryMockCreate) Optional() *mSessionRepositoryMockCreate <span class="cov0" title="0">{
        mmCreate.optional = true
        return mmCreate
}</span>

// Expect sets up expected params for SessionRepository.Create
func (mmCreate *mSessionRepositoryMockCreate) Expect(ctx context.Context, item *entity.Session) *mSessionRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("SessionRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;SessionRepositoryMockCreateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("SessionRepositoryMock.Create mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmCreate.defaultExpectation.params = &amp;SessionRepositoryMockCreateParams{ctx, item}
        mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmCreate.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmCreate.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmCreate</span>
}

// ExpectCtxParam1 sets up expected param ctx for SessionRepository.Create
func (mmCreate *mSessionRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mSessionRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("SessionRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;SessionRepositoryMockCreateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("SessionRepositoryMock.Create mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation.paramPtrs = &amp;SessionRepositoryMockCreateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreate.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmCreate</span>
}

// ExpectItemParam2 sets up expected param item for SessionRepository.Create
func (mmCreate *mSessionRepositoryMockCreate) ExpectItemParam2(item *entity.Session) *mSessionRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("SessionRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;SessionRepositoryMockCreateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("SessionRepositoryMock.Create mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation.paramPtrs = &amp;SessionRepositoryMockCreateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreate.defaultExpectation.paramPtrs.item = &amp;item
        mmCreate.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

        return mmCreate</span>
}

// Inspect accepts an inspector function that has same arguments as the SessionRepository.Create
func (mmCreate *mSessionRepositoryMockCreate) Inspect(f func(ctx context.Context, item *entity.Session)) *mSessionRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.inspectFuncCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Inspect function is already set for SessionRepositoryMock.Create")
        }</span>

        <span class="cov0" title="0">mmCreate.mock.inspectFuncCreate = f

        return mmCreate</span>
}

// Return sets up results that will be returned by SessionRepository.Create
func (mmCreate *mSessionRepositoryMockCreate) Return(err error) *SessionRepositoryMock <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("SessionRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;SessionRepositoryMockCreateExpectation{mock: mmCreate.mock}
        }</span>
        <span class="cov0" title="0">mmCreate.defaultExpectation.results = &amp;SessionRepositoryMockCreateResults{err}
        mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmCreate.mock</span>
}

// Set uses given function f to mock the SessionRepository.Create method
func (mmCreate *mSessionRepositoryMockCreate) Set(f func(ctx context.Context, item *entity.Session) (err error)) *SessionRepositoryMock <span class="cov0" title="0">{
        if mmCreate.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Default expectation is already set for the SessionRepository.Create method")
        }</span>

        <span class="cov0" title="0">if len(mmCreate.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Some expectations are already set for the SessionRepository.Create method")
        }</span>

        <span class="cov0" title="0">mmCreate.mock.funcCreate = f
        mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
        return mmCreate.mock</span>
}

// When sets expectation for the SessionRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mSessionRepositoryMockCreate) When(ctx context.Context, item *entity.Session) *SessionRepositoryMockCreateExpectation <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("SessionRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;SessionRepositoryMockCreateExpectation{
                mock:               mmCreate.mock,
                params:             &amp;SessionRepositoryMockCreateParams{ctx, item},
                expectationOrigins: SessionRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmCreate.expectations = append(mmCreate.expectations, expectation)
        return expectation</span>
}

// Then sets up SessionRepository.Create return parameters for the expectation previously defined by the When method
func (e *SessionRepositoryMockCreateExpectation) Then(err error) *SessionRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;SessionRepositoryMockCreateResults{err}
        return e.mock
}</span>

// Times sets number of times SessionRepository.Create should be invoked
func (mmCreate *mSessionRepositoryMockCreate) Times(n uint64) *mSessionRepositoryMockCreate <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Times of SessionRepositoryMock.Create mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmCreate.expectedInvocations, n)
        mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmCreate</span>
}

func (mmCreate *mSessionRepositoryMockCreate) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmCreate.expectations) == 0 &amp;&amp; mmCreate.defaultExpectation == nil &amp;&amp; mmCreate.mock.funcCreate == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmCreate.mock.afterCreateCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmCreate.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Create implements mm_usecase.SessionRepository
func (mmCreate *SessionRepositoryMock) Create(ctx context.Context, item *entity.Session) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmCreate.beforeCreateCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmCreate.afterCreateCounter, 1)

        mmCreate.t.Helper()

        if mmCreate.inspectFuncCreate != nil </span><span class="cov0" title="0">{
                mmCreate.inspectFuncCreate(ctx, item)
        }</span>

        <span class="cov0" title="0">mm_params := SessionRepositoryMockCreateParams{ctx, item}

        // Record call args
        mmCreate.CreateMock.mutex.Lock()
        mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &amp;mm_params)
        mmCreate.CreateMock.mutex.Unlock()

        for _, e := range mmCreate.CreateMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmCreate.CreateMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmCreate.CreateMock.defaultExpectation.Counter, 1)
                mm_want := mmCreate.CreateMock.defaultExpectation.params
                mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

                mm_got := SessionRepositoryMockCreateParams{ctx, item}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmCreate.t.Errorf("SessionRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.item != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.item, mm_got.item) </span><span class="cov0" title="0">{
                                mmCreate.t.Errorf("SessionRepositoryMock.Create got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCreate.CreateMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmCreate.t.Errorf("SessionRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmCreate.CreateMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmCreate.t.Fatal("No results are set for the SessionRepositoryMock.Create")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmCreate.funcCreate != nil </span><span class="cov0" title="0">{
                return mmCreate.funcCreate(ctx, item)
        }</span>
        <span class="cov0" title="0">mmCreate.t.Fatalf("Unexpected call to SessionRepositoryMock.Create. %v %v", ctx, item)
        return</span>
}

// CreateAfterCounter returns a count of finished SessionRepositoryMock.Create invocations
func (mmCreate *SessionRepositoryMock) CreateAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreate.afterCreateCounter)
}</span>

// CreateBeforeCounter returns a count of SessionRepositoryMock.Create invocations
func (mmCreate *SessionRepositoryMock) CreateBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreate.beforeCreateCounter)
}</span>

// Calls returns a list of arguments used in each call to SessionRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mSessionRepositoryMockCreate) Calls() []*SessionRepositoryMockCreateParams <span class="cov0" title="0">{
        mmCreate.mutex.RLock()

        argCopy := make([]*SessionRepositoryMockCreateParams, len(mmCreate.callArgs))
        copy(argCopy, mmCreate.callArgs)

        mmCreate.mutex.RUnlock()

        return argCopy
}</span>

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *SessionRepositoryMock) MinimockCreateDone() bool <span class="cov0" title="0">{
        if m.CreateMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.CreateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.CreateMock.invocationsDone()</span>
}

// MinimockCreateInspect logs each unmet expectation
func (m *SessionRepositoryMock) MinimockCreateInspect() <span class="cov0" title="0">{
        for _, e := range m.CreateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterCreateCounter := mm_atomic.LoadUint64(&amp;m.afterCreateCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.CreateMock.defaultExpectation != nil &amp;&amp; afterCreateCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.CreateMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to SessionRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcCreate != nil &amp;&amp; afterCreateCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to SessionRepositoryMock.Create at\n%s", m.funcCreateOrigin)
        }</span>

        <span class="cov0" title="0">if !m.CreateMock.invocationsDone() &amp;&amp; afterCreateCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to SessionRepositoryMock.Create at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
        }</span>
}

type mSessionRepositoryMockFindList struct {
        optional           bool
        mock               *SessionRepositoryMock
        defaultExpectation *SessionRepositoryMockFindListExpectation
        expectations       []*SessionRepositoryMockFindListExpectation

        callArgs []*SessionRepositoryMockFindListParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// SessionRepositoryMockFindListExpectation specifies expectation struct of the SessionRepository.FindList
type SessionRepositoryMockFindListExpectation struct {
        mock               *SessionRepositoryMock
        params             *SessionRepositoryMockFindListParams
        paramPtrs          *SessionRepositoryMockFindListParamPtrs
        expectationOrigins SessionRepositoryMockFindListExpectationOrigins
        results            *SessionRepositoryMockFindListResults
        returnOrigin       string
        Counter            uint64
}

// SessionRepositoryMockFindListParams contains parameters of the SessionRepository.FindList
type SessionRepositoryMockFindListParams struct {
        ctx         context.Context
        listOptions *mm_usecase.SessionListOptions
        queryParams *uctypes.QueryGetListParams
}

// SessionRepositoryMockFindListParamPtrs contains pointers to parameters of the SessionRepository.FindList
type SessionRepositoryMockFindListParamPtrs struct {
        ctx         *context.Context
        listOptions **mm_usecase.SessionListOptions
        queryParams **uctypes.QueryGetListParams
}

// SessionRepositoryMockFindListResults contains results of the SessionRepository.FindList
type SessionRepositoryMockFindListResults struct {
        items []*entity.Session
        err   error
}

// SessionRepositoryMockFindListOrigins contains origins of expectations of the SessionRepository.FindList
type SessionRepositoryMockFindListExpectationOrigins struct {
        origin            string
        originCtx         string
        originListOptions string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindList *mSessionRepositoryMockFindList) Optional() *mSessionRepositoryMockFindList <span class="cov0" title="0">{
        mmFindList.optional = true
        return mmFindList
}</span>

// Expect sets up expected params for SessionRepository.FindList
func (mmFindList *mSessionRepositoryMockFindList) Expect(ctx context.Context, listOptions *mm_usecase.SessionListOptions, queryParams *uctypes.QueryGetListParams) *mSessionRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("SessionRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;SessionRepositoryMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("SessionRepositoryMock.FindList mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindList.defaultExpectation.params = &amp;SessionRepositoryMockFindListParams{ctx, listOptions, queryParams}
        mmFindList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindList.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindList.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindList.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindList</span>
}

// ExpectCtxParam1 sets up expected param ctx for SessionRepository.FindList
func (mmFindList *mSessionRepositoryMockFindList) ExpectCtxParam1(ctx context.Context) *mSessionRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("SessionRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;SessionRepositoryMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("SessionRepositoryMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;SessionRepositoryMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindList</span>
}

// ExpectListOptionsParam2 sets up expected param listOptions for SessionRepository.FindList
func (mmFindList *mSessionRepositoryMockFindList) ExpectListOptionsParam2(listOptions *mm_usecase.SessionListOptions) *mSessionRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("SessionRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;SessionRepositoryMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("SessionRepositoryMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;SessionRepositoryMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.listOptions = &amp;listOptions
        mmFindList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

        return mmFindList</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for SessionRepository.FindList
func (mmFindList *mSessionRepositoryMockFindList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mSessionRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("SessionRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;SessionRepositoryMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("SessionRepositoryMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;SessionRepositoryMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindList</span>
}

// Inspect accepts an inspector function that has same arguments as the SessionRepository.FindList
func (mmFindList *mSessionRepositoryMockFindList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.SessionListOptions, queryParams *uctypes.QueryGetListParams)) *mSessionRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.inspectFuncFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Inspect function is already set for SessionRepositoryMock.FindList")
        }</span>

        <span class="cov0" title="0">mmFindList.mock.inspectFuncFindList = f

        return mmFindList</span>
}

// Return sets up results that will be returned by SessionRepository.FindList
func (mmFindList *mSessionRepositoryMockFindList) Return(items []*entity.Session, err error) *SessionRepositoryMock <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("SessionRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;SessionRepositoryMockFindListExpectation{mock: mmFindList.mock}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.results = &amp;SessionRepositoryMockFindListResults{items, err}
        mmFindList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindList.mock</span>
}

// Set uses given function f to mock the SessionRepository.FindList method
func (mmFindList *mSessionRepositoryMockFindList) Set(f func(ctx context.Context, listOptions *mm_usecase.SessionListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Session, err error)) *SessionRepositoryMock <span class="cov0" title="0">{
        if mmFindList.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Default expectation is already set for the SessionRepository.FindList method")
        }</span>

        <span class="cov0" title="0">if len(mmFindList.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Some expectations are already set for the SessionRepository.FindList method")
        }</span>

        <span class="cov0" title="0">mmFindList.mock.funcFindList = f
        mmFindList.mock.funcFindListOrigin = minimock.CallerInfo(1)
        return mmFindList.mock</span>
}

// When sets expectation for the SessionRepository.FindList which will trigger the result defined by the following
// Then helper
func (mmFindList *mSessionRepositoryMockFindList) When(ctx context.Context, listOptions *mm_usecase.SessionListOptions, queryParams *uctypes.QueryGetListParams) *SessionRepositoryMockFindListExpectation <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("SessionRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;SessionRepositoryMockFindListExpectation{
                mock:               mmFindList.mock,
                params:             &amp;SessionRepositoryMockFindListParams{ctx, listOptions, queryParams},
                expectationOrigins: SessionRepositoryMockFindListExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindList.expectations = append(mmFindList.expectations, expectation)
        return expectation</span>
}

// Then sets up SessionRepository.FindList return parameters for the expectation previously defined by the When method
func (e *SessionRepositoryMockFindListExpectation) Then(items []*entity.Session, err error) *SessionRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;SessionRepositoryMockFindListResults{items, err}
        return e.mock
}</span>

// Times sets number of times SessionRepository.FindList should be invoked
func (mmFindList *mSessionRepositoryMockFindList) Times(n uint64) *mSessionRepositoryMockFindList <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Times of SessionRepositoryMock.FindList mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindList.expectedInvocations, n)
        mmFindList.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindList</span>
}

func (mmFindList *mSessionRepositoryMockFindList) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindList.expectations) == 0 &amp;&amp; mmFindList.defaultExpectation == nil &amp;&amp; mmFindList.mock.funcFindList == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindList.mock.afterFindListCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindList.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindList implements mm_usecase.SessionRepository
func (mmFindList *SessionRepositoryMock) FindList(ctx context.Context, listOptions *mm_usecase.SessionListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Session, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindList.beforeFindListCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindList.afterFindListCounter, 1)

        mmFindList.t.Helper()

        if mmFindList.inspectFuncFindList != nil </span><span class="cov0" title="0">{
                mmFindList.inspectFuncFindList(ctx, listOptions, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := SessionRepositoryMockFindListParams{ctx, listOptions, queryParams}

        // Record call args
        mmFindList.FindListMock.mutex.Lock()
        mmFindList.FindListMock.callArgs = append(mmFindList.FindListMock.callArgs, &amp;mm_params)
        mmFindList.FindListMock.mutex.Unlock()

        for _, e := range mmFindList.FindListMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.items, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindList.FindListMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindList.FindListMock.defaultExpectation.Counter, 1)
                mm_want := mmFindList.FindListMock.defaultExpectation.params
                mm_want_ptrs := mmFindList.FindListMock.defaultExpectation.paramPtrs

                mm_got := SessionRepositoryMockFindListParams{ctx, listOptions, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("SessionRepositoryMock.FindList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.listOptions != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("SessionRepositoryMock.FindList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("SessionRepositoryMock.FindList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindList.t.Errorf("SessionRepositoryMock.FindList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindList.FindListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindList.FindListMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindList.t.Fatal("No results are set for the SessionRepositoryMock.FindList")
                }</span>
                <span class="cov0" title="0">return (*mm_results).items, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindList.funcFindList != nil </span><span class="cov0" title="0">{
                return mmFindList.funcFindList(ctx, listOptions, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindList.t.Fatalf("Unexpected call to SessionRepositoryMock.FindList. %v %v %v", ctx, listOptions, queryParams)
        return</span>
}

// FindListAfterCounter returns a count of finished SessionRepositoryMock.FindList invocations
func (mmFindList *SessionRepositoryMock) FindListAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindList.afterFindListCounter)
}</span>

// FindListBeforeCounter returns a count of SessionRepositoryMock.FindList invocations
func (mmFindList *SessionRepositoryMock) FindListBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindList.beforeFindListCounter)
}</span>

// Calls returns a list of arguments used in each call to SessionRepositoryMock.FindList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindList *mSessionRepositoryMockFindList) Calls() []*SessionRepositoryMockFindListParams <span class="cov0" title="0">{
        mmFindList.mutex.RLock()

        argCopy := make([]*SessionRepositoryMockFindListParams, len(mmFindList.callArgs))
        copy(argCopy, mmFindList.callArgs)

        mmFindList.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindListDone returns true if the count of the FindList invocations corresponds
// the number of defined expectations
func (m *SessionRepositoryMock) MinimockFindListDone() bool <span class="cov0" title="0">{
        if m.FindListMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindListMock.invocationsDone()</span>
}

// MinimockFindListInspect logs each unmet expectation
func (m *SessionRepositoryMock) MinimockFindListInspect() <span class="cov0" title="0">{
        for _, e := range m.FindListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionRepositoryMock.FindList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindListCounter := mm_atomic.LoadUint64(&amp;m.afterFindListCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindListMock.defaultExpectation != nil &amp;&amp; afterFindListCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindListMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionRepositoryMock.FindList at\n%s", m.FindListMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to SessionRepositoryMock.FindList at\n%s with params: %#v", m.FindListMock.defaultExpectation.expectationOrigins.origin, *m.FindListMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindList != nil &amp;&amp; afterFindListCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to SessionRepositoryMock.FindList at\n%s", m.funcFindListOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindListMock.invocationsDone() &amp;&amp; afterFindListCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to SessionRepositoryMock.FindList at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindListMock.expectedInvocations), m.FindListMock.expectedInvocationsOrigin, afterFindListCounter)
        }</span>
}

type mSessionRepositoryMockFindOneByID struct {
        optional           bool
        mock               *SessionRepositoryMock
        defaultExpectation *SessionRepositoryMockFindOneByIDExpectation
        expectations       []*SessionRepositoryMockFindOneByIDExpectation

        callArgs []*SessionRepositoryMockFindOneByIDParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// SessionRepositoryMockFindOneByIDExpectation specifies expectation struct of the SessionRepository.FindOneByID
type SessionRepositoryMockFindOneByIDExpectation struct {
        mock               *SessionRepositoryMock
        params             *SessionRepositoryMockFindOneByIDParams
        paramPtrs          *SessionRepositoryMockFindOneByIDParamPtrs
        expectationOrigins SessionRepositoryMockFindOneByIDExpectationOrigins
        results            *SessionRepositoryMockFindOneByIDResults
        returnOrigin       string
        Counter            uint64
}

// SessionRepositoryMockFindOneByIDParams contains parameters of the SessionRepository.FindOneByID
type SessionRepositoryMockFindOneByIDParams struct {
        ctx         context.Context
        id          uuid.UUID
        queryParams *uctypes.QueryGetOneParams
}

// SessionRepositoryMockFindOneByIDParamPtrs contains pointers to parameters of the SessionRepository.FindOneByID
type SessionRepositoryMockFindOneByIDParamPtrs struct {
        ctx         *context.Context
        id          *uuid.UUID
        queryParams **uctypes.QueryGetOneParams
}

// SessionRepositoryMockFindOneByIDResults contains results of the SessionRepository.FindOneByID
type SessionRepositoryMockFindOneByIDResults struct {
        session *entity.Session
        err     error
}

// SessionRepositoryMockFindOneByIDOrigins contains origins of expectations of the SessionRepository.FindOneByID
type SessionRepositoryMockFindOneByIDExpectationOrigins struct {
        origin            string
        originCtx         string
        originId          string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindOneByID *mSessionRepositoryMockFindOneByID) Optional() *mSessionRepositoryMockFindOneByID <span class="cov0" title="0">{
        mmFindOneByID.optional = true
        return mmFindOneByID
}</span>

// Expect sets up expected params for SessionRepository.FindOneByID
func (mmFindOneByID *mSessionRepositoryMockFindOneByID) Expect(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *mSessionRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("SessionRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;SessionRepositoryMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("SessionRepositoryMock.FindOneByID mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.params = &amp;SessionRepositoryMockFindOneByIDParams{ctx, id, queryParams}
        mmFindOneByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindOneByID.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindOneByID.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindOneByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindOneByID.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindOneByID</span>
}

// ExpectCtxParam1 sets up expected param ctx for SessionRepository.FindOneByID
func (mmFindOneByID *mSessionRepositoryMockFindOneByID) ExpectCtxParam1(ctx context.Context) *mSessionRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("SessionRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;SessionRepositoryMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("SessionRepositoryMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;SessionRepositoryMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindOneByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// ExpectIdParam2 sets up expected param id for SessionRepository.FindOneByID
func (mmFindOneByID *mSessionRepositoryMockFindOneByID) ExpectIdParam2(id uuid.UUID) *mSessionRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("SessionRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;SessionRepositoryMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("SessionRepositoryMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;SessionRepositoryMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.id = &amp;id
        mmFindOneByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for SessionRepository.FindOneByID
func (mmFindOneByID *mSessionRepositoryMockFindOneByID) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetOneParams) *mSessionRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("SessionRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;SessionRepositoryMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("SessionRepositoryMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;SessionRepositoryMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindOneByID.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// Inspect accepts an inspector function that has same arguments as the SessionRepository.FindOneByID
func (mmFindOneByID *mSessionRepositoryMockFindOneByID) Inspect(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)) *mSessionRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.inspectFuncFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Inspect function is already set for SessionRepositoryMock.FindOneByID")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.mock.inspectFuncFindOneByID = f

        return mmFindOneByID</span>
}

// Return sets up results that will be returned by SessionRepository.FindOneByID
func (mmFindOneByID *mSessionRepositoryMockFindOneByID) Return(session *entity.Session, err error) *SessionRepositoryMock <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("SessionRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;SessionRepositoryMockFindOneByIDExpectation{mock: mmFindOneByID.mock}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.results = &amp;SessionRepositoryMockFindOneByIDResults{session, err}
        mmFindOneByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindOneByID.mock</span>
}

// Set uses given function f to mock the SessionRepository.FindOneByID method
func (mmFindOneByID *mSessionRepositoryMockFindOneByID) Set(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (session *entity.Session, err error)) *SessionRepositoryMock <span class="cov0" title="0">{
        if mmFindOneByID.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Default expectation is already set for the SessionRepository.FindOneByID method")
        }</span>

        <span class="cov0" title="0">if len(mmFindOneByID.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Some expectations are already set for the SessionRepository.FindOneByID method")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.mock.funcFindOneByID = f
        mmFindOneByID.mock.funcFindOneByIDOrigin = minimock.CallerInfo(1)
        return mmFindOneByID.mock</span>
}

// When sets expectation for the SessionRepository.FindOneByID which will trigger the result defined by the following
// Then helper
func (mmFindOneByID *mSessionRepositoryMockFindOneByID) When(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *SessionRepositoryMockFindOneByIDExpectation <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("SessionRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;SessionRepositoryMockFindOneByIDExpectation{
                mock:               mmFindOneByID.mock,
                params:             &amp;SessionRepositoryMockFindOneByIDParams{ctx, id, queryParams},
                expectationOrigins: SessionRepositoryMockFindOneByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindOneByID.expectations = append(mmFindOneByID.expectations, expectation)
        return expectation</span>
}

// Then sets up SessionRepository.FindOneByID return parameters for the expectation previously defined by the When method
func (e *SessionRepositoryMockFindOneByIDExpectation) Then(session *entity.Session, err error) *SessionRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;SessionRepositoryMockFindOneByIDResults{session, err}
        return e.mock
}</span>

// Times sets number of times SessionRepository.FindOneByID should be invoked
func (mmFindOneByID *mSessionRepositoryMockFindOneByID) Times(n uint64) *mSessionRepositoryMockFindOneByID <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Times of SessionRepositoryMock.FindOneByID mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindOneByID.expectedInvocations, n)
        mmFindOneByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindOneByID</span>
}

func (mmFindOneByID *mSessionRepositoryMockFindOneByID) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindOneByID.expectations) == 0 &amp;&amp; mmFindOneByID.defaultExpectation == nil &amp;&amp; mmFindOneByID.mock.funcFindOneByID == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByID.mock.afterFindOneByIDCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByID.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindOneByID implements mm_usecase.SessionRepository
func (mmFindOneByID *SessionRepositoryMock) FindOneByID(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (session *entity.Session, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindOneByID.beforeFindOneByIDCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindOneByID.afterFindOneByIDCounter, 1)

        mmFindOneByID.t.Helper()

        if mmFindOneByID.inspectFuncFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.inspectFuncFindOneByID(ctx, id, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := SessionRepositoryMockFindOneByIDParams{ctx, id, queryParams}

        // Record call args
        mmFindOneByID.FindOneByIDMock.mutex.Lock()
        mmFindOneByID.FindOneByIDMock.callArgs = append(mmFindOneByID.FindOneByIDMock.callArgs, &amp;mm_params)
        mmFindOneByID.FindOneByIDMock.mutex.Unlock()

        for _, e := range mmFindOneByID.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.session, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindOneByID.FindOneByIDMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindOneByID.FindOneByIDMock.defaultExpectation.Counter, 1)
                mm_want := mmFindOneByID.FindOneByIDMock.defaultExpectation.params
                mm_want_ptrs := mmFindOneByID.FindOneByIDMock.defaultExpectation.paramPtrs

                mm_got := SessionRepositoryMockFindOneByIDParams{ctx, id, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("SessionRepositoryMock.FindOneByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("SessionRepositoryMock.FindOneByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("SessionRepositoryMock.FindOneByID got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindOneByID.t.Errorf("SessionRepositoryMock.FindOneByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindOneByID.FindOneByIDMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindOneByID.t.Fatal("No results are set for the SessionRepositoryMock.FindOneByID")
                }</span>
                <span class="cov0" title="0">return (*mm_results).session, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindOneByID.funcFindOneByID != nil </span><span class="cov0" title="0">{
                return mmFindOneByID.funcFindOneByID(ctx, id, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindOneByID.t.Fatalf("Unexpected call to SessionRepositoryMock.FindOneByID. %v %v %v", ctx, id, queryParams)
        return</span>
}

// FindOneByIDAfterCounter returns a count of finished SessionRepositoryMock.FindOneByID invocations
func (mmFindOneByID *SessionRepositoryMock) FindOneByIDAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByID.afterFindOneByIDCounter)
}</span>

// FindOneByIDBeforeCounter returns a count of SessionRepositoryMock.FindOneByID invocations
func (mmFindOneByID *SessionRepositoryMock) FindOneByIDBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByID.beforeFindOneByIDCounter)
}</span>

// Calls returns a list of arguments used in each call to SessionRepositoryMock.FindOneByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindOneByID *mSessionRepositoryMockFindOneByID) Calls() []*SessionRepositoryMockFindOneByIDParams <span class="cov0" title="0">{
        mmFindOneByID.mutex.RLock()

        argCopy := make([]*SessionRepositoryMockFindOneByIDParams, len(mmFindOneByID.callArgs))
        copy(argCopy, mmFindOneByID.callArgs)

        mmFindOneByID.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindOneByIDDone returns true if the count of the FindOneByID invocations corresponds
// the number of defined expectations
func (m *SessionRepositoryMock) MinimockFindOneByIDDone() bool <span class="cov0" title="0">{
        if m.FindOneByIDMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindOneByIDMock.invocationsDone()</span>
}

// MinimockFindOneByIDInspect logs each unmet expectation
func (m *SessionRepositoryMock) MinimockFindOneByIDInspect() <span class="cov0" title="0">{
        for _, e := range m.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionRepositoryMock.FindOneByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindOneByIDCounter := mm_atomic.LoadUint64(&amp;m.afterFindOneByIDCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindOneByIDMock.defaultExpectation != nil &amp;&amp; afterFindOneByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindOneByIDMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionRepositoryMock.FindOneByID at\n%s", m.FindOneByIDMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to SessionRepositoryMock.FindOneByID at\n%s with params: %#v", m.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *m.FindOneByIDMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindOneByID != nil &amp;&amp; afterFindOneByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to SessionRepositoryMock.FindOneByID at\n%s", m.funcFindOneByIDOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindOneByIDMock.invocationsDone() &amp;&amp; afterFindOneByIDCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to SessionRepositoryMock.FindOneByID at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindOneByIDMock.expectedInvocations), m.FindOneByIDMock.expectedInvocationsOrigin, afterFindOneByIDCounter)
        }</span>
}

type mSessionRepositoryMockUpdate struct {
        optional           bool
        mock               *SessionRepositoryMock
        defaultExpectation *SessionRepositoryMockUpdateExpectation
        expectations       []*SessionRepositoryMockUpdateExpectation

        callArgs []*SessionRepositoryMockUpdateParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// SessionRepositoryMockUpdateExpectation specifies expectation struct of the SessionRepository.Update
type SessionRepositoryMockUpdateExpectation struct {
        mock               *SessionRepositoryMock
        params             *SessionRepositoryMockUpdateParams
        paramPtrs          *SessionRepositoryMockUpdateParamPtrs
        expectationOrigins SessionRepositoryMockUpdateExpectationOrigins
        results            *SessionRepositoryMockUpdateResults
        returnOrigin       string
        Counter            uint64
}

// SessionRepositoryMockUpdateParams contains parameters of the SessionRepository.Update
type SessionRepositoryMockUpdateParams struct {
        ctx  context.Context
        item *entity.Session
}

// SessionRepositoryMockUpdateParamPtrs contains pointers to parameters of the SessionRepository.Update
type SessionRepositoryMockUpdateParamPtrs struct {
        ctx  *context.Context
        item **entity.Session
}

// SessionRepositoryMockUpdateResults contains results of the SessionRepository.Update
type SessionRepositoryMockUpdateResults struct {
        err error
}

// SessionRepositoryMockUpdateOrigins contains origins of expectations of the SessionRepository.Update
type SessionRepositoryMockUpdateExpectationOrigins struct {
        origin     string
        originCtx  string
        originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mSessionRepositoryMockUpdate) Optional() *mSessionRepositoryMockUpdate <span class="cov0" title="0">{
        mmUpdate.optional = true
        return mmUpdate
}</span>

// Expect sets up expected params for SessionRepository.Update
func (mmUpdate *mSessionRepositoryMockUpdate) Expect(ctx context.Context, item *entity.Session) *mSessionRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;SessionRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionRepositoryMock.Update mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmUpdate.defaultExpectation.params = &amp;SessionRepositoryMockUpdateParams{ctx, item}
        mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmUpdate.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmUpdate</span>
}

// ExpectCtxParam1 sets up expected param ctx for SessionRepository.Update
func (mmUpdate *mSessionRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mSessionRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;SessionRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionRepositoryMock.Update mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation.paramPtrs = &amp;SessionRepositoryMockUpdateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmUpdate</span>
}

// ExpectItemParam2 sets up expected param item for SessionRepository.Update
func (mmUpdate *mSessionRepositoryMockUpdate) ExpectItemParam2(item *entity.Session) *mSessionRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;SessionRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionRepositoryMock.Update mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation.paramPtrs = &amp;SessionRepositoryMockUpdateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.paramPtrs.item = &amp;item
        mmUpdate.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

        return mmUpdate</span>
}

// Inspect accepts an inspector function that has same arguments as the SessionRepository.Update
func (mmUpdate *mSessionRepositoryMockUpdate) Inspect(f func(ctx context.Context, item *entity.Session)) *mSessionRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.inspectFuncUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Inspect function is already set for SessionRepositoryMock.Update")
        }</span>

        <span class="cov0" title="0">mmUpdate.mock.inspectFuncUpdate = f

        return mmUpdate</span>
}

// Return sets up results that will be returned by SessionRepository.Update
func (mmUpdate *mSessionRepositoryMockUpdate) Return(err error) *SessionRepositoryMock <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;SessionRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.results = &amp;SessionRepositoryMockUpdateResults{err}
        mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmUpdate.mock</span>
}

// Set uses given function f to mock the SessionRepository.Update method
func (mmUpdate *mSessionRepositoryMockUpdate) Set(f func(ctx context.Context, item *entity.Session) (err error)) *SessionRepositoryMock <span class="cov0" title="0">{
        if mmUpdate.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Default expectation is already set for the SessionRepository.Update method")
        }</span>

        <span class="cov0" title="0">if len(mmUpdate.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Some expectations are already set for the SessionRepository.Update method")
        }</span>

        <span class="cov0" title="0">mmUpdate.mock.funcUpdate = f
        mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
        return mmUpdate.mock</span>
}

// When sets expectation for the SessionRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mSessionRepositoryMockUpdate) When(ctx context.Context, item *entity.Session) *SessionRepositoryMockUpdateExpectation <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;SessionRepositoryMockUpdateExpectation{
                mock:               mmUpdate.mock,
                params:             &amp;SessionRepositoryMockUpdateParams{ctx, item},
                expectationOrigins: SessionRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmUpdate.expectations = append(mmUpdate.expectations, expectation)
        return expectation</span>
}

// Then sets up SessionRepository.Update return parameters for the expectation previously defined by the When method
func (e *SessionRepositoryMockUpdateExpectation) Then(err error) *SessionRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;SessionRepositoryMockUpdateResults{err}
        return e.mock
}</span>

// Times sets number of times SessionRepository.Update should be invoked
func (mmUpdate *mSessionRepositoryMockUpdate) Times(n uint64) *mSessionRepositoryMockUpdate <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Times of SessionRepositoryMock.Update mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmUpdate.expectedInvocations, n)
        mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmUpdate</span>
}

func (mmUpdate *mSessionRepositoryMockUpdate) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmUpdate.expectations) == 0 &amp;&amp; mmUpdate.defaultExpectation == nil &amp;&amp; mmUpdate.mock.funcUpdate == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmUpdate.mock.afterUpdateCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmUpdate.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Update implements mm_usecase.SessionRepository
func (mmUpdate *SessionRepositoryMock) Update(ctx context.Context, item *entity.Session) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmUpdate.beforeUpdateCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmUpdate.afterUpdateCounter, 1)

        mmUpdate.t.Helper()

        if mmUpdate.inspectFuncUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.inspectFuncUpdate(ctx, item)
        }</span>

        <span class="cov0" title="0">mm_params := SessionRepositoryMockUpdateParams{ctx, item}

        // Record call args
        mmUpdate.UpdateMock.mutex.Lock()
        mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &amp;mm_params)
        mmUpdate.UpdateMock.mutex.Unlock()

        for _, e := range mmUpdate.UpdateMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmUpdate.UpdateMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
                mm_want := mmUpdate.UpdateMock.defaultExpectation.params
                mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

                mm_got := SessionRepositoryMockUpdateParams{ctx, item}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmUpdate.t.Errorf("SessionRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.item != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.item, mm_got.item) </span><span class="cov0" title="0">{
                                mmUpdate.t.Errorf("SessionRepositoryMock.Update got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmUpdate.t.Errorf("SessionRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmUpdate.UpdateMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmUpdate.t.Fatal("No results are set for the SessionRepositoryMock.Update")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmUpdate.funcUpdate != nil </span><span class="cov0" title="0">{
                return mmUpdate.funcUpdate(ctx, item)
        }</span>
        <span class="cov0" title="0">mmUpdate.t.Fatalf("Unexpected call to SessionRepositoryMock.Update. %v %v", ctx, item)
        return</span>
}

// UpdateAfterCounter returns a count of finished SessionRepositoryMock.Update invocations
func (mmUpdate *SessionRepositoryMock) UpdateAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdate.afterUpdateCounter)
}</span>

// UpdateBeforeCounter returns a count of SessionRepositoryMock.Update invocations
func (mmUpdate *SessionRepositoryMock) UpdateBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdate.beforeUpdateCounter)
}</span>

// Calls returns a list of arguments used in each call to SessionRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mSessionRepositoryMockUpdate) Calls() []*SessionRepositoryMockUpdateParams <span class="cov0" title="0">{
        mmUpdate.mutex.RLock()

        argCopy := make([]*SessionRepositoryMockUpdateParams, len(mmUpdate.callArgs))
        copy(argCopy, mmUpdate.callArgs)

        mmUpdate.mutex.RUnlock()

        return argCopy
}</span>

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *SessionRepositoryMock) MinimockUpdateDone() bool <span class="cov0" title="0">{
        if m.UpdateMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.UpdateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.UpdateMock.invocationsDone()</span>
}

// MinimockUpdateInspect logs each unmet expectation
func (m *SessionRepositoryMock) MinimockUpdateInspect() <span class="cov0" title="0">{
        for _, e := range m.UpdateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterUpdateCounter := mm_atomic.LoadUint64(&amp;m.afterUpdateCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.UpdateMock.defaultExpectation != nil &amp;&amp; afterUpdateCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.UpdateMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to SessionRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcUpdate != nil &amp;&amp; afterUpdateCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to SessionRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
        }</span>

        <span class="cov0" title="0">if !m.UpdateMock.invocationsDone() &amp;&amp; afterUpdateCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to SessionRepositoryMock.Update at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SessionRepositoryMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockCreateInspect()

                        m.MinimockFindListInspect()

                        m.MinimockFindOneByIDInspect()

                        m.MinimockUpdateInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SessionRepositoryMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *SessionRepositoryMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockCreateDone() &amp;&amp;
                m.MinimockFindListDone() &amp;&amp;
                m.MinimockFindOneByIDDone() &amp;&amp;
                m.MinimockUpdateDone()
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase.SessionUsecase -o session_usecase.go -n SessionUsecaseMock -p mocks

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/auth/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
        mm_usecase "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
)

// SessionUsecaseMock implements mm_usecase.SessionUsecase
type SessionUsecaseMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcCreate          func(ctx context.Context, item *entity.Session) (err error)
        funcCreateOrigin    string
        inspectFuncCreate   func(ctx context.Context, item *entity.Session)
        afterCreateCounter  uint64
        beforeCreateCounter uint64
        CreateMock          mSessionUsecaseMockCreate

        funcFindList          func(ctx context.Context, listOptions *mm_usecase.SessionListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Session, err error)
        funcFindListOrigin    string
        inspectFuncFindList   func(ctx context.Context, listOptions *mm_usecase.SessionListOptions, queryParams *uctypes.QueryGetListParams)
        afterFindListCounter  uint64
        beforeFindListCounter uint64
        FindListMock          mSessionUsecaseMockFindList

        funcFindOneByID          func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (session *entity.Session, err error)
        funcFindOneByIDOrigin    string
        inspectFuncFindOneByID   func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)
        afterFindOneByIDCounter  uint64
        beforeFindOneByIDCounter uint64
        FindOneByIDMock          mSessionUsecaseMockFindOneByID

        funcRevokeSessionByID          func(ctx context.Context, ID uuid.UUID) (err error)
        funcRevokeSessionByIDOrigin    string
        inspectFuncRevokeSessionByID   func(ctx context.Context, ID uuid.UUID)
        afterRevokeSessionByIDCounter  uint64
        beforeRevokeSessionByIDCounter uint64
        RevokeSessionByIDMock          mSessionUsecaseMockRevokeSessionByID

        funcRevokeSessionsByAccountID          func(ctx context.Context, accountID uuid.UUID) (err error)
        funcRevokeSessionsByAccountIDOrigin    string
        inspectFuncRevokeSessionsByAccountID   func(ctx context.Context, accountID uuid.UUID)
        afterRevokeSessionsByAccountIDCounter  uint64
        beforeRevokeSessionsByAccountIDCounter uint64
        RevokeSessionsByAccountIDMock          mSessionUsecaseMockRevokeSessionsByAccountID

        funcUpdate          func(ctx context.Context, item *entity.Session) (err error)
        funcUpdateOrigin    string
        inspectFuncUpdate   func(ctx context.Context, item *entity.Session)
        afterUpdateCounter  uint64
        beforeUpdateCounter uint64
        UpdateMock          mSessionUsecaseMockUpdate
}

// NewSessionUsecaseMock returns a mock for mm_usecase.SessionUsecase
func NewSessionUsecaseMock(t minimock.Tester) *SessionUsecaseMock <span class="cov0" title="0">{
        m := &amp;SessionUsecaseMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.CreateMock = mSessionUsecaseMockCreate{mock: m}
        m.CreateMock.callArgs = []*SessionUsecaseMockCreateParams{}

        m.FindListMock = mSessionUsecaseMockFindList{mock: m}
        m.FindListMock.callArgs = []*SessionUsecaseMockFindListParams{}

        m.FindOneByIDMock = mSessionUsecaseMockFindOneByID{mock: m}
        m.FindOneByIDMock.callArgs = []*SessionUsecaseMockFindOneByIDParams{}

        m.RevokeSessionByIDMock = mSessionUsecaseMockRevokeSessionByID{mock: m}
        m.RevokeSessionByIDMock.callArgs = []*SessionUsecaseMockRevokeSessionByIDParams{}

        m.RevokeSessionsByAccountIDMock = mSessionUsecaseMockRevokeSessionsByAccountID{mock: m}
        m.RevokeSessionsByAccountIDMock.callArgs = []*SessionUsecaseMockRevokeSessionsByAccountIDParams{}

        m.UpdateMock = mSessionUsecaseMockUpdate{mock: m}
        m.UpdateMock.callArgs = []*SessionUsecaseMockUpdateParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mSessionUsecaseMockCreate struct {
        optional           bool
        mock               *SessionUsecaseMock
        defaultExpectation *SessionUsecaseMockCreateExpectation
        expectations       []*SessionUsecaseMockCreateExpectation

        callArgs []*SessionUsecaseMockCreateParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// SessionUsecaseMockCreateExpectation specifies expectation struct of the SessionUsecase.Create
type SessionUsecaseMockCreateExpectation struct {
        mock               *SessionUsecaseMock
        params             *SessionUsecaseMockCreateParams
        paramPtrs          *SessionUsecaseMockCreateParamPtrs
        expectationOrigins SessionUsecaseMockCreateExpectationOrigins
        results            *SessionUsecaseMockCreateResults
        returnOrigin       string
        Counter            uint64
}

// SessionUsecaseMockCreateParams contains parameters of the SessionUsecase.Create
type SessionUsecaseMockCreateParams struct {
        ctx  context.Context
        item *entity.Session
}

// SessionUsecaseMockCreateParamPtrs contains pointers to parameters of the SessionUsecase.Create
type SessionUsecaseMockCreateParamPtrs struct {
        ctx  *context.Context
        item **entity.Session
}

// SessionUsecaseMockCreateResults contains results of the SessionUsecase.Create
type SessionUsecaseMockCreateResults struct {
        err error
}

// SessionUsecaseMockCreateOrigins contains origins of expectations of the SessionUsecase.Create
type SessionUsecaseMockCreateExpectationOrigins struct {
        origin     string
        originCtx  string
        originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mSessionUsecaseMockCreate) Optional() *mSessionUsecaseMockCreate <span class="cov0" title="0">{
        mmCreate.optional = true
        return mmCreate
}</span>

// Expect sets up expected params for SessionUsecase.Create
func (mmCreate *mSessionUsecaseMockCreate) Expect(ctx context.Context, item *entity.Session) *mSessionUsecaseMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("SessionUsecaseMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;SessionUsecaseMockCreateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("SessionUsecaseMock.Create mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmCreate.defaultExpectation.params = &amp;SessionUsecaseMockCreateParams{ctx, item}
        mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmCreate.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmCreate.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmCreate</span>
}

// ExpectCtxParam1 sets up expected param ctx for SessionUsecase.Create
func (mmCreate *mSessionUsecaseMockCreate) ExpectCtxParam1(ctx context.Context) *mSessionUsecaseMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("SessionUsecaseMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;SessionUsecaseMockCreateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("SessionUsecaseMock.Create mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation.paramPtrs = &amp;SessionUsecaseMockCreateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreate.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmCreate</span>
}

// ExpectItemParam2 sets up expected param item for SessionUsecase.Create
func (mmCreate *mSessionUsecaseMockCreate) ExpectItemParam2(item *entity.Session) *mSessionUsecaseMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("SessionUsecaseMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;SessionUsecaseMockCreateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("SessionUsecaseMock.Create mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation.paramPtrs = &amp;SessionUsecaseMockCreateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreate.defaultExpectation.paramPtrs.item = &amp;item
        mmCreate.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

        return mmCreate</span>
}

// Inspect accepts an inspector function that has same arguments as the SessionUsecase.Create
func (mmCreate *mSessionUsecaseMockCreate) Inspect(f func(ctx context.Context, item *entity.Session)) *mSessionUsecaseMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.inspectFuncCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Inspect function is already set for SessionUsecaseMock.Create")
        }</span>

        <span class="cov0" title="0">mmCreate.mock.inspectFuncCreate = f

        return mmCreate</span>
}

// Return sets up results that will be returned by SessionUsecase.Create
func (mmCreate *mSessionUsecaseMockCreate) Return(err error) *SessionUsecaseMock <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("SessionUsecaseMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;SessionUsecaseMockCreateExpectation{mock: mmCreate.mock}
        }</span>
        <span class="cov0" title="0">mmCreate.defaultExpectation.results = &amp;SessionUsecaseMockCreateResults{err}
        mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmCreate.mock</span>
}

// Set uses given function f to mock the SessionUsecase.Create method
func (mmCreate *mSessionUsecaseMockCreate) Set(f func(ctx context.Context, item *entity.Session) (err error)) *SessionUsecaseMock <span class="cov0" title="0">{
        if mmCreate.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Default expectation is already set for the SessionUsecase.Create method")
        }</span>

        <span class="cov0" title="0">if len(mmCreate.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Some expectations are already set for the SessionUsecase.Create method")
        }</span>

        <span class="cov0" title="0">mmCreate.mock.funcCreate = f
        mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
        return mmCreate.mock</span>
}

// When sets expectation for the SessionUsecase.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mSessionUsecaseMockCreate) When(ctx context.Context, item *entity.Session) *SessionUsecaseMockCreateExpectation <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("SessionUsecaseMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;SessionUsecaseMockCreateExpectation{
                mock:               mmCreate.mock,
                params:             &amp;SessionUsecaseMockCreateParams{ctx, item},
                expectationOrigins: SessionUsecaseMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmCreate.expectations = append(mmCreate.expectations, expectation)
        return expectation</span>
}

// Then sets up SessionUsecase.Create return parameters for the expectation previously defined by the When method
func (e *SessionUsecaseMockCreateExpectation) Then(err error) *SessionUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;SessionUsecaseMockCreateResults{err}
        return e.mock
}</span>

// Times sets number of times SessionUsecase.Create should be invoked
func (mmCreate *mSessionUsecaseMockCreate) Times(n uint64) *mSessionUsecaseMockCreate <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Times of SessionUsecaseMock.Create mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmCreate.expectedInvocations, n)
        mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmCreate</span>
}

func (mmCreate *mSessionUsecaseMockCreate) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmCreate.expectations) == 0 &amp;&amp; mmCreate.defaultExpectation == nil &amp;&amp; mmCreate.mock.funcCreate == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmCreate.mock.afterCreateCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmCreate.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Create implements mm_usecase.SessionUsecase
func (mmCreate *SessionUsecaseMock) Create(ctx context.Context, item *entity.Session) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmCreate.beforeCreateCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmCreate.afterCreateCounter, 1)

        mmCreate.t.Helper()

        if mmCreate.inspectFuncCreate != nil </span><span class="cov0" title="0">{
                mmCreate.inspectFuncCreate(ctx, item)
        }</span>

        <span class="cov0" title="0">mm_params := SessionUsecaseMockCreateParams{ctx, item}

        // Record call args
        mmCreate.CreateMock.mutex.Lock()
        mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &amp;mm_params)
        mmCreate.CreateMock.mutex.Unlock()

        for _, e := range mmCreate.CreateMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmCreate.CreateMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmCreate.CreateMock.defaultExpectation.Counter, 1)
                mm_want := mmCreate.CreateMock.defaultExpectation.params
                mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

                mm_got := SessionUsecaseMockCreateParams{ctx, item}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmCreate.t.Errorf("SessionUsecaseMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.item != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.item, mm_got.item) </span><span class="cov0" title="0">{
                                mmCreate.t.Errorf("SessionUsecaseMock.Create got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCreate.CreateMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmCreate.t.Errorf("SessionUsecaseMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmCreate.CreateMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmCreate.t.Fatal("No results are set for the SessionUsecaseMock.Create")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmCreate.funcCreate != nil </span><span class="cov0" title="0">{
                return mmCreate.funcCreate(ctx, item)
        }</span>
        <span class="cov0" title="0">mmCreate.t.Fatalf("Unexpected call to SessionUsecaseMock.Create. %v %v", ctx, item)
        return</span>
}

// CreateAfterCounter returns a count of finished SessionUsecaseMock.Create invocations
func (mmCreate *SessionUsecaseMock) CreateAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreate.afterCreateCounter)
}</span>

// CreateBeforeCounter returns a count of SessionUsecaseMock.Create invocations
func (mmCreate *SessionUsecaseMock) CreateBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreate.beforeCreateCounter)
}</span>

// Calls returns a list of arguments used in each call to SessionUsecaseMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mSessionUsecaseMockCreate) Calls() []*SessionUsecaseMockCreateParams <span class="cov0" title="0">{
        mmCreate.mutex.RLock()

        argCopy := make([]*SessionUsecaseMockCreateParams, len(mmCreate.callArgs))
        copy(argCopy, mmCreate.callArgs)

        mmCreate.mutex.RUnlock()

        return argCopy
}</span>

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *SessionUsecaseMock) MinimockCreateDone() bool <span class="cov0" title="0">{
        if m.CreateMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.CreateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.CreateMock.invocationsDone()</span>
}

// MinimockCreateInspect logs each unmet expectation
func (m *SessionUsecaseMock) MinimockCreateInspect() <span class="cov0" title="0">{
        for _, e := range m.CreateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionUsecaseMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterCreateCounter := mm_atomic.LoadUint64(&amp;m.afterCreateCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.CreateMock.defaultExpectation != nil &amp;&amp; afterCreateCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.CreateMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionUsecaseMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to SessionUsecaseMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcCreate != nil &amp;&amp; afterCreateCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to SessionUsecaseMock.Create at\n%s", m.funcCreateOrigin)
        }</span>

        <span class="cov0" title="0">if !m.CreateMock.invocationsDone() &amp;&amp; afterCreateCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to SessionUsecaseMock.Create at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
        }</span>
}

type mSessionUsecaseMockFindList struct {
        optional           bool
        mock               *SessionUsecaseMock
        defaultExpectation *SessionUsecaseMockFindListExpectation
        expectations       []*SessionUsecaseMockFindListExpectation

        callArgs []*SessionUsecaseMockFindListParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// SessionUsecaseMockFindListExpectation specifies expectation struct of the SessionUsecase.FindList
type SessionUsecaseMockFindListExpectation struct {
        mock               *SessionUsecaseMock
        params             *SessionUsecaseMockFindListParams
        paramPtrs          *SessionUsecaseMockFindListParamPtrs
        expectationOrigins SessionUsecaseMockFindListExpectationOrigins
        results            *SessionUsecaseMockFindListResults
        returnOrigin       string
        Counter            uint64
}

// SessionUsecaseMockFindListParams contains parameters of the SessionUsecase.FindList
type SessionUsecaseMockFindListParams struct {
        ctx         context.Context
        listOptions *mm_usecase.SessionListOptions
        queryParams *uctypes.QueryGetListParams
}

// SessionUsecaseMockFindListParamPtrs contains pointers to parameters of the SessionUsecase.FindList
type SessionUsecaseMockFindListParamPtrs struct {
        ctx         *context.Context
        listOptions **mm_usecase.SessionListOptions
        queryParams **uctypes.QueryGetListParams
}

// SessionUsecaseMockFindListResults contains results of the SessionUsecase.FindList
type SessionUsecaseMockFindListResults struct {
        items []*entity.Session
        err   error
}

// SessionUsecaseMockFindListOrigins contains origins of expectations of the SessionUsecase.FindList
type SessionUsecaseMockFindListExpectationOrigins struct {
        origin            string
        originCtx         string
        originListOptions string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindList *mSessionUsecaseMockFindList) Optional() *mSessionUsecaseMockFindList <span class="cov0" title="0">{
        mmFindList.optional = true
        return mmFindList
}</span>

// Expect sets up expected params for SessionUsecase.FindList
func (mmFindList *mSessionUsecaseMockFindList) Expect(ctx context.Context, listOptions *mm_usecase.SessionListOptions, queryParams *uctypes.QueryGetListParams) *mSessionUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("SessionUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;SessionUsecaseMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("SessionUsecaseMock.FindList mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindList.defaultExpectation.params = &amp;SessionUsecaseMockFindListParams{ctx, listOptions, queryParams}
        mmFindList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindList.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindList.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindList.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindList</span>
}

// ExpectCtxParam1 sets up expected param ctx for SessionUsecase.FindList
func (mmFindList *mSessionUsecaseMockFindList) ExpectCtxParam1(ctx context.Context) *mSessionUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("SessionUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;SessionUsecaseMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("SessionUsecaseMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;SessionUsecaseMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindList</span>
}

// ExpectListOptionsParam2 sets up expected param listOptions for SessionUsecase.FindList
func (mmFindList *mSessionUsecaseMockFindList) ExpectListOptionsParam2(listOptions *mm_usecase.SessionListOptions) *mSessionUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("SessionUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;SessionUsecaseMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("SessionUsecaseMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;SessionUsecaseMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.listOptions = &amp;listOptions
        mmFindList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

        return mmFindList</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for SessionUsecase.FindList
func (mmFindList *mSessionUsecaseMockFindList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mSessionUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("SessionUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;SessionUsecaseMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("SessionUsecaseMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;SessionUsecaseMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindList</span>
}

// Inspect accepts an inspector function that has same arguments as the SessionUsecase.FindList
func (mmFindList *mSessionUsecaseMockFindList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.SessionListOptions, queryParams *uctypes.QueryGetListParams)) *mSessionUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.inspectFuncFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Inspect function is already set for SessionUsecaseMock.FindList")
        }</span>

        <span class="cov0" title="0">mmFindList.mock.inspectFuncFindList = f

        return mmFindList</span>
}

// Return sets up results that will be returned by SessionUsecase.FindList
func (mmFindList *mSessionUsecaseMockFindList) Return(items []*entity.Session, err error) *SessionUsecaseMock <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("SessionUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;SessionUsecaseMockFindListExpectation{mock: mmFindList.mock}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.results = &amp;SessionUsecaseMockFindListResults{items, err}
        mmFindList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindList.mock</span>
}

// Set uses given function f to mock the SessionUsecase.FindList method
func (mmFindList *mSessionUsecaseMockFindList) Set(f func(ctx context.Context, listOptions *mm_usecase.SessionListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Session, err error)) *SessionUsecaseMock <span class="cov0" title="0">{
        if mmFindList.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Default expectation is already set for the SessionUsecase.FindList method")
        }</span>

        <span class="cov0" title="0">if len(mmFindList.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Some expectations are already set for the SessionUsecase.FindList method")
        }</span>

        <span class="cov0" title="0">mmFindList.mock.funcFindList = f
        mmFindList.mock.funcFindListOrigin = minimock.CallerInfo(1)
        return mmFindList.mock</span>
}

// When sets expectation for the SessionUsecase.FindList which will trigger the result defined by the following
// Then helper
func (mmFindList *mSessionUsecaseMockFindList) When(ctx context.Context, listOptions *mm_usecase.SessionListOptions, queryParams *uctypes.QueryGetListParams) *SessionUsecaseMockFindListExpectation <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("SessionUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;SessionUsecaseMockFindListExpectation{
                mock:               mmFindList.mock,
                params:             &amp;SessionUsecaseMockFindListParams{ctx, listOptions, queryParams},
                expectationOrigins: SessionUsecaseMockFindListExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindList.expectations = append(mmFindList.expectations, expectation)
        return expectation</span>
}

// Then sets up SessionUsecase.FindList return parameters for the expectation previously defined by the When method
func (e *SessionUsecaseMockFindListExpectation) Then(items []*entity.Session, err error) *SessionUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;SessionUsecaseMockFindListResults{items, err}
        return e.mock
}</span>

// Times sets number of times SessionUsecase.FindList should be invoked
func (mmFindList *mSessionUsecaseMockFindList) Times(n uint64) *mSessionUsecaseMockFindList <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Times of SessionUsecaseMock.FindList mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindList.expectedInvocations, n)
        mmFindList.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindList</span>
}

func (mmFindList *mSessionUsecaseMockFindList) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindList.expectations) == 0 &amp;&amp; mmFindList.defaultExpectation == nil &amp;&amp; mmFindList.mock.funcFindList == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindList.mock.afterFindListCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindList.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindList implements mm_usecase.SessionUsecase
func (mmFindList *SessionUsecaseMock) FindList(ctx context.Context, listOptions *mm_usecase.SessionListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Session, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindList.beforeFindListCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindList.afterFindListCounter, 1)

        mmFindList.t.Helper()

        if mmFindList.inspectFuncFindList != nil </span><span class="cov0" title="0">{
                mmFindList.inspectFuncFindList(ctx, listOptions, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := SessionUsecaseMockFindListParams{ctx, listOptions, queryParams}

        // Record call args
        mmFindList.FindListMock.mutex.Lock()
        mmFindList.FindListMock.callArgs = append(mmFindList.FindListMock.callArgs, &amp;mm_params)
        mmFindList.FindListMock.mutex.Unlock()

        for _, e := range mmFindList.FindListMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.items, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindList.FindListMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindList.FindListMock.defaultExpectation.Counter, 1)
                mm_want := mmFindList.FindListMock.defaultExpectation.params
                mm_want_ptrs := mmFindList.FindListMock.defaultExpectation.paramPtrs

                mm_got := SessionUsecaseMockFindListParams{ctx, listOptions, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("SessionUsecaseMock.FindList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.listOptions != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("SessionUsecaseMock.FindList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("SessionUsecaseMock.FindList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindList.t.Errorf("SessionUsecaseMock.FindList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindList.FindListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindList.FindListMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindList.t.Fatal("No results are set for the SessionUsecaseMock.FindList")
                }</span>
                <span class="cov0" title="0">return (*mm_results).items, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindList.funcFindList != nil </span><span class="cov0" title="0">{
                return mmFindList.funcFindList(ctx, listOptions, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindList.t.Fatalf("Unexpected call to SessionUsecaseMock.FindList. %v %v %v", ctx, listOptions, queryParams)
        return</span>
}

// FindListAfterCounter returns a count of finished SessionUsecaseMock.FindList invocations
func (mmFindList *SessionUsecaseMock) FindListAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindList.afterFindListCounter)
}</span>

// FindListBeforeCounter returns a count of SessionUsecaseMock.FindList invocations
func (mmFindList *SessionUsecaseMock) FindListBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindList.beforeFindListCounter)
}</span>

// Calls returns a list of arguments used in each call to SessionUsecaseMock.FindList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindList *mSessionUsecaseMockFindList) Calls() []*SessionUsecaseMockFindListParams <span class="cov0" title="0">{
        mmFindList.mutex.RLock()

        argCopy := make([]*SessionUsecaseMockFindListParams, len(mmFindList.callArgs))
        copy(argCopy, mmFindList.callArgs)

        mmFindList.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindListDone returns true if the count of the FindList invocations corresponds
// the number of defined expectations
func (m *SessionUsecaseMock) MinimockFindListDone() bool <span class="cov0" title="0">{
        if m.FindListMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindListMock.invocationsDone()</span>
}

// MinimockFindListInspect logs each unmet expectation
func (m *SessionUsecaseMock) MinimockFindListInspect() <span class="cov0" title="0">{
        for _, e := range m.FindListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionUsecaseMock.FindList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindListCounter := mm_atomic.LoadUint64(&amp;m.afterFindListCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindListMock.defaultExpectation != nil &amp;&amp; afterFindListCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindListMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionUsecaseMock.FindList at\n%s", m.FindListMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to SessionUsecaseMock.FindList at\n%s with params: %#v", m.FindListMock.defaultExpectation.expectationOrigins.origin, *m.FindListMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindList != nil &amp;&amp; afterFindListCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to SessionUsecaseMock.FindList at\n%s", m.funcFindListOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindListMock.invocationsDone() &amp;&amp; afterFindListCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to SessionUsecaseMock.FindList at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindListMock.expectedInvocations), m.FindListMock.expectedInvocationsOrigin, afterFindListCounter)
        }</span>
}

type mSessionUsecaseMockFindOneByID struct {
        optional           bool
        mock               *SessionUsecaseMock
        defaultExpectation *SessionUsecaseMockFindOneByIDExpectation
        expectations       []*SessionUsecaseMockFindOneByIDExpectation

        callArgs []*SessionUsecaseMockFindOneByIDParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// SessionUsecaseMockFindOneByIDExpectation specifies expectation struct of the SessionUsecase.FindOneByID
type SessionUsecaseMockFindOneByIDExpectation struct {
        mock               *SessionUsecaseMock
        params             *SessionUsecaseMockFindOneByIDParams
        paramPtrs          *SessionUsecaseMockFindOneByIDParamPtrs
        expectationOrigins SessionUsecaseMockFindOneByIDExpectationOrigins
        results            *SessionUsecaseMockFindOneByIDResults
        returnOrigin       string
        Counter            uint64
}

// SessionUsecaseMockFindOneByIDParams contains parameters of the SessionUsecase.FindOneByID
type SessionUsecaseMockFindOneByIDParams struct {
        ctx         context.Context
        id          uuid.UUID
        queryParams *uctypes.QueryGetOneParams
}

// SessionUsecaseMockFindOneByIDParamPtrs contains pointers to parameters of the SessionUsecase.FindOneByID
type SessionUsecaseMockFindOneByIDParamPtrs struct {
        ctx         *context.Context
        id          *uuid.UUID
        queryParams **uctypes.QueryGetOneParams
}

// SessionUsecaseMockFindOneByIDResults contains results of the SessionUsecase.FindOneByID
type SessionUsecaseMockFindOneByIDResults struct {
        session *entity.Session
        err     error
}

// SessionUsecaseMockFindOneByIDOrigins contains origins of expectations of the SessionUsecase.FindOneByID
type SessionUsecaseMockFindOneByIDExpectationOrigins struct {
        origin            string
        originCtx         string
        originId          string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) Optional() *mSessionUsecaseMockFindOneByID <span class="cov0" title="0">{
        mmFindOneByID.optional = true
        return mmFindOneByID
}</span>

// Expect sets up expected params for SessionUsecase.FindOneByID
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) Expect(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *mSessionUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("SessionUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;SessionUsecaseMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("SessionUsecaseMock.FindOneByID mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.params = &amp;SessionUsecaseMockFindOneByIDParams{ctx, id, queryParams}
        mmFindOneByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindOneByID.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindOneByID.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindOneByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindOneByID.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindOneByID</span>
}

// ExpectCtxParam1 sets up expected param ctx for SessionUsecase.FindOneByID
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) ExpectCtxParam1(ctx context.Context) *mSessionUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("SessionUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;SessionUsecaseMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("SessionUsecaseMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;SessionUsecaseMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindOneByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// ExpectIdParam2 sets up expected param id for SessionUsecase.FindOneByID
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) ExpectIdParam2(id uuid.UUID) *mSessionUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("SessionUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;SessionUsecaseMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("SessionUsecaseMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;SessionUsecaseMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.id = &amp;id
        mmFindOneByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for SessionUsecase.FindOneByID
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetOneParams) *mSessionUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("SessionUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;SessionUsecaseMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("SessionUsecaseMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;SessionUsecaseMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindOneByID.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// Inspect accepts an inspector function that has same arguments as the SessionUsecase.FindOneByID
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) Inspect(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)) *mSessionUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.inspectFuncFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Inspect function is already set for SessionUsecaseMock.FindOneByID")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.mock.inspectFuncFindOneByID = f

        return mmFindOneByID</span>
}

// Return sets up results that will be returned by SessionUsecase.FindOneByID
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) Return(session *entity.Session, err error) *SessionUsecaseMock <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("SessionUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;SessionUsecaseMockFindOneByIDExpectation{mock: mmFindOneByID.mock}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.results = &amp;SessionUsecaseMockFindOneByIDResults{session, err}
        mmFindOneByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindOneByID.mock</span>
}

// Set uses given function f to mock the SessionUsecase.FindOneByID method
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) Set(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (session *entity.Session, err error)) *SessionUsecaseMock <span class="cov0" title="0">{
        if mmFindOneByID.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Default expectation is already set for the SessionUsecase.FindOneByID method")
        }</span>

        <span class="cov0" title="0">if len(mmFindOneByID.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Some expectations are already set for the SessionUsecase.FindOneByID method")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.mock.funcFindOneByID = f
        mmFindOneByID.mock.funcFindOneByIDOrigin = minimock.CallerInfo(1)
        return mmFindOneByID.mock</span>
}

// When sets expectation for the SessionUsecase.FindOneByID which will trigger the result defined by the following
// Then helper
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) When(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *SessionUsecaseMockFindOneByIDExpectation <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("SessionUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;SessionUsecaseMockFindOneByIDExpectation{
                mock:               mmFindOneByID.mock,
                params:             &amp;SessionUsecaseMockFindOneByIDParams{ctx, id, queryParams},
                expectationOrigins: SessionUsecaseMockFindOneByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindOneByID.expectations = append(mmFindOneByID.expectations, expectation)
        return expectation</span>
}

// Then sets up SessionUsecase.FindOneByID return parameters for the expectation previously defined by the When method
func (e *SessionUsecaseMockFindOneByIDExpectation) Then(session *entity.Session, err error) *SessionUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;SessionUsecaseMockFindOneByIDResults{session, err}
        return e.mock
}</span>

// Times sets number of times SessionUsecase.FindOneByID should be invoked
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) Times(n uint64) *mSessionUsecaseMockFindOneByID <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Times of SessionUsecaseMock.FindOneByID mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindOneByID.expectedInvocations, n)
        mmFindOneByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindOneByID</span>
}

func (mmFindOneByID *mSessionUsecaseMockFindOneByID) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindOneByID.expectations) == 0 &amp;&amp; mmFindOneByID.defaultExpectation == nil &amp;&amp; mmFindOneByID.mock.funcFindOneByID == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByID.mock.afterFindOneByIDCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByID.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindOneByID implements mm_usecase.SessionUsecase
func (mmFindOneByID *SessionUsecaseMock) FindOneByID(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (session *entity.Session, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindOneByID.beforeFindOneByIDCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindOneByID.afterFindOneByIDCounter, 1)

        mmFindOneByID.t.Helper()

        if mmFindOneByID.inspectFuncFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.inspectFuncFindOneByID(ctx, id, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := SessionUsecaseMockFindOneByIDParams{ctx, id, queryParams}

        // Record call args
        mmFindOneByID.FindOneByIDMock.mutex.Lock()
        mmFindOneByID.FindOneByIDMock.callArgs = append(mmFindOneByID.FindOneByIDMock.callArgs, &amp;mm_params)
        mmFindOneByID.FindOneByIDMock.mutex.Unlock()

        for _, e := range mmFindOneByID.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.session, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindOneByID.FindOneByIDMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindOneByID.FindOneByIDMock.defaultExpectation.Counter, 1)
                mm_want := mmFindOneByID.FindOneByIDMock.defaultExpectation.params
                mm_want_ptrs := mmFindOneByID.FindOneByIDMock.defaultExpectation.paramPtrs

                mm_got := SessionUsecaseMockFindOneByIDParams{ctx, id, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("SessionUsecaseMock.FindOneByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("SessionUsecaseMock.FindOneByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("SessionUsecaseMock.FindOneByID got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindOneByID.t.Errorf("SessionUsecaseMock.FindOneByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindOneByID.FindOneByIDMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindOneByID.t.Fatal("No results are set for the SessionUsecaseMock.FindOneByID")
                }</span>
                <span class="cov0" title="0">return (*mm_results).session, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindOneByID.funcFindOneByID != nil </span><span class="cov0" title="0">{
                return mmFindOneByID.funcFindOneByID(ctx, id, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindOneByID.t.Fatalf("Unexpected call to SessionUsecaseMock.FindOneByID. %v %v %v", ctx, id, queryParams)
        return</span>
}

// FindOneByIDAfterCounter returns a count of finished SessionUsecaseMock.FindOneByID invocations
func (mmFindOneByID *SessionUsecaseMock) FindOneByIDAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByID.afterFindOneByIDCounter)
}</span>

// FindOneByIDBeforeCounter returns a count of SessionUsecaseMock.FindOneByID invocations
func (mmFindOneByID *SessionUsecaseMock) FindOneByIDBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByID.beforeFindOneByIDCounter)
}</span>

// Calls returns a list of arguments used in each call to SessionUsecaseMock.FindOneByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) Calls() []*SessionUsecaseMockFindOneByIDParams <span class="cov0" title="0">{
        mmFindOneByID.mutex.RLock()

        argCopy := make([]*SessionUsecaseMockFindOneByIDParams, len(mmFindOneByID.callArgs))
        copy(argCopy, mmFindOneByID.callArgs)

        mmFindOneByID.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindOneByIDDone returns true if the count of the FindOneByID invocations corresponds
// the number of defined expectations
func (m *SessionUsecaseMock) MinimockFindOneByIDDone() bool <span class="cov0" title="0">{
        if m.FindOneByIDMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindOneByIDMock.invocationsDone()</span>
}

// MinimockFindOneByIDInspect logs each unmet expectation
func (m *SessionUsecaseMock) MinimockFindOneByIDInspect() <span class="cov0" title="0">{
        for _, e := range m.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionUsecaseMock.FindOneByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindOneByIDCounter := mm_atomic.LoadUint64(&amp;m.afterFindOneByIDCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindOneByIDMock.defaultExpectation != nil &amp;&amp; afterFindOneByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindOneByIDMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionUsecaseMock.FindOneByID at\n%s", m.FindOneByIDMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to SessionUsecaseMock.FindOneByID at\n%s with params: %#v", m.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *m.FindOneByIDMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindOneByID != nil &amp;&amp; afterFindOneByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to SessionUsecaseMock.FindOneByID at\n%s", m.funcFindOneByIDOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindOneByIDMock.invocationsDone() &amp;&amp; afterFindOneByIDCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to SessionUsecaseMock.FindOneByID at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindOneByIDMock.expectedInvocations), m.FindOneByIDMock.expectedInvocationsOrigin, afterFindOneByIDCounter)
        }</span>
}

type mSessionUsecaseMockRevokeSessionByID struct {
        optional           bool
        mock               *SessionUsecaseMock
        defaultExpectation *SessionUsecaseMockRevokeSessionByIDExpectation
        expectations       []*SessionUsecaseMockRevokeSessionByIDExpectation

        callArgs []*SessionUsecaseMockRevokeSessionByIDParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// SessionUsecaseMockRevokeSessionByIDExpectation specifies expectation struct of the SessionUsecase.RevokeSessionByID
type SessionUsecaseMockRevokeSessionByIDExpectation struct {
        mock               *SessionUsecaseMock
        params             *SessionUsecaseMockRevokeSessionByIDParams
        paramPtrs          *SessionUsecaseMockRevokeSessionByIDParamPtrs
        expectationOrigins SessionUsecaseMockRevokeSessionByIDExpectationOrigins
        results            *SessionUsecaseMockRevokeSessionByIDResults
        returnOrigin       string
        Counter            uint64
}

// SessionUsecaseMockRevokeSessionByIDParams contains parameters of the SessionUsecase.RevokeSessionByID
type SessionUsecaseMockRevokeSessionByIDParams struct {
        ctx context.Context
        ID  uuid.UUID
}

// SessionUsecaseMockRevokeSessionByIDParamPtrs contains pointers to parameters of the SessionUsecase.RevokeSessionByID
type SessionUsecaseMockRevokeSessionByIDParamPtrs struct {
        ctx *context.Context
        ID  *uuid.UUID
}

// SessionUsecaseMockRevokeSessionByIDResults contains results of the SessionUsecase.RevokeSessionByID
type SessionUsecaseMockRevokeSessionByIDResults struct {
        err error
}

// SessionUsecaseMockRevokeSessionByIDOrigins contains origins of expectations of the SessionUsecase.RevokeSessionByID
type SessionUsecaseMockRevokeSessionByIDExpectationOrigins struct {
        origin    string
        originCtx string
        originID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) Optional() *mSessionUsecaseMockRevokeSessionByID <span class="cov0" title="0">{
        mmRevokeSessionByID.optional = true
        return mmRevokeSessionByID
}</span>

// Expect sets up expected params for SessionUsecase.RevokeSessionByID
func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) Expect(ctx context.Context, ID uuid.UUID) *mSessionUsecaseMockRevokeSessionByID <span class="cov0" title="0">{
        if mmRevokeSessionByID.mock.funcRevokeSessionByID != nil </span><span class="cov0" title="0">{
                mmRevokeSessionByID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmRevokeSessionByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmRevokeSessionByID.defaultExpectation = &amp;SessionUsecaseMockRevokeSessionByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmRevokeSessionByID.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmRevokeSessionByID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionByID mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmRevokeSessionByID.defaultExpectation.params = &amp;SessionUsecaseMockRevokeSessionByIDParams{ctx, ID}
        mmRevokeSessionByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmRevokeSessionByID.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmRevokeSessionByID.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmRevokeSessionByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRevokeSessionByID.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmRevokeSessionByID</span>
}

// ExpectCtxParam1 sets up expected param ctx for SessionUsecase.RevokeSessionByID
func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) ExpectCtxParam1(ctx context.Context) *mSessionUsecaseMockRevokeSessionByID <span class="cov0" title="0">{
        if mmRevokeSessionByID.mock.funcRevokeSessionByID != nil </span><span class="cov0" title="0">{
                mmRevokeSessionByID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmRevokeSessionByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmRevokeSessionByID.defaultExpectation = &amp;SessionUsecaseMockRevokeSessionByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmRevokeSessionByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmRevokeSessionByID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmRevokeSessionByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmRevokeSessionByID.defaultExpectation.paramPtrs = &amp;SessionUsecaseMockRevokeSessionByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmRevokeSessionByID.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmRevokeSessionByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmRevokeSessionByID</span>
}

// ExpectIDParam2 sets up expected param ID for SessionUsecase.RevokeSessionByID
func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) ExpectIDParam2(ID uuid.UUID) *mSessionUsecaseMockRevokeSessionByID <span class="cov0" title="0">{
        if mmRevokeSessionByID.mock.funcRevokeSessionByID != nil </span><span class="cov0" title="0">{
                mmRevokeSessionByID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmRevokeSessionByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmRevokeSessionByID.defaultExpectation = &amp;SessionUsecaseMockRevokeSessionByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmRevokeSessionByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmRevokeSessionByID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmRevokeSessionByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmRevokeSessionByID.defaultExpectation.paramPtrs = &amp;SessionUsecaseMockRevokeSessionByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmRevokeSessionByID.defaultExpectation.paramPtrs.ID = &amp;ID
        mmRevokeSessionByID.defaultExpectation.expectationOrigins.originID = minimock.CallerInfo(1)

        return mmRevokeSessionByID</span>
}

// Inspect accepts an inspector function that has same arguments as the SessionUsecase.RevokeSessionByID
func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) Inspect(f func(ctx context.Context, ID uuid.UUID)) *mSessionUsecaseMockRevokeSessionByID <span class="cov0" title="0">{
        if mmRevokeSessionByID.mock.inspectFuncRevokeSessionByID != nil </span><span class="cov0" title="0">{
                mmRevokeSessionByID.mock.t.Fatalf("Inspect function is already set for SessionUsecaseMock.RevokeSessionByID")
        }</span>

        <span class="cov0" title="0">mmRevokeSessionByID.mock.inspectFuncRevokeSessionByID = f

        return mmRevokeSessionByID</span>
}

// Return sets up results that will be returned by SessionUsecase.RevokeSessionByID
func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) Return(err error) *SessionUsecaseMock <span class="cov0" title="0">{
        if mmRevokeSessionByID.mock.funcRevokeSessionByID != nil </span><span class="cov0" title="0">{
                mmRevokeSessionByID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmRevokeSessionByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmRevokeSessionByID.defaultExpectation = &amp;SessionUsecaseMockRevokeSessionByIDExpectation{mock: mmRevokeSessionByID.mock}
        }</span>
        <span class="cov0" title="0">mmRevokeSessionByID.defaultExpectation.results = &amp;SessionUsecaseMockRevokeSessionByIDResults{err}
        mmRevokeSessionByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmRevokeSessionByID.mock</span>
}

// Set uses given function f to mock the SessionUsecase.RevokeSessionByID method
func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) Set(f func(ctx context.Context, ID uuid.UUID) (err error)) *SessionUsecaseMock <span class="cov0" title="0">{
        if mmRevokeSessionByID.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmRevokeSessionByID.mock.t.Fatalf("Default expectation is already set for the SessionUsecase.RevokeSessionByID method")
        }</span>

        <span class="cov0" title="0">if len(mmRevokeSessionByID.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmRevokeSessionByID.mock.t.Fatalf("Some expectations are already set for the SessionUsecase.RevokeSessionByID method")
        }</span>

        <span class="cov0" title="0">mmRevokeSessionByID.mock.funcRevokeSessionByID = f
        mmRevokeSessionByID.mock.funcRevokeSessionByIDOrigin = minimock.CallerInfo(1)
        return mmRevokeSessionByID.mock</span>
}

// When sets expectation for the SessionUsecase.RevokeSessionByID which will trigger the result defined by the following
// Then helper
func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) When(ctx context.Context, ID uuid.UUID) *SessionUsecaseMockRevokeSessionByIDExpectation <span class="cov0" title="0">{
        if mmRevokeSessionByID.mock.funcRevokeSessionByID != nil </span><span class="cov0" title="0">{
                mmRevokeSessionByID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;SessionUsecaseMockRevokeSessionByIDExpectation{
                mock:               mmRevokeSessionByID.mock,
                params:             &amp;SessionUsecaseMockRevokeSessionByIDParams{ctx, ID},
                expectationOrigins: SessionUsecaseMockRevokeSessionByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmRevokeSessionByID.expectations = append(mmRevokeSessionByID.expectations, expectation)
        return expectation</span>
}

// Then sets up SessionUsecase.RevokeSessionByID return parameters for the expectation previously defined by the When method
func (e *SessionUsecaseMockRevokeSessionByIDExpectation) Then(err error) *SessionUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;SessionUsecaseMockRevokeSessionByIDResults{err}
        return e.mock
}</span>

// Times sets number of times SessionUsecase.RevokeSessionByID should be invoked
func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) Times(n uint64) *mSessionUsecaseMockRevokeSessionByID <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmRevokeSessionByID.mock.t.Fatalf("Times of SessionUsecaseMock.RevokeSessionByID mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmRevokeSessionByID.expectedInvocations, n)
        mmRevokeSessionByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmRevokeSessionByID</span>
}

func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmRevokeSessionByID.expectations) == 0 &amp;&amp; mmRevokeSessionByID.defaultExpectation == nil &amp;&amp; mmRevokeSessionByID.mock.funcRevokeSessionByID == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmRevokeSessionByID.mock.afterRevokeSessionByIDCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmRevokeSessionByID.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// RevokeSessionByID implements mm_usecase.SessionUsecase
func (mmRevokeSessionByID *SessionUsecaseMock) RevokeSessionByID(ctx context.Context, ID uuid.UUID) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmRevokeSessionByID.beforeRevokeSessionByIDCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmRevokeSessionByID.afterRevokeSessionByIDCounter, 1)

        mmRevokeSessionByID.t.Helper()

        if mmRevokeSessionByID.inspectFuncRevokeSessionByID != nil </span><span class="cov0" title="0">{
                mmRevokeSessionByID.inspectFuncRevokeSessionByID(ctx, ID)
        }</span>

        <span class="cov0" title="0">mm_params := SessionUsecaseMockRevokeSessionByIDParams{ctx, ID}

        // Record call args
        mmRevokeSessionByID.RevokeSessionByIDMock.mutex.Lock()
        mmRevokeSessionByID.RevokeSessionByIDMock.callArgs = append(mmRevokeSessionByID.RevokeSessionByIDMock.callArgs, &amp;mm_params)
        mmRevokeSessionByID.RevokeSessionByIDMock.mutex.Unlock()

        for _, e := range mmRevokeSessionByID.RevokeSessionByIDMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmRevokeSessionByID.RevokeSessionByIDMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmRevokeSessionByID.RevokeSessionByIDMock.defaultExpectation.Counter, 1)
                mm_want := mmRevokeSessionByID.RevokeSessionByIDMock.defaultExpectation.params
                mm_want_ptrs := mmRevokeSessionByID.RevokeSessionByIDMock.defaultExpectation.paramPtrs

                mm_got := SessionUsecaseMockRevokeSessionByIDParams{ctx, ID}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmRevokeSessionByID.t.Errorf("SessionUsecaseMock.RevokeSessionByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmRevokeSessionByID.RevokeSessionByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.ID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ID, mm_got.ID) </span><span class="cov0" title="0">{
                                mmRevokeSessionByID.t.Errorf("SessionUsecaseMock.RevokeSessionByID got unexpected parameter ID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmRevokeSessionByID.RevokeSessionByIDMock.defaultExpectation.expectationOrigins.originID, *mm_want_ptrs.ID, mm_got.ID, minimock.Diff(*mm_want_ptrs.ID, mm_got.ID))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmRevokeSessionByID.t.Errorf("SessionUsecaseMock.RevokeSessionByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmRevokeSessionByID.RevokeSessionByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmRevokeSessionByID.RevokeSessionByIDMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmRevokeSessionByID.t.Fatal("No results are set for the SessionUsecaseMock.RevokeSessionByID")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmRevokeSessionByID.funcRevokeSessionByID != nil </span><span class="cov0" title="0">{
                return mmRevokeSessionByID.funcRevokeSessionByID(ctx, ID)
        }</span>
        <span class="cov0" title="0">mmRevokeSessionByID.t.Fatalf("Unexpected call to SessionUsecaseMock.RevokeSessionByID. %v %v", ctx, ID)
        return</span>
}

// RevokeSessionByIDAfterCounter returns a count of finished SessionUsecaseMock.RevokeSessionByID invocations
func (mmRevokeSessionByID *SessionUsecaseMock) RevokeSessionByIDAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmRevokeSessionByID.afterRevokeSessionByIDCounter)
}</span>

// RevokeSessionByIDBeforeCounter returns a count of SessionUsecaseMock.RevokeSessionByID invocations
func (mmRevokeSessionByID *SessionUsecaseMock) RevokeSessionByIDBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmRevokeSessionByID.beforeRevokeSessionByIDCounter)
}</span>

// Calls returns a list of arguments used in each call to SessionUsecaseMock.RevokeSessionByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) Calls() []*SessionUsecaseMockRevokeSessionByIDParams <span class="cov0" title="0">{
        mmRevokeSessionByID.mutex.RLock()

        argCopy := make([]*SessionUsecaseMockRevokeSessionByIDParams, len(mmRevokeSessionByID.callArgs))
        copy(argCopy, mmRevokeSessionByID.callArgs)

        mmRevokeSessionByID.mutex.RUnlock()

        return argCopy
}</span>

// MinimockRevokeSessionByIDDone returns true if the count of the RevokeSessionByID invocations corresponds
// the number of defined expectations
func (m *SessionUsecaseMock) MinimockRevokeSessionByIDDone() bool <span class="cov0" title="0">{
        if m.RevokeSessionByIDMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.RevokeSessionByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.RevokeSessionByIDMock.invocationsDone()</span>
}

// MinimockRevokeSessionByIDInspect logs each unmet expectation
func (m *SessionUsecaseMock) MinimockRevokeSessionByIDInspect() <span class="cov0" title="0">{
        for _, e := range m.RevokeSessionByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionUsecaseMock.RevokeSessionByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterRevokeSessionByIDCounter := mm_atomic.LoadUint64(&amp;m.afterRevokeSessionByIDCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.RevokeSessionByIDMock.defaultExpectation != nil &amp;&amp; afterRevokeSessionByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.RevokeSessionByIDMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionUsecaseMock.RevokeSessionByID at\n%s", m.RevokeSessionByIDMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to SessionUsecaseMock.RevokeSessionByID at\n%s with params: %#v", m.RevokeSessionByIDMock.defaultExpectation.expectationOrigins.origin, *m.RevokeSessionByIDMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcRevokeSessionByID != nil &amp;&amp; afterRevokeSessionByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to SessionUsecaseMock.RevokeSessionByID at\n%s", m.funcRevokeSessionByIDOrigin)
        }</span>

        <span class="cov0" title="0">if !m.RevokeSessionByIDMock.invocationsDone() &amp;&amp; afterRevokeSessionByIDCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to SessionUsecaseMock.RevokeSessionByID at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.RevokeSessionByIDMock.expectedInvocations), m.RevokeSessionByIDMock.expectedInvocationsOrigin, afterRevokeSessionByIDCounter)
        }</span>
}

type mSessionUsecaseMockRevokeSessionsByAccountID struct {
        optional           bool
        mock               *SessionUsecaseMock
        defaultExpectation *SessionUsecaseMockRevokeSessionsByAccountIDExpectation
        expectations       []*SessionUsecaseMockRevokeSessionsByAccountIDExpectation

        callArgs []*SessionUsecaseMockRevokeSessionsByAccountIDParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// SessionUsecaseMockRevokeSessionsByAccountIDExpectation specifies expectation struct of the SessionUsecase.RevokeSessionsByAccountID
type SessionUsecaseMockRevokeSessionsByAccountIDExpectation struct {
        mock               *SessionUsecaseMock
        params             *SessionUsecaseMockRevokeSessionsByAccountIDParams
        paramPtrs          *SessionUsecaseMockRevokeSessionsByAccountIDParamPtrs
        expectationOrigins SessionUsecaseMockRevokeSessionsByAccountIDExpectationOrigins
        results            *SessionUsecaseMockRevokeSessionsByAccountIDResults
        returnOrigin       string
        Counter            uint64
}

// SessionUsecaseMockRevokeSessionsByAccountIDParams contains parameters of the SessionUsecase.RevokeSessionsByAccountID
type SessionUsecaseMockRevokeSessionsByAccountIDParams struct {
        ctx       context.Context
        accountID uuid.UUID
}

// SessionUsecaseMockRevokeSessionsByAccountIDParamPtrs contains pointers to parameters of the SessionUsecase.RevokeSessionsByAccountID
type SessionUsecaseMockRevokeSessionsByAccountIDParamPtrs struct {
        ctx       *context.Context
        accountID *uuid.UUID
}

// SessionUsecaseMockRevokeSessionsByAccountIDResults contains results of the SessionUsecase.RevokeSessionsByAccountID
type SessionUsecaseMockRevokeSessionsByAccountIDResults struct {
        err error
}

// SessionUsecaseMockRevokeSessionsByAccountIDOrigins contains origins of expectations of the SessionUsecase.RevokeSessionsByAccountID
type SessionUsecaseMockRevokeSessionsByAccountIDExpectationOrigins struct {
        origin          string
        originCtx       string
        originAccountID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) Optional() *mSessionUsecaseMockRevokeSessionsByAccountID <span class="cov0" title="0">{
        mmRevokeSessionsByAccountID.optional = true
        return mmRevokeSessionsByAccountID
}</span>

// Expect sets up expected params for SessionUsecase.RevokeSessionsByAccountID
func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) Expect(ctx context.Context, accountID uuid.UUID) *mSessionUsecaseMockRevokeSessionsByAccountID <span class="cov0" title="0">{
        if mmRevokeSessionsByAccountID.mock.funcRevokeSessionsByAccountID != nil </span><span class="cov0" title="0">{
                mmRevokeSessionsByAccountID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionsByAccountID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmRevokeSessionsByAccountID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmRevokeSessionsByAccountID.defaultExpectation = &amp;SessionUsecaseMockRevokeSessionsByAccountIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmRevokeSessionsByAccountID.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmRevokeSessionsByAccountID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionsByAccountID mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmRevokeSessionsByAccountID.defaultExpectation.params = &amp;SessionUsecaseMockRevokeSessionsByAccountIDParams{ctx, accountID}
        mmRevokeSessionsByAccountID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmRevokeSessionsByAccountID.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmRevokeSessionsByAccountID.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmRevokeSessionsByAccountID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRevokeSessionsByAccountID.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmRevokeSessionsByAccountID</span>
}

// ExpectCtxParam1 sets up expected param ctx for SessionUsecase.RevokeSessionsByAccountID
func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) ExpectCtxParam1(ctx context.Context) *mSessionUsecaseMockRevokeSessionsByAccountID <span class="cov0" title="0">{
        if mmRevokeSessionsByAccountID.mock.funcRevokeSessionsByAccountID != nil </span><span class="cov0" title="0">{
                mmRevokeSessionsByAccountID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionsByAccountID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmRevokeSessionsByAccountID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmRevokeSessionsByAccountID.defaultExpectation = &amp;SessionUsecaseMockRevokeSessionsByAccountIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmRevokeSessionsByAccountID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmRevokeSessionsByAccountID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionsByAccountID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmRevokeSessionsByAccountID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmRevokeSessionsByAccountID.defaultExpectation.paramPtrs = &amp;SessionUsecaseMockRevokeSessionsByAccountIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmRevokeSessionsByAccountID.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmRevokeSessionsByAccountID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmRevokeSessionsByAccountID</span>
}

// ExpectAccountIDParam2 sets up expected param accountID for SessionUsecase.RevokeSessionsByAccountID
func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) ExpectAccountIDParam2(accountID uuid.UUID) *mSessionUsecaseMockRevokeSessionsByAccountID <span class="cov0" title="0">{
        if mmRevokeSessionsByAccountID.mock.funcRevokeSessionsByAccountID != nil </span><span class="cov0" title="0">{
                mmRevokeSessionsByAccountID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionsByAccountID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmRevokeSessionsByAccountID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmRevokeSessionsByAccountID.defaultExpectation = &amp;SessionUsecaseMockRevokeSessionsByAccountIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmRevokeSessionsByAccountID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmRevokeSessionsByAccountID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionsByAccountID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmRevokeSessionsByAccountID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmRevokeSessionsByAccountID.defaultExpectation.paramPtrs = &amp;SessionUsecaseMockRevokeSessionsByAccountIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmRevokeSessionsByAccountID.defaultExpectation.paramPtrs.accountID = &amp;accountID
        mmRevokeSessionsByAccountID.defaultExpectation.expectationOrigins.originAccountID = minimock.CallerInfo(1)

        return mmRevokeSessionsByAccountID</span>
}

// Inspect accepts an inspector function that has same arguments as the SessionUsecase.RevokeSessionsByAccountID
func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) Inspect(f func(ctx context.Context, accountID uuid.UUID)) *mSessionUsecaseMockRevokeSessionsByAccountID <span class="cov0" title="0">{
        if mmRevokeSessionsByAccountID.mock.inspectFuncRevokeSessionsByAccountID != nil </span><span class="cov0" title="0">{
                mmRevokeSessionsByAccountID.mock.t.Fatalf("Inspect function is already set for SessionUsecaseMock.RevokeSessionsByAccountID")
        }</span>

        <span class="cov0" title="0">mmRevokeSessionsByAccountID.mock.inspectFuncRevokeSessionsByAccountID = f

        return mmRevokeSessionsByAccountID</span>
}

// Return sets up results that will be returned by SessionUsecase.RevokeSessionsByAccountID
func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) Return(err error) *SessionUsecaseMock <span class="cov0" title="0">{
        if mmRevokeSessionsByAccountID.mock.funcRevokeSessionsByAccountID != nil </span><span class="cov0" title="0">{
                mmRevokeSessionsByAccountID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionsByAccountID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmRevokeSessionsByAccountID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmRevokeSessionsByAccountID.defaultExpectation = &amp;SessionUsecaseMockRevokeSessionsByAccountIDExpectation{mock: mmRevokeSessionsByAccountID.mock}
        }</span>
        <span class="cov0" title="0">mmRevokeSessionsByAccountID.defaultExpectation.results = &amp;SessionUsecaseMockRevokeSessionsByAccountIDResults{err}
        mmRevokeSessionsByAccountID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmRevokeSessionsByAccountID.mock</span>
}

// Set uses given function f to mock the SessionUsecase.RevokeSessionsByAccountID method
func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) Set(f func(ctx context.Context, accountID uuid.UUID) (err error)) *SessionUsecaseMock <span class="cov0" title="0">{
        if mmRevokeSessionsByAccountID.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmRevokeSessionsByAccountID.mock.t.Fatalf("Default expectation is already set for the SessionUsecase.RevokeSessionsByAccountID method")
        }</span>

        <span class="cov0" title="0">if len(mmRevokeSessionsByAccountID.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmRevokeSessionsByAccountID.mock.t.Fatalf("Some expectations are already set for the SessionUsecase.RevokeSessionsByAccountID method")
        }</span>

        <span class="cov0" title="0">mmRevokeSessionsByAccountID.mock.funcRevokeSessionsByAccountID = f
        mmRevokeSessionsByAccountID.mock.funcRevokeSessionsByAccountIDOrigin = minimock.CallerInfo(1)
        return mmRevokeSessionsByAccountID.mock</span>
}

// When sets expectation for the SessionUsecase.RevokeSessionsByAccountID which will trigger the result defined by the following
// Then helper
func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) When(ctx context.Context, accountID uuid.UUID) *SessionUsecaseMockRevokeSessionsByAccountIDExpectation <span class="cov0" title="0">{
        if mmRevokeSessionsByAccountID.mock.funcRevokeSessionsByAccountID != nil </span><span class="cov0" title="0">{
                mmRevokeSessionsByAccountID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionsByAccountID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;SessionUsecaseMockRevokeSessionsByAccountIDExpectation{
                mock:               mmRevokeSessionsByAccountID.mock,
                params:             &amp;SessionUsecaseMockRevokeSessionsByAccountIDParams{ctx, accountID},
                expectationOrigins: SessionUsecaseMockRevokeSessionsByAccountIDExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmRevokeSessionsByAccountID.expectations = append(mmRevokeSessionsByAccountID.expectations, expectation)
        return expectation</span>
}

// Then sets up SessionUsecase.RevokeSessionsByAccountID return parameters for the expectation previously defined by the When method
func (e *SessionUsecaseMockRevokeSessionsByAccountIDExpectation) Then(err error) *SessionUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;SessionUsecaseMockRevokeSessionsByAccountIDResults{err}
        return e.mock
}</span>

// Times sets number of times SessionUsecase.RevokeSessionsByAccountID should be invoked
func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) Times(n uint64) *mSessionUsecaseMockRevokeSessionsByAccountID <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmRevokeSessionsByAccountID.mock.t.Fatalf("Times of SessionUsecaseMock.RevokeSessionsByAccountID mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmRevokeSessionsByAccountID.expectedInvocations, n)
        mmRevokeSessionsByAccountID.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmRevokeSessionsByAccountID</span>
}

func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmRevokeSessionsByAccountID.expectations) == 0 &amp;&amp; mmRevokeSessionsByAccountID.defaultExpectation == nil &amp;&amp; mmRevokeSessionsByAccountID.mock.funcRevokeSessionsByAccountID == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmRevokeSessionsByAccountID.mock.afterRevokeSessionsByAccountIDCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmRevokeSessionsByAccountID.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// RevokeSessionsByAccountID implements mm_usecase.SessionUsecase
func (mmRevokeSessionsByAccountID *SessionUsecaseMock) RevokeSessionsByAccountID(ctx context.Context, accountID uuid.UUID) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmRevokeSessionsByAccountID.beforeRevokeSessionsByAccountIDCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmRevokeSessionsByAccountID.afterRevokeSessionsByAccountIDCounter, 1)

        mmRevokeSessionsByAccountID.t.Helper()

        if mmRevokeSessionsByAccountID.inspectFuncRevokeSessionsByAccountID != nil </span><span class="cov0" title="0">{
                mmRevokeSessionsByAccountID.inspectFuncRevokeSessionsByAccountID(ctx, accountID)
        }</span>

        <span class="cov0" title="0">mm_params := SessionUsecaseMockRevokeSessionsByAccountIDParams{ctx, accountID}

        // Record call args
        mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.mutex.Lock()
        mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.callArgs = append(mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.callArgs, &amp;mm_params)
        mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.mutex.Unlock()

        for _, e := range mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.defaultExpectation.Counter, 1)
                mm_want := mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.defaultExpectation.params
                mm_want_ptrs := mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.defaultExpectation.paramPtrs

                mm_got := SessionUsecaseMockRevokeSessionsByAccountIDParams{ctx, accountID}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmRevokeSessionsByAccountID.t.Errorf("SessionUsecaseMock.RevokeSessionsByAccountID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.accountID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.accountID, mm_got.accountID) </span><span class="cov0" title="0">{
                                mmRevokeSessionsByAccountID.t.Errorf("SessionUsecaseMock.RevokeSessionsByAccountID got unexpected parameter accountID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.defaultExpectation.expectationOrigins.originAccountID, *mm_want_ptrs.accountID, mm_got.accountID, minimock.Diff(*mm_want_ptrs.accountID, mm_got.accountID))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmRevokeSessionsByAccountID.t.Errorf("SessionUsecaseMock.RevokeSessionsByAccountID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmRevokeSessionsByAccountID.t.Fatal("No results are set for the SessionUsecaseMock.RevokeSessionsByAccountID")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmRevokeSessionsByAccountID.funcRevokeSessionsByAccountID != nil </span><span class="cov0" title="0">{
                return mmRevokeSessionsByAccountID.funcRevokeSessionsByAccountID(ctx, accountID)
        }</span>
        <span class="cov0" title="0">mmRevokeSessionsByAccountID.t.Fatalf("Unexpected call to SessionUsecaseMock.RevokeSessionsByAccountID. %v %v", ctx, accountID)
        return</span>
}

// RevokeSessionsByAccountIDAfterCounter returns a count of finished SessionUsecaseMock.RevokeSessionsByAccountID invocations
func (mmRevokeSessionsByAccountID *SessionUsecaseMock) RevokeSessionsByAccountIDAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmRevokeSessionsByAccountID.afterRevokeSessionsByAccountIDCounter)
}</span>

// RevokeSessionsByAccountIDBeforeCounter returns a count of SessionUsecaseMock.RevokeSessionsByAccountID invocations
func (mmRevokeSessionsByAccountID *SessionUsecaseMock) RevokeSessionsByAccountIDBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmRevokeSessionsByAccountID.beforeRevokeSessionsByAccountIDCounter)
}</span>

// Calls returns a list of arguments used in each call to SessionUsecaseMock.RevokeSessionsByAccountID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) Calls() []*SessionUsecaseMockRevokeSessionsByAccountIDParams <span class="cov0" title="0">{
        mmRevokeSessionsByAccountID.mutex.RLock()

        argCopy := make([]*SessionUsecaseMockRevokeSessionsByAccountIDParams, len(mmRevokeSessionsByAccountID.callArgs))
        copy(argCopy, mmRevokeSessionsByAccountID.callArgs)

        mmRevokeSessionsByAccountID.mutex.RUnlock()

        return argCopy
}</span>

// MinimockRevokeSessionsByAccountIDDone returns true if the count of the RevokeSessionsByAccountID invocations corresponds
// the number of defined expectations
func (m *SessionUsecaseMock) MinimockRevokeSessionsByAccountIDDone() bool <span class="cov0" title="0">{
        if m.RevokeSessionsByAccountIDMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.RevokeSessionsByAccountIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.RevokeSessionsByAccountIDMock.invocationsDone()</span>
}

// MinimockRevokeSessionsByAccountIDInspect logs each unmet expectation
func (m *SessionUsecaseMock) MinimockRevokeSessionsByAccountIDInspect() <span class="cov0" title="0">{
        for _, e := range m.RevokeSessionsByAccountIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionUsecaseMock.RevokeSessionsByAccountID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterRevokeSessionsByAccountIDCounter := mm_atomic.LoadUint64(&amp;m.afterRevokeSessionsByAccountIDCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.RevokeSessionsByAccountIDMock.defaultExpectation != nil &amp;&amp; afterRevokeSessionsByAccountIDCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.RevokeSessionsByAccountIDMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionUsecaseMock.RevokeSessionsByAccountID at\n%s", m.RevokeSessionsByAccountIDMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to SessionUsecaseMock.RevokeSessionsByAccountID at\n%s with params: %#v", m.RevokeSessionsByAccountIDMock.defaultExpectation.expectationOrigins.origin, *m.RevokeSessionsByAccountIDMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcRevokeSessionsByAccountID != nil &amp;&amp; afterRevokeSessionsByAccountIDCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to SessionUsecaseMock.RevokeSessionsByAccountID at\n%s", m.funcRevokeSessionsByAccountIDOrigin)
        }</span>

        <span class="cov0" title="0">if !m.RevokeSessionsByAccountIDMock.invocationsDone() &amp;&amp; afterRevokeSessionsByAccountIDCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to SessionUsecaseMock.RevokeSessionsByAccountID at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.RevokeSessionsByAccountIDMock.expectedInvocations), m.RevokeSessionsByAccountIDMock.expectedInvocationsOrigin, afterRevokeSessionsByAccountIDCounter)
        }</span>
}

type mSessionUsecaseMockUpdate struct {
        optional           bool
        mock               *SessionUsecaseMock
        defaultExpectation *SessionUsecaseMockUpdateExpectation
        expectations       []*SessionUsecaseMockUpdateExpectation

        callArgs []*SessionUsecaseMockUpdateParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// SessionUsecaseMockUpdateExpectation specifies expectation struct of the SessionUsecase.Update
type SessionUsecaseMockUpdateExpectation struct {
        mock               *SessionUsecaseMock
        params             *SessionUsecaseMockUpdateParams
        paramPtrs          *SessionUsecaseMockUpdateParamPtrs
        expectationOrigins SessionUsecaseMockUpdateExpectationOrigins
        results            *SessionUsecaseMockUpdateResults
        returnOrigin       string
        Counter            uint64
}

// SessionUsecaseMockUpdateParams contains parameters of the SessionUsecase.Update
type SessionUsecaseMockUpdateParams struct {
        ctx  context.Context
        item *entity.Session
}

// SessionUsecaseMockUpdateParamPtrs contains pointers to parameters of the SessionUsecase.Update
type SessionUsecaseMockUpdateParamPtrs struct {
        ctx  *context.Context
        item **entity.Session
}

// SessionUsecaseMockUpdateResults contains results of the SessionUsecase.Update
type SessionUsecaseMockUpdateResults struct {
        err error
}

// SessionUsecaseMockUpdateOrigins contains origins of expectations of the SessionUsecase.Update
type SessionUsecaseMockUpdateExpectationOrigins struct {
        origin     string
        originCtx  string
        originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mSessionUsecaseMockUpdate) Optional() *mSessionUsecaseMockUpdate <span class="cov0" title="0">{
        mmUpdate.optional = true
        return mmUpdate
}</span>

// Expect sets up expected params for SessionUsecase.Update
func (mmUpdate *mSessionUsecaseMockUpdate) Expect(ctx context.Context, item *entity.Session) *mSessionUsecaseMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionUsecaseMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;SessionUsecaseMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionUsecaseMock.Update mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmUpdate.defaultExpectation.params = &amp;SessionUsecaseMockUpdateParams{ctx, item}
        mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmUpdate.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmUpdate</span>
}

// ExpectCtxParam1 sets up expected param ctx for SessionUsecase.Update
func (mmUpdate *mSessionUsecaseMockUpdate) ExpectCtxParam1(ctx context.Context) *mSessionUsecaseMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionUsecaseMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;SessionUsecaseMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionUsecaseMock.Update mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation.paramPtrs = &amp;SessionUsecaseMockUpdateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmUpdate</span>
}

// ExpectItemParam2 sets up expected param item for SessionUsecase.Update
func (mmUpdate *mSessionUsecaseMockUpdate) ExpectItemParam2(item *entity.Session) *mSessionUsecaseMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionUsecaseMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;SessionUsecaseMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionUsecaseMock.Update mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation.paramPtrs = &amp;SessionUsecaseMockUpdateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.paramPtrs.item = &amp;item
        mmUpdate.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

        return mmUpdate</span>
}

// Inspect accepts an inspector function that has same arguments as the SessionUsecase.Update
func (mmUpdate *mSessionUsecaseMockUpdate) Inspect(f func(ctx context.Context, item *entity.Session)) *mSessionUsecaseMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.inspectFuncUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Inspect function is already set for SessionUsecaseMock.Update")
        }</span>

        <span class="cov0" title="0">mmUpdate.mock.inspectFuncUpdate = f

        return mmUpdate</span>
}

// Return sets up results that will be returned by SessionUsecase.Update
func (mmUpdate *mSessionUsecaseMockUpdate) Return(err error) *SessionUsecaseMock <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionUsecaseMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;SessionUsecaseMockUpdateExpectation{mock: mmUpdate.mock}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.results = &amp;SessionUsecaseMockUpdateResults{err}
        mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmUpdate.mock</span>
}

// Set uses given function f to mock the SessionUsecase.Update method
func (mmUpdate *mSessionUsecaseMockUpdate) Set(f func(ctx context.Context, item *entity.Session) (err error)) *SessionUsecaseMock <span class="cov0" title="0">{
        if mmUpdate.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Default expectation is already set for the SessionUsecase.Update method")
        }</span>

        <span class="cov0" title="0">if len(mmUpdate.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Some expectations are already set for the SessionUsecase.Update method")
        }</span>

        <span class="cov0" title="0">mmUpdate.mock.funcUpdate = f
        mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
        return mmUpdate.mock</span>
}

// When sets expectation for the SessionUsecase.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mSessionUsecaseMockUpdate) When(ctx context.Context, item *entity.Session) *SessionUsecaseMockUpdateExpectation <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionUsecaseMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;SessionUsecaseMockUpdateExpectation{
                mock:               mmUpdate.mock,
                params:             &amp;SessionUsecaseMockUpdateParams{ctx, item},
                expectationOrigins: SessionUsecaseMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmUpdate.expectations = append(mmUpdate.expectations, expectation)
        return expectation</span>
}

// Then sets up SessionUsecase.Update return parameters for the expectation previously defined by the When method
func (e *SessionUsecaseMockUpdateExpectation) Then(err error) *SessionUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;SessionUsecaseMockUpdateResults{err}
        return e.mock
}</span>

// Times sets number of times SessionUsecase.Update should be invoked
func (mmUpdate *mSessionUsecaseMockUpdate) Times(n uint64) *mSessionUsecaseMockUpdate <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Times of SessionUsecaseMock.Update mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmUpdate.expectedInvocations, n)
        mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmUpdate</span>
}

func (mmUpdate *mSessionUsecaseMockUpdate) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmUpdate.expectations) == 0 &amp;&amp; mmUpdate.defaultExpectation == nil &amp;&amp; mmUpdate.mock.funcUpdate == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmUpdate.mock.afterUpdateCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmUpdate.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Update implements mm_usecase.SessionUsecase
func (mmUpdate *SessionUsecaseMock) Update(ctx context.Context, item *entity.Session) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmUpdate.beforeUpdateCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmUpdate.afterUpdateCounter, 1)

        mmUpdate.t.Helper()

        if mmUpdate.inspectFuncUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.inspectFuncUpdate(ctx, item)
        }</span>

        <span class="cov0" title="0">mm_params := SessionUsecaseMockUpdateParams{ctx, item}

        // Record call args
        mmUpdate.UpdateMock.mutex.Lock()
        mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &amp;mm_params)
        mmUpdate.UpdateMock.mutex.Unlock()

        for _, e := range mmUpdate.UpdateMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmUpdate.UpdateMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
                mm_want := mmUpdate.UpdateMock.defaultExpectation.params
                mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

                mm_got := SessionUsecaseMockUpdateParams{ctx, item}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmUpdate.t.Errorf("SessionUsecaseMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.item != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.item, mm_got.item) </span><span class="cov0" title="0">{
                                mmUpdate.t.Errorf("SessionUsecaseMock.Update got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmUpdate.t.Errorf("SessionUsecaseMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmUpdate.UpdateMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmUpdate.t.Fatal("No results are set for the SessionUsecaseMock.Update")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmUpdate.funcUpdate != nil </span><span class="cov0" title="0">{
                return mmUpdate.funcUpdate(ctx, item)
        }</span>
        <span class="cov0" title="0">mmUpdate.t.Fatalf("Unexpected call to SessionUsecaseMock.Update. %v %v", ctx, item)
        return</span>
}

// UpdateAfterCounter returns a count of finished SessionUsecaseMock.Update invocations
func (mmUpdate *SessionUsecaseMock) UpdateAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdate.afterUpdateCounter)
}</span>

// UpdateBeforeCounter returns a count of SessionUsecaseMock.Update invocations
func (mmUpdate *SessionUsecaseMock) UpdateBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdate.beforeUpdateCounter)
}</span>

// Calls returns a list of arguments used in each call to SessionUsecaseMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mSessionUsecaseMockUpdate) Calls() []*SessionUsecaseMockUpdateParams <span class="cov0" title="0">{
        mmUpdate.mutex.RLock()

        argCopy := make([]*SessionUsecaseMockUpdateParams, len(mmUpdate.callArgs))
        copy(argCopy, mmUpdate.callArgs)

        mmUpdate.mutex.RUnlock()

        return argCopy
}</span>

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *SessionUsecaseMock) MinimockUpdateDone() bool <span class="cov0" title="0">{
        if m.UpdateMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.UpdateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.UpdateMock.invocationsDone()</span>
}

// MinimockUpdateInspect logs each unmet expectation
func (m *SessionUsecaseMock) MinimockUpdateInspect() <span class="cov0" title="0">{
        for _, e := range m.UpdateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionUsecaseMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterUpdateCounter := mm_atomic.LoadUint64(&amp;m.afterUpdateCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.UpdateMock.defaultExpectation != nil &amp;&amp; afterUpdateCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.UpdateMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionUsecaseMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to SessionUsecaseMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcUpdate != nil &amp;&amp; afterUpdateCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to SessionUsecaseMock.Update at\n%s", m.funcUpdateOrigin)
        }</span>

        <span class="cov0" title="0">if !m.UpdateMock.invocationsDone() &amp;&amp; afterUpdateCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to SessionUsecaseMock.Update at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SessionUsecaseMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockCreateInspect()

                        m.MinimockFindListInspect()

                        m.MinimockFindOneByIDInspect()

                        m.MinimockRevokeSessionByIDInspect()

                        m.MinimockRevokeSessionsByAccountIDInspect()

                        m.MinimockUpdateInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SessionUsecaseMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *SessionUsecaseMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockCreateDone() &amp;&amp;
                m.MinimockFindListDone() &amp;&amp;
                m.MinimockFindOneByIDDone() &amp;&amp;
                m.MinimockRevokeSessionByIDDone() &amp;&amp;
                m.MinimockRevokeSessionsByAccountIDDone() &amp;&amp;
                m.MinimockUpdateDone()
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package session

import (
        "context"

        "github.com/google/uuid"
        appErrors "github.com/m11ano/budget_planner/backend/auth/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/auth/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
)

func (uc *UsecaseImpl) Create(
        ctx context.Context,
        item *entity.Session,
) error <span class="cov10" title="2">{
        const op = "Create"

        err := uc.repo.Create(ctx, item)
        if err != nil </span><span class="cov1" title="1">{
                return appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (uc *UsecaseImpl) Update(
        ctx context.Context,
        item *entity.Session,
) error <span class="cov10" title="2">{
        const op = "Update"

        err := uc.repo.Update(ctx, item)
        if err != nil </span><span class="cov1" title="1">{
                return appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (uc *UsecaseImpl) RevokeSessionsByAccountID(ctx context.Context, accountID uuid.UUID) error <span class="cov10" title="2">{
        const op = "RevokeSessionsByAccountID"

        err := uc.dbMasterClient.Do(ctx, func(ctx context.Context) error </span><span class="cov10" title="2">{
                sessions, err := uc.repo.FindList(ctx, &amp;usecase.SessionListOptions{
                        FilterAccountID: &amp;accountID,
                }, &amp;uctypes.QueryGetListParams{
                        ForUpdate: true,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov10" title="2">for _, session := range sessions </span><span class="cov10" title="2">{
                        err := uc.delete(ctx, session)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov10" title="2">return nil</span>
        })
        <span class="cov10" title="2">if err != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov10" title="2">return nil</span>
}

func (uc *UsecaseImpl) RevokeSessionByID(ctx context.Context, ID uuid.UUID) error <span class="cov1" title="1">{
        const op = "RevokeSessionByID"

        err := uc.dbMasterClient.Do(ctx, func(ctx context.Context) error </span><span class="cov1" title="1">{
                session, err := uc.repo.FindOneByID(ctx, ID, &amp;uctypes.QueryGetOneParams{
                        ForUpdate: true,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">err = uc.delete(ctx, session)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">return nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package session

import (
        "context"
        "time"

        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
)

func (uc *UsecaseImpl) delete(ctx context.Context, session *entity.Session) error <span class="cov10" title="3">{
        nowTime := time.Now()
        session.DeletedAt = &amp;nowTime
        return uc.repo.Update(ctx, session)
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package session

import (
        "log/slog"

        "github.com/m11ano/budget_planner/backend/auth/internal/app/config"
        "github.com/m11ano/budget_planner/backend/auth/internal/infra/db"

        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
)

type UsecaseImpl struct {
        pkg            string
        logger         *slog.Logger
        cfg            config.Config
        dbMasterClient db.MasterClient
        repo           usecase.SessionRepository
}

func NewUsecaseImpl(
        logger *slog.Logger,
        cfg config.Config,
        dbMasterClient db.MasterClient,
        repo usecase.SessionRepository,
) *UsecaseImpl <span class="cov10" title="12">{
        uc := &amp;UsecaseImpl{
                pkg:            "TenantUser.usecase.Session",
                logger:         logger,
                cfg:            cfg,
                dbMasterClient: dbMasterClient,
                repo:           repo,
        }

        return uc
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package session

import (
        "context"

        "github.com/google/uuid"
        appErrors "github.com/m11ano/budget_planner/backend/auth/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/auth/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
        "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
)

func (uc *UsecaseImpl) FindOneByID(
        ctx context.Context,
        id uuid.UUID,
        queryParams *uctypes.QueryGetOneParams,
) (*entity.Session, error) <span class="cov6" title="2">{
        const op = "FindOneByID"

        item, err := uc.repo.FindOneByID(ctx, id, queryParams)
        if err != nil </span><span class="cov1" title="1">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return item, nil</span>
}

func (uc *UsecaseImpl) FindList(
        ctx context.Context,
        listOptions *usecase.SessionListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]*entity.Session, error) <span class="cov10" title="3">{
        const op = "FindList"

        items, err := uc.repo.FindList(ctx, listOptions, queryParams)
        if err != nil </span><span class="cov1" title="1">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov6" title="2">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package db

import (
        "fmt"
        "log/slog"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/stdlib"
        "github.com/pressly/goose/v3"
)

func UpMigrations(dsn string, migrationsPath string, logger *slog.Logger) error <span class="cov0" title="0">{
        if err := goose.SetDialect("postgres"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to set dialect: %w", err)
        }</span>

        <span class="cov0" title="0">gooseLogger := &amp;migrationsLogger{logger: logger}
        goose.SetLogger(gooseLogger)

        pgxCfg, err := pgx.ParseConfig(dsn)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to parse dsn: %w", err)
        }</span>

        <span class="cov0" title="0">db := stdlib.OpenDB(*pgxCfg)
        defer func() </span><span class="cov0" title="0">{
                err := db.Close()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("unable to close db connection: %v", err))
                }</span>
        }()

        <span class="cov0" title="0">if err := goose.Up(db, migrationsPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to run up migrations: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func DownMigrations(dsn string, migrationsPath string, logger *slog.Logger) error <span class="cov0" title="0">{
        if err := goose.SetDialect("postgres"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to set dialect: %w", err)
        }</span>

        <span class="cov0" title="0">gooseLogger := &amp;migrationsLogger{logger: logger}
        goose.SetLogger(gooseLogger)

        pgxCfg, err := pgx.ParseConfig(dsn)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to parse dsn: %w", err)
        }</span>

        <span class="cov0" title="0">db := stdlib.OpenDB(*pgxCfg)
        defer func() </span><span class="cov0" title="0">{
                err := db.Close()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("unable to close db connection: %v", err))
                }</span>
        }()

        <span class="cov0" title="0">if err := goose.DownTo(db, migrationsPath, 0); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to run down migrations: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type migrationsLogger struct {
        logger *slog.Logger
}

func (l *migrationsLogger) Fatalf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.logger.Error(fmt.Sprintf(format, v...))
}</span>

func (l *migrationsLogger) Printf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.logger.Info(fmt.Sprintf(format, v...))
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package loghandler

import "context"

type contextKey string

const (
        contextKeyData       contextKey = "log_context_data"
        contextKeyWithSource contextKey = "log_context_with_source"
)

type contextData map[string]any

func GetData(ctx context.Context) (contextData, bool) <span class="cov0" title="0">{
        data, ok := ctx.Value(contextKeyData).(contextData)
        return data, ok
}</span>

func SetData(ctx context.Context, key string, value any) (contextData, contextKey) <span class="cov0" title="0">{
        data, ok := GetData(ctx)
        if !ok </span><span class="cov0" title="0">{
                data = contextData{}
        }</span>

        <span class="cov0" title="0">data[key] = value

        return data, contextKeyData</span>
}

func SetContextData(ctx context.Context, key string, value any) context.Context <span class="cov0" title="0">{
        data, ctxKey := SetData(ctx, key, value)
        return context.WithValue(ctx, ctxKey, data)
}</span>

func WithSource(ctx context.Context) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, contextKeyWithSource, true)
}</span>

func IsWithSource(ctx context.Context) bool <span class="cov0" title="0">{
        is, ok := ctx.Value(contextKeyWithSource).(bool)
        return ok &amp;&amp; is
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package loghandler

import (
        "context"
        "log/slog"
        "runtime"
)

type handlerMiddlware struct {
        next slog.Handler
}

func NewHandlerMiddleware(next slog.Handler) *handlerMiddlware <span class="cov0" title="0">{
        return &amp;handlerMiddlware{next: next}
}</span>

func (h *handlerMiddlware) Enabled(ctx context.Context, rec slog.Level) bool <span class="cov0" title="0">{
        return h.next.Enabled(ctx, rec)
}</span>

func (h *handlerMiddlware) Handle(ctx context.Context, rec slog.Record) error <span class="cov0" title="0">{
        data, ok := GetData(ctx)
        if ok </span><span class="cov0" title="0">{
                for k, v := range data </span><span class="cov0" title="0">{
                        rec.Add(k, v)
                }</span>
        }

        <span class="cov0" title="0">if IsWithSource(ctx) </span><span class="cov0" title="0">{
                if pc, file, line, ok := runtime.Caller(3); ok </span><span class="cov0" title="0">{
                        fn := runtime.FuncForPC(pc).Name()

                        rec.AddAttrs(
                                slog.Group("source",
                                        slog.String("file", file),
                                        slog.String("function", fn),
                                        slog.Int("line", line),
                                ),
                        )
                }</span>
        }

        <span class="cov0" title="0">return h.next.Handle(ctx, rec)</span>
}

func (h *handlerMiddlware) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov0" title="0">{
        return &amp;handlerMiddlware{next: h.next.WithAttrs(attrs)}
}</span>

func (h *handlerMiddlware) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        return &amp;handlerMiddlware{next: h.next.WithGroup(name)}
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package auth

import (
        "github.com/golang-jwt/jwt/v5"
)

func ParseAccessToken(tokenStr string, validate bool, secret []byte) (*SessionAccessClaims, error) <span class="cov0" title="0">{
        ops := []jwt.ParserOption{
                jwt.WithValidMethods([]string{jwt.SigningMethodHS256.Name}),
        }

        if !validate </span><span class="cov0" title="0">{
                ops = append(ops, jwt.WithoutClaimsValidation())
        }</span>

        <span class="cov0" title="0">token, err := jwt.ParseWithClaims(tokenStr, &amp;SessionAccessClaims{}, func(token *jwt.Token) (any, error) </span><span class="cov0" title="0">{
                return secret, nil
        }</span>, ops...)
        <span class="cov0" title="0">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                return nil, ErrInvalidToken
        }</span>

        <span class="cov0" title="0">claims, ok := token.Claims.(*SessionAccessClaims)
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrInvalidToken
        }</span>

        <span class="cov0" title="0">return claims, nil</span>
}

func IssueAccessJWT(access *SessionAccessClaims, secret []byte) (string, error) <span class="cov0" title="0">{
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, access)

        return token.SignedString(secret)
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package auth

import "github.com/google/uuid"

type AuthData struct {
        SessionID uuid.UUID
        AccountID uuid.UUID
}

func ClaimsToAuthData(claims *SessionAccessClaims) (*AuthData, error) <span class="cov0" title="0">{
        sessionID, err := claims.GetSessionID()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">accountID, err := claims.GetAccountID()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">data := &amp;AuthData{
                SessionID: sessionID,
                AccountID: accountID,
        }

        return data, nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package auth

import (
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        authpb "github.com/m11ano/budget_planner/backend/auth/pkg/proto_pb/access_claims"
)

type SessionAccessClaims struct {
        authpb.AccessClaims
        jwt.RegisteredClaims
}

func (c *SessionAccessClaims) GetSessionID() (uuid.UUID, error) <span class="cov0" title="0">{
        return uuid.Parse(c.SessionId)
}</span>

func (c *SessionAccessClaims) GetAccountID() (uuid.UUID, error) <span class="cov0" title="0">{
        return uuid.Parse(c.AccountId)
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package auth

import (
        "context"

        "github.com/LastPossum/kamino"
)

type contextKey string

const (
        ContextKeyAccessToken    contextKey = "auth_context_access_token"
        ContextKeyAuthData       contextKey = "auth_context_auth_data"
        ContextKeyAuthCheckRight contextKey = "auth_context_auth_check_right"
)

func GetAuthData(ctx context.Context) *AuthData <span class="cov0" title="0">{
        data, ok := ctx.Value(ContextKeyAuthData).(*AuthData)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">copy, err := kamino.Clone(data)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return copy</span>
}

func SetAccessToken(ctx context.Context, token string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, ContextKeyAccessToken, token)
}</span>

func AccessToken(ctx context.Context) (string, bool) <span class="cov0" title="0">{
        token, ok := ctx.Value(ContextKeyAccessToken).(string)
        return token, ok
}</span>

func SetAuthData(ctx context.Context, data *AuthData) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, ContextKeyAuthData, data)
}</span>

func WithoutCheckRight(ctx context.Context) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, ContextKeyAuthCheckRight, false)
}</span>

func WithCheckRight(ctx context.Context) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, ContextKeyAuthCheckRight, true)
}</span>

func IsNeedToCheckRights(ctx context.Context) bool <span class="cov0" title="0">{
        is, ok := ctx.Value(ContextKeyAuthCheckRight).(bool)
        return ok &amp;&amp; is
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package backoff

import (
        "container/heap"
        "context"
        "sync"
        "sync/atomic"
        "time"
)

type ControllerOption func(*controllerOptions)

type SessionOption func(*sessionOptions)

const DefaultGroupID = "default"

type Controller struct {
        ctx        context.Context
        cancel     context.CancelFunc
        heapCtrl   *heapController
        sessions   map[string]*Session
        groupCfg   map[string]*sessionOptions
        mu         sync.RWMutex
        opts       *controllerOptions
        evictGoing int32
}

func NewController(ctrlOpts ...ControllerOption) *Controller <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        cOpts := defaultControllerOptions()
        for _, opt := range ctrlOpts </span><span class="cov0" title="0">{
                opt(cOpts)
        }</span>

        <span class="cov0" title="0">ctrl := &amp;Controller{
                ctx:        ctx,
                cancel:     cancel,
                heapCtrl:   newHeapController(),
                sessions:   make(map[string]*Session),
                groupCfg:   make(map[string]*sessionOptions),
                opts:       cOpts,
                evictGoing: 1,
        }

        ctrl.groupCfg[DefaultGroupID] = defaultSessionOptions()

        go ctrl.evictLoop()
        return ctrl</span>
}

func (c *Controller) SetConfigForGroup(groupID string, opts ...SessionOption) <span class="cov0" title="0">{
        cfg := defaultSessionOptions()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(cfg)
        }</span>

        <span class="cov0" title="0">c.mu.Lock()
        c.groupCfg[groupID] = cfg
        c.mu.Unlock()</span>
}

func (c *Controller) GetIfExists(sessionKey string, groupID ...string) (*Session, bool) <span class="cov0" title="0">{
        useGroup := DefaultGroupID
        if len(groupID) &gt; 0 &amp;&amp; groupID[0] != "" </span><span class="cov0" title="0">{
                useGroup = groupID[0]
        }</span>
        <span class="cov0" title="0">key := sessionKey + "_" + useGroup

        c.mu.RLock()
        sess, sessOK := c.sessions[key]
        _, cfgOK := c.groupCfg[useGroup]
        c.mu.RUnlock()

        if sessOK &amp;&amp; cfgOK &amp;&amp; !sess.isExpired() </span><span class="cov0" title="0">{
                return sess, true
        }</span>

        <span class="cov0" title="0">return nil, false</span>
}

func (c *Controller) Get(sessionKey string, groupIDs ...string) *Session <span class="cov0" title="0">{
        useGroup := DefaultGroupID
        if len(groupIDs) &gt; 0 &amp;&amp; groupIDs[0] != "" </span><span class="cov0" title="0">{
                useGroup = groupIDs[0]
        }</span>
        <span class="cov0" title="0">key := sessionKey + "_" + useGroup

        c.mu.RLock()
        sess, sessOK := c.sessions[key]
        cfg, cfgOK := c.groupCfg[useGroup]
        c.mu.RUnlock()

        if sessOK &amp;&amp; cfgOK &amp;&amp; !sess.isExpired() </span><span class="cov0" title="0">{
                return sess
        }</span>

        <span class="cov0" title="0">c.mu.Lock()
        defer c.mu.Unlock()

        if !cfgOK </span><span class="cov0" title="0">{
                cfg = defaultSessionOptions()
                c.groupCfg[useGroup] = cfg
        }</span>

        <span class="cov0" title="0">sess = newSession(c.heapCtrl, key, cfg)
        c.sessions[key] = sess

        return sess</span>
}

func (c *Controller) removeSession(s *Session) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        delete(c.sessions, s.Key())
        atomic.StoreInt32(&amp;s.expired, 1)
}</span>

func (c *Controller) evictLoop() <span class="cov0" title="0">{
        defer atomic.StoreInt32(&amp;c.evictGoing, 0)

        ticker := time.NewTicker(c.opts.ClearInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-c.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        var toRemove []*Session

                        c.heapCtrl.mu.Lock()
                        for c.heapCtrl.Len() &gt; 0 </span><span class="cov0" title="0">{
                                item := c.heapCtrl.items[0]
                                if !item.session.isExpired() </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">heap.Pop(c.heapCtrl)
                                toRemove = append(toRemove, item.session)</span>
                        }
                        <span class="cov0" title="0">c.heapCtrl.mu.Unlock()

                        for _, s := range toRemove </span><span class="cov0" title="0">{
                                c.removeSession(s)
                        }</span>
                }
        }
}

func (c *Controller) Stop(ctx context.Context) <span class="cov0" title="0">{
        c.cancel()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        if atomic.LoadInt32(&amp;c.evictGoing) == 0 </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package backoff

import (
        "container/heap"
        "sync"
        "time"
)

type heapItem struct {
        session   *Session
        expiredAt time.Time
        index     int
}

type heapController struct {
        mu    sync.Mutex
        items []*heapItem
        idx   map[string]*heapItem
}

func newHeapController() *heapController <span class="cov0" title="0">{
        h := &amp;heapController{idx: make(map[string]*heapItem)}
        heap.Init(h)
        return h
}</span>

func (h *heapController) Len() int <span class="cov0" title="0">{
        return len(h.items)
}</span>

func (h *heapController) Less(i, j int) bool <span class="cov0" title="0">{
        return h.items[i].expiredAt.Before(h.items[j].expiredAt)
}</span>

func (h *heapController) Swap(i, j int) <span class="cov0" title="0">{
        h.items[i], h.items[j] = h.items[j], h.items[i]
        h.items[i].index = i
        h.items[j].index = j
}</span>

func (h *heapController) Push(x interface{}) <span class="cov0" title="0">{
        // nolint
        item := x.(*heapItem)
        h.items = append(h.items, item)
        item.index = len(h.items) - 1
        h.idx[item.session.Key()] = item
}</span>

func (h *heapController) Pop() interface{} <span class="cov0" title="0">{
        n := len(h.items)
        item := h.items[n-1]
        h.items = h.items[:n-1]
        delete(h.idx, item.session.Key())
        return item
}</span>

func (h *heapController) add(s *Session) <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()
        h.Push(&amp;heapItem{
                session:   s,
                expiredAt: s.expiredAt,
        })
}</span>

func (h *heapController) update(s *Session) <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()
        if item, ok := h.idx[s.key]; ok </span><span class="cov0" title="0">{
                item.expiredAt = s.expiredAt
                heap.Fix(h, item.index)
        }</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package backoff

import "time"

type controllerOptions struct {
        ClearInterval time.Duration
}

func defaultControllerOptions() *controllerOptions <span class="cov0" title="0">{
        return &amp;controllerOptions{
                ClearInterval: 1 * time.Minute,
        }
}</span>

func WithControllerClearInterval(d time.Duration) ControllerOption <span class="cov0" title="0">{
        return func(o *controllerOptions) </span><span class="cov0" title="0">{
                o.ClearInterval = d
        }</span>
}

type sessionOptions struct {
        Ttl             time.Duration
        InitialInterval time.Duration
        Multiplier      float64
        MaxInterval     time.Duration
}

func defaultSessionOptions() *sessionOptions <span class="cov0" title="0">{
        return &amp;sessionOptions{
                Ttl:             1 * time.Hour,
                InitialInterval: 1 * time.Second,
                Multiplier:      2,
                MaxInterval:     60 * time.Second,
        }
}</span>

func WithTtl(d time.Duration) SessionOption <span class="cov0" title="0">{
        return func(o *sessionOptions) </span><span class="cov0" title="0">{
                o.Ttl = d
        }</span>
}

func WithInitialInterval(d time.Duration) SessionOption <span class="cov0" title="0">{
        return func(o *sessionOptions) </span><span class="cov0" title="0">{
                o.InitialInterval = d
        }</span>
}

func WithMultiplier(m float64) SessionOption <span class="cov0" title="0">{
        return func(o *sessionOptions) </span><span class="cov0" title="0">{
                o.Multiplier = m
        }</span>
}

func WithMaxInterval(d time.Duration) SessionOption <span class="cov0" title="0">{
        return func(o *sessionOptions) </span><span class="cov0" title="0">{
                o.MaxInterval = d
        }</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package backoff

import (
        "math"
        "sync"
        "sync/atomic"
        "time"
)

type Session struct {
        heapCtrl       *heapController
        key            string
        cfg            *sessionOptions
        nextAllowedAt  time.Time
        mu             sync.RWMutex
        expiredAt      time.Time
        expired        int32
        counter        int
        backoffCounter int
}

func newSession(heapCtrl *heapController, key string, opts *sessionOptions) *Session <span class="cov0" title="0">{
        s := &amp;Session{
                heapCtrl:      heapCtrl,
                key:           key,
                cfg:           opts,
                nextAllowedAt: time.Now(),
                expiredAt:     time.Now().Add(opts.Ttl),
        }

        heapCtrl.add(s)
        return s
}</span>

func (s *Session) isExpired() bool <span class="cov0" title="0">{
        return time.Now().After(s.expiredAt)
}</span>

func (s *Session) AddBackoff() bool <span class="cov0" title="0">{
        if atomic.LoadInt32(&amp;s.expired) == 1 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()

        mul := time.Duration(math.Pow(s.cfg.Multiplier, float64(s.backoffCounter)))

        s.backoffCounter++

        diffTime := time.Duration(s.cfg.InitialInterval * mul)
        if diffTime &gt; s.cfg.MaxInterval </span><span class="cov0" title="0">{
                diffTime = s.cfg.MaxInterval
        }</span>

        <span class="cov0" title="0">s.nextAllowedAt = time.Now().Add(diffTime)
        s.expiredAt = time.Now().Add(s.cfg.Ttl)
        s.heapCtrl.update(s)

        return true</span>
}

func (s *Session) Counter() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.counter
}</span>

func (s *Session) AddCounter(value ...int) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        val := 1
        if len(value) &gt; 0 </span><span class="cov0" title="0">{
                val = value[0]
        }</span>

        <span class="cov0" title="0">s.counter += val
        s.expiredAt = time.Now().Add(s.cfg.Ttl)
        s.heapCtrl.update(s)</span>
}

func (s *Session) Key() string <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.key
}</span>

func (s *Session) IsAllowed() bool <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return time.Now().After(s.nextAllowedAt) || time.Now().Equal(s.nextAllowedAt)
}</span>

func (s *Session) Reset() <span class="cov0" title="0">{
        if atomic.LoadInt32(&amp;s.expired) == 1 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()

        s.counter = 0
        s.backoffCounter = 0
        s.nextAllowedAt = time.Now()
        s.expiredAt = time.Now().Add(s.cfg.Ttl)
        s.heapCtrl.update(s)</span>
}

func (s *Session) NextAllowed() time.Time <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.nextAllowedAt
}</span>

func (s *Session) NextAllowedUntilSeconds() int64 <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        diff := time.Until(s.nextAllowedAt).Seconds()
        if diff &lt; 0 </span><span class="cov0" title="0">{
                diff = 0
        }</span>

        <span class="cov0" title="0">return int64(math.Ceil(diff))</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package dbhelper

import (
        "fmt"
        "reflect"
        "sync"
)

type ConverterFunc func(src interface{}) (interface{}, error)

var convertersMu sync.RWMutex

var converters = make(map[string]ConverterFunc)

func converterKey(srcType, dstType reflect.Type) string <span class="cov10" title="25">{
        return srcType.String() + "-&gt;" + dstType.String()
}</span>

func RegisterBidirectionalConverter(dbType, domainType reflect.Type,
        dbToDomain ConverterFunc, domainToDB ConverterFunc,
) <span class="cov4" title="4">{
        convertersMu.Lock()
        defer convertersMu.Unlock()
        converters[converterKey(dbType, domainType)] = dbToDomain
        converters[converterKey(domainType, dbType)] = domainToDB
}</span>

func getConverter(srcType, dstType reflect.Type) (ConverterFunc, bool) <span class="cov8" title="17">{
        convertersMu.RLock()
        defer convertersMu.RUnlock()
        conv, ok := converters[converterKey(srcType, dstType)]
        return conv, ok
}</span>

func safeConvert(conv ConverterFunc, src interface{}) (result interface{}, err error) <span class="cov5" title="5">{
        defer func() </span><span class="cov5" title="5">{
                if r := recover(); r != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("panic in converter: %v", r)
                }</span>
        }()
        <span class="cov5" title="5">result, err = conv(src)
        return</span>
}

func ConvertDBToDomain(dbRecord, domainModel interface{}) error <span class="cov6" title="6">{
        dbVal := reflect.ValueOf(dbRecord)
        if dbVal.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                dbVal = dbVal.Elem()
        }</span>
        <span class="cov6" title="6">if dbVal.Kind() != reflect.Struct </span><span class="cov1" title="1">{
                return fmt.Errorf("dbRecord must be a struct or pointer to a struct")
        }</span>

        <span class="cov5" title="5">dVal := reflect.ValueOf(domainModel)
        if dVal.Kind() != reflect.Ptr || dVal.Elem().Kind() != reflect.Struct </span><span class="cov1" title="1">{
                return fmt.Errorf("domainModel must be a pointer to a struct")
        }</span>
        <span class="cov4" title="4">dVal = dVal.Elem()
        dType := dVal.Type()

        dbType := dbVal.Type()
        for i := 0; i &lt; dbType.NumField(); i++ </span><span class="cov6" title="8">{
                dbField := dbType.Field(i)
                dbFieldValue := dbVal.Field(i)
                if !dbFieldValue.IsValid() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov6" title="8">fieldName := dbField.Name

                dField, found := dType.FieldByName(fieldName)
                if !found </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov6" title="7">dFieldVal := dVal.FieldByName(dField.Name)
                if !dFieldVal.CanSet() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov6" title="7">srcType := dbFieldValue.Type()
                dstType := dFieldVal.Type()

                if conv, ok := getConverter(srcType, dstType); ok </span><span class="cov1" title="1">{
                        converted, err := safeConvert(conv, dbFieldValue.Interface())
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("converter error for field %s: %v", dbField.Name, err)
                        }</span>
                        <span class="cov1" title="1">convVal := reflect.ValueOf(converted)
                        if !convVal.Type().AssignableTo(dstType) </span><span class="cov0" title="0">{
                                return fmt.Errorf("converted value for field %s is not assignable to type %s", dbField.Name, dstType)
                        }</span>
                        <span class="cov1" title="1">dFieldVal.Set(convVal)
                        continue</span>
                }

                <span class="cov6" title="6">if srcType.AssignableTo(dstType) </span><span class="cov5" title="5">{
                        dFieldVal.Set(dbFieldValue)
                        continue</span>
                }

                <span class="cov1" title="1">if srcType.ConvertibleTo(dstType) </span><span class="cov0" title="0">{
                        dFieldVal.Set(dbFieldValue.Convert(dstType))
                        continue</span>
                }

                <span class="cov1" title="1">return fmt.Errorf("no converter registered for field %s: %s -&gt; %s", dbField.Name, srcType, dstType)</span>
        }

        <span class="cov4" title="3">return nil</span>
}

func StructToDBMap(src, dbSchema interface{}) (map[string]interface{}, error) <span class="cov5" title="5">{
        result := make(map[string]interface{})

        schemaVal := reflect.ValueOf(dbSchema)
        if schemaVal.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                schemaVal = schemaVal.Elem()
        }</span>
        <span class="cov5" title="5">if schemaVal.Kind() != reflect.Struct </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("dbSchema must be a struct or pointer to a struct")
        }</span>
        <span class="cov4" title="4">schemaType := schemaVal.Type()

        srcVal := reflect.ValueOf(src)
        if srcVal.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                srcVal = srcVal.Elem()
        }</span>
        <span class="cov4" title="4">if srcVal.Kind() != reflect.Struct </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("src must be a struct or pointer to a struct")
        }</span>
        <span class="cov4" title="3">srcType := srcVal.Type()

        for i := 0; i &lt; schemaType.NumField(); i++ </span><span class="cov6" title="7">{
                schemaField := schemaType.Field(i)
                key := schemaField.Tag.Get("db")
                if key == "" </span><span class="cov0" title="0">{
                        key = schemaField.Name
                }</span>

                <span class="cov6" title="7">srcField, found := srcType.FieldByName(schemaField.Name)
                if !found </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov6" title="7">srcFieldVal := srcVal.FieldByName(srcField.Name)
                expectedType := schemaField.Type

                srcTypeVal := srcFieldVal.Type()

                if conv, ok := getConverter(srcTypeVal, expectedType); ok </span><span class="cov1" title="1">{
                        converted, err := safeConvert(conv, srcFieldVal.Interface())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cant convert field %s: %v", schemaField.Name, err)
                        }</span>
                        <span class="cov1" title="1">convVal := reflect.ValueOf(converted)
                        if !convVal.Type().AssignableTo(expectedType) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov1" title="1">result[key] = converted
                        continue</span>
                }

                <span class="cov6" title="6">if srcTypeVal.AssignableTo(expectedType) </span><span class="cov5" title="5">{
                        result[key] = srcFieldVal.Interface()
                        continue</span>
                }

                <span class="cov1" title="1">if srcTypeVal.ConvertibleTo(expectedType) </span><span class="cov0" title="0">{
                        convVal := srcFieldVal.Convert(expectedType)
                        result[key] = convVal.Interface()
                        continue</span>
                }
        }
        <span class="cov4" title="3">return result, nil</span>
}

func ExtractDBFields(dbModel interface{}) []string <span class="cov2" title="2">{
        val := reflect.ValueOf(dbModel)
        if val.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                val = val.Elem()
        }</span>
        <span class="cov2" title="2">if val.Kind() != reflect.Struct </span><span class="cov1" title="1">{
                return []string{}
        }</span>
        <span class="cov1" title="1">typ := val.Type()
        var fields []string
        for i := 0; i &lt; typ.NumField(); i++ </span><span class="cov5" title="5">{
                field := typ.Field(i)
                dbTag := field.Tag.Get("db")
                if dbTag == "" </span><span class="cov0" title="0">{
                        dbTag = field.Name
                }</span>
                <span class="cov5" title="5">fields = append(fields, dbTag)</span>
        }
        <span class="cov1" title="1">return fields</span>
}

func DBModelToMap(dbModel interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        result := make(map[string]interface{})

        val := reflect.ValueOf(dbModel)
        if val.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                val = val.Elem()
        }</span>
        <span class="cov0" title="0">if val.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dbModel must be a struct or pointer to a struct")
        }</span>

        <span class="cov0" title="0">typ := val.Type()
        for i := 0; i &lt; typ.NumField(); i++ </span><span class="cov0" title="0">{
                field := typ.Field(i)
                dbTag := field.Tag.Get("db")
                if dbTag == "" </span><span class="cov0" title="0">{
                        dbTag = field.Name
                }</span>

                <span class="cov0" title="0">fv := val.Field(i)
                if !fv.CanInterface() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">result[dbTag] = fv.Interface()</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package emailnormalize

import (
        "errors"
        "net/mail"
        "strings"
)

type Rules uint

const (
        DashAddressing Rules = 1 &lt;&lt; iota
        PlusAddressing
        LocalPartAsHostname
        StripPeriods
)

type Provider struct {
        Name      string
        Domains   []string
        Canonical string
        Flags     Rules
}

type Result struct {
        Address           string
        NormalizedAddress string
        Provider          string
}

var Providers = []Provider{
        {
                Name:      "Fastmail",
                Domains:   []string{"fastmail.com", "messagingengine.com", "fastmail.fm"},
                Canonical: "fastmail.com",
                Flags:     PlusAddressing | LocalPartAsHostname,
        },
        {
                Name:      "Apple",
                Domains:   []string{"icloud.com", "me.com", "mac.com"},
                Canonical: "icloud.com",
                Flags:     PlusAddressing,
        },
        {
                Name: "Yahoo",
                Domains: []string{
                        "yahoo.com.ar", "yahoo.com.au", "yahoo.at", "yahoo.be", "yahoo.com.br",
                        "ca.yahoo.com", "qc.yahoo.com", "yahoo.com.co", "yahoo.com.hr", "yahoo.cz",
                        "yahoo.dk", "yahoo.fi", "yahoo.fr", "yahoo.de", "yahoo.gr",
                        "yahoo.com.hk", "yahoo.hu", "yahoo.co.in", "yahoo.in", "yahoo.co.id",
                        "yahoo.ie", "yahoo.co.il", "yahoo.it", "yahoo.co.jp", "yahoo.com.my",
                        "yahoo.com.mx", "yahoo.ae", "yahoo.nl", "yahoo.co.nz", "yahoo.no",
                        "yahoo.com.ph", "yahoo.pl", "yahoo.pt", "yahoo.ro", "yahoo.ru",
                        "yahoo.com.sg", "yahoo.co.za", "yahoo.es", "yahoo.se", "yahoo.ch/fr",
                        "yahoo.ch/de", "yahoo.com.tw", "yahoo.co.th", "yahoo.com.tr", "yahoo.co.uk",
                        "yahoo.com", "yahoo.com.vn", "ymail.com", "yahoodns.net",
                },
                Canonical: "yahoo.com",
                Flags:     DashAddressing,
        },
        {
                Name:      "Google",
                Domains:   []string{"gmail.com", "googlemail.com", "google.com"},
                Canonical: "gmail.com",
                Flags:     PlusAddressing | StripPeriods,
        },
        {
                Name:      "Rambler",
                Domains:   []string{"rambler.ru", "lenta.ru", "autorambler.ru", "myrambler.ru", "ro.ru"},
                Canonical: "rambler.ru",
                Flags:     0,
        },
        {
                Name: "Microsoft",
                Domains: []string{
                        "hotmail.com", "hotmail.at", "hotmail.be", "hotmail.ca", "hotmail.cl",
                        "hotmail.co.il", "hotmail.co.nz", "hotmail.co.th", "hotmail.co.uk",
                        "hotmail.com.ar", "hotmail.com.au", "hotmail.com.br", "hotmail.com.gr",
                        "hotmail.com.mx", "hotmail.com.pe", "hotmail.com.tr", "hotmail.com.vn",
                        "hotmail.cz", "hotmail.de", "hotmail.dk", "hotmail.es", "hotmail.fr",
                        "hotmail.hu", "hotmail.id", "hotmail.ie", "hotmail.in", "hotmail.it",
                        "hotmail.jp", "hotmail.kr", "hotmail.lv", "hotmail.my", "hotmail.ph",
                        "hotmail.pt", "hotmail.sa", "hotmail.sg", "hotmail.sk", "live.com",
                        "live.be", "live.co.uk", "live.com.ar", "live.com.mx", "live.de",
                        "live.es", "live.eu", "live.fr", "live.it", "live.nl", "msn.com",
                        "outlook.com", "outlook.at", "outlook.be", "outlook.cl", "outlook.co.il",
                        "outlook.co.nz", "outlook.co.th", "outlook.com.ar", "outlook.com.au",
                        "outlook.com.br", "outlook.com.gr", "outlook.com.pe", "outlook.com.tr",
                        "outlook.com.vn", "outlook.cz", "outlook.de", "outlook.dk", "outlook.es",
                        "outlook.fr", "outlook.hu", "outlook.id", "outlook.ie", "outlook.in",
                        "outlook.it", "outlook.jp", "outlook.kr", "outlook.lv", "outlook.my",
                        "outlook.ph", "outlook.pt", "outlook.sa", "outlook.sg", "outlook.sk",
                        "passport.com",
                },
                Canonical: "outlook.com",
                Flags:     PlusAddressing,
        },
        {
                Name: "Yandex",
                Domains: []string{
                        "narod.ru", "yandex.ru", "yandex.org", "yandex.net", "yandex.net.ru",
                        "yandex.com.ru", "yandex.ua", "yandex.com.ua", "yandex.by", "yandex.eu",
                        "yandex.ee", "yandex.lt", "yandex.lv", "yandex.md", "yandex.uz",
                        "yandex.mx", "yandex.do", "yandex.tm", "yandex.de", "yandex.ie",
                        "yandex.in", "yandex.qa", "yandex.so", "yandex.nu", "yandex.tj",
                        "yandex.dk", "yandex.es", "yandex.pt", "yandex.kz", "yandex.pl",
                        "yandex.lu", "yandex.it", "yandex.az", "yandex.ro", "yandex.rs",
                        "yandex.sk", "yandex.no", "ya.ru", "yandex.com", "yandex.asia",
                        "yandex.mobi",
                },
                Canonical: "yandex.ru",
                Flags:     PlusAddressing,
        },
        {
                Name:      "ProtonMail",
                Domains:   []string{"protonmail.ch", "protonmail.com", "proton.me", "pm.me"},
                Canonical: "protonmail.ch",
                Flags:     PlusAddressing,
        },
}

func Normalize(email string) (*Result, error) <span class="cov0" title="0">{
        addr, err := mail.ParseAddress(email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">raw := strings.ToLower(addr.Address)
        parts := strings.SplitN(raw, "@", 2)
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid email address")
        }</span>
        <span class="cov0" title="0">local, domain := parts[0], parts[1]

        provider := lookupProvider(domain)
        if provider != nil </span><span class="cov0" title="0">{
                if provider.Flags&amp;LocalPartAsHostname != 0 </span><span class="cov0" title="0">{
                        if i := strings.Index(domain, "."); i != -1 </span><span class="cov0" title="0">{
                                local = domain[:i]
                        }</span>
                }

                <span class="cov0" title="0">domain = provider.Canonical

                if provider.Flags&amp;StripPeriods != 0 </span><span class="cov0" title="0">{
                        local = strings.ReplaceAll(local, ".", "")
                }</span>

                <span class="cov0" title="0">if provider.Flags&amp;PlusAddressing != 0 </span><span class="cov0" title="0">{
                        if i := strings.Index(local, "+"); i != -1 </span><span class="cov0" title="0">{
                                local = local[:i]
                        }</span>
                }

                <span class="cov0" title="0">if provider.Flags&amp;DashAddressing != 0 </span><span class="cov0" title="0">{
                        if i := strings.Index(local, "-"); i != -1 </span><span class="cov0" title="0">{
                                local = local[:i]
                        }</span>
                }
        }

        <span class="cov0" title="0">return &amp;Result{
                Address:           addr.Address,
                NormalizedAddress: local + "@" + domain,
                Provider: func() string </span><span class="cov0" title="0">{
                        if provider != nil </span><span class="cov0" title="0">{
                                return provider.Name
                        }</span>
                        <span class="cov0" title="0">return ""</span>
                }(),
        }, nil
}

func lookupProvider(domain string) *Provider <span class="cov0" title="0">{
        for i := range Providers </span><span class="cov0" title="0">{
                p := &amp;Providers[i]
                for _, d := range p.Domains </span><span class="cov0" title="0">{
                        if domain == d </span><span class="cov0" title="0">{
                                return p
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package pgclient

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
)

type (
        txKey      struct{}
        txDepthKey struct{}
)

type clientImpl struct {
        serverID        string
        pool            Pool
        readOnly        bool
        defaultIsoLevel TxIsoLevel
        txKey           txKey
        txDepthKey      txDepthKey
        logger          *slog.Logger
}

// NewClientOpts - options for constructing pg client
type NewClientOpts struct {
        ReadOnly        bool
        DefaultIsoLevel TxIsoLevel
        Logger          *slog.Logger
        LogQueries      bool
}

// NewClient - create new pg client
func NewClient(ctx context.Context, serverID string, dsn string, opts NewClientOpts) (*clientImpl, error) <span class="cov4" title="3">{
        pgxCfg, err := pgxpool.ParseConfig(dsn)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("unable to parse dsn: %w", err)
        }</span>

        <span class="cov3" title="2">if opts.ReadOnly </span><span class="cov1" title="1">{
                pgxCfg.ConnConfig.RuntimeParams["default_transaction_read_only"] = "true"
        }</span>

        <span class="cov3" title="2">if opts.LogQueries </span><span class="cov1" title="1">{
                pgxCfg.ConnConfig.Tracer = &amp;pgxTracer{logger: opts.Logger}
        }</span>

        <span class="cov3" title="2">dbpool, err := pgxpool.NewWithConfig(ctx, pgxCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to create pg connection pool: %w", err)
        }</span>

        <span class="cov3" title="2">client := &amp;clientImpl{
                serverID:        serverID,
                pool:            dbpool,
                readOnly:        opts.ReadOnly,
                defaultIsoLevel: ReadCommitted,
        }

        if opts.DefaultIsoLevel != "" </span><span class="cov1" title="1">{
                client.defaultIsoLevel = opts.DefaultIsoLevel
        }</span>

        <span class="cov3" title="2">if opts.Logger != nil </span><span class="cov1" title="1">{
                client.logger = opts.Logger
        }</span>

        <span class="cov3" title="2">return client, nil</span>
}

var _ Client = (*clientImpl)(nil)

// ServerID - get server id
func (c *clientImpl) ServerID() string <span class="cov5" title="5">{
        return c.serverID
}</span>

// Pool - get pool connection
func (c *clientImpl) Pool() Pool <span class="cov6" title="7">{
        return c.pool
}</span>

// GetConn - get pg connection: pool or tx
func (c *clientImpl) GetConn(ctx context.Context) Conn <span class="cov3" title="2">{
        tx, ok := ctx.Value(c.txKey).(pgx.Tx)
        if ok &amp;&amp; tx != nil </span><span class="cov1" title="1">{
                return tx
        }</span>

        <span class="cov1" title="1">return c.pool</span>
}

// Do - execute tx with default iso level
func (c *clientImpl) Do(ctx context.Context, fn func(context.Context) error) error <span class="cov7" title="10">{
        return c.DoWithIsoLvl(ctx, c.defaultIsoLevel, fn)
}</span>

// DoWithIsoLvl - execute tx with iso level
func (c *clientImpl) DoWithIsoLvl(ctx context.Context, isoLvl TxIsoLevel, fn func(context.Context) error) error <span class="cov10" title="21">{
        tx, ok := ctx.Value(c.txKey).(pgx.Tx)
        if ok &amp;&amp; tx != nil </span><span class="cov6" title="7">{
                depth, ok := ctx.Value(c.txKey).(int)
                if !ok </span><span class="cov6" title="7">{
                        depth = 0
                }</span>

                <span class="cov6" title="7">spName := fmt.Sprintf("sp_%d", depth+1)

                if _, err := tx.Exec(ctx, "SAVEPOINT "+spName); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov6" title="6">ctx = context.WithValue(ctx, c.txDepthKey, depth+1)

                err := fn(ctx)
                if err != nil </span><span class="cov3" title="2">{
                        _, rbErr := tx.Exec(ctx, "ROLLBACK TO SAVEPOINT "+spName)
                        if rbErr != nil </span><span class="cov1" title="1">{
                                if c.logger != nil </span><span class="cov1" title="1">{
                                        c.logger.ErrorContext(ctx, "rollback to savepoint failed", slog.Any("error", rbErr.Error()))
                                }</span>
                        }

                        <span class="cov3" title="2">return err</span>
                }

                <span class="cov5" title="4">if _, err := tx.Exec(ctx, "RELEASE SAVEPOINT "+spName); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov4" title="3">return nil</span>
        }

        <span class="cov8" title="14">tx, err := c.pool.BeginTx(ctx, pgx.TxOptions{IsoLevel: pgx.TxIsoLevel(isoLvl)})
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov8" title="13">ctx = context.WithValue(ctx, c.txKey, tx)
        ctx = context.WithValue(ctx, c.txDepthKey, 0)

        defer func() </span><span class="cov8" title="13">{
                if p := recover(); p != nil </span><span class="cov3" title="2">{
                        rbErr := tx.Rollback(ctx)
                        if rbErr != nil </span><span class="cov1" title="1">{
                                if c.logger != nil </span><span class="cov1" title="1">{
                                        c.logger.ErrorContext(ctx, "rollback on panic failed", slog.Any("error", rbErr.Error()))
                                }</span>
                        }

                        <span class="cov3" title="2">panic(p)</span>
                }
        }()

        <span class="cov8" title="13">err = fn(ctx)
        if err != nil </span><span class="cov5" title="5">{
                rbErr := tx.Rollback(ctx)
                if rbErr != nil </span><span class="cov1" title="1">{
                        if c.logger != nil </span><span class="cov1" title="1">{
                                c.logger.ErrorContext(ctx, "rollback failed", slog.Any("error", rbErr.Error()))
                        }</span>
                }

                <span class="cov5" title="5">return err</span>
        }

        <span class="cov6" title="6">if commitErr := tx.Commit(ctx); commitErr != nil </span><span class="cov1" title="1">{
                return commitErr
        }</span>

        <span class="cov5" title="5">return nil</span>
}

// Close - close pool
func (c *clientImpl) Close() <span class="cov1" title="1">{
        c.pool.Close()
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">package pgclient

import "context"

type mockImpl struct{}

func NewMock() *mockImpl <span class="cov0" title="0">{
        return &amp;mockImpl{}
}</span>

var _ Client = (*mockImpl)(nil)

func (m *mockImpl) ServerID() string <span class="cov0" title="0">{
        return "sid"
}</span>

func (m *mockImpl) Pool() Pool <span class="cov0" title="0">{
        return nil
}</span>

func (m *mockImpl) GetConn(ctx context.Context) Conn <span class="cov0" title="0">{
        return nil
}</span>

func (m *mockImpl) Do(ctx context.Context, fn func(context.Context) error) error <span class="cov0" title="0">{
        fn(ctx)
        return nil
}</span>

func (m *mockImpl) DoWithIsoLvl(ctx context.Context, isoLvl TxIsoLevel, fn func(context.Context) error) error <span class="cov0" title="0">{
        fn(ctx)
        return nil
}</span>

func (m *mockImpl) Close() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">package pgclient

import (
        "context"
        "log/slog"
        "time"
)

// TestConnection - test connection with postgres
func TestConnection(
        ctx context.Context,
        client Client,
        logger *slog.Logger,
        maxAttempt int,
        attemptSleepSeconds int,
) error <span class="cov7" title="4">{
        attemp := 1
        var err error
        for attemp &lt;= maxAttempt </span><span class="cov10" title="6">{
                err = client.Pool().Ping(ctx)
                if err != nil </span><span class="cov7" title="4">{
                        logger.Info(
                                "failed to connect to Postgress",
                                slog.String("serverID", client.ServerID()),
                                slog.Int("attemp", attemp),
                        )
                        time.Sleep(time.Duration(attemptSleepSeconds) * time.Second)
                        attemp++
                        continue</span>
                }
                <span class="cov4" title="2">break</span>
        }
        <span class="cov7" title="4">if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package pgclient

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/jackc/pgx/v5"
)

type pgxTracer struct {
        logger *slog.Logger
}

func (t *pgxTracer) TraceQueryStart(ctx context.Context, _ *pgx.Conn, data pgx.TraceQueryStartData) context.Context <span class="cov0" title="0">{
        t.logger.InfoContext(
                ctx, "start of query",
                slog.String("sql.query", data.SQL),
                slog.Any("sql.args", data.Args),
        )

        return ctx
}</span>

func (t *pgxTracer) TraceQueryEnd(ctx context.Context, _ *pgx.Conn, data pgx.TraceQueryEndData) <span class="cov0" title="0">{
        t.logger.InfoContext(
                ctx,
                "end of query",
                slog.String("sql.query.ctag", fmt.Sprintf("%v", data.CommandTag)),
                slog.Any("sql.query.error", data.Err),
        )
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">package prettylog

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log/slog"
        "os"
        "strconv"
        "strings"
        "sync"
)

const (
        timeFormat = "[15:04:05.000]"

        reset = "\033[0m"

        black        = 30
        red          = 31
        green        = 32
        yellow       = 33
        blue         = 34
        magenta      = 35
        cyan         = 36
        lightGray    = 37
        darkGray     = 90
        lightRed     = 91
        lightGreen   = 92
        lightYellow  = 93
        lightBlue    = 94
        lightMagenta = 95
        lightCyan    = 96
        white        = 97
)

func colorizer(colorCode int, v string) string <span class="cov0" title="0">{
        return fmt.Sprintf("\033[%sm%s%s", strconv.Itoa(colorCode), v, reset)
}</span>

type Handler struct {
        h                slog.Handler
        r                func([]string, slog.Attr) slog.Attr
        b                *bytes.Buffer
        m                *sync.Mutex
        writer           io.Writer
        colorize         bool
        outputEmptyAttrs bool
}

func (h *Handler) Enabled(ctx context.Context, level slog.Level) bool <span class="cov4" title="2">{
        return h.h.Enabled(ctx, level)
}</span>

func (h *Handler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov0" title="0">{
        return &amp;Handler{
                h:        h.h.WithAttrs(attrs),
                b:        h.b,
                r:        h.r,
                m:        h.m,
                writer:   h.writer,
                colorize: h.colorize,
        }
}</span>

func (h *Handler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        return &amp;Handler{
                h:        h.h.WithGroup(name),
                b:        h.b,
                r:        h.r,
                m:        h.m,
                writer:   h.writer,
                colorize: h.colorize,
        }
}</span>

func (h *Handler) computeAttrs(
        ctx context.Context,
        r slog.Record,
) (map[string]any, error) <span class="cov4" title="2">{
        h.m.Lock()
        defer func() </span><span class="cov4" title="2">{
                h.b.Reset()
                h.m.Unlock()
        }</span>()
        <span class="cov4" title="2">if err := h.h.Handle(ctx, r); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(
                        "error when calling inner handler's Handle: %w",
                        err,
                )
        }</span>

        <span class="cov4" title="2">var attrs map[string]any
        err := json.Unmarshal(h.b.Bytes(), &amp;attrs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(
                        "error when unmarshaling inner handler's Handle result: %w",
                        err,
                )
        }</span>
        <span class="cov4" title="2">return attrs, nil</span>
}

func (h *Handler) Handle(ctx context.Context, r slog.Record) error <span class="cov4" title="2">{
        colorize := func(code int, value string) string </span><span class="cov10" title="7">{
                return value
        }</span>
        <span class="cov4" title="2">if h.colorize </span><span class="cov0" title="0">{
                colorize = colorizer
        }</span>

        <span class="cov4" title="2">var level string
        levelAttr := slog.Attr{
                Key:   slog.LevelKey,
                Value: slog.AnyValue(r.Level),
        }
        if h.r != nil </span><span class="cov0" title="0">{
                levelAttr = h.r([]string{}, levelAttr)
        }</span>

        <span class="cov4" title="2">if !levelAttr.Equal(slog.Attr{}) </span><span class="cov4" title="2">{
                level = levelAttr.Value.String() + ":"

                if r.Level &lt;= slog.LevelDebug </span><span class="cov0" title="0">{
                        level = colorize(lightGray, level)
                }</span> else<span class="cov4" title="2"> if r.Level &lt;= slog.LevelInfo </span><span class="cov4" title="2">{
                        level = colorize(cyan, level)
                }</span> else<span class="cov0" title="0"> if r.Level &lt; slog.LevelWarn </span><span class="cov0" title="0">{
                        level = colorize(lightBlue, level)
                }</span> else<span class="cov0" title="0"> if r.Level &lt; slog.LevelError </span><span class="cov0" title="0">{
                        level = colorize(lightYellow, level)
                }</span> else<span class="cov0" title="0"> if r.Level &lt;= slog.LevelError+1 </span><span class="cov0" title="0">{
                        level = colorize(lightRed, level)
                }</span> else<span class="cov0" title="0"> if r.Level &gt; slog.LevelError+1 </span><span class="cov0" title="0">{
                        level = colorize(lightMagenta, level)
                }</span>
        }

        <span class="cov4" title="2">var timestamp string
        timeAttr := slog.Attr{
                Key:   slog.TimeKey,
                Value: slog.StringValue(r.Time.Format(timeFormat)),
        }
        if h.r != nil </span><span class="cov0" title="0">{
                timeAttr = h.r([]string{}, timeAttr)
        }</span>
        <span class="cov4" title="2">if !timeAttr.Equal(slog.Attr{}) </span><span class="cov4" title="2">{
                timestamp = colorize(lightGray, timeAttr.Value.String())
        }</span>

        <span class="cov4" title="2">var msg string
        msgAttr := slog.Attr{
                Key:   slog.MessageKey,
                Value: slog.StringValue(r.Message),
        }
        if h.r != nil </span><span class="cov0" title="0">{
                msgAttr = h.r([]string{}, msgAttr)
        }</span>
        <span class="cov4" title="2">if !msgAttr.Equal(slog.Attr{}) </span><span class="cov4" title="2">{
                msg = colorize(white, msgAttr.Value.String())
        }</span>

        <span class="cov4" title="2">attrs, err := h.computeAttrs(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">var attrsAsBytes []byte
        if h.outputEmptyAttrs || len(attrs) &gt; 0 </span><span class="cov1" title="1">{
                attrsAsBytes, err = json.MarshalIndent(attrs, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error when marshaling attrs: %w", err)
                }</span>
        }

        <span class="cov4" title="2">out := strings.Builder{}
        if len(timestamp) &gt; 0 </span><span class="cov4" title="2">{
                out.WriteString(timestamp)
                out.WriteString(" ")
        }</span>
        <span class="cov4" title="2">if len(level) &gt; 0 </span><span class="cov4" title="2">{
                out.WriteString(level)
                out.WriteString(" ")
        }</span>
        <span class="cov4" title="2">if len(msg) &gt; 0 </span><span class="cov4" title="2">{
                out.WriteString(msg)
                out.WriteString(" ")
        }</span>
        <span class="cov4" title="2">if len(attrsAsBytes) &gt; 0 </span><span class="cov1" title="1">{
                out.WriteString(colorize(darkGray, string(attrsAsBytes)))
        }</span>

        <span class="cov4" title="2">_, err = io.WriteString(h.writer, out.String()+"\n")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">return nil</span>
}

func suppressDefaults(
        next func([]string, slog.Attr) slog.Attr,
) func([]string, slog.Attr) slog.Attr <span class="cov4" title="2">{
        return func(groups []string, a slog.Attr) slog.Attr </span><span class="cov9" title="6">{
                if a.Key == slog.TimeKey ||
                        a.Key == slog.LevelKey ||
                        a.Key == slog.MessageKey </span><span class="cov9" title="6">{
                        return slog.Attr{}
                }</span>
                <span class="cov0" title="0">if next == nil </span><span class="cov0" title="0">{
                        return a
                }</span>
                <span class="cov0" title="0">return next(groups, a)</span>
        }
}

func New(handlerOptions *slog.HandlerOptions, options ...Option) *Handler <span class="cov4" title="2">{
        if handlerOptions == nil </span><span class="cov4" title="2">{
                handlerOptions = &amp;slog.HandlerOptions{}
        }</span>

        <span class="cov4" title="2">buf := &amp;bytes.Buffer{}
        handler := &amp;Handler{
                b: buf,
                h: slog.NewJSONHandler(buf, &amp;slog.HandlerOptions{
                        Level:       handlerOptions.Level,
                        AddSource:   handlerOptions.AddSource,
                        ReplaceAttr: suppressDefaults(handlerOptions.ReplaceAttr),
                }),
                r: handlerOptions.ReplaceAttr,
                m: &amp;sync.Mutex{},
        }

        for _, opt := range options </span><span class="cov6" title="3">{
                opt(handler)
        }</span>

        <span class="cov4" title="2">return handler</span>
}

func NewHandler(opts *slog.HandlerOptions) *Handler <span class="cov0" title="0">{
        return New(opts, WithDestinationWriter(os.Stdout), WithColor(), WithOutputEmptyAttrs())
}</span>

type Option func(h *Handler)

func WithDestinationWriter(writer io.Writer) Option <span class="cov4" title="2">{
        return func(h *Handler) </span><span class="cov4" title="2">{
                h.writer = writer
        }</span>
}

func WithColor() Option <span class="cov0" title="0">{
        return func(h *Handler) </span><span class="cov0" title="0">{
                h.colorize = true
        }</span>
}

func WithOutputEmptyAttrs() Option <span class="cov1" title="1">{
        return func(h *Handler) </span><span class="cov1" title="1">{
                h.outputEmptyAttrs = true
        }</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        (unknown)
// source: access_claims/access_claims.proto

package access_claimsv1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type AccessClaims struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        AccountId     string                 `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
        SessionId     string                 `protobuf:"bytes,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
        Meta          map[string]string      `protobuf:"bytes,3,rep,name=meta,proto3" json:"meta,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *AccessClaims) Reset() <span class="cov0" title="0">{
        *x = AccessClaims{}
        mi := &amp;file_access_claims_access_claims_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AccessClaims) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AccessClaims) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AccessClaims) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_access_claims_access_claims_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AccessClaims.ProtoReflect.Descriptor instead.
func (*AccessClaims) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_access_claims_access_claims_proto_rawDescGZIP(), []int{0}
}</span>

func (x *AccessClaims) GetAccountId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccountId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AccessClaims) GetSessionId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SessionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AccessClaims) GetMeta() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Meta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_access_claims_access_claims_proto protoreflect.FileDescriptor

const file_access_claims_access_claims_proto_rawDesc = "" +
        "\n" +
        "!access_claims/access_claims.proto\x12\x10access_claims.v1\"\xc3\x01\n" +
        "\fAccessClaims\x12\x1d\n" +
        "\n" +
        "account_id\x18\x01 \x01(\tR\taccountId\x12\x1d\n" +
        "\n" +
        "session_id\x18\x02 \x01(\tR\tsessionId\x12&lt;\n" +
        "\x04meta\x18\x03 \x03(\v2(.access_claims.v1.AccessClaims.MetaEntryR\x04meta\x1a7\n" +
        "\tMetaEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\xe0\x01\n" +
        "\x14com.access_claims.v1B\x11AccessClaimsProtoP\x01ZXgithub.com/m11ano/budget_planner/backend/auth/pkg/proto_pb/access_claims;access_claimsv1\xa2\x02\x03AXX\xaa\x02\x0fAccessClaims.V1\xca\x02\x0fAccessClaims\\V1\xe2\x02\x1bAccessClaims\\V1\\GPBMetadata\xea\x02\x10AccessClaims::V1b\x06proto3"

var (
        file_access_claims_access_claims_proto_rawDescOnce sync.Once
        file_access_claims_access_claims_proto_rawDescData []byte
)

func file_access_claims_access_claims_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_access_claims_access_claims_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_access_claims_access_claims_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_access_claims_access_claims_proto_rawDesc), len(file_access_claims_access_claims_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_access_claims_access_claims_proto_rawDescData</span>
}

var file_access_claims_access_claims_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_access_claims_access_claims_proto_goTypes = []any{
        (*AccessClaims)(nil), // 0: access_claims.v1.AccessClaims
        nil,                  // 1: access_claims.v1.AccessClaims.MetaEntry
}
var file_access_claims_access_claims_proto_depIdxs = []int32{
        1, // 0: access_claims.v1.AccessClaims.meta:type_name -&gt; access_claims.v1.AccessClaims.MetaEntry
        1, // [1:1] is the sub-list for method output_type
        1, // [1:1] is the sub-list for method input_type
        1, // [1:1] is the sub-list for extension type_name
        1, // [1:1] is the sub-list for extension extendee
        0, // [0:1] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_access_claims_access_claims_proto_init() }</span>
func file_access_claims_access_claims_proto_init() <span class="cov0" title="0">{
        if File_access_claims_access_claims_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_access_claims_access_claims_proto_rawDesc), len(file_access_claims_access_claims_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_access_claims_access_claims_proto_goTypes,
                DependencyIndexes: file_access_claims_access_claims_proto_depIdxs,
                MessageInfos:      file_access_claims_access_claims_proto_msgTypes,
        }.Build()
        File_access_claims_access_claims_proto = out.File
        file_access_claims_access_claims_proto_goTypes = nil
        file_access_claims_access_claims_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: access_claims/access_claims.proto

package access_claimsv1

import (
        "bytes"
        "errors"
        "fmt"
        "net"
        "net/mail"
        "net/url"
        "regexp"
        "sort"
        "strings"
        "time"
        "unicode/utf8"

        "google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
        _ = bytes.MinRead
        _ = errors.New("")
        _ = fmt.Print
        _ = utf8.UTFMax
        _ = (*regexp.Regexp)(nil)
        _ = (*strings.Reader)(nil)
        _ = net.IPv4len
        _ = time.Duration(0)
        _ = (*url.URL)(nil)
        _ = (*mail.Address)(nil)
        _ = anypb.Any{}
        _ = sort.Sort
)

// Validate checks the field values on AccessClaims with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AccessClaims) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on AccessClaims with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AccessClaimsMultiError, or
// nil if none found.
func (m *AccessClaims) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *AccessClaims) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for AccountId

        // no validation rules for SessionId

        // no validation rules for Meta

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return AccessClaimsMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AccessClaimsMultiError is an error wrapping multiple validation errors
// returned by AccessClaims.ValidateAll() if the designated constraints aren't met.
type AccessClaimsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccessClaimsMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m AccessClaimsMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// AccessClaimsValidationError is the validation error returned by
// AccessClaims.Validate if the designated constraints aren't met.
type AccessClaimsValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e AccessClaimsValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e AccessClaimsValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e AccessClaimsValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e AccessClaimsValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e AccessClaimsValidationError) ErrorName() string <span class="cov0" title="0">{ return "AccessClaimsValidationError" }</span>

// Error satisfies the builtin error interface
func (e AccessClaimsValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sAccessClaims.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = AccessClaimsValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = AccessClaimsValidationError{}
</pre>
		
		<pre class="file" id="file78" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        (unknown)
// source: auth_service/service.proto

package auth_servicev1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Tokens struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        RefreshJwt    string                 `protobuf:"bytes,1,opt,name=refresh_jwt,json=refreshJwt,proto3" json:"refresh_jwt,omitempty"`
        AccessJwt     string                 `protobuf:"bytes,2,opt,name=access_jwt,json=accessJwt,proto3" json:"access_jwt,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Tokens) Reset() <span class="cov0" title="0">{
        *x = Tokens{}
        mi := &amp;file_auth_service_service_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Tokens) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Tokens) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Tokens) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_service_service_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Tokens.ProtoReflect.Descriptor instead.
func (*Tokens) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_service_service_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Tokens) GetRefreshJwt() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshJwt
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Tokens) GetAccessJwt() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessJwt
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Account struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        Id             string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Email          string                 `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
        ProfileName    string                 `protobuf:"bytes,3,opt,name=profile_name,json=profileName,proto3" json:"profile_name,omitempty"`
        ProfileSurname string                 `protobuf:"bytes,4,opt,name=profile_surname,json=profileSurname,proto3" json:"profile_surname,omitempty"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *Account) Reset() <span class="cov0" title="0">{
        *x = Account{}
        mi := &amp;file_auth_service_service_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Account) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Account) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Account) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_service_service_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Account.ProtoReflect.Descriptor instead.
func (*Account) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_service_service_proto_rawDescGZIP(), []int{1}
}</span>

func (x *Account) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Account) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Account) GetProfileName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ProfileName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Account) GetProfileSurname() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ProfileSurname
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RegisterRequest struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        Email          string                 `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
        Password       string                 `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
        ProfileName    string                 `protobuf:"bytes,3,opt,name=profile_name,json=profileName,proto3" json:"profile_name,omitempty"`
        ProfileSurname string                 `protobuf:"bytes,4,opt,name=profile_surname,json=profileSurname,proto3" json:"profile_surname,omitempty"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *RegisterRequest) Reset() <span class="cov0" title="0">{
        *x = RegisterRequest{}
        mi := &amp;file_auth_service_service_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RegisterRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_service_service_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterRequest.ProtoReflect.Descriptor instead.
func (*RegisterRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_service_service_proto_rawDescGZIP(), []int{2}
}</span>

func (x *RegisterRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetProfileName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ProfileName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetProfileSurname() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ProfileSurname
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RegisterResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *RegisterResponse) Reset() <span class="cov0" title="0">{
        *x = RegisterResponse{}
        mi := &amp;file_auth_service_service_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RegisterResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_service_service_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterResponse.ProtoReflect.Descriptor instead.
func (*RegisterResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_service_service_proto_rawDescGZIP(), []int{3}
}</span>

type LoginRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Email         string                 `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
        Password      string                 `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LoginRequest) Reset() <span class="cov0" title="0">{
        *x = LoginRequest{}
        mi := &amp;file_auth_service_service_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LoginRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_service_service_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginRequest.ProtoReflect.Descriptor instead.
func (*LoginRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_service_service_proto_rawDescGZIP(), []int{4}
}</span>

func (x *LoginRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LoginResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
        Tokens        *Tokens                `protobuf:"bytes,2,opt,name=tokens,proto3" json:"tokens,omitempty"`
        Account       *Account               `protobuf:"bytes,3,opt,name=account,proto3" json:"account,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LoginResponse) Reset() <span class="cov0" title="0">{
        *x = LoginResponse{}
        mi := &amp;file_auth_service_service_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LoginResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_service_service_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginResponse.ProtoReflect.Descriptor instead.
func (*LoginResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_service_service_proto_rawDescGZIP(), []int{5}
}</span>

func (x *LoginResponse) GetSessionId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SessionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginResponse) GetTokens() *Tokens <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tokens
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *LoginResponse) GetAccount() *Account <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Account
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type RefreshRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        RefreshJwt    string                 `protobuf:"bytes,1,opt,name=refresh_jwt,json=refreshJwt,proto3" json:"refresh_jwt,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *RefreshRequest) Reset() <span class="cov0" title="0">{
        *x = RefreshRequest{}
        mi := &amp;file_auth_service_service_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RefreshRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RefreshRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RefreshRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_service_service_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RefreshRequest.ProtoReflect.Descriptor instead.
func (*RefreshRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_service_service_proto_rawDescGZIP(), []int{6}
}</span>

func (x *RefreshRequest) GetRefreshJwt() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshJwt
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RefreshResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Tokens        *Tokens                `protobuf:"bytes,1,opt,name=tokens,proto3" json:"tokens,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *RefreshResponse) Reset() <span class="cov0" title="0">{
        *x = RefreshResponse{}
        mi := &amp;file_auth_service_service_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RefreshResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RefreshResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RefreshResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_service_service_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RefreshResponse.ProtoReflect.Descriptor instead.
func (*RefreshResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_service_service_proto_rawDescGZIP(), []int{7}
}</span>

func (x *RefreshResponse) GetTokens() *Tokens <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tokens
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type WhoIAmRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *WhoIAmRequest) Reset() <span class="cov0" title="0">{
        *x = WhoIAmRequest{}
        mi := &amp;file_auth_service_service_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *WhoIAmRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*WhoIAmRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *WhoIAmRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_service_service_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use WhoIAmRequest.ProtoReflect.Descriptor instead.
func (*WhoIAmRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_service_service_proto_rawDescGZIP(), []int{8}
}</span>

type WhoIAmResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Account       *Account               `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *WhoIAmResponse) Reset() <span class="cov0" title="0">{
        *x = WhoIAmResponse{}
        mi := &amp;file_auth_service_service_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *WhoIAmResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*WhoIAmResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *WhoIAmResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_service_service_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use WhoIAmResponse.ProtoReflect.Descriptor instead.
func (*WhoIAmResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_service_service_proto_rawDescGZIP(), []int{9}
}</span>

func (x *WhoIAmResponse) GetAccount() *Account <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Account
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type LogoutRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LogoutRequest) Reset() <span class="cov0" title="0">{
        *x = LogoutRequest{}
        mi := &amp;file_auth_service_service_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LogoutRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LogoutRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LogoutRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_service_service_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LogoutRequest.ProtoReflect.Descriptor instead.
func (*LogoutRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_service_service_proto_rawDescGZIP(), []int{10}
}</span>

type LogoutResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LogoutResponse) Reset() <span class="cov0" title="0">{
        *x = LogoutResponse{}
        mi := &amp;file_auth_service_service_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LogoutResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LogoutResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LogoutResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_service_service_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LogoutResponse.ProtoReflect.Descriptor instead.
func (*LogoutResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_service_service_proto_rawDescGZIP(), []int{11}
}</span>

var File_auth_service_service_proto protoreflect.FileDescriptor

const file_auth_service_service_proto_rawDesc = "" +
        "\n" +
        "\x1aauth_service/service.proto\x12\x0fauth_service.v1\"H\n" +
        "\x06Tokens\x12\x1f\n" +
        "\vrefresh_jwt\x18\x01 \x01(\tR\n" +
        "refreshJwt\x12\x1d\n" +
        "\n" +
        "access_jwt\x18\x02 \x01(\tR\taccessJwt\"{\n" +
        "\aAccount\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x14\n" +
        "\x05email\x18\x02 \x01(\tR\x05email\x12!\n" +
        "\fprofile_name\x18\x03 \x01(\tR\vprofileName\x12'\n" +
        "\x0fprofile_surname\x18\x04 \x01(\tR\x0eprofileSurname\"\x8f\x01\n" +
        "\x0fRegisterRequest\x12\x14\n" +
        "\x05email\x18\x01 \x01(\tR\x05email\x12\x1a\n" +
        "\bpassword\x18\x02 \x01(\tR\bpassword\x12!\n" +
        "\fprofile_name\x18\x03 \x01(\tR\vprofileName\x12'\n" +
        "\x0fprofile_surname\x18\x04 \x01(\tR\x0eprofileSurname\"\x12\n" +
        "\x10RegisterResponse\"@\n" +
        "\fLoginRequest\x12\x14\n" +
        "\x05email\x18\x01 \x01(\tR\x05email\x12\x1a\n" +
        "\bpassword\x18\x02 \x01(\tR\bpassword\"\x93\x01\n" +
        "\rLoginResponse\x12\x1d\n" +
        "\n" +
        "session_id\x18\x01 \x01(\tR\tsessionId\x12/\n" +
        "\x06tokens\x18\x02 \x01(\v2\x17.auth_service.v1.TokensR\x06tokens\x122\n" +
        "\aaccount\x18\x03 \x01(\v2\x18.auth_service.v1.AccountR\aaccount\"1\n" +
        "\x0eRefreshRequest\x12\x1f\n" +
        "\vrefresh_jwt\x18\x01 \x01(\tR\n" +
        "refreshJwt\"B\n" +
        "\x0fRefreshResponse\x12/\n" +
        "\x06tokens\x18\x01 \x01(\v2\x17.auth_service.v1.TokensR\x06tokens\"\x0f\n" +
        "\rWhoIAmRequest\"D\n" +
        "\x0eWhoIAmResponse\x122\n" +
        "\aaccount\x18\x01 \x01(\v2\x18.auth_service.v1.AccountR\aaccount\"\x0f\n" +
        "\rLogoutRequest\"\x10\n" +
        "\x0eLogoutResponse2\x83\x03\n" +
        "\x04Auth\x12O\n" +
        "\bRegister\x12 .auth_service.v1.RegisterRequest\x1a!.auth_service.v1.RegisterResponse\x12F\n" +
        "\x05Login\x12\x1d.auth_service.v1.LoginRequest\x1a\x1e.auth_service.v1.LoginResponse\x12L\n" +
        "\aRefresh\x12\x1f.auth_service.v1.RefreshRequest\x1a .auth_service.v1.RefreshResponse\x12I\n" +
        "\x06WhoIAm\x12\x1e.auth_service.v1.WhoIAmRequest\x1a\x1f.auth_service.v1.WhoIAmResponse\x12I\n" +
        "\x06Logout\x12\x1e.auth_service.v1.LogoutRequest\x1a\x1f.auth_service.v1.LogoutResponseB\xd4\x01\n" +
        "\x13com.auth_service.v1B\fServiceProtoP\x01ZVgithub.com/m11ano/budget_planner/backend/auth/pkg/proto_pb/auth_service;auth_servicev1\xa2\x02\x03AXX\xaa\x02\x0eAuthService.V1\xca\x02\x0eAuthService\\V1\xe2\x02\x1aAuthService\\V1\\GPBMetadata\xea\x02\x0fAuthService::V1b\x06proto3"

var (
        file_auth_service_service_proto_rawDescOnce sync.Once
        file_auth_service_service_proto_rawDescData []byte
)

func file_auth_service_service_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_auth_service_service_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_auth_service_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_auth_service_service_proto_rawDesc), len(file_auth_service_service_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_auth_service_service_proto_rawDescData</span>
}

var file_auth_service_service_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_auth_service_service_proto_goTypes = []any{
        (*Tokens)(nil),           // 0: auth_service.v1.Tokens
        (*Account)(nil),          // 1: auth_service.v1.Account
        (*RegisterRequest)(nil),  // 2: auth_service.v1.RegisterRequest
        (*RegisterResponse)(nil), // 3: auth_service.v1.RegisterResponse
        (*LoginRequest)(nil),     // 4: auth_service.v1.LoginRequest
        (*LoginResponse)(nil),    // 5: auth_service.v1.LoginResponse
        (*RefreshRequest)(nil),   // 6: auth_service.v1.RefreshRequest
        (*RefreshResponse)(nil),  // 7: auth_service.v1.RefreshResponse
        (*WhoIAmRequest)(nil),    // 8: auth_service.v1.WhoIAmRequest
        (*WhoIAmResponse)(nil),   // 9: auth_service.v1.WhoIAmResponse
        (*LogoutRequest)(nil),    // 10: auth_service.v1.LogoutRequest
        (*LogoutResponse)(nil),   // 11: auth_service.v1.LogoutResponse
}
var file_auth_service_service_proto_depIdxs = []int32{
        0,  // 0: auth_service.v1.LoginResponse.tokens:type_name -&gt; auth_service.v1.Tokens
        1,  // 1: auth_service.v1.LoginResponse.account:type_name -&gt; auth_service.v1.Account
        0,  // 2: auth_service.v1.RefreshResponse.tokens:type_name -&gt; auth_service.v1.Tokens
        1,  // 3: auth_service.v1.WhoIAmResponse.account:type_name -&gt; auth_service.v1.Account
        2,  // 4: auth_service.v1.Auth.Register:input_type -&gt; auth_service.v1.RegisterRequest
        4,  // 5: auth_service.v1.Auth.Login:input_type -&gt; auth_service.v1.LoginRequest
        6,  // 6: auth_service.v1.Auth.Refresh:input_type -&gt; auth_service.v1.RefreshRequest
        8,  // 7: auth_service.v1.Auth.WhoIAm:input_type -&gt; auth_service.v1.WhoIAmRequest
        10, // 8: auth_service.v1.Auth.Logout:input_type -&gt; auth_service.v1.LogoutRequest
        3,  // 9: auth_service.v1.Auth.Register:output_type -&gt; auth_service.v1.RegisterResponse
        5,  // 10: auth_service.v1.Auth.Login:output_type -&gt; auth_service.v1.LoginResponse
        7,  // 11: auth_service.v1.Auth.Refresh:output_type -&gt; auth_service.v1.RefreshResponse
        9,  // 12: auth_service.v1.Auth.WhoIAm:output_type -&gt; auth_service.v1.WhoIAmResponse
        11, // 13: auth_service.v1.Auth.Logout:output_type -&gt; auth_service.v1.LogoutResponse
        9,  // [9:14] is the sub-list for method output_type
        4,  // [4:9] is the sub-list for method input_type
        4,  // [4:4] is the sub-list for extension type_name
        4,  // [4:4] is the sub-list for extension extendee
        0,  // [0:4] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_auth_service_service_proto_init() }</span>
func file_auth_service_service_proto_init() <span class="cov0" title="0">{
        if File_auth_service_service_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_auth_service_service_proto_rawDesc), len(file_auth_service_service_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   12,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_auth_service_service_proto_goTypes,
                DependencyIndexes: file_auth_service_service_proto_depIdxs,
                MessageInfos:      file_auth_service_service_proto_msgTypes,
        }.Build()
        File_auth_service_service_proto = out.File
        file_auth_service_service_proto_goTypes = nil
        file_auth_service_service_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: auth_service/service.proto

package auth_servicev1

import (
        "bytes"
        "errors"
        "fmt"
        "net"
        "net/mail"
        "net/url"
        "regexp"
        "sort"
        "strings"
        "time"
        "unicode/utf8"

        "google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
        _ = bytes.MinRead
        _ = errors.New("")
        _ = fmt.Print
        _ = utf8.UTFMax
        _ = (*regexp.Regexp)(nil)
        _ = (*strings.Reader)(nil)
        _ = net.IPv4len
        _ = time.Duration(0)
        _ = (*url.URL)(nil)
        _ = (*mail.Address)(nil)
        _ = anypb.Any{}
        _ = sort.Sort
)

// Validate checks the field values on Tokens with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Tokens) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on Tokens with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TokensMultiError, or nil if none found.
func (m *Tokens) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *Tokens) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for RefreshJwt

        // no validation rules for AccessJwt

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return TokensMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// TokensMultiError is an error wrapping multiple validation errors returned by
// Tokens.ValidateAll() if the designated constraints aren't met.
type TokensMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokensMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m TokensMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// TokensValidationError is the validation error returned by Tokens.Validate if
// the designated constraints aren't met.
type TokensValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e TokensValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e TokensValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e TokensValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e TokensValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e TokensValidationError) ErrorName() string <span class="cov0" title="0">{ return "TokensValidationError" }</span>

// Error satisfies the builtin error interface
func (e TokensValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sTokens.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = TokensValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = TokensValidationError{}

// Validate checks the field values on Account with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Account) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on Account with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AccountMultiError, or nil if none found.
func (m *Account) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *Account) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Id

        // no validation rules for Email

        // no validation rules for ProfileName

        // no validation rules for ProfileSurname

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return AccountMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AccountMultiError is an error wrapping multiple validation errors returned
// by Account.ValidateAll() if the designated constraints aren't met.
type AccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccountMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m AccountMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// AccountValidationError is the validation error returned by Account.Validate
// if the designated constraints aren't met.
type AccountValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e AccountValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e AccountValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e AccountValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e AccountValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e AccountValidationError) ErrorName() string <span class="cov0" title="0">{ return "AccountValidationError" }</span>

// Error satisfies the builtin error interface
func (e AccountValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sAccount.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = AccountValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = AccountValidationError{}

// Validate checks the field values on RegisterRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RegisterRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on RegisterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterRequestMultiError, or nil if none found.
func (m *RegisterRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *RegisterRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Email

        // no validation rules for Password

        // no validation rules for ProfileName

        // no validation rules for ProfileSurname

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return RegisterRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RegisterRequestMultiError is an error wrapping multiple validation errors
// returned by RegisterRequest.ValidateAll() if the designated constraints
// aren't met.
type RegisterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m RegisterRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// RegisterRequestValidationError is the validation error returned by
// RegisterRequest.Validate if the designated constraints aren't met.
type RegisterRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e RegisterRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e RegisterRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e RegisterRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e RegisterRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e RegisterRequestValidationError) ErrorName() string <span class="cov0" title="0">{ return "RegisterRequestValidationError" }</span>

// Error satisfies the builtin error interface
func (e RegisterRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sRegisterRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = RegisterRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = RegisterRequestValidationError{}

// Validate checks the field values on RegisterResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RegisterResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on RegisterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterResponseMultiError, or nil if none found.
func (m *RegisterResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *RegisterResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return RegisterResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RegisterResponseMultiError is an error wrapping multiple validation errors
// returned by RegisterResponse.ValidateAll() if the designated constraints
// aren't met.
type RegisterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m RegisterResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// RegisterResponseValidationError is the validation error returned by
// RegisterResponse.Validate if the designated constraints aren't met.
type RegisterResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e RegisterResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e RegisterResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e RegisterResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e RegisterResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e RegisterResponseValidationError) ErrorName() string <span class="cov0" title="0">{ return "RegisterResponseValidationError" }</span>

// Error satisfies the builtin error interface
func (e RegisterResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sRegisterResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = RegisterResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = RegisterResponseValidationError{}

// Validate checks the field values on LoginRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on LoginRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginRequestMultiError, or
// nil if none found.
func (m *LoginRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *LoginRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Email

        // no validation rules for Password

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return LoginRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// LoginRequestMultiError is an error wrapping multiple validation errors
// returned by LoginRequest.ValidateAll() if the designated constraints aren't met.
type LoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m LoginRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// LoginRequestValidationError is the validation error returned by
// LoginRequest.Validate if the designated constraints aren't met.
type LoginRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e LoginRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e LoginRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e LoginRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e LoginRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e LoginRequestValidationError) ErrorName() string <span class="cov0" title="0">{ return "LoginRequestValidationError" }</span>

// Error satisfies the builtin error interface
func (e LoginRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sLoginRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = LoginRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = LoginRequestValidationError{}

// Validate checks the field values on LoginResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on LoginResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginResponseMultiError, or
// nil if none found.
func (m *LoginResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *LoginResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for SessionId

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetTokens()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, LoginResponseValidationError{
                                        field:  "Tokens",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, LoginResponseValidationError{
                                        field:  "Tokens",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetTokens()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return LoginResponseValidationError{
                                field:  "Tokens",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetAccount()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, LoginResponseValidationError{
                                        field:  "Account",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, LoginResponseValidationError{
                                        field:  "Account",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetAccount()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return LoginResponseValidationError{
                                field:  "Account",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return LoginResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// LoginResponseMultiError is an error wrapping multiple validation errors
// returned by LoginResponse.ValidateAll() if the designated constraints
// aren't met.
type LoginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m LoginResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// LoginResponseValidationError is the validation error returned by
// LoginResponse.Validate if the designated constraints aren't met.
type LoginResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e LoginResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e LoginResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e LoginResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e LoginResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e LoginResponseValidationError) ErrorName() string <span class="cov0" title="0">{ return "LoginResponseValidationError" }</span>

// Error satisfies the builtin error interface
func (e LoginResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sLoginResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = LoginResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = LoginResponseValidationError{}

// Validate checks the field values on RefreshRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RefreshRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on RefreshRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RefreshRequestMultiError,
// or nil if none found.
func (m *RefreshRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *RefreshRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for RefreshJwt

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return RefreshRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RefreshRequestMultiError is an error wrapping multiple validation errors
// returned by RefreshRequest.ValidateAll() if the designated constraints
// aren't met.
type RefreshRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m RefreshRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// RefreshRequestValidationError is the validation error returned by
// RefreshRequest.Validate if the designated constraints aren't met.
type RefreshRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e RefreshRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e RefreshRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e RefreshRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e RefreshRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e RefreshRequestValidationError) ErrorName() string <span class="cov0" title="0">{ return "RefreshRequestValidationError" }</span>

// Error satisfies the builtin error interface
func (e RefreshRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sRefreshRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = RefreshRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = RefreshRequestValidationError{}

// Validate checks the field values on RefreshResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RefreshResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on RefreshResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshResponseMultiError, or nil if none found.
func (m *RefreshResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *RefreshResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetTokens()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, RefreshResponseValidationError{
                                        field:  "Tokens",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, RefreshResponseValidationError{
                                        field:  "Tokens",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetTokens()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return RefreshResponseValidationError{
                                field:  "Tokens",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return RefreshResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RefreshResponseMultiError is an error wrapping multiple validation errors
// returned by RefreshResponse.ValidateAll() if the designated constraints
// aren't met.
type RefreshResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m RefreshResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// RefreshResponseValidationError is the validation error returned by
// RefreshResponse.Validate if the designated constraints aren't met.
type RefreshResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e RefreshResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e RefreshResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e RefreshResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e RefreshResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e RefreshResponseValidationError) ErrorName() string <span class="cov0" title="0">{ return "RefreshResponseValidationError" }</span>

// Error satisfies the builtin error interface
func (e RefreshResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sRefreshResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = RefreshResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = RefreshResponseValidationError{}

// Validate checks the field values on WhoIAmRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WhoIAmRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on WhoIAmRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WhoIAmRequestMultiError, or
// nil if none found.
func (m *WhoIAmRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *WhoIAmRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return WhoIAmRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// WhoIAmRequestMultiError is an error wrapping multiple validation errors
// returned by WhoIAmRequest.ValidateAll() if the designated constraints
// aren't met.
type WhoIAmRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WhoIAmRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m WhoIAmRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// WhoIAmRequestValidationError is the validation error returned by
// WhoIAmRequest.Validate if the designated constraints aren't met.
type WhoIAmRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e WhoIAmRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e WhoIAmRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e WhoIAmRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e WhoIAmRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e WhoIAmRequestValidationError) ErrorName() string <span class="cov0" title="0">{ return "WhoIAmRequestValidationError" }</span>

// Error satisfies the builtin error interface
func (e WhoIAmRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sWhoIAmRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = WhoIAmRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = WhoIAmRequestValidationError{}

// Validate checks the field values on WhoIAmResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WhoIAmResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on WhoIAmResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WhoIAmResponseMultiError,
// or nil if none found.
func (m *WhoIAmResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *WhoIAmResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetAccount()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, WhoIAmResponseValidationError{
                                        field:  "Account",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, WhoIAmResponseValidationError{
                                        field:  "Account",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetAccount()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return WhoIAmResponseValidationError{
                                field:  "Account",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return WhoIAmResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// WhoIAmResponseMultiError is an error wrapping multiple validation errors
// returned by WhoIAmResponse.ValidateAll() if the designated constraints
// aren't met.
type WhoIAmResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WhoIAmResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m WhoIAmResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// WhoIAmResponseValidationError is the validation error returned by
// WhoIAmResponse.Validate if the designated constraints aren't met.
type WhoIAmResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e WhoIAmResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e WhoIAmResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e WhoIAmResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e WhoIAmResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e WhoIAmResponseValidationError) ErrorName() string <span class="cov0" title="0">{ return "WhoIAmResponseValidationError" }</span>

// Error satisfies the builtin error interface
func (e WhoIAmResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sWhoIAmResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = WhoIAmResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = WhoIAmResponseValidationError{}

// Validate checks the field values on LogoutRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LogoutRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on LogoutRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LogoutRequestMultiError, or
// nil if none found.
func (m *LogoutRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *LogoutRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return LogoutRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// LogoutRequestMultiError is an error wrapping multiple validation errors
// returned by LogoutRequest.ValidateAll() if the designated constraints
// aren't met.
type LogoutRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogoutRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m LogoutRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// LogoutRequestValidationError is the validation error returned by
// LogoutRequest.Validate if the designated constraints aren't met.
type LogoutRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e LogoutRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e LogoutRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e LogoutRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e LogoutRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e LogoutRequestValidationError) ErrorName() string <span class="cov0" title="0">{ return "LogoutRequestValidationError" }</span>

// Error satisfies the builtin error interface
func (e LogoutRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sLogoutRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = LogoutRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = LogoutRequestValidationError{}

// Validate checks the field values on LogoutResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LogoutResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on LogoutResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LogoutResponseMultiError,
// or nil if none found.
func (m *LogoutResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *LogoutResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return LogoutResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// LogoutResponseMultiError is an error wrapping multiple validation errors
// returned by LogoutResponse.ValidateAll() if the designated constraints
// aren't met.
type LogoutResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogoutResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m LogoutResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// LogoutResponseValidationError is the validation error returned by
// LogoutResponse.Validate if the designated constraints aren't met.
type LogoutResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e LogoutResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e LogoutResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e LogoutResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e LogoutResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e LogoutResponseValidationError) ErrorName() string <span class="cov0" title="0">{ return "LogoutResponseValidationError" }</span>

// Error satisfies the builtin error interface
func (e LogoutResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sLogoutResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = LogoutResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = LogoutResponseValidationError{}
</pre>
		
		<pre class="file" id="file80" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: auth_service/service.proto

package auth_servicev1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Auth_Register_FullMethodName = "/auth_service.v1.Auth/Register"
        Auth_Login_FullMethodName    = "/auth_service.v1.Auth/Login"
        Auth_Refresh_FullMethodName  = "/auth_service.v1.Auth/Refresh"
        Auth_WhoIAm_FullMethodName   = "/auth_service.v1.Auth/WhoIAm"
        Auth_Logout_FullMethodName   = "/auth_service.v1.Auth/Logout"
)

// AuthClient is the client API for Auth service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthClient interface {
        Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
        Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
        Refresh(ctx context.Context, in *RefreshRequest, opts ...grpc.CallOption) (*RefreshResponse, error)
        WhoIAm(ctx context.Context, in *WhoIAmRequest, opts ...grpc.CallOption) (*WhoIAmResponse, error)
        Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error)
}

type authClient struct {
        cc grpc.ClientConnInterface
}

func NewAuthClient(cc grpc.ClientConnInterface) AuthClient <span class="cov0" title="0">{
        return &amp;authClient{cc}
}</span>

func (c *authClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(RegisterResponse)
        err := c.cc.Invoke(ctx, Auth_Register_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(LoginResponse)
        err := c.cc.Invoke(ctx, Auth_Login_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authClient) Refresh(ctx context.Context, in *RefreshRequest, opts ...grpc.CallOption) (*RefreshResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(RefreshResponse)
        err := c.cc.Invoke(ctx, Auth_Refresh_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authClient) WhoIAm(ctx context.Context, in *WhoIAmRequest, opts ...grpc.CallOption) (*WhoIAmResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(WhoIAmResponse)
        err := c.cc.Invoke(ctx, Auth_WhoIAm_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(LogoutResponse)
        err := c.cc.Invoke(ctx, Auth_Logout_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// AuthServer is the server API for Auth service.
// All implementations must embed UnimplementedAuthServer
// for forward compatibility.
type AuthServer interface {
        Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
        Login(context.Context, *LoginRequest) (*LoginResponse, error)
        Refresh(context.Context, *RefreshRequest) (*RefreshResponse, error)
        WhoIAm(context.Context, *WhoIAmRequest) (*WhoIAmResponse, error)
        Logout(context.Context, *LogoutRequest) (*LogoutResponse, error)
        mustEmbedUnimplementedAuthServer()
}

// UnimplementedAuthServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthServer struct{}

func (UnimplementedAuthServer) Register(context.Context, *RegisterRequest) (*RegisterResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}</span>
func (UnimplementedAuthServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}</span>
func (UnimplementedAuthServer) Refresh(context.Context, *RefreshRequest) (*RefreshResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Refresh not implemented")
}</span>
func (UnimplementedAuthServer) WhoIAm(context.Context, *WhoIAmRequest) (*WhoIAmResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method WhoIAm not implemented")
}</span>
func (UnimplementedAuthServer) Logout(context.Context, *LogoutRequest) (*LogoutResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}</span>
func (UnimplementedAuthServer) mustEmbedUnimplementedAuthServer() {<span class="cov0" title="0">}</span>
func (UnimplementedAuthServer) testEmbeddedByValue()              {<span class="cov0" title="0">}</span>

// UnsafeAuthServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServer will
// result in compilation errors.
type UnsafeAuthServer interface {
        mustEmbedUnimplementedAuthServer()
}

func RegisterAuthServer(s grpc.ServiceRegistrar, srv AuthServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedAuthServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Auth_ServiceDesc, srv)</span>
}

func _Auth_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RegisterRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServer).Register(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Auth_Register_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServer).Register(ctx, req.(*RegisterRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Auth_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LoginRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServer).Login(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Auth_Login_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServer).Login(ctx, req.(*LoginRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Auth_Refresh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RefreshRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServer).Refresh(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Auth_Refresh_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServer).Refresh(ctx, req.(*RefreshRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Auth_WhoIAm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(WhoIAmRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServer).WhoIAm(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Auth_WhoIAm_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServer).WhoIAm(ctx, req.(*WhoIAmRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Auth_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LogoutRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServer).Logout(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Auth_Logout_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServer).Logout(ctx, req.(*LogoutRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Auth_ServiceDesc is the grpc.ServiceDesc for Auth service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Auth_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "auth_service.v1.Auth",
        HandlerType: (*AuthServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Register",
                        Handler:    _Auth_Register_Handler,
                },
                {
                        MethodName: "Login",
                        Handler:    _Auth_Login_Handler,
                },
                {
                        MethodName: "Refresh",
                        Handler:    _Auth_Refresh_Handler,
                },
                {
                        MethodName: "WhoIAm",
                        Handler:    _Auth_WhoIAm_Handler,
                },
                {
                        MethodName: "Logout",
                        Handler:    _Auth_Logout_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "auth_service/service.proto",
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package validation

import (
        "reflect"
        "regexp"
        "strings"

        "github.com/go-playground/validator/v10"
)

func FormatErrors(err error, subjects ...any) []string <span class="cov0" title="0">{
        hints := make([]string, 0)

        ve, ok := err.(validator.ValidationErrors)
        if !ok </span><span class="cov0" title="0">{
                return hints
        }</span>

        <span class="cov0" title="0">var root reflect.Value
        if len(subjects) &gt; 0 &amp;&amp; subjects[0] != nil </span><span class="cov0" title="0">{
                root = reflect.ValueOf(subjects[0])
                for root.Kind() == reflect.Ptr &amp;&amp; !root.IsNil() </span><span class="cov0" title="0">{
                        root = root.Elem()
                }</span>
        }

        <span class="cov0" title="0">for _, fe := range ve </span><span class="cov0" title="0">{
                if root.IsValid() </span><span class="cov0" title="0">{
                        if msg, ok := lookupErrMsgTag(root, fe); ok &amp;&amp; msg != "" </span><span class="cov0" title="0">{
                                hints = append(hints, msg)
                                continue</span>
                        }
                }
                <span class="cov0" title="0">hints = append(hints, fe.Error())</span>
        }

        <span class="cov0" title="0">return hints</span>
}

func lookupErrMsgTag(root reflect.Value, fe validator.FieldError) (string, bool) <span class="cov0" title="0">{
        if !root.IsValid() || root.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">path := fe.StructNamespace()
        if path == "" </span><span class="cov0" title="0">{
                path = fe.StructField()
        }</span>
        <span class="cov0" title="0">segments := strings.Split(path, ".")
        if len(segments) &gt; 1 &amp;&amp; segments[0] == root.Type().Name() </span><span class="cov0" title="0">{
                segments = segments[1:]
        }</span>

        <span class="cov0" title="0">indexRe := regexp.MustCompile(`\[[0-9]+\]`)
        rt := root.Type()
        current := root
        var sf reflect.StructField
        found := false

        for _, seg := range segments </span><span class="cov0" title="0">{
                seg = indexRe.ReplaceAllString(seg, "")
                f, ok := findField(rt, seg)
                if !ok </span><span class="cov0" title="0">{
                        return "", false
                }</span>
                <span class="cov0" title="0">sf = f
                found = true

                if current.IsValid() &amp;&amp; current.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                        fieldVal := current.FieldByIndex(sf.Index)
                        for fieldVal.Kind() == reflect.Ptr &amp;&amp; !fieldVal.IsNil() </span><span class="cov0" title="0">{
                                fieldVal = fieldVal.Elem()
                        }</span>
                        <span class="cov0" title="0">current = fieldVal
                        rt = current.Type()</span>
                }
        }

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov0" title="0">if v, ok := sf.Tag.Lookup("errmsg"); ok </span><span class="cov0" title="0">{
                return v, true
        }</span>
        <span class="cov0" title="0">return "", false</span>
}

func findField(t reflect.Type, name string) (reflect.StructField, bool) <span class="cov0" title="0">{
        if f, ok := t.FieldByName(name); ok </span><span class="cov0" title="0">{
                return f, true
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; t.NumField(); i++ </span><span class="cov0" title="0">{
                f := t.Field(i)
                if f.Anonymous </span><span class="cov0" title="0">{
                        ft := f.Type
                        for ft.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                                ft = ft.Elem()
                        }</span>
                        <span class="cov0" title="0">if ft.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                                if ff, ok := findField(ft, name); ok </span><span class="cov0" title="0">{
                                        return combineIndex(f, ff), true
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return reflect.StructField{}, false</span>
}

func combineIndex(parent reflect.StructField, child reflect.StructField) reflect.StructField <span class="cov0" title="0">{
        idx := make([]int, 0, len(parent.Index)+len(child.Index))
        idx = append(idx, parent.Index...)
        idx = append(idx, child.Index...)
        child.Index = idx
        return child
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">package validation

import (
        "github.com/go-playground/validator/v10"
)

func New() *validator.Validate <span class="cov0" title="0">{
        validate := validator.New()
        return validate
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
