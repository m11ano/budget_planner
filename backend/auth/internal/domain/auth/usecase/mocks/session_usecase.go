// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase.SessionUsecase -o session_usecase.go -n SessionUsecaseMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
	"github.com/m11ano/budget_planner/backend/auth/internal/common/uctypes"
	"github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
	mm_usecase "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
)

// SessionUsecaseMock implements mm_usecase.SessionUsecase
type SessionUsecaseMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, item *entity.Session) (err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, item *entity.Session)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mSessionUsecaseMockCreate

	funcFindList          func(ctx context.Context, listOptions *mm_usecase.SessionListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Session, err error)
	funcFindListOrigin    string
	inspectFuncFindList   func(ctx context.Context, listOptions *mm_usecase.SessionListOptions, queryParams *uctypes.QueryGetListParams)
	afterFindListCounter  uint64
	beforeFindListCounter uint64
	FindListMock          mSessionUsecaseMockFindList

	funcFindOneByID          func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (session *entity.Session, err error)
	funcFindOneByIDOrigin    string
	inspectFuncFindOneByID   func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)
	afterFindOneByIDCounter  uint64
	beforeFindOneByIDCounter uint64
	FindOneByIDMock          mSessionUsecaseMockFindOneByID

	funcRevokeSessionByID          func(ctx context.Context, ID uuid.UUID) (err error)
	funcRevokeSessionByIDOrigin    string
	inspectFuncRevokeSessionByID   func(ctx context.Context, ID uuid.UUID)
	afterRevokeSessionByIDCounter  uint64
	beforeRevokeSessionByIDCounter uint64
	RevokeSessionByIDMock          mSessionUsecaseMockRevokeSessionByID

	funcRevokeSessionsByAccountID          func(ctx context.Context, accountID uuid.UUID) (err error)
	funcRevokeSessionsByAccountIDOrigin    string
	inspectFuncRevokeSessionsByAccountID   func(ctx context.Context, accountID uuid.UUID)
	afterRevokeSessionsByAccountIDCounter  uint64
	beforeRevokeSessionsByAccountIDCounter uint64
	RevokeSessionsByAccountIDMock          mSessionUsecaseMockRevokeSessionsByAccountID

	funcUpdate          func(ctx context.Context, item *entity.Session) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, item *entity.Session)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mSessionUsecaseMockUpdate
}

// NewSessionUsecaseMock returns a mock for mm_usecase.SessionUsecase
func NewSessionUsecaseMock(t minimock.Tester) *SessionUsecaseMock {
	m := &SessionUsecaseMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mSessionUsecaseMockCreate{mock: m}
	m.CreateMock.callArgs = []*SessionUsecaseMockCreateParams{}

	m.FindListMock = mSessionUsecaseMockFindList{mock: m}
	m.FindListMock.callArgs = []*SessionUsecaseMockFindListParams{}

	m.FindOneByIDMock = mSessionUsecaseMockFindOneByID{mock: m}
	m.FindOneByIDMock.callArgs = []*SessionUsecaseMockFindOneByIDParams{}

	m.RevokeSessionByIDMock = mSessionUsecaseMockRevokeSessionByID{mock: m}
	m.RevokeSessionByIDMock.callArgs = []*SessionUsecaseMockRevokeSessionByIDParams{}

	m.RevokeSessionsByAccountIDMock = mSessionUsecaseMockRevokeSessionsByAccountID{mock: m}
	m.RevokeSessionsByAccountIDMock.callArgs = []*SessionUsecaseMockRevokeSessionsByAccountIDParams{}

	m.UpdateMock = mSessionUsecaseMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*SessionUsecaseMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mSessionUsecaseMockCreate struct {
	optional           bool
	mock               *SessionUsecaseMock
	defaultExpectation *SessionUsecaseMockCreateExpectation
	expectations       []*SessionUsecaseMockCreateExpectation

	callArgs []*SessionUsecaseMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SessionUsecaseMockCreateExpectation specifies expectation struct of the SessionUsecase.Create
type SessionUsecaseMockCreateExpectation struct {
	mock               *SessionUsecaseMock
	params             *SessionUsecaseMockCreateParams
	paramPtrs          *SessionUsecaseMockCreateParamPtrs
	expectationOrigins SessionUsecaseMockCreateExpectationOrigins
	results            *SessionUsecaseMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// SessionUsecaseMockCreateParams contains parameters of the SessionUsecase.Create
type SessionUsecaseMockCreateParams struct {
	ctx  context.Context
	item *entity.Session
}

// SessionUsecaseMockCreateParamPtrs contains pointers to parameters of the SessionUsecase.Create
type SessionUsecaseMockCreateParamPtrs struct {
	ctx  *context.Context
	item **entity.Session
}

// SessionUsecaseMockCreateResults contains results of the SessionUsecase.Create
type SessionUsecaseMockCreateResults struct {
	err error
}

// SessionUsecaseMockCreateOrigins contains origins of expectations of the SessionUsecase.Create
type SessionUsecaseMockCreateExpectationOrigins struct {
	origin     string
	originCtx  string
	originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mSessionUsecaseMockCreate) Optional() *mSessionUsecaseMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for SessionUsecase.Create
func (mmCreate *mSessionUsecaseMockCreate) Expect(ctx context.Context, item *entity.Session) *mSessionUsecaseMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("SessionUsecaseMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &SessionUsecaseMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("SessionUsecaseMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &SessionUsecaseMockCreateParams{ctx, item}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for SessionUsecase.Create
func (mmCreate *mSessionUsecaseMockCreate) ExpectCtxParam1(ctx context.Context) *mSessionUsecaseMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("SessionUsecaseMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &SessionUsecaseMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("SessionUsecaseMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &SessionUsecaseMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectItemParam2 sets up expected param item for SessionUsecase.Create
func (mmCreate *mSessionUsecaseMockCreate) ExpectItemParam2(item *entity.Session) *mSessionUsecaseMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("SessionUsecaseMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &SessionUsecaseMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("SessionUsecaseMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &SessionUsecaseMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.item = &item
	mmCreate.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the SessionUsecase.Create
func (mmCreate *mSessionUsecaseMockCreate) Inspect(f func(ctx context.Context, item *entity.Session)) *mSessionUsecaseMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for SessionUsecaseMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by SessionUsecase.Create
func (mmCreate *mSessionUsecaseMockCreate) Return(err error) *SessionUsecaseMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("SessionUsecaseMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &SessionUsecaseMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &SessionUsecaseMockCreateResults{err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the SessionUsecase.Create method
func (mmCreate *mSessionUsecaseMockCreate) Set(f func(ctx context.Context, item *entity.Session) (err error)) *SessionUsecaseMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the SessionUsecase.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the SessionUsecase.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the SessionUsecase.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mSessionUsecaseMockCreate) When(ctx context.Context, item *entity.Session) *SessionUsecaseMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("SessionUsecaseMock.Create mock is already set by Set")
	}

	expectation := &SessionUsecaseMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &SessionUsecaseMockCreateParams{ctx, item},
		expectationOrigins: SessionUsecaseMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up SessionUsecase.Create return parameters for the expectation previously defined by the When method
func (e *SessionUsecaseMockCreateExpectation) Then(err error) *SessionUsecaseMock {
	e.results = &SessionUsecaseMockCreateResults{err}
	return e.mock
}

// Times sets number of times SessionUsecase.Create should be invoked
func (mmCreate *mSessionUsecaseMockCreate) Times(n uint64) *mSessionUsecaseMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of SessionUsecaseMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mSessionUsecaseMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_usecase.SessionUsecase
func (mmCreate *SessionUsecaseMock) Create(ctx context.Context, item *entity.Session) (err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, item)
	}

	mm_params := SessionUsecaseMockCreateParams{ctx, item}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := SessionUsecaseMockCreateParams{ctx, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("SessionUsecaseMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmCreate.t.Errorf("SessionUsecaseMock.Create got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("SessionUsecaseMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the SessionUsecaseMock.Create")
		}
		return (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, item)
	}
	mmCreate.t.Fatalf("Unexpected call to SessionUsecaseMock.Create. %v %v", ctx, item)
	return
}

// CreateAfterCounter returns a count of finished SessionUsecaseMock.Create invocations
func (mmCreate *SessionUsecaseMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of SessionUsecaseMock.Create invocations
func (mmCreate *SessionUsecaseMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to SessionUsecaseMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mSessionUsecaseMockCreate) Calls() []*SessionUsecaseMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*SessionUsecaseMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *SessionUsecaseMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *SessionUsecaseMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SessionUsecaseMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SessionUsecaseMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SessionUsecaseMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to SessionUsecaseMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to SessionUsecaseMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mSessionUsecaseMockFindList struct {
	optional           bool
	mock               *SessionUsecaseMock
	defaultExpectation *SessionUsecaseMockFindListExpectation
	expectations       []*SessionUsecaseMockFindListExpectation

	callArgs []*SessionUsecaseMockFindListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SessionUsecaseMockFindListExpectation specifies expectation struct of the SessionUsecase.FindList
type SessionUsecaseMockFindListExpectation struct {
	mock               *SessionUsecaseMock
	params             *SessionUsecaseMockFindListParams
	paramPtrs          *SessionUsecaseMockFindListParamPtrs
	expectationOrigins SessionUsecaseMockFindListExpectationOrigins
	results            *SessionUsecaseMockFindListResults
	returnOrigin       string
	Counter            uint64
}

// SessionUsecaseMockFindListParams contains parameters of the SessionUsecase.FindList
type SessionUsecaseMockFindListParams struct {
	ctx         context.Context
	listOptions *mm_usecase.SessionListOptions
	queryParams *uctypes.QueryGetListParams
}

// SessionUsecaseMockFindListParamPtrs contains pointers to parameters of the SessionUsecase.FindList
type SessionUsecaseMockFindListParamPtrs struct {
	ctx         *context.Context
	listOptions **mm_usecase.SessionListOptions
	queryParams **uctypes.QueryGetListParams
}

// SessionUsecaseMockFindListResults contains results of the SessionUsecase.FindList
type SessionUsecaseMockFindListResults struct {
	items []*entity.Session
	err   error
}

// SessionUsecaseMockFindListOrigins contains origins of expectations of the SessionUsecase.FindList
type SessionUsecaseMockFindListExpectationOrigins struct {
	origin            string
	originCtx         string
	originListOptions string
	originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindList *mSessionUsecaseMockFindList) Optional() *mSessionUsecaseMockFindList {
	mmFindList.optional = true
	return mmFindList
}

// Expect sets up expected params for SessionUsecase.FindList
func (mmFindList *mSessionUsecaseMockFindList) Expect(ctx context.Context, listOptions *mm_usecase.SessionListOptions, queryParams *uctypes.QueryGetListParams) *mSessionUsecaseMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("SessionUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &SessionUsecaseMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.paramPtrs != nil {
		mmFindList.mock.t.Fatalf("SessionUsecaseMock.FindList mock is already set by ExpectParams functions")
	}

	mmFindList.defaultExpectation.params = &SessionUsecaseMockFindListParams{ctx, listOptions, queryParams}
	mmFindList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindList.expectations {
		if minimock.Equal(e.params, mmFindList.defaultExpectation.params) {
			mmFindList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindList.defaultExpectation.params)
		}
	}

	return mmFindList
}

// ExpectCtxParam1 sets up expected param ctx for SessionUsecase.FindList
func (mmFindList *mSessionUsecaseMockFindList) ExpectCtxParam1(ctx context.Context) *mSessionUsecaseMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("SessionUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &SessionUsecaseMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.params != nil {
		mmFindList.mock.t.Fatalf("SessionUsecaseMock.FindList mock is already set by Expect")
	}

	if mmFindList.defaultExpectation.paramPtrs == nil {
		mmFindList.defaultExpectation.paramPtrs = &SessionUsecaseMockFindListParamPtrs{}
	}
	mmFindList.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindList
}

// ExpectListOptionsParam2 sets up expected param listOptions for SessionUsecase.FindList
func (mmFindList *mSessionUsecaseMockFindList) ExpectListOptionsParam2(listOptions *mm_usecase.SessionListOptions) *mSessionUsecaseMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("SessionUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &SessionUsecaseMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.params != nil {
		mmFindList.mock.t.Fatalf("SessionUsecaseMock.FindList mock is already set by Expect")
	}

	if mmFindList.defaultExpectation.paramPtrs == nil {
		mmFindList.defaultExpectation.paramPtrs = &SessionUsecaseMockFindListParamPtrs{}
	}
	mmFindList.defaultExpectation.paramPtrs.listOptions = &listOptions
	mmFindList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

	return mmFindList
}

// ExpectQueryParamsParam3 sets up expected param queryParams for SessionUsecase.FindList
func (mmFindList *mSessionUsecaseMockFindList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mSessionUsecaseMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("SessionUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &SessionUsecaseMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.params != nil {
		mmFindList.mock.t.Fatalf("SessionUsecaseMock.FindList mock is already set by Expect")
	}

	if mmFindList.defaultExpectation.paramPtrs == nil {
		mmFindList.defaultExpectation.paramPtrs = &SessionUsecaseMockFindListParamPtrs{}
	}
	mmFindList.defaultExpectation.paramPtrs.queryParams = &queryParams
	mmFindList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

	return mmFindList
}

// Inspect accepts an inspector function that has same arguments as the SessionUsecase.FindList
func (mmFindList *mSessionUsecaseMockFindList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.SessionListOptions, queryParams *uctypes.QueryGetListParams)) *mSessionUsecaseMockFindList {
	if mmFindList.mock.inspectFuncFindList != nil {
		mmFindList.mock.t.Fatalf("Inspect function is already set for SessionUsecaseMock.FindList")
	}

	mmFindList.mock.inspectFuncFindList = f

	return mmFindList
}

// Return sets up results that will be returned by SessionUsecase.FindList
func (mmFindList *mSessionUsecaseMockFindList) Return(items []*entity.Session, err error) *SessionUsecaseMock {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("SessionUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &SessionUsecaseMockFindListExpectation{mock: mmFindList.mock}
	}
	mmFindList.defaultExpectation.results = &SessionUsecaseMockFindListResults{items, err}
	mmFindList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindList.mock
}

// Set uses given function f to mock the SessionUsecase.FindList method
func (mmFindList *mSessionUsecaseMockFindList) Set(f func(ctx context.Context, listOptions *mm_usecase.SessionListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Session, err error)) *SessionUsecaseMock {
	if mmFindList.defaultExpectation != nil {
		mmFindList.mock.t.Fatalf("Default expectation is already set for the SessionUsecase.FindList method")
	}

	if len(mmFindList.expectations) > 0 {
		mmFindList.mock.t.Fatalf("Some expectations are already set for the SessionUsecase.FindList method")
	}

	mmFindList.mock.funcFindList = f
	mmFindList.mock.funcFindListOrigin = minimock.CallerInfo(1)
	return mmFindList.mock
}

// When sets expectation for the SessionUsecase.FindList which will trigger the result defined by the following
// Then helper
func (mmFindList *mSessionUsecaseMockFindList) When(ctx context.Context, listOptions *mm_usecase.SessionListOptions, queryParams *uctypes.QueryGetListParams) *SessionUsecaseMockFindListExpectation {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("SessionUsecaseMock.FindList mock is already set by Set")
	}

	expectation := &SessionUsecaseMockFindListExpectation{
		mock:               mmFindList.mock,
		params:             &SessionUsecaseMockFindListParams{ctx, listOptions, queryParams},
		expectationOrigins: SessionUsecaseMockFindListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindList.expectations = append(mmFindList.expectations, expectation)
	return expectation
}

// Then sets up SessionUsecase.FindList return parameters for the expectation previously defined by the When method
func (e *SessionUsecaseMockFindListExpectation) Then(items []*entity.Session, err error) *SessionUsecaseMock {
	e.results = &SessionUsecaseMockFindListResults{items, err}
	return e.mock
}

// Times sets number of times SessionUsecase.FindList should be invoked
func (mmFindList *mSessionUsecaseMockFindList) Times(n uint64) *mSessionUsecaseMockFindList {
	if n == 0 {
		mmFindList.mock.t.Fatalf("Times of SessionUsecaseMock.FindList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindList.expectedInvocations, n)
	mmFindList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindList
}

func (mmFindList *mSessionUsecaseMockFindList) invocationsDone() bool {
	if len(mmFindList.expectations) == 0 && mmFindList.defaultExpectation == nil && mmFindList.mock.funcFindList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindList.mock.afterFindListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindList implements mm_usecase.SessionUsecase
func (mmFindList *SessionUsecaseMock) FindList(ctx context.Context, listOptions *mm_usecase.SessionListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Session, err error) {
	mm_atomic.AddUint64(&mmFindList.beforeFindListCounter, 1)
	defer mm_atomic.AddUint64(&mmFindList.afterFindListCounter, 1)

	mmFindList.t.Helper()

	if mmFindList.inspectFuncFindList != nil {
		mmFindList.inspectFuncFindList(ctx, listOptions, queryParams)
	}

	mm_params := SessionUsecaseMockFindListParams{ctx, listOptions, queryParams}

	// Record call args
	mmFindList.FindListMock.mutex.Lock()
	mmFindList.FindListMock.callArgs = append(mmFindList.FindListMock.callArgs, &mm_params)
	mmFindList.FindListMock.mutex.Unlock()

	for _, e := range mmFindList.FindListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.items, e.results.err
		}
	}

	if mmFindList.FindListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindList.FindListMock.defaultExpectation.Counter, 1)
		mm_want := mmFindList.FindListMock.defaultExpectation.params
		mm_want_ptrs := mmFindList.FindListMock.defaultExpectation.paramPtrs

		mm_got := SessionUsecaseMockFindListParams{ctx, listOptions, queryParams}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindList.t.Errorf("SessionUsecaseMock.FindList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindList.FindListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.listOptions != nil && !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) {
				mmFindList.t.Errorf("SessionUsecaseMock.FindList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindList.FindListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
			}

			if mm_want_ptrs.queryParams != nil && !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) {
				mmFindList.t.Errorf("SessionUsecaseMock.FindList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindList.FindListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindList.t.Errorf("SessionUsecaseMock.FindList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindList.FindListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindList.FindListMock.defaultExpectation.results
		if mm_results == nil {
			mmFindList.t.Fatal("No results are set for the SessionUsecaseMock.FindList")
		}
		return (*mm_results).items, (*mm_results).err
	}
	if mmFindList.funcFindList != nil {
		return mmFindList.funcFindList(ctx, listOptions, queryParams)
	}
	mmFindList.t.Fatalf("Unexpected call to SessionUsecaseMock.FindList. %v %v %v", ctx, listOptions, queryParams)
	return
}

// FindListAfterCounter returns a count of finished SessionUsecaseMock.FindList invocations
func (mmFindList *SessionUsecaseMock) FindListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindList.afterFindListCounter)
}

// FindListBeforeCounter returns a count of SessionUsecaseMock.FindList invocations
func (mmFindList *SessionUsecaseMock) FindListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindList.beforeFindListCounter)
}

// Calls returns a list of arguments used in each call to SessionUsecaseMock.FindList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindList *mSessionUsecaseMockFindList) Calls() []*SessionUsecaseMockFindListParams {
	mmFindList.mutex.RLock()

	argCopy := make([]*SessionUsecaseMockFindListParams, len(mmFindList.callArgs))
	copy(argCopy, mmFindList.callArgs)

	mmFindList.mutex.RUnlock()

	return argCopy
}

// MinimockFindListDone returns true if the count of the FindList invocations corresponds
// the number of defined expectations
func (m *SessionUsecaseMock) MinimockFindListDone() bool {
	if m.FindListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindListMock.invocationsDone()
}

// MinimockFindListInspect logs each unmet expectation
func (m *SessionUsecaseMock) MinimockFindListInspect() {
	for _, e := range m.FindListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SessionUsecaseMock.FindList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindListCounter := mm_atomic.LoadUint64(&m.afterFindListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindListMock.defaultExpectation != nil && afterFindListCounter < 1 {
		if m.FindListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SessionUsecaseMock.FindList at\n%s", m.FindListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SessionUsecaseMock.FindList at\n%s with params: %#v", m.FindListMock.defaultExpectation.expectationOrigins.origin, *m.FindListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindList != nil && afterFindListCounter < 1 {
		m.t.Errorf("Expected call to SessionUsecaseMock.FindList at\n%s", m.funcFindListOrigin)
	}

	if !m.FindListMock.invocationsDone() && afterFindListCounter > 0 {
		m.t.Errorf("Expected %d calls to SessionUsecaseMock.FindList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindListMock.expectedInvocations), m.FindListMock.expectedInvocationsOrigin, afterFindListCounter)
	}
}

type mSessionUsecaseMockFindOneByID struct {
	optional           bool
	mock               *SessionUsecaseMock
	defaultExpectation *SessionUsecaseMockFindOneByIDExpectation
	expectations       []*SessionUsecaseMockFindOneByIDExpectation

	callArgs []*SessionUsecaseMockFindOneByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SessionUsecaseMockFindOneByIDExpectation specifies expectation struct of the SessionUsecase.FindOneByID
type SessionUsecaseMockFindOneByIDExpectation struct {
	mock               *SessionUsecaseMock
	params             *SessionUsecaseMockFindOneByIDParams
	paramPtrs          *SessionUsecaseMockFindOneByIDParamPtrs
	expectationOrigins SessionUsecaseMockFindOneByIDExpectationOrigins
	results            *SessionUsecaseMockFindOneByIDResults
	returnOrigin       string
	Counter            uint64
}

// SessionUsecaseMockFindOneByIDParams contains parameters of the SessionUsecase.FindOneByID
type SessionUsecaseMockFindOneByIDParams struct {
	ctx         context.Context
	id          uuid.UUID
	queryParams *uctypes.QueryGetOneParams
}

// SessionUsecaseMockFindOneByIDParamPtrs contains pointers to parameters of the SessionUsecase.FindOneByID
type SessionUsecaseMockFindOneByIDParamPtrs struct {
	ctx         *context.Context
	id          *uuid.UUID
	queryParams **uctypes.QueryGetOneParams
}

// SessionUsecaseMockFindOneByIDResults contains results of the SessionUsecase.FindOneByID
type SessionUsecaseMockFindOneByIDResults struct {
	session *entity.Session
	err     error
}

// SessionUsecaseMockFindOneByIDOrigins contains origins of expectations of the SessionUsecase.FindOneByID
type SessionUsecaseMockFindOneByIDExpectationOrigins struct {
	origin            string
	originCtx         string
	originId          string
	originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) Optional() *mSessionUsecaseMockFindOneByID {
	mmFindOneByID.optional = true
	return mmFindOneByID
}

// Expect sets up expected params for SessionUsecase.FindOneByID
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) Expect(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *mSessionUsecaseMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("SessionUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &SessionUsecaseMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.paramPtrs != nil {
		mmFindOneByID.mock.t.Fatalf("SessionUsecaseMock.FindOneByID mock is already set by ExpectParams functions")
	}

	mmFindOneByID.defaultExpectation.params = &SessionUsecaseMockFindOneByIDParams{ctx, id, queryParams}
	mmFindOneByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindOneByID.expectations {
		if minimock.Equal(e.params, mmFindOneByID.defaultExpectation.params) {
			mmFindOneByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindOneByID.defaultExpectation.params)
		}
	}

	return mmFindOneByID
}

// ExpectCtxParam1 sets up expected param ctx for SessionUsecase.FindOneByID
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) ExpectCtxParam1(ctx context.Context) *mSessionUsecaseMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("SessionUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &SessionUsecaseMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.params != nil {
		mmFindOneByID.mock.t.Fatalf("SessionUsecaseMock.FindOneByID mock is already set by Expect")
	}

	if mmFindOneByID.defaultExpectation.paramPtrs == nil {
		mmFindOneByID.defaultExpectation.paramPtrs = &SessionUsecaseMockFindOneByIDParamPtrs{}
	}
	mmFindOneByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindOneByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindOneByID
}

// ExpectIdParam2 sets up expected param id for SessionUsecase.FindOneByID
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) ExpectIdParam2(id uuid.UUID) *mSessionUsecaseMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("SessionUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &SessionUsecaseMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.params != nil {
		mmFindOneByID.mock.t.Fatalf("SessionUsecaseMock.FindOneByID mock is already set by Expect")
	}

	if mmFindOneByID.defaultExpectation.paramPtrs == nil {
		mmFindOneByID.defaultExpectation.paramPtrs = &SessionUsecaseMockFindOneByIDParamPtrs{}
	}
	mmFindOneByID.defaultExpectation.paramPtrs.id = &id
	mmFindOneByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmFindOneByID
}

// ExpectQueryParamsParam3 sets up expected param queryParams for SessionUsecase.FindOneByID
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetOneParams) *mSessionUsecaseMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("SessionUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &SessionUsecaseMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.params != nil {
		mmFindOneByID.mock.t.Fatalf("SessionUsecaseMock.FindOneByID mock is already set by Expect")
	}

	if mmFindOneByID.defaultExpectation.paramPtrs == nil {
		mmFindOneByID.defaultExpectation.paramPtrs = &SessionUsecaseMockFindOneByIDParamPtrs{}
	}
	mmFindOneByID.defaultExpectation.paramPtrs.queryParams = &queryParams
	mmFindOneByID.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

	return mmFindOneByID
}

// Inspect accepts an inspector function that has same arguments as the SessionUsecase.FindOneByID
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) Inspect(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)) *mSessionUsecaseMockFindOneByID {
	if mmFindOneByID.mock.inspectFuncFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("Inspect function is already set for SessionUsecaseMock.FindOneByID")
	}

	mmFindOneByID.mock.inspectFuncFindOneByID = f

	return mmFindOneByID
}

// Return sets up results that will be returned by SessionUsecase.FindOneByID
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) Return(session *entity.Session, err error) *SessionUsecaseMock {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("SessionUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &SessionUsecaseMockFindOneByIDExpectation{mock: mmFindOneByID.mock}
	}
	mmFindOneByID.defaultExpectation.results = &SessionUsecaseMockFindOneByIDResults{session, err}
	mmFindOneByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindOneByID.mock
}

// Set uses given function f to mock the SessionUsecase.FindOneByID method
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) Set(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (session *entity.Session, err error)) *SessionUsecaseMock {
	if mmFindOneByID.defaultExpectation != nil {
		mmFindOneByID.mock.t.Fatalf("Default expectation is already set for the SessionUsecase.FindOneByID method")
	}

	if len(mmFindOneByID.expectations) > 0 {
		mmFindOneByID.mock.t.Fatalf("Some expectations are already set for the SessionUsecase.FindOneByID method")
	}

	mmFindOneByID.mock.funcFindOneByID = f
	mmFindOneByID.mock.funcFindOneByIDOrigin = minimock.CallerInfo(1)
	return mmFindOneByID.mock
}

// When sets expectation for the SessionUsecase.FindOneByID which will trigger the result defined by the following
// Then helper
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) When(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *SessionUsecaseMockFindOneByIDExpectation {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("SessionUsecaseMock.FindOneByID mock is already set by Set")
	}

	expectation := &SessionUsecaseMockFindOneByIDExpectation{
		mock:               mmFindOneByID.mock,
		params:             &SessionUsecaseMockFindOneByIDParams{ctx, id, queryParams},
		expectationOrigins: SessionUsecaseMockFindOneByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindOneByID.expectations = append(mmFindOneByID.expectations, expectation)
	return expectation
}

// Then sets up SessionUsecase.FindOneByID return parameters for the expectation previously defined by the When method
func (e *SessionUsecaseMockFindOneByIDExpectation) Then(session *entity.Session, err error) *SessionUsecaseMock {
	e.results = &SessionUsecaseMockFindOneByIDResults{session, err}
	return e.mock
}

// Times sets number of times SessionUsecase.FindOneByID should be invoked
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) Times(n uint64) *mSessionUsecaseMockFindOneByID {
	if n == 0 {
		mmFindOneByID.mock.t.Fatalf("Times of SessionUsecaseMock.FindOneByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindOneByID.expectedInvocations, n)
	mmFindOneByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindOneByID
}

func (mmFindOneByID *mSessionUsecaseMockFindOneByID) invocationsDone() bool {
	if len(mmFindOneByID.expectations) == 0 && mmFindOneByID.defaultExpectation == nil && mmFindOneByID.mock.funcFindOneByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindOneByID.mock.afterFindOneByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindOneByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindOneByID implements mm_usecase.SessionUsecase
func (mmFindOneByID *SessionUsecaseMock) FindOneByID(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (session *entity.Session, err error) {
	mm_atomic.AddUint64(&mmFindOneByID.beforeFindOneByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmFindOneByID.afterFindOneByIDCounter, 1)

	mmFindOneByID.t.Helper()

	if mmFindOneByID.inspectFuncFindOneByID != nil {
		mmFindOneByID.inspectFuncFindOneByID(ctx, id, queryParams)
	}

	mm_params := SessionUsecaseMockFindOneByIDParams{ctx, id, queryParams}

	// Record call args
	mmFindOneByID.FindOneByIDMock.mutex.Lock()
	mmFindOneByID.FindOneByIDMock.callArgs = append(mmFindOneByID.FindOneByIDMock.callArgs, &mm_params)
	mmFindOneByID.FindOneByIDMock.mutex.Unlock()

	for _, e := range mmFindOneByID.FindOneByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.session, e.results.err
		}
	}

	if mmFindOneByID.FindOneByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindOneByID.FindOneByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmFindOneByID.FindOneByIDMock.defaultExpectation.params
		mm_want_ptrs := mmFindOneByID.FindOneByIDMock.defaultExpectation.paramPtrs

		mm_got := SessionUsecaseMockFindOneByIDParams{ctx, id, queryParams}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindOneByID.t.Errorf("SessionUsecaseMock.FindOneByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmFindOneByID.t.Errorf("SessionUsecaseMock.FindOneByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.queryParams != nil && !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) {
				mmFindOneByID.t.Errorf("SessionUsecaseMock.FindOneByID got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindOneByID.t.Errorf("SessionUsecaseMock.FindOneByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindOneByID.FindOneByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmFindOneByID.t.Fatal("No results are set for the SessionUsecaseMock.FindOneByID")
		}
		return (*mm_results).session, (*mm_results).err
	}
	if mmFindOneByID.funcFindOneByID != nil {
		return mmFindOneByID.funcFindOneByID(ctx, id, queryParams)
	}
	mmFindOneByID.t.Fatalf("Unexpected call to SessionUsecaseMock.FindOneByID. %v %v %v", ctx, id, queryParams)
	return
}

// FindOneByIDAfterCounter returns a count of finished SessionUsecaseMock.FindOneByID invocations
func (mmFindOneByID *SessionUsecaseMock) FindOneByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindOneByID.afterFindOneByIDCounter)
}

// FindOneByIDBeforeCounter returns a count of SessionUsecaseMock.FindOneByID invocations
func (mmFindOneByID *SessionUsecaseMock) FindOneByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindOneByID.beforeFindOneByIDCounter)
}

// Calls returns a list of arguments used in each call to SessionUsecaseMock.FindOneByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindOneByID *mSessionUsecaseMockFindOneByID) Calls() []*SessionUsecaseMockFindOneByIDParams {
	mmFindOneByID.mutex.RLock()

	argCopy := make([]*SessionUsecaseMockFindOneByIDParams, len(mmFindOneByID.callArgs))
	copy(argCopy, mmFindOneByID.callArgs)

	mmFindOneByID.mutex.RUnlock()

	return argCopy
}

// MinimockFindOneByIDDone returns true if the count of the FindOneByID invocations corresponds
// the number of defined expectations
func (m *SessionUsecaseMock) MinimockFindOneByIDDone() bool {
	if m.FindOneByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindOneByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindOneByIDMock.invocationsDone()
}

// MinimockFindOneByIDInspect logs each unmet expectation
func (m *SessionUsecaseMock) MinimockFindOneByIDInspect() {
	for _, e := range m.FindOneByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SessionUsecaseMock.FindOneByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindOneByIDCounter := mm_atomic.LoadUint64(&m.afterFindOneByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindOneByIDMock.defaultExpectation != nil && afterFindOneByIDCounter < 1 {
		if m.FindOneByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SessionUsecaseMock.FindOneByID at\n%s", m.FindOneByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SessionUsecaseMock.FindOneByID at\n%s with params: %#v", m.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *m.FindOneByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindOneByID != nil && afterFindOneByIDCounter < 1 {
		m.t.Errorf("Expected call to SessionUsecaseMock.FindOneByID at\n%s", m.funcFindOneByIDOrigin)
	}

	if !m.FindOneByIDMock.invocationsDone() && afterFindOneByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to SessionUsecaseMock.FindOneByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindOneByIDMock.expectedInvocations), m.FindOneByIDMock.expectedInvocationsOrigin, afterFindOneByIDCounter)
	}
}

type mSessionUsecaseMockRevokeSessionByID struct {
	optional           bool
	mock               *SessionUsecaseMock
	defaultExpectation *SessionUsecaseMockRevokeSessionByIDExpectation
	expectations       []*SessionUsecaseMockRevokeSessionByIDExpectation

	callArgs []*SessionUsecaseMockRevokeSessionByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SessionUsecaseMockRevokeSessionByIDExpectation specifies expectation struct of the SessionUsecase.RevokeSessionByID
type SessionUsecaseMockRevokeSessionByIDExpectation struct {
	mock               *SessionUsecaseMock
	params             *SessionUsecaseMockRevokeSessionByIDParams
	paramPtrs          *SessionUsecaseMockRevokeSessionByIDParamPtrs
	expectationOrigins SessionUsecaseMockRevokeSessionByIDExpectationOrigins
	results            *SessionUsecaseMockRevokeSessionByIDResults
	returnOrigin       string
	Counter            uint64
}

// SessionUsecaseMockRevokeSessionByIDParams contains parameters of the SessionUsecase.RevokeSessionByID
type SessionUsecaseMockRevokeSessionByIDParams struct {
	ctx context.Context
	ID  uuid.UUID
}

// SessionUsecaseMockRevokeSessionByIDParamPtrs contains pointers to parameters of the SessionUsecase.RevokeSessionByID
type SessionUsecaseMockRevokeSessionByIDParamPtrs struct {
	ctx *context.Context
	ID  *uuid.UUID
}

// SessionUsecaseMockRevokeSessionByIDResults contains results of the SessionUsecase.RevokeSessionByID
type SessionUsecaseMockRevokeSessionByIDResults struct {
	err error
}

// SessionUsecaseMockRevokeSessionByIDOrigins contains origins of expectations of the SessionUsecase.RevokeSessionByID
type SessionUsecaseMockRevokeSessionByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) Optional() *mSessionUsecaseMockRevokeSessionByID {
	mmRevokeSessionByID.optional = true
	return mmRevokeSessionByID
}

// Expect sets up expected params for SessionUsecase.RevokeSessionByID
func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) Expect(ctx context.Context, ID uuid.UUID) *mSessionUsecaseMockRevokeSessionByID {
	if mmRevokeSessionByID.mock.funcRevokeSessionByID != nil {
		mmRevokeSessionByID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionByID mock is already set by Set")
	}

	if mmRevokeSessionByID.defaultExpectation == nil {
		mmRevokeSessionByID.defaultExpectation = &SessionUsecaseMockRevokeSessionByIDExpectation{}
	}

	if mmRevokeSessionByID.defaultExpectation.paramPtrs != nil {
		mmRevokeSessionByID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionByID mock is already set by ExpectParams functions")
	}

	mmRevokeSessionByID.defaultExpectation.params = &SessionUsecaseMockRevokeSessionByIDParams{ctx, ID}
	mmRevokeSessionByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRevokeSessionByID.expectations {
		if minimock.Equal(e.params, mmRevokeSessionByID.defaultExpectation.params) {
			mmRevokeSessionByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRevokeSessionByID.defaultExpectation.params)
		}
	}

	return mmRevokeSessionByID
}

// ExpectCtxParam1 sets up expected param ctx for SessionUsecase.RevokeSessionByID
func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) ExpectCtxParam1(ctx context.Context) *mSessionUsecaseMockRevokeSessionByID {
	if mmRevokeSessionByID.mock.funcRevokeSessionByID != nil {
		mmRevokeSessionByID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionByID mock is already set by Set")
	}

	if mmRevokeSessionByID.defaultExpectation == nil {
		mmRevokeSessionByID.defaultExpectation = &SessionUsecaseMockRevokeSessionByIDExpectation{}
	}

	if mmRevokeSessionByID.defaultExpectation.params != nil {
		mmRevokeSessionByID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionByID mock is already set by Expect")
	}

	if mmRevokeSessionByID.defaultExpectation.paramPtrs == nil {
		mmRevokeSessionByID.defaultExpectation.paramPtrs = &SessionUsecaseMockRevokeSessionByIDParamPtrs{}
	}
	mmRevokeSessionByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmRevokeSessionByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRevokeSessionByID
}

// ExpectIDParam2 sets up expected param ID for SessionUsecase.RevokeSessionByID
func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) ExpectIDParam2(ID uuid.UUID) *mSessionUsecaseMockRevokeSessionByID {
	if mmRevokeSessionByID.mock.funcRevokeSessionByID != nil {
		mmRevokeSessionByID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionByID mock is already set by Set")
	}

	if mmRevokeSessionByID.defaultExpectation == nil {
		mmRevokeSessionByID.defaultExpectation = &SessionUsecaseMockRevokeSessionByIDExpectation{}
	}

	if mmRevokeSessionByID.defaultExpectation.params != nil {
		mmRevokeSessionByID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionByID mock is already set by Expect")
	}

	if mmRevokeSessionByID.defaultExpectation.paramPtrs == nil {
		mmRevokeSessionByID.defaultExpectation.paramPtrs = &SessionUsecaseMockRevokeSessionByIDParamPtrs{}
	}
	mmRevokeSessionByID.defaultExpectation.paramPtrs.ID = &ID
	mmRevokeSessionByID.defaultExpectation.expectationOrigins.originID = minimock.CallerInfo(1)

	return mmRevokeSessionByID
}

// Inspect accepts an inspector function that has same arguments as the SessionUsecase.RevokeSessionByID
func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) Inspect(f func(ctx context.Context, ID uuid.UUID)) *mSessionUsecaseMockRevokeSessionByID {
	if mmRevokeSessionByID.mock.inspectFuncRevokeSessionByID != nil {
		mmRevokeSessionByID.mock.t.Fatalf("Inspect function is already set for SessionUsecaseMock.RevokeSessionByID")
	}

	mmRevokeSessionByID.mock.inspectFuncRevokeSessionByID = f

	return mmRevokeSessionByID
}

// Return sets up results that will be returned by SessionUsecase.RevokeSessionByID
func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) Return(err error) *SessionUsecaseMock {
	if mmRevokeSessionByID.mock.funcRevokeSessionByID != nil {
		mmRevokeSessionByID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionByID mock is already set by Set")
	}

	if mmRevokeSessionByID.defaultExpectation == nil {
		mmRevokeSessionByID.defaultExpectation = &SessionUsecaseMockRevokeSessionByIDExpectation{mock: mmRevokeSessionByID.mock}
	}
	mmRevokeSessionByID.defaultExpectation.results = &SessionUsecaseMockRevokeSessionByIDResults{err}
	mmRevokeSessionByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRevokeSessionByID.mock
}

// Set uses given function f to mock the SessionUsecase.RevokeSessionByID method
func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) Set(f func(ctx context.Context, ID uuid.UUID) (err error)) *SessionUsecaseMock {
	if mmRevokeSessionByID.defaultExpectation != nil {
		mmRevokeSessionByID.mock.t.Fatalf("Default expectation is already set for the SessionUsecase.RevokeSessionByID method")
	}

	if len(mmRevokeSessionByID.expectations) > 0 {
		mmRevokeSessionByID.mock.t.Fatalf("Some expectations are already set for the SessionUsecase.RevokeSessionByID method")
	}

	mmRevokeSessionByID.mock.funcRevokeSessionByID = f
	mmRevokeSessionByID.mock.funcRevokeSessionByIDOrigin = minimock.CallerInfo(1)
	return mmRevokeSessionByID.mock
}

// When sets expectation for the SessionUsecase.RevokeSessionByID which will trigger the result defined by the following
// Then helper
func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) When(ctx context.Context, ID uuid.UUID) *SessionUsecaseMockRevokeSessionByIDExpectation {
	if mmRevokeSessionByID.mock.funcRevokeSessionByID != nil {
		mmRevokeSessionByID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionByID mock is already set by Set")
	}

	expectation := &SessionUsecaseMockRevokeSessionByIDExpectation{
		mock:               mmRevokeSessionByID.mock,
		params:             &SessionUsecaseMockRevokeSessionByIDParams{ctx, ID},
		expectationOrigins: SessionUsecaseMockRevokeSessionByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRevokeSessionByID.expectations = append(mmRevokeSessionByID.expectations, expectation)
	return expectation
}

// Then sets up SessionUsecase.RevokeSessionByID return parameters for the expectation previously defined by the When method
func (e *SessionUsecaseMockRevokeSessionByIDExpectation) Then(err error) *SessionUsecaseMock {
	e.results = &SessionUsecaseMockRevokeSessionByIDResults{err}
	return e.mock
}

// Times sets number of times SessionUsecase.RevokeSessionByID should be invoked
func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) Times(n uint64) *mSessionUsecaseMockRevokeSessionByID {
	if n == 0 {
		mmRevokeSessionByID.mock.t.Fatalf("Times of SessionUsecaseMock.RevokeSessionByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRevokeSessionByID.expectedInvocations, n)
	mmRevokeSessionByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRevokeSessionByID
}

func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) invocationsDone() bool {
	if len(mmRevokeSessionByID.expectations) == 0 && mmRevokeSessionByID.defaultExpectation == nil && mmRevokeSessionByID.mock.funcRevokeSessionByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRevokeSessionByID.mock.afterRevokeSessionByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRevokeSessionByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RevokeSessionByID implements mm_usecase.SessionUsecase
func (mmRevokeSessionByID *SessionUsecaseMock) RevokeSessionByID(ctx context.Context, ID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmRevokeSessionByID.beforeRevokeSessionByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmRevokeSessionByID.afterRevokeSessionByIDCounter, 1)

	mmRevokeSessionByID.t.Helper()

	if mmRevokeSessionByID.inspectFuncRevokeSessionByID != nil {
		mmRevokeSessionByID.inspectFuncRevokeSessionByID(ctx, ID)
	}

	mm_params := SessionUsecaseMockRevokeSessionByIDParams{ctx, ID}

	// Record call args
	mmRevokeSessionByID.RevokeSessionByIDMock.mutex.Lock()
	mmRevokeSessionByID.RevokeSessionByIDMock.callArgs = append(mmRevokeSessionByID.RevokeSessionByIDMock.callArgs, &mm_params)
	mmRevokeSessionByID.RevokeSessionByIDMock.mutex.Unlock()

	for _, e := range mmRevokeSessionByID.RevokeSessionByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRevokeSessionByID.RevokeSessionByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRevokeSessionByID.RevokeSessionByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmRevokeSessionByID.RevokeSessionByIDMock.defaultExpectation.params
		mm_want_ptrs := mmRevokeSessionByID.RevokeSessionByIDMock.defaultExpectation.paramPtrs

		mm_got := SessionUsecaseMockRevokeSessionByIDParams{ctx, ID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRevokeSessionByID.t.Errorf("SessionUsecaseMock.RevokeSessionByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRevokeSessionByID.RevokeSessionByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ID != nil && !minimock.Equal(*mm_want_ptrs.ID, mm_got.ID) {
				mmRevokeSessionByID.t.Errorf("SessionUsecaseMock.RevokeSessionByID got unexpected parameter ID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRevokeSessionByID.RevokeSessionByIDMock.defaultExpectation.expectationOrigins.originID, *mm_want_ptrs.ID, mm_got.ID, minimock.Diff(*mm_want_ptrs.ID, mm_got.ID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRevokeSessionByID.t.Errorf("SessionUsecaseMock.RevokeSessionByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRevokeSessionByID.RevokeSessionByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRevokeSessionByID.RevokeSessionByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmRevokeSessionByID.t.Fatal("No results are set for the SessionUsecaseMock.RevokeSessionByID")
		}
		return (*mm_results).err
	}
	if mmRevokeSessionByID.funcRevokeSessionByID != nil {
		return mmRevokeSessionByID.funcRevokeSessionByID(ctx, ID)
	}
	mmRevokeSessionByID.t.Fatalf("Unexpected call to SessionUsecaseMock.RevokeSessionByID. %v %v", ctx, ID)
	return
}

// RevokeSessionByIDAfterCounter returns a count of finished SessionUsecaseMock.RevokeSessionByID invocations
func (mmRevokeSessionByID *SessionUsecaseMock) RevokeSessionByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRevokeSessionByID.afterRevokeSessionByIDCounter)
}

// RevokeSessionByIDBeforeCounter returns a count of SessionUsecaseMock.RevokeSessionByID invocations
func (mmRevokeSessionByID *SessionUsecaseMock) RevokeSessionByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRevokeSessionByID.beforeRevokeSessionByIDCounter)
}

// Calls returns a list of arguments used in each call to SessionUsecaseMock.RevokeSessionByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRevokeSessionByID *mSessionUsecaseMockRevokeSessionByID) Calls() []*SessionUsecaseMockRevokeSessionByIDParams {
	mmRevokeSessionByID.mutex.RLock()

	argCopy := make([]*SessionUsecaseMockRevokeSessionByIDParams, len(mmRevokeSessionByID.callArgs))
	copy(argCopy, mmRevokeSessionByID.callArgs)

	mmRevokeSessionByID.mutex.RUnlock()

	return argCopy
}

// MinimockRevokeSessionByIDDone returns true if the count of the RevokeSessionByID invocations corresponds
// the number of defined expectations
func (m *SessionUsecaseMock) MinimockRevokeSessionByIDDone() bool {
	if m.RevokeSessionByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RevokeSessionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RevokeSessionByIDMock.invocationsDone()
}

// MinimockRevokeSessionByIDInspect logs each unmet expectation
func (m *SessionUsecaseMock) MinimockRevokeSessionByIDInspect() {
	for _, e := range m.RevokeSessionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SessionUsecaseMock.RevokeSessionByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRevokeSessionByIDCounter := mm_atomic.LoadUint64(&m.afterRevokeSessionByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RevokeSessionByIDMock.defaultExpectation != nil && afterRevokeSessionByIDCounter < 1 {
		if m.RevokeSessionByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SessionUsecaseMock.RevokeSessionByID at\n%s", m.RevokeSessionByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SessionUsecaseMock.RevokeSessionByID at\n%s with params: %#v", m.RevokeSessionByIDMock.defaultExpectation.expectationOrigins.origin, *m.RevokeSessionByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRevokeSessionByID != nil && afterRevokeSessionByIDCounter < 1 {
		m.t.Errorf("Expected call to SessionUsecaseMock.RevokeSessionByID at\n%s", m.funcRevokeSessionByIDOrigin)
	}

	if !m.RevokeSessionByIDMock.invocationsDone() && afterRevokeSessionByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to SessionUsecaseMock.RevokeSessionByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RevokeSessionByIDMock.expectedInvocations), m.RevokeSessionByIDMock.expectedInvocationsOrigin, afterRevokeSessionByIDCounter)
	}
}

type mSessionUsecaseMockRevokeSessionsByAccountID struct {
	optional           bool
	mock               *SessionUsecaseMock
	defaultExpectation *SessionUsecaseMockRevokeSessionsByAccountIDExpectation
	expectations       []*SessionUsecaseMockRevokeSessionsByAccountIDExpectation

	callArgs []*SessionUsecaseMockRevokeSessionsByAccountIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SessionUsecaseMockRevokeSessionsByAccountIDExpectation specifies expectation struct of the SessionUsecase.RevokeSessionsByAccountID
type SessionUsecaseMockRevokeSessionsByAccountIDExpectation struct {
	mock               *SessionUsecaseMock
	params             *SessionUsecaseMockRevokeSessionsByAccountIDParams
	paramPtrs          *SessionUsecaseMockRevokeSessionsByAccountIDParamPtrs
	expectationOrigins SessionUsecaseMockRevokeSessionsByAccountIDExpectationOrigins
	results            *SessionUsecaseMockRevokeSessionsByAccountIDResults
	returnOrigin       string
	Counter            uint64
}

// SessionUsecaseMockRevokeSessionsByAccountIDParams contains parameters of the SessionUsecase.RevokeSessionsByAccountID
type SessionUsecaseMockRevokeSessionsByAccountIDParams struct {
	ctx       context.Context
	accountID uuid.UUID
}

// SessionUsecaseMockRevokeSessionsByAccountIDParamPtrs contains pointers to parameters of the SessionUsecase.RevokeSessionsByAccountID
type SessionUsecaseMockRevokeSessionsByAccountIDParamPtrs struct {
	ctx       *context.Context
	accountID *uuid.UUID
}

// SessionUsecaseMockRevokeSessionsByAccountIDResults contains results of the SessionUsecase.RevokeSessionsByAccountID
type SessionUsecaseMockRevokeSessionsByAccountIDResults struct {
	err error
}

// SessionUsecaseMockRevokeSessionsByAccountIDOrigins contains origins of expectations of the SessionUsecase.RevokeSessionsByAccountID
type SessionUsecaseMockRevokeSessionsByAccountIDExpectationOrigins struct {
	origin          string
	originCtx       string
	originAccountID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) Optional() *mSessionUsecaseMockRevokeSessionsByAccountID {
	mmRevokeSessionsByAccountID.optional = true
	return mmRevokeSessionsByAccountID
}

// Expect sets up expected params for SessionUsecase.RevokeSessionsByAccountID
func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) Expect(ctx context.Context, accountID uuid.UUID) *mSessionUsecaseMockRevokeSessionsByAccountID {
	if mmRevokeSessionsByAccountID.mock.funcRevokeSessionsByAccountID != nil {
		mmRevokeSessionsByAccountID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionsByAccountID mock is already set by Set")
	}

	if mmRevokeSessionsByAccountID.defaultExpectation == nil {
		mmRevokeSessionsByAccountID.defaultExpectation = &SessionUsecaseMockRevokeSessionsByAccountIDExpectation{}
	}

	if mmRevokeSessionsByAccountID.defaultExpectation.paramPtrs != nil {
		mmRevokeSessionsByAccountID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionsByAccountID mock is already set by ExpectParams functions")
	}

	mmRevokeSessionsByAccountID.defaultExpectation.params = &SessionUsecaseMockRevokeSessionsByAccountIDParams{ctx, accountID}
	mmRevokeSessionsByAccountID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRevokeSessionsByAccountID.expectations {
		if minimock.Equal(e.params, mmRevokeSessionsByAccountID.defaultExpectation.params) {
			mmRevokeSessionsByAccountID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRevokeSessionsByAccountID.defaultExpectation.params)
		}
	}

	return mmRevokeSessionsByAccountID
}

// ExpectCtxParam1 sets up expected param ctx for SessionUsecase.RevokeSessionsByAccountID
func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) ExpectCtxParam1(ctx context.Context) *mSessionUsecaseMockRevokeSessionsByAccountID {
	if mmRevokeSessionsByAccountID.mock.funcRevokeSessionsByAccountID != nil {
		mmRevokeSessionsByAccountID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionsByAccountID mock is already set by Set")
	}

	if mmRevokeSessionsByAccountID.defaultExpectation == nil {
		mmRevokeSessionsByAccountID.defaultExpectation = &SessionUsecaseMockRevokeSessionsByAccountIDExpectation{}
	}

	if mmRevokeSessionsByAccountID.defaultExpectation.params != nil {
		mmRevokeSessionsByAccountID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionsByAccountID mock is already set by Expect")
	}

	if mmRevokeSessionsByAccountID.defaultExpectation.paramPtrs == nil {
		mmRevokeSessionsByAccountID.defaultExpectation.paramPtrs = &SessionUsecaseMockRevokeSessionsByAccountIDParamPtrs{}
	}
	mmRevokeSessionsByAccountID.defaultExpectation.paramPtrs.ctx = &ctx
	mmRevokeSessionsByAccountID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRevokeSessionsByAccountID
}

// ExpectAccountIDParam2 sets up expected param accountID for SessionUsecase.RevokeSessionsByAccountID
func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) ExpectAccountIDParam2(accountID uuid.UUID) *mSessionUsecaseMockRevokeSessionsByAccountID {
	if mmRevokeSessionsByAccountID.mock.funcRevokeSessionsByAccountID != nil {
		mmRevokeSessionsByAccountID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionsByAccountID mock is already set by Set")
	}

	if mmRevokeSessionsByAccountID.defaultExpectation == nil {
		mmRevokeSessionsByAccountID.defaultExpectation = &SessionUsecaseMockRevokeSessionsByAccountIDExpectation{}
	}

	if mmRevokeSessionsByAccountID.defaultExpectation.params != nil {
		mmRevokeSessionsByAccountID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionsByAccountID mock is already set by Expect")
	}

	if mmRevokeSessionsByAccountID.defaultExpectation.paramPtrs == nil {
		mmRevokeSessionsByAccountID.defaultExpectation.paramPtrs = &SessionUsecaseMockRevokeSessionsByAccountIDParamPtrs{}
	}
	mmRevokeSessionsByAccountID.defaultExpectation.paramPtrs.accountID = &accountID
	mmRevokeSessionsByAccountID.defaultExpectation.expectationOrigins.originAccountID = minimock.CallerInfo(1)

	return mmRevokeSessionsByAccountID
}

// Inspect accepts an inspector function that has same arguments as the SessionUsecase.RevokeSessionsByAccountID
func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) Inspect(f func(ctx context.Context, accountID uuid.UUID)) *mSessionUsecaseMockRevokeSessionsByAccountID {
	if mmRevokeSessionsByAccountID.mock.inspectFuncRevokeSessionsByAccountID != nil {
		mmRevokeSessionsByAccountID.mock.t.Fatalf("Inspect function is already set for SessionUsecaseMock.RevokeSessionsByAccountID")
	}

	mmRevokeSessionsByAccountID.mock.inspectFuncRevokeSessionsByAccountID = f

	return mmRevokeSessionsByAccountID
}

// Return sets up results that will be returned by SessionUsecase.RevokeSessionsByAccountID
func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) Return(err error) *SessionUsecaseMock {
	if mmRevokeSessionsByAccountID.mock.funcRevokeSessionsByAccountID != nil {
		mmRevokeSessionsByAccountID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionsByAccountID mock is already set by Set")
	}

	if mmRevokeSessionsByAccountID.defaultExpectation == nil {
		mmRevokeSessionsByAccountID.defaultExpectation = &SessionUsecaseMockRevokeSessionsByAccountIDExpectation{mock: mmRevokeSessionsByAccountID.mock}
	}
	mmRevokeSessionsByAccountID.defaultExpectation.results = &SessionUsecaseMockRevokeSessionsByAccountIDResults{err}
	mmRevokeSessionsByAccountID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRevokeSessionsByAccountID.mock
}

// Set uses given function f to mock the SessionUsecase.RevokeSessionsByAccountID method
func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) Set(f func(ctx context.Context, accountID uuid.UUID) (err error)) *SessionUsecaseMock {
	if mmRevokeSessionsByAccountID.defaultExpectation != nil {
		mmRevokeSessionsByAccountID.mock.t.Fatalf("Default expectation is already set for the SessionUsecase.RevokeSessionsByAccountID method")
	}

	if len(mmRevokeSessionsByAccountID.expectations) > 0 {
		mmRevokeSessionsByAccountID.mock.t.Fatalf("Some expectations are already set for the SessionUsecase.RevokeSessionsByAccountID method")
	}

	mmRevokeSessionsByAccountID.mock.funcRevokeSessionsByAccountID = f
	mmRevokeSessionsByAccountID.mock.funcRevokeSessionsByAccountIDOrigin = minimock.CallerInfo(1)
	return mmRevokeSessionsByAccountID.mock
}

// When sets expectation for the SessionUsecase.RevokeSessionsByAccountID which will trigger the result defined by the following
// Then helper
func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) When(ctx context.Context, accountID uuid.UUID) *SessionUsecaseMockRevokeSessionsByAccountIDExpectation {
	if mmRevokeSessionsByAccountID.mock.funcRevokeSessionsByAccountID != nil {
		mmRevokeSessionsByAccountID.mock.t.Fatalf("SessionUsecaseMock.RevokeSessionsByAccountID mock is already set by Set")
	}

	expectation := &SessionUsecaseMockRevokeSessionsByAccountIDExpectation{
		mock:               mmRevokeSessionsByAccountID.mock,
		params:             &SessionUsecaseMockRevokeSessionsByAccountIDParams{ctx, accountID},
		expectationOrigins: SessionUsecaseMockRevokeSessionsByAccountIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRevokeSessionsByAccountID.expectations = append(mmRevokeSessionsByAccountID.expectations, expectation)
	return expectation
}

// Then sets up SessionUsecase.RevokeSessionsByAccountID return parameters for the expectation previously defined by the When method
func (e *SessionUsecaseMockRevokeSessionsByAccountIDExpectation) Then(err error) *SessionUsecaseMock {
	e.results = &SessionUsecaseMockRevokeSessionsByAccountIDResults{err}
	return e.mock
}

// Times sets number of times SessionUsecase.RevokeSessionsByAccountID should be invoked
func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) Times(n uint64) *mSessionUsecaseMockRevokeSessionsByAccountID {
	if n == 0 {
		mmRevokeSessionsByAccountID.mock.t.Fatalf("Times of SessionUsecaseMock.RevokeSessionsByAccountID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRevokeSessionsByAccountID.expectedInvocations, n)
	mmRevokeSessionsByAccountID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRevokeSessionsByAccountID
}

func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) invocationsDone() bool {
	if len(mmRevokeSessionsByAccountID.expectations) == 0 && mmRevokeSessionsByAccountID.defaultExpectation == nil && mmRevokeSessionsByAccountID.mock.funcRevokeSessionsByAccountID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRevokeSessionsByAccountID.mock.afterRevokeSessionsByAccountIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRevokeSessionsByAccountID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RevokeSessionsByAccountID implements mm_usecase.SessionUsecase
func (mmRevokeSessionsByAccountID *SessionUsecaseMock) RevokeSessionsByAccountID(ctx context.Context, accountID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmRevokeSessionsByAccountID.beforeRevokeSessionsByAccountIDCounter, 1)
	defer mm_atomic.AddUint64(&mmRevokeSessionsByAccountID.afterRevokeSessionsByAccountIDCounter, 1)

	mmRevokeSessionsByAccountID.t.Helper()

	if mmRevokeSessionsByAccountID.inspectFuncRevokeSessionsByAccountID != nil {
		mmRevokeSessionsByAccountID.inspectFuncRevokeSessionsByAccountID(ctx, accountID)
	}

	mm_params := SessionUsecaseMockRevokeSessionsByAccountIDParams{ctx, accountID}

	// Record call args
	mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.mutex.Lock()
	mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.callArgs = append(mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.callArgs, &mm_params)
	mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.mutex.Unlock()

	for _, e := range mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.defaultExpectation.Counter, 1)
		mm_want := mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.defaultExpectation.params
		mm_want_ptrs := mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.defaultExpectation.paramPtrs

		mm_got := SessionUsecaseMockRevokeSessionsByAccountIDParams{ctx, accountID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRevokeSessionsByAccountID.t.Errorf("SessionUsecaseMock.RevokeSessionsByAccountID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.accountID != nil && !minimock.Equal(*mm_want_ptrs.accountID, mm_got.accountID) {
				mmRevokeSessionsByAccountID.t.Errorf("SessionUsecaseMock.RevokeSessionsByAccountID got unexpected parameter accountID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.defaultExpectation.expectationOrigins.originAccountID, *mm_want_ptrs.accountID, mm_got.accountID, minimock.Diff(*mm_want_ptrs.accountID, mm_got.accountID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRevokeSessionsByAccountID.t.Errorf("SessionUsecaseMock.RevokeSessionsByAccountID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRevokeSessionsByAccountID.RevokeSessionsByAccountIDMock.defaultExpectation.results
		if mm_results == nil {
			mmRevokeSessionsByAccountID.t.Fatal("No results are set for the SessionUsecaseMock.RevokeSessionsByAccountID")
		}
		return (*mm_results).err
	}
	if mmRevokeSessionsByAccountID.funcRevokeSessionsByAccountID != nil {
		return mmRevokeSessionsByAccountID.funcRevokeSessionsByAccountID(ctx, accountID)
	}
	mmRevokeSessionsByAccountID.t.Fatalf("Unexpected call to SessionUsecaseMock.RevokeSessionsByAccountID. %v %v", ctx, accountID)
	return
}

// RevokeSessionsByAccountIDAfterCounter returns a count of finished SessionUsecaseMock.RevokeSessionsByAccountID invocations
func (mmRevokeSessionsByAccountID *SessionUsecaseMock) RevokeSessionsByAccountIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRevokeSessionsByAccountID.afterRevokeSessionsByAccountIDCounter)
}

// RevokeSessionsByAccountIDBeforeCounter returns a count of SessionUsecaseMock.RevokeSessionsByAccountID invocations
func (mmRevokeSessionsByAccountID *SessionUsecaseMock) RevokeSessionsByAccountIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRevokeSessionsByAccountID.beforeRevokeSessionsByAccountIDCounter)
}

// Calls returns a list of arguments used in each call to SessionUsecaseMock.RevokeSessionsByAccountID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRevokeSessionsByAccountID *mSessionUsecaseMockRevokeSessionsByAccountID) Calls() []*SessionUsecaseMockRevokeSessionsByAccountIDParams {
	mmRevokeSessionsByAccountID.mutex.RLock()

	argCopy := make([]*SessionUsecaseMockRevokeSessionsByAccountIDParams, len(mmRevokeSessionsByAccountID.callArgs))
	copy(argCopy, mmRevokeSessionsByAccountID.callArgs)

	mmRevokeSessionsByAccountID.mutex.RUnlock()

	return argCopy
}

// MinimockRevokeSessionsByAccountIDDone returns true if the count of the RevokeSessionsByAccountID invocations corresponds
// the number of defined expectations
func (m *SessionUsecaseMock) MinimockRevokeSessionsByAccountIDDone() bool {
	if m.RevokeSessionsByAccountIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RevokeSessionsByAccountIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RevokeSessionsByAccountIDMock.invocationsDone()
}

// MinimockRevokeSessionsByAccountIDInspect logs each unmet expectation
func (m *SessionUsecaseMock) MinimockRevokeSessionsByAccountIDInspect() {
	for _, e := range m.RevokeSessionsByAccountIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SessionUsecaseMock.RevokeSessionsByAccountID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRevokeSessionsByAccountIDCounter := mm_atomic.LoadUint64(&m.afterRevokeSessionsByAccountIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RevokeSessionsByAccountIDMock.defaultExpectation != nil && afterRevokeSessionsByAccountIDCounter < 1 {
		if m.RevokeSessionsByAccountIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SessionUsecaseMock.RevokeSessionsByAccountID at\n%s", m.RevokeSessionsByAccountIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SessionUsecaseMock.RevokeSessionsByAccountID at\n%s with params: %#v", m.RevokeSessionsByAccountIDMock.defaultExpectation.expectationOrigins.origin, *m.RevokeSessionsByAccountIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRevokeSessionsByAccountID != nil && afterRevokeSessionsByAccountIDCounter < 1 {
		m.t.Errorf("Expected call to SessionUsecaseMock.RevokeSessionsByAccountID at\n%s", m.funcRevokeSessionsByAccountIDOrigin)
	}

	if !m.RevokeSessionsByAccountIDMock.invocationsDone() && afterRevokeSessionsByAccountIDCounter > 0 {
		m.t.Errorf("Expected %d calls to SessionUsecaseMock.RevokeSessionsByAccountID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RevokeSessionsByAccountIDMock.expectedInvocations), m.RevokeSessionsByAccountIDMock.expectedInvocationsOrigin, afterRevokeSessionsByAccountIDCounter)
	}
}

type mSessionUsecaseMockUpdate struct {
	optional           bool
	mock               *SessionUsecaseMock
	defaultExpectation *SessionUsecaseMockUpdateExpectation
	expectations       []*SessionUsecaseMockUpdateExpectation

	callArgs []*SessionUsecaseMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SessionUsecaseMockUpdateExpectation specifies expectation struct of the SessionUsecase.Update
type SessionUsecaseMockUpdateExpectation struct {
	mock               *SessionUsecaseMock
	params             *SessionUsecaseMockUpdateParams
	paramPtrs          *SessionUsecaseMockUpdateParamPtrs
	expectationOrigins SessionUsecaseMockUpdateExpectationOrigins
	results            *SessionUsecaseMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// SessionUsecaseMockUpdateParams contains parameters of the SessionUsecase.Update
type SessionUsecaseMockUpdateParams struct {
	ctx  context.Context
	item *entity.Session
}

// SessionUsecaseMockUpdateParamPtrs contains pointers to parameters of the SessionUsecase.Update
type SessionUsecaseMockUpdateParamPtrs struct {
	ctx  *context.Context
	item **entity.Session
}

// SessionUsecaseMockUpdateResults contains results of the SessionUsecase.Update
type SessionUsecaseMockUpdateResults struct {
	err error
}

// SessionUsecaseMockUpdateOrigins contains origins of expectations of the SessionUsecase.Update
type SessionUsecaseMockUpdateExpectationOrigins struct {
	origin     string
	originCtx  string
	originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mSessionUsecaseMockUpdate) Optional() *mSessionUsecaseMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for SessionUsecase.Update
func (mmUpdate *mSessionUsecaseMockUpdate) Expect(ctx context.Context, item *entity.Session) *mSessionUsecaseMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("SessionUsecaseMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &SessionUsecaseMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("SessionUsecaseMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &SessionUsecaseMockUpdateParams{ctx, item}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for SessionUsecase.Update
func (mmUpdate *mSessionUsecaseMockUpdate) ExpectCtxParam1(ctx context.Context) *mSessionUsecaseMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("SessionUsecaseMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &SessionUsecaseMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("SessionUsecaseMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &SessionUsecaseMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectItemParam2 sets up expected param item for SessionUsecase.Update
func (mmUpdate *mSessionUsecaseMockUpdate) ExpectItemParam2(item *entity.Session) *mSessionUsecaseMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("SessionUsecaseMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &SessionUsecaseMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("SessionUsecaseMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &SessionUsecaseMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.item = &item
	mmUpdate.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the SessionUsecase.Update
func (mmUpdate *mSessionUsecaseMockUpdate) Inspect(f func(ctx context.Context, item *entity.Session)) *mSessionUsecaseMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for SessionUsecaseMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by SessionUsecase.Update
func (mmUpdate *mSessionUsecaseMockUpdate) Return(err error) *SessionUsecaseMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("SessionUsecaseMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &SessionUsecaseMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &SessionUsecaseMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the SessionUsecase.Update method
func (mmUpdate *mSessionUsecaseMockUpdate) Set(f func(ctx context.Context, item *entity.Session) (err error)) *SessionUsecaseMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the SessionUsecase.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the SessionUsecase.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the SessionUsecase.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mSessionUsecaseMockUpdate) When(ctx context.Context, item *entity.Session) *SessionUsecaseMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("SessionUsecaseMock.Update mock is already set by Set")
	}

	expectation := &SessionUsecaseMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &SessionUsecaseMockUpdateParams{ctx, item},
		expectationOrigins: SessionUsecaseMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up SessionUsecase.Update return parameters for the expectation previously defined by the When method
func (e *SessionUsecaseMockUpdateExpectation) Then(err error) *SessionUsecaseMock {
	e.results = &SessionUsecaseMockUpdateResults{err}
	return e.mock
}

// Times sets number of times SessionUsecase.Update should be invoked
func (mmUpdate *mSessionUsecaseMockUpdate) Times(n uint64) *mSessionUsecaseMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of SessionUsecaseMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mSessionUsecaseMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_usecase.SessionUsecase
func (mmUpdate *SessionUsecaseMock) Update(ctx context.Context, item *entity.Session) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, item)
	}

	mm_params := SessionUsecaseMockUpdateParams{ctx, item}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := SessionUsecaseMockUpdateParams{ctx, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("SessionUsecaseMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmUpdate.t.Errorf("SessionUsecaseMock.Update got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("SessionUsecaseMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the SessionUsecaseMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, item)
	}
	mmUpdate.t.Fatalf("Unexpected call to SessionUsecaseMock.Update. %v %v", ctx, item)
	return
}

// UpdateAfterCounter returns a count of finished SessionUsecaseMock.Update invocations
func (mmUpdate *SessionUsecaseMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of SessionUsecaseMock.Update invocations
func (mmUpdate *SessionUsecaseMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to SessionUsecaseMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mSessionUsecaseMockUpdate) Calls() []*SessionUsecaseMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*SessionUsecaseMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *SessionUsecaseMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *SessionUsecaseMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SessionUsecaseMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SessionUsecaseMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SessionUsecaseMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to SessionUsecaseMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to SessionUsecaseMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SessionUsecaseMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockFindListInspect()

			m.MinimockFindOneByIDInspect()

			m.MinimockRevokeSessionByIDInspect()

			m.MinimockRevokeSessionsByAccountIDInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SessionUsecaseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SessionUsecaseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockFindListDone() &&
		m.MinimockFindOneByIDDone() &&
		m.MinimockRevokeSessionByIDDone() &&
		m.MinimockRevokeSessionsByAccountIDDone() &&
		m.MinimockUpdateDone()
}
