// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase.AccountUsecase -o account_usecase.go -n AccountUsecaseMock -p mocks

import (
	"context"
	"net"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
	"github.com/m11ano/budget_planner/backend/auth/internal/common/uctypes"
	"github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
	mm_usecase "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
)

// AccountUsecaseMock implements mm_usecase.AccountUsecase
type AccountUsecaseMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateAccountByDTO          func(ctx context.Context, in mm_usecase.CreateAccountDataInput, requestIP *net.IP) (resAccountDTO *mm_usecase.AccountDTO, err error)
	funcCreateAccountByDTOOrigin    string
	inspectFuncCreateAccountByDTO   func(ctx context.Context, in mm_usecase.CreateAccountDataInput, requestIP *net.IP)
	afterCreateAccountByDTOCounter  uint64
	beforeCreateAccountByDTOCounter uint64
	CreateAccountByDTOMock          mAccountUsecaseMockCreateAccountByDTO

	funcFindList          func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.AccountDTO, err error)
	funcFindListOrigin    string
	inspectFuncFindList   func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams)
	afterFindListCounter  uint64
	beforeFindListCounter uint64
	FindListMock          mAccountUsecaseMockFindList

	funcFindListInMap          func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (resItems map[uuid.UUID]*mm_usecase.AccountDTO, err error)
	funcFindListInMapOrigin    string
	inspectFuncFindListInMap   func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams)
	afterFindListInMapCounter  uint64
	beforeFindListInMapCounter uint64
	FindListInMapMock          mAccountUsecaseMockFindListInMap

	funcFindOneByEmail          func(ctx context.Context, email string, queryParams *uctypes.QueryGetOneParams) (resAccount *mm_usecase.AccountDTO, err error)
	funcFindOneByEmailOrigin    string
	inspectFuncFindOneByEmail   func(ctx context.Context, email string, queryParams *uctypes.QueryGetOneParams)
	afterFindOneByEmailCounter  uint64
	beforeFindOneByEmailCounter uint64
	FindOneByEmailMock          mAccountUsecaseMockFindOneByEmail

	funcFindOneByID          func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (resAccount *mm_usecase.AccountDTO, err error)
	funcFindOneByIDOrigin    string
	inspectFuncFindOneByID   func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)
	afterFindOneByIDCounter  uint64
	beforeFindOneByIDCounter uint64
	FindOneByIDMock          mAccountUsecaseMockFindOneByID

	funcFindPagedList          func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.AccountDTO, total uint64, err error)
	funcFindPagedListOrigin    string
	inspectFuncFindPagedList   func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams)
	afterFindPagedListCounter  uint64
	beforeFindPagedListCounter uint64
	FindPagedListMock          mAccountUsecaseMockFindPagedList

	funcPatchAccountByDTO          func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchAccountDataInput, skipVersionCheck bool) (err error)
	funcPatchAccountByDTOOrigin    string
	inspectFuncPatchAccountByDTO   func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchAccountDataInput, skipVersionCheck bool)
	afterPatchAccountByDTOCounter  uint64
	beforePatchAccountByDTOCounter uint64
	PatchAccountByDTOMock          mAccountUsecaseMockPatchAccountByDTO

	funcUpdateAccount          func(ctx context.Context, item *entity.Account) (err error)
	funcUpdateAccountOrigin    string
	inspectFuncUpdateAccount   func(ctx context.Context, item *entity.Account)
	afterUpdateAccountCounter  uint64
	beforeUpdateAccountCounter uint64
	UpdateAccountMock          mAccountUsecaseMockUpdateAccount
}

// NewAccountUsecaseMock returns a mock for mm_usecase.AccountUsecase
func NewAccountUsecaseMock(t minimock.Tester) *AccountUsecaseMock {
	m := &AccountUsecaseMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateAccountByDTOMock = mAccountUsecaseMockCreateAccountByDTO{mock: m}
	m.CreateAccountByDTOMock.callArgs = []*AccountUsecaseMockCreateAccountByDTOParams{}

	m.FindListMock = mAccountUsecaseMockFindList{mock: m}
	m.FindListMock.callArgs = []*AccountUsecaseMockFindListParams{}

	m.FindListInMapMock = mAccountUsecaseMockFindListInMap{mock: m}
	m.FindListInMapMock.callArgs = []*AccountUsecaseMockFindListInMapParams{}

	m.FindOneByEmailMock = mAccountUsecaseMockFindOneByEmail{mock: m}
	m.FindOneByEmailMock.callArgs = []*AccountUsecaseMockFindOneByEmailParams{}

	m.FindOneByIDMock = mAccountUsecaseMockFindOneByID{mock: m}
	m.FindOneByIDMock.callArgs = []*AccountUsecaseMockFindOneByIDParams{}

	m.FindPagedListMock = mAccountUsecaseMockFindPagedList{mock: m}
	m.FindPagedListMock.callArgs = []*AccountUsecaseMockFindPagedListParams{}

	m.PatchAccountByDTOMock = mAccountUsecaseMockPatchAccountByDTO{mock: m}
	m.PatchAccountByDTOMock.callArgs = []*AccountUsecaseMockPatchAccountByDTOParams{}

	m.UpdateAccountMock = mAccountUsecaseMockUpdateAccount{mock: m}
	m.UpdateAccountMock.callArgs = []*AccountUsecaseMockUpdateAccountParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAccountUsecaseMockCreateAccountByDTO struct {
	optional           bool
	mock               *AccountUsecaseMock
	defaultExpectation *AccountUsecaseMockCreateAccountByDTOExpectation
	expectations       []*AccountUsecaseMockCreateAccountByDTOExpectation

	callArgs []*AccountUsecaseMockCreateAccountByDTOParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AccountUsecaseMockCreateAccountByDTOExpectation specifies expectation struct of the AccountUsecase.CreateAccountByDTO
type AccountUsecaseMockCreateAccountByDTOExpectation struct {
	mock               *AccountUsecaseMock
	params             *AccountUsecaseMockCreateAccountByDTOParams
	paramPtrs          *AccountUsecaseMockCreateAccountByDTOParamPtrs
	expectationOrigins AccountUsecaseMockCreateAccountByDTOExpectationOrigins
	results            *AccountUsecaseMockCreateAccountByDTOResults
	returnOrigin       string
	Counter            uint64
}

// AccountUsecaseMockCreateAccountByDTOParams contains parameters of the AccountUsecase.CreateAccountByDTO
type AccountUsecaseMockCreateAccountByDTOParams struct {
	ctx       context.Context
	in        mm_usecase.CreateAccountDataInput
	requestIP *net.IP
}

// AccountUsecaseMockCreateAccountByDTOParamPtrs contains pointers to parameters of the AccountUsecase.CreateAccountByDTO
type AccountUsecaseMockCreateAccountByDTOParamPtrs struct {
	ctx       *context.Context
	in        *mm_usecase.CreateAccountDataInput
	requestIP **net.IP
}

// AccountUsecaseMockCreateAccountByDTOResults contains results of the AccountUsecase.CreateAccountByDTO
type AccountUsecaseMockCreateAccountByDTOResults struct {
	resAccountDTO *mm_usecase.AccountDTO
	err           error
}

// AccountUsecaseMockCreateAccountByDTOOrigins contains origins of expectations of the AccountUsecase.CreateAccountByDTO
type AccountUsecaseMockCreateAccountByDTOExpectationOrigins struct {
	origin          string
	originCtx       string
	originIn        string
	originRequestIP string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) Optional() *mAccountUsecaseMockCreateAccountByDTO {
	mmCreateAccountByDTO.optional = true
	return mmCreateAccountByDTO
}

// Expect sets up expected params for AccountUsecase.CreateAccountByDTO
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) Expect(ctx context.Context, in mm_usecase.CreateAccountDataInput, requestIP *net.IP) *mAccountUsecaseMockCreateAccountByDTO {
	if mmCreateAccountByDTO.mock.funcCreateAccountByDTO != nil {
		mmCreateAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.CreateAccountByDTO mock is already set by Set")
	}

	if mmCreateAccountByDTO.defaultExpectation == nil {
		mmCreateAccountByDTO.defaultExpectation = &AccountUsecaseMockCreateAccountByDTOExpectation{}
	}

	if mmCreateAccountByDTO.defaultExpectation.paramPtrs != nil {
		mmCreateAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.CreateAccountByDTO mock is already set by ExpectParams functions")
	}

	mmCreateAccountByDTO.defaultExpectation.params = &AccountUsecaseMockCreateAccountByDTOParams{ctx, in, requestIP}
	mmCreateAccountByDTO.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateAccountByDTO.expectations {
		if minimock.Equal(e.params, mmCreateAccountByDTO.defaultExpectation.params) {
			mmCreateAccountByDTO.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateAccountByDTO.defaultExpectation.params)
		}
	}

	return mmCreateAccountByDTO
}

// ExpectCtxParam1 sets up expected param ctx for AccountUsecase.CreateAccountByDTO
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) ExpectCtxParam1(ctx context.Context) *mAccountUsecaseMockCreateAccountByDTO {
	if mmCreateAccountByDTO.mock.funcCreateAccountByDTO != nil {
		mmCreateAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.CreateAccountByDTO mock is already set by Set")
	}

	if mmCreateAccountByDTO.defaultExpectation == nil {
		mmCreateAccountByDTO.defaultExpectation = &AccountUsecaseMockCreateAccountByDTOExpectation{}
	}

	if mmCreateAccountByDTO.defaultExpectation.params != nil {
		mmCreateAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.CreateAccountByDTO mock is already set by Expect")
	}

	if mmCreateAccountByDTO.defaultExpectation.paramPtrs == nil {
		mmCreateAccountByDTO.defaultExpectation.paramPtrs = &AccountUsecaseMockCreateAccountByDTOParamPtrs{}
	}
	mmCreateAccountByDTO.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateAccountByDTO.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateAccountByDTO
}

// ExpectInParam2 sets up expected param in for AccountUsecase.CreateAccountByDTO
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) ExpectInParam2(in mm_usecase.CreateAccountDataInput) *mAccountUsecaseMockCreateAccountByDTO {
	if mmCreateAccountByDTO.mock.funcCreateAccountByDTO != nil {
		mmCreateAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.CreateAccountByDTO mock is already set by Set")
	}

	if mmCreateAccountByDTO.defaultExpectation == nil {
		mmCreateAccountByDTO.defaultExpectation = &AccountUsecaseMockCreateAccountByDTOExpectation{}
	}

	if mmCreateAccountByDTO.defaultExpectation.params != nil {
		mmCreateAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.CreateAccountByDTO mock is already set by Expect")
	}

	if mmCreateAccountByDTO.defaultExpectation.paramPtrs == nil {
		mmCreateAccountByDTO.defaultExpectation.paramPtrs = &AccountUsecaseMockCreateAccountByDTOParamPtrs{}
	}
	mmCreateAccountByDTO.defaultExpectation.paramPtrs.in = &in
	mmCreateAccountByDTO.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmCreateAccountByDTO
}

// ExpectRequestIPParam3 sets up expected param requestIP for AccountUsecase.CreateAccountByDTO
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) ExpectRequestIPParam3(requestIP *net.IP) *mAccountUsecaseMockCreateAccountByDTO {
	if mmCreateAccountByDTO.mock.funcCreateAccountByDTO != nil {
		mmCreateAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.CreateAccountByDTO mock is already set by Set")
	}

	if mmCreateAccountByDTO.defaultExpectation == nil {
		mmCreateAccountByDTO.defaultExpectation = &AccountUsecaseMockCreateAccountByDTOExpectation{}
	}

	if mmCreateAccountByDTO.defaultExpectation.params != nil {
		mmCreateAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.CreateAccountByDTO mock is already set by Expect")
	}

	if mmCreateAccountByDTO.defaultExpectation.paramPtrs == nil {
		mmCreateAccountByDTO.defaultExpectation.paramPtrs = &AccountUsecaseMockCreateAccountByDTOParamPtrs{}
	}
	mmCreateAccountByDTO.defaultExpectation.paramPtrs.requestIP = &requestIP
	mmCreateAccountByDTO.defaultExpectation.expectationOrigins.originRequestIP = minimock.CallerInfo(1)

	return mmCreateAccountByDTO
}

// Inspect accepts an inspector function that has same arguments as the AccountUsecase.CreateAccountByDTO
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) Inspect(f func(ctx context.Context, in mm_usecase.CreateAccountDataInput, requestIP *net.IP)) *mAccountUsecaseMockCreateAccountByDTO {
	if mmCreateAccountByDTO.mock.inspectFuncCreateAccountByDTO != nil {
		mmCreateAccountByDTO.mock.t.Fatalf("Inspect function is already set for AccountUsecaseMock.CreateAccountByDTO")
	}

	mmCreateAccountByDTO.mock.inspectFuncCreateAccountByDTO = f

	return mmCreateAccountByDTO
}

// Return sets up results that will be returned by AccountUsecase.CreateAccountByDTO
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) Return(resAccountDTO *mm_usecase.AccountDTO, err error) *AccountUsecaseMock {
	if mmCreateAccountByDTO.mock.funcCreateAccountByDTO != nil {
		mmCreateAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.CreateAccountByDTO mock is already set by Set")
	}

	if mmCreateAccountByDTO.defaultExpectation == nil {
		mmCreateAccountByDTO.defaultExpectation = &AccountUsecaseMockCreateAccountByDTOExpectation{mock: mmCreateAccountByDTO.mock}
	}
	mmCreateAccountByDTO.defaultExpectation.results = &AccountUsecaseMockCreateAccountByDTOResults{resAccountDTO, err}
	mmCreateAccountByDTO.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateAccountByDTO.mock
}

// Set uses given function f to mock the AccountUsecase.CreateAccountByDTO method
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) Set(f func(ctx context.Context, in mm_usecase.CreateAccountDataInput, requestIP *net.IP) (resAccountDTO *mm_usecase.AccountDTO, err error)) *AccountUsecaseMock {
	if mmCreateAccountByDTO.defaultExpectation != nil {
		mmCreateAccountByDTO.mock.t.Fatalf("Default expectation is already set for the AccountUsecase.CreateAccountByDTO method")
	}

	if len(mmCreateAccountByDTO.expectations) > 0 {
		mmCreateAccountByDTO.mock.t.Fatalf("Some expectations are already set for the AccountUsecase.CreateAccountByDTO method")
	}

	mmCreateAccountByDTO.mock.funcCreateAccountByDTO = f
	mmCreateAccountByDTO.mock.funcCreateAccountByDTOOrigin = minimock.CallerInfo(1)
	return mmCreateAccountByDTO.mock
}

// When sets expectation for the AccountUsecase.CreateAccountByDTO which will trigger the result defined by the following
// Then helper
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) When(ctx context.Context, in mm_usecase.CreateAccountDataInput, requestIP *net.IP) *AccountUsecaseMockCreateAccountByDTOExpectation {
	if mmCreateAccountByDTO.mock.funcCreateAccountByDTO != nil {
		mmCreateAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.CreateAccountByDTO mock is already set by Set")
	}

	expectation := &AccountUsecaseMockCreateAccountByDTOExpectation{
		mock:               mmCreateAccountByDTO.mock,
		params:             &AccountUsecaseMockCreateAccountByDTOParams{ctx, in, requestIP},
		expectationOrigins: AccountUsecaseMockCreateAccountByDTOExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateAccountByDTO.expectations = append(mmCreateAccountByDTO.expectations, expectation)
	return expectation
}

// Then sets up AccountUsecase.CreateAccountByDTO return parameters for the expectation previously defined by the When method
func (e *AccountUsecaseMockCreateAccountByDTOExpectation) Then(resAccountDTO *mm_usecase.AccountDTO, err error) *AccountUsecaseMock {
	e.results = &AccountUsecaseMockCreateAccountByDTOResults{resAccountDTO, err}
	return e.mock
}

// Times sets number of times AccountUsecase.CreateAccountByDTO should be invoked
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) Times(n uint64) *mAccountUsecaseMockCreateAccountByDTO {
	if n == 0 {
		mmCreateAccountByDTO.mock.t.Fatalf("Times of AccountUsecaseMock.CreateAccountByDTO mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateAccountByDTO.expectedInvocations, n)
	mmCreateAccountByDTO.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateAccountByDTO
}

func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) invocationsDone() bool {
	if len(mmCreateAccountByDTO.expectations) == 0 && mmCreateAccountByDTO.defaultExpectation == nil && mmCreateAccountByDTO.mock.funcCreateAccountByDTO == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateAccountByDTO.mock.afterCreateAccountByDTOCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateAccountByDTO.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateAccountByDTO implements mm_usecase.AccountUsecase
func (mmCreateAccountByDTO *AccountUsecaseMock) CreateAccountByDTO(ctx context.Context, in mm_usecase.CreateAccountDataInput, requestIP *net.IP) (resAccountDTO *mm_usecase.AccountDTO, err error) {
	mm_atomic.AddUint64(&mmCreateAccountByDTO.beforeCreateAccountByDTOCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateAccountByDTO.afterCreateAccountByDTOCounter, 1)

	mmCreateAccountByDTO.t.Helper()

	if mmCreateAccountByDTO.inspectFuncCreateAccountByDTO != nil {
		mmCreateAccountByDTO.inspectFuncCreateAccountByDTO(ctx, in, requestIP)
	}

	mm_params := AccountUsecaseMockCreateAccountByDTOParams{ctx, in, requestIP}

	// Record call args
	mmCreateAccountByDTO.CreateAccountByDTOMock.mutex.Lock()
	mmCreateAccountByDTO.CreateAccountByDTOMock.callArgs = append(mmCreateAccountByDTO.CreateAccountByDTOMock.callArgs, &mm_params)
	mmCreateAccountByDTO.CreateAccountByDTOMock.mutex.Unlock()

	for _, e := range mmCreateAccountByDTO.CreateAccountByDTOMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resAccountDTO, e.results.err
		}
	}

	if mmCreateAccountByDTO.CreateAccountByDTOMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateAccountByDTO.CreateAccountByDTOMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateAccountByDTO.CreateAccountByDTOMock.defaultExpectation.params
		mm_want_ptrs := mmCreateAccountByDTO.CreateAccountByDTOMock.defaultExpectation.paramPtrs

		mm_got := AccountUsecaseMockCreateAccountByDTOParams{ctx, in, requestIP}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateAccountByDTO.t.Errorf("AccountUsecaseMock.CreateAccountByDTO got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateAccountByDTO.CreateAccountByDTOMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmCreateAccountByDTO.t.Errorf("AccountUsecaseMock.CreateAccountByDTO got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateAccountByDTO.CreateAccountByDTOMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.requestIP != nil && !minimock.Equal(*mm_want_ptrs.requestIP, mm_got.requestIP) {
				mmCreateAccountByDTO.t.Errorf("AccountUsecaseMock.CreateAccountByDTO got unexpected parameter requestIP, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateAccountByDTO.CreateAccountByDTOMock.defaultExpectation.expectationOrigins.originRequestIP, *mm_want_ptrs.requestIP, mm_got.requestIP, minimock.Diff(*mm_want_ptrs.requestIP, mm_got.requestIP))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateAccountByDTO.t.Errorf("AccountUsecaseMock.CreateAccountByDTO got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateAccountByDTO.CreateAccountByDTOMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateAccountByDTO.CreateAccountByDTOMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateAccountByDTO.t.Fatal("No results are set for the AccountUsecaseMock.CreateAccountByDTO")
		}
		return (*mm_results).resAccountDTO, (*mm_results).err
	}
	if mmCreateAccountByDTO.funcCreateAccountByDTO != nil {
		return mmCreateAccountByDTO.funcCreateAccountByDTO(ctx, in, requestIP)
	}
	mmCreateAccountByDTO.t.Fatalf("Unexpected call to AccountUsecaseMock.CreateAccountByDTO. %v %v %v", ctx, in, requestIP)
	return
}

// CreateAccountByDTOAfterCounter returns a count of finished AccountUsecaseMock.CreateAccountByDTO invocations
func (mmCreateAccountByDTO *AccountUsecaseMock) CreateAccountByDTOAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAccountByDTO.afterCreateAccountByDTOCounter)
}

// CreateAccountByDTOBeforeCounter returns a count of AccountUsecaseMock.CreateAccountByDTO invocations
func (mmCreateAccountByDTO *AccountUsecaseMock) CreateAccountByDTOBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAccountByDTO.beforeCreateAccountByDTOCounter)
}

// Calls returns a list of arguments used in each call to AccountUsecaseMock.CreateAccountByDTO.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateAccountByDTO *mAccountUsecaseMockCreateAccountByDTO) Calls() []*AccountUsecaseMockCreateAccountByDTOParams {
	mmCreateAccountByDTO.mutex.RLock()

	argCopy := make([]*AccountUsecaseMockCreateAccountByDTOParams, len(mmCreateAccountByDTO.callArgs))
	copy(argCopy, mmCreateAccountByDTO.callArgs)

	mmCreateAccountByDTO.mutex.RUnlock()

	return argCopy
}

// MinimockCreateAccountByDTODone returns true if the count of the CreateAccountByDTO invocations corresponds
// the number of defined expectations
func (m *AccountUsecaseMock) MinimockCreateAccountByDTODone() bool {
	if m.CreateAccountByDTOMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateAccountByDTOMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateAccountByDTOMock.invocationsDone()
}

// MinimockCreateAccountByDTOInspect logs each unmet expectation
func (m *AccountUsecaseMock) MinimockCreateAccountByDTOInspect() {
	for _, e := range m.CreateAccountByDTOMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccountUsecaseMock.CreateAccountByDTO at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateAccountByDTOCounter := mm_atomic.LoadUint64(&m.afterCreateAccountByDTOCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateAccountByDTOMock.defaultExpectation != nil && afterCreateAccountByDTOCounter < 1 {
		if m.CreateAccountByDTOMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AccountUsecaseMock.CreateAccountByDTO at\n%s", m.CreateAccountByDTOMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AccountUsecaseMock.CreateAccountByDTO at\n%s with params: %#v", m.CreateAccountByDTOMock.defaultExpectation.expectationOrigins.origin, *m.CreateAccountByDTOMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateAccountByDTO != nil && afterCreateAccountByDTOCounter < 1 {
		m.t.Errorf("Expected call to AccountUsecaseMock.CreateAccountByDTO at\n%s", m.funcCreateAccountByDTOOrigin)
	}

	if !m.CreateAccountByDTOMock.invocationsDone() && afterCreateAccountByDTOCounter > 0 {
		m.t.Errorf("Expected %d calls to AccountUsecaseMock.CreateAccountByDTO at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateAccountByDTOMock.expectedInvocations), m.CreateAccountByDTOMock.expectedInvocationsOrigin, afterCreateAccountByDTOCounter)
	}
}

type mAccountUsecaseMockFindList struct {
	optional           bool
	mock               *AccountUsecaseMock
	defaultExpectation *AccountUsecaseMockFindListExpectation
	expectations       []*AccountUsecaseMockFindListExpectation

	callArgs []*AccountUsecaseMockFindListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AccountUsecaseMockFindListExpectation specifies expectation struct of the AccountUsecase.FindList
type AccountUsecaseMockFindListExpectation struct {
	mock               *AccountUsecaseMock
	params             *AccountUsecaseMockFindListParams
	paramPtrs          *AccountUsecaseMockFindListParamPtrs
	expectationOrigins AccountUsecaseMockFindListExpectationOrigins
	results            *AccountUsecaseMockFindListResults
	returnOrigin       string
	Counter            uint64
}

// AccountUsecaseMockFindListParams contains parameters of the AccountUsecase.FindList
type AccountUsecaseMockFindListParams struct {
	ctx         context.Context
	listOptions *mm_usecase.AccountListOptions
	queryParams *uctypes.QueryGetListParams
}

// AccountUsecaseMockFindListParamPtrs contains pointers to parameters of the AccountUsecase.FindList
type AccountUsecaseMockFindListParamPtrs struct {
	ctx         *context.Context
	listOptions **mm_usecase.AccountListOptions
	queryParams **uctypes.QueryGetListParams
}

// AccountUsecaseMockFindListResults contains results of the AccountUsecase.FindList
type AccountUsecaseMockFindListResults struct {
	resItems []*mm_usecase.AccountDTO
	err      error
}

// AccountUsecaseMockFindListOrigins contains origins of expectations of the AccountUsecase.FindList
type AccountUsecaseMockFindListExpectationOrigins struct {
	origin            string
	originCtx         string
	originListOptions string
	originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindList *mAccountUsecaseMockFindList) Optional() *mAccountUsecaseMockFindList {
	mmFindList.optional = true
	return mmFindList
}

// Expect sets up expected params for AccountUsecase.FindList
func (mmFindList *mAccountUsecaseMockFindList) Expect(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) *mAccountUsecaseMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("AccountUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &AccountUsecaseMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.paramPtrs != nil {
		mmFindList.mock.t.Fatalf("AccountUsecaseMock.FindList mock is already set by ExpectParams functions")
	}

	mmFindList.defaultExpectation.params = &AccountUsecaseMockFindListParams{ctx, listOptions, queryParams}
	mmFindList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindList.expectations {
		if minimock.Equal(e.params, mmFindList.defaultExpectation.params) {
			mmFindList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindList.defaultExpectation.params)
		}
	}

	return mmFindList
}

// ExpectCtxParam1 sets up expected param ctx for AccountUsecase.FindList
func (mmFindList *mAccountUsecaseMockFindList) ExpectCtxParam1(ctx context.Context) *mAccountUsecaseMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("AccountUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &AccountUsecaseMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.params != nil {
		mmFindList.mock.t.Fatalf("AccountUsecaseMock.FindList mock is already set by Expect")
	}

	if mmFindList.defaultExpectation.paramPtrs == nil {
		mmFindList.defaultExpectation.paramPtrs = &AccountUsecaseMockFindListParamPtrs{}
	}
	mmFindList.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindList
}

// ExpectListOptionsParam2 sets up expected param listOptions for AccountUsecase.FindList
func (mmFindList *mAccountUsecaseMockFindList) ExpectListOptionsParam2(listOptions *mm_usecase.AccountListOptions) *mAccountUsecaseMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("AccountUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &AccountUsecaseMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.params != nil {
		mmFindList.mock.t.Fatalf("AccountUsecaseMock.FindList mock is already set by Expect")
	}

	if mmFindList.defaultExpectation.paramPtrs == nil {
		mmFindList.defaultExpectation.paramPtrs = &AccountUsecaseMockFindListParamPtrs{}
	}
	mmFindList.defaultExpectation.paramPtrs.listOptions = &listOptions
	mmFindList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

	return mmFindList
}

// ExpectQueryParamsParam3 sets up expected param queryParams for AccountUsecase.FindList
func (mmFindList *mAccountUsecaseMockFindList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mAccountUsecaseMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("AccountUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &AccountUsecaseMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.params != nil {
		mmFindList.mock.t.Fatalf("AccountUsecaseMock.FindList mock is already set by Expect")
	}

	if mmFindList.defaultExpectation.paramPtrs == nil {
		mmFindList.defaultExpectation.paramPtrs = &AccountUsecaseMockFindListParamPtrs{}
	}
	mmFindList.defaultExpectation.paramPtrs.queryParams = &queryParams
	mmFindList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

	return mmFindList
}

// Inspect accepts an inspector function that has same arguments as the AccountUsecase.FindList
func (mmFindList *mAccountUsecaseMockFindList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams)) *mAccountUsecaseMockFindList {
	if mmFindList.mock.inspectFuncFindList != nil {
		mmFindList.mock.t.Fatalf("Inspect function is already set for AccountUsecaseMock.FindList")
	}

	mmFindList.mock.inspectFuncFindList = f

	return mmFindList
}

// Return sets up results that will be returned by AccountUsecase.FindList
func (mmFindList *mAccountUsecaseMockFindList) Return(resItems []*mm_usecase.AccountDTO, err error) *AccountUsecaseMock {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("AccountUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &AccountUsecaseMockFindListExpectation{mock: mmFindList.mock}
	}
	mmFindList.defaultExpectation.results = &AccountUsecaseMockFindListResults{resItems, err}
	mmFindList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindList.mock
}

// Set uses given function f to mock the AccountUsecase.FindList method
func (mmFindList *mAccountUsecaseMockFindList) Set(f func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.AccountDTO, err error)) *AccountUsecaseMock {
	if mmFindList.defaultExpectation != nil {
		mmFindList.mock.t.Fatalf("Default expectation is already set for the AccountUsecase.FindList method")
	}

	if len(mmFindList.expectations) > 0 {
		mmFindList.mock.t.Fatalf("Some expectations are already set for the AccountUsecase.FindList method")
	}

	mmFindList.mock.funcFindList = f
	mmFindList.mock.funcFindListOrigin = minimock.CallerInfo(1)
	return mmFindList.mock
}

// When sets expectation for the AccountUsecase.FindList which will trigger the result defined by the following
// Then helper
func (mmFindList *mAccountUsecaseMockFindList) When(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) *AccountUsecaseMockFindListExpectation {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("AccountUsecaseMock.FindList mock is already set by Set")
	}

	expectation := &AccountUsecaseMockFindListExpectation{
		mock:               mmFindList.mock,
		params:             &AccountUsecaseMockFindListParams{ctx, listOptions, queryParams},
		expectationOrigins: AccountUsecaseMockFindListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindList.expectations = append(mmFindList.expectations, expectation)
	return expectation
}

// Then sets up AccountUsecase.FindList return parameters for the expectation previously defined by the When method
func (e *AccountUsecaseMockFindListExpectation) Then(resItems []*mm_usecase.AccountDTO, err error) *AccountUsecaseMock {
	e.results = &AccountUsecaseMockFindListResults{resItems, err}
	return e.mock
}

// Times sets number of times AccountUsecase.FindList should be invoked
func (mmFindList *mAccountUsecaseMockFindList) Times(n uint64) *mAccountUsecaseMockFindList {
	if n == 0 {
		mmFindList.mock.t.Fatalf("Times of AccountUsecaseMock.FindList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindList.expectedInvocations, n)
	mmFindList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindList
}

func (mmFindList *mAccountUsecaseMockFindList) invocationsDone() bool {
	if len(mmFindList.expectations) == 0 && mmFindList.defaultExpectation == nil && mmFindList.mock.funcFindList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindList.mock.afterFindListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindList implements mm_usecase.AccountUsecase
func (mmFindList *AccountUsecaseMock) FindList(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.AccountDTO, err error) {
	mm_atomic.AddUint64(&mmFindList.beforeFindListCounter, 1)
	defer mm_atomic.AddUint64(&mmFindList.afterFindListCounter, 1)

	mmFindList.t.Helper()

	if mmFindList.inspectFuncFindList != nil {
		mmFindList.inspectFuncFindList(ctx, listOptions, queryParams)
	}

	mm_params := AccountUsecaseMockFindListParams{ctx, listOptions, queryParams}

	// Record call args
	mmFindList.FindListMock.mutex.Lock()
	mmFindList.FindListMock.callArgs = append(mmFindList.FindListMock.callArgs, &mm_params)
	mmFindList.FindListMock.mutex.Unlock()

	for _, e := range mmFindList.FindListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resItems, e.results.err
		}
	}

	if mmFindList.FindListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindList.FindListMock.defaultExpectation.Counter, 1)
		mm_want := mmFindList.FindListMock.defaultExpectation.params
		mm_want_ptrs := mmFindList.FindListMock.defaultExpectation.paramPtrs

		mm_got := AccountUsecaseMockFindListParams{ctx, listOptions, queryParams}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindList.t.Errorf("AccountUsecaseMock.FindList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindList.FindListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.listOptions != nil && !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) {
				mmFindList.t.Errorf("AccountUsecaseMock.FindList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindList.FindListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
			}

			if mm_want_ptrs.queryParams != nil && !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) {
				mmFindList.t.Errorf("AccountUsecaseMock.FindList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindList.FindListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindList.t.Errorf("AccountUsecaseMock.FindList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindList.FindListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindList.FindListMock.defaultExpectation.results
		if mm_results == nil {
			mmFindList.t.Fatal("No results are set for the AccountUsecaseMock.FindList")
		}
		return (*mm_results).resItems, (*mm_results).err
	}
	if mmFindList.funcFindList != nil {
		return mmFindList.funcFindList(ctx, listOptions, queryParams)
	}
	mmFindList.t.Fatalf("Unexpected call to AccountUsecaseMock.FindList. %v %v %v", ctx, listOptions, queryParams)
	return
}

// FindListAfterCounter returns a count of finished AccountUsecaseMock.FindList invocations
func (mmFindList *AccountUsecaseMock) FindListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindList.afterFindListCounter)
}

// FindListBeforeCounter returns a count of AccountUsecaseMock.FindList invocations
func (mmFindList *AccountUsecaseMock) FindListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindList.beforeFindListCounter)
}

// Calls returns a list of arguments used in each call to AccountUsecaseMock.FindList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindList *mAccountUsecaseMockFindList) Calls() []*AccountUsecaseMockFindListParams {
	mmFindList.mutex.RLock()

	argCopy := make([]*AccountUsecaseMockFindListParams, len(mmFindList.callArgs))
	copy(argCopy, mmFindList.callArgs)

	mmFindList.mutex.RUnlock()

	return argCopy
}

// MinimockFindListDone returns true if the count of the FindList invocations corresponds
// the number of defined expectations
func (m *AccountUsecaseMock) MinimockFindListDone() bool {
	if m.FindListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindListMock.invocationsDone()
}

// MinimockFindListInspect logs each unmet expectation
func (m *AccountUsecaseMock) MinimockFindListInspect() {
	for _, e := range m.FindListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccountUsecaseMock.FindList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindListCounter := mm_atomic.LoadUint64(&m.afterFindListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindListMock.defaultExpectation != nil && afterFindListCounter < 1 {
		if m.FindListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AccountUsecaseMock.FindList at\n%s", m.FindListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AccountUsecaseMock.FindList at\n%s with params: %#v", m.FindListMock.defaultExpectation.expectationOrigins.origin, *m.FindListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindList != nil && afterFindListCounter < 1 {
		m.t.Errorf("Expected call to AccountUsecaseMock.FindList at\n%s", m.funcFindListOrigin)
	}

	if !m.FindListMock.invocationsDone() && afterFindListCounter > 0 {
		m.t.Errorf("Expected %d calls to AccountUsecaseMock.FindList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindListMock.expectedInvocations), m.FindListMock.expectedInvocationsOrigin, afterFindListCounter)
	}
}

type mAccountUsecaseMockFindListInMap struct {
	optional           bool
	mock               *AccountUsecaseMock
	defaultExpectation *AccountUsecaseMockFindListInMapExpectation
	expectations       []*AccountUsecaseMockFindListInMapExpectation

	callArgs []*AccountUsecaseMockFindListInMapParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AccountUsecaseMockFindListInMapExpectation specifies expectation struct of the AccountUsecase.FindListInMap
type AccountUsecaseMockFindListInMapExpectation struct {
	mock               *AccountUsecaseMock
	params             *AccountUsecaseMockFindListInMapParams
	paramPtrs          *AccountUsecaseMockFindListInMapParamPtrs
	expectationOrigins AccountUsecaseMockFindListInMapExpectationOrigins
	results            *AccountUsecaseMockFindListInMapResults
	returnOrigin       string
	Counter            uint64
}

// AccountUsecaseMockFindListInMapParams contains parameters of the AccountUsecase.FindListInMap
type AccountUsecaseMockFindListInMapParams struct {
	ctx         context.Context
	listOptions *mm_usecase.AccountListOptions
	queryParams *uctypes.QueryGetListParams
}

// AccountUsecaseMockFindListInMapParamPtrs contains pointers to parameters of the AccountUsecase.FindListInMap
type AccountUsecaseMockFindListInMapParamPtrs struct {
	ctx         *context.Context
	listOptions **mm_usecase.AccountListOptions
	queryParams **uctypes.QueryGetListParams
}

// AccountUsecaseMockFindListInMapResults contains results of the AccountUsecase.FindListInMap
type AccountUsecaseMockFindListInMapResults struct {
	resItems map[uuid.UUID]*mm_usecase.AccountDTO
	err      error
}

// AccountUsecaseMockFindListInMapOrigins contains origins of expectations of the AccountUsecase.FindListInMap
type AccountUsecaseMockFindListInMapExpectationOrigins struct {
	origin            string
	originCtx         string
	originListOptions string
	originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) Optional() *mAccountUsecaseMockFindListInMap {
	mmFindListInMap.optional = true
	return mmFindListInMap
}

// Expect sets up expected params for AccountUsecase.FindListInMap
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) Expect(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) *mAccountUsecaseMockFindListInMap {
	if mmFindListInMap.mock.funcFindListInMap != nil {
		mmFindListInMap.mock.t.Fatalf("AccountUsecaseMock.FindListInMap mock is already set by Set")
	}

	if mmFindListInMap.defaultExpectation == nil {
		mmFindListInMap.defaultExpectation = &AccountUsecaseMockFindListInMapExpectation{}
	}

	if mmFindListInMap.defaultExpectation.paramPtrs != nil {
		mmFindListInMap.mock.t.Fatalf("AccountUsecaseMock.FindListInMap mock is already set by ExpectParams functions")
	}

	mmFindListInMap.defaultExpectation.params = &AccountUsecaseMockFindListInMapParams{ctx, listOptions, queryParams}
	mmFindListInMap.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindListInMap.expectations {
		if minimock.Equal(e.params, mmFindListInMap.defaultExpectation.params) {
			mmFindListInMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindListInMap.defaultExpectation.params)
		}
	}

	return mmFindListInMap
}

// ExpectCtxParam1 sets up expected param ctx for AccountUsecase.FindListInMap
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) ExpectCtxParam1(ctx context.Context) *mAccountUsecaseMockFindListInMap {
	if mmFindListInMap.mock.funcFindListInMap != nil {
		mmFindListInMap.mock.t.Fatalf("AccountUsecaseMock.FindListInMap mock is already set by Set")
	}

	if mmFindListInMap.defaultExpectation == nil {
		mmFindListInMap.defaultExpectation = &AccountUsecaseMockFindListInMapExpectation{}
	}

	if mmFindListInMap.defaultExpectation.params != nil {
		mmFindListInMap.mock.t.Fatalf("AccountUsecaseMock.FindListInMap mock is already set by Expect")
	}

	if mmFindListInMap.defaultExpectation.paramPtrs == nil {
		mmFindListInMap.defaultExpectation.paramPtrs = &AccountUsecaseMockFindListInMapParamPtrs{}
	}
	mmFindListInMap.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindListInMap.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindListInMap
}

// ExpectListOptionsParam2 sets up expected param listOptions for AccountUsecase.FindListInMap
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) ExpectListOptionsParam2(listOptions *mm_usecase.AccountListOptions) *mAccountUsecaseMockFindListInMap {
	if mmFindListInMap.mock.funcFindListInMap != nil {
		mmFindListInMap.mock.t.Fatalf("AccountUsecaseMock.FindListInMap mock is already set by Set")
	}

	if mmFindListInMap.defaultExpectation == nil {
		mmFindListInMap.defaultExpectation = &AccountUsecaseMockFindListInMapExpectation{}
	}

	if mmFindListInMap.defaultExpectation.params != nil {
		mmFindListInMap.mock.t.Fatalf("AccountUsecaseMock.FindListInMap mock is already set by Expect")
	}

	if mmFindListInMap.defaultExpectation.paramPtrs == nil {
		mmFindListInMap.defaultExpectation.paramPtrs = &AccountUsecaseMockFindListInMapParamPtrs{}
	}
	mmFindListInMap.defaultExpectation.paramPtrs.listOptions = &listOptions
	mmFindListInMap.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

	return mmFindListInMap
}

// ExpectQueryParamsParam3 sets up expected param queryParams for AccountUsecase.FindListInMap
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mAccountUsecaseMockFindListInMap {
	if mmFindListInMap.mock.funcFindListInMap != nil {
		mmFindListInMap.mock.t.Fatalf("AccountUsecaseMock.FindListInMap mock is already set by Set")
	}

	if mmFindListInMap.defaultExpectation == nil {
		mmFindListInMap.defaultExpectation = &AccountUsecaseMockFindListInMapExpectation{}
	}

	if mmFindListInMap.defaultExpectation.params != nil {
		mmFindListInMap.mock.t.Fatalf("AccountUsecaseMock.FindListInMap mock is already set by Expect")
	}

	if mmFindListInMap.defaultExpectation.paramPtrs == nil {
		mmFindListInMap.defaultExpectation.paramPtrs = &AccountUsecaseMockFindListInMapParamPtrs{}
	}
	mmFindListInMap.defaultExpectation.paramPtrs.queryParams = &queryParams
	mmFindListInMap.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

	return mmFindListInMap
}

// Inspect accepts an inspector function that has same arguments as the AccountUsecase.FindListInMap
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) Inspect(f func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams)) *mAccountUsecaseMockFindListInMap {
	if mmFindListInMap.mock.inspectFuncFindListInMap != nil {
		mmFindListInMap.mock.t.Fatalf("Inspect function is already set for AccountUsecaseMock.FindListInMap")
	}

	mmFindListInMap.mock.inspectFuncFindListInMap = f

	return mmFindListInMap
}

// Return sets up results that will be returned by AccountUsecase.FindListInMap
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) Return(resItems map[uuid.UUID]*mm_usecase.AccountDTO, err error) *AccountUsecaseMock {
	if mmFindListInMap.mock.funcFindListInMap != nil {
		mmFindListInMap.mock.t.Fatalf("AccountUsecaseMock.FindListInMap mock is already set by Set")
	}

	if mmFindListInMap.defaultExpectation == nil {
		mmFindListInMap.defaultExpectation = &AccountUsecaseMockFindListInMapExpectation{mock: mmFindListInMap.mock}
	}
	mmFindListInMap.defaultExpectation.results = &AccountUsecaseMockFindListInMapResults{resItems, err}
	mmFindListInMap.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindListInMap.mock
}

// Set uses given function f to mock the AccountUsecase.FindListInMap method
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) Set(f func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (resItems map[uuid.UUID]*mm_usecase.AccountDTO, err error)) *AccountUsecaseMock {
	if mmFindListInMap.defaultExpectation != nil {
		mmFindListInMap.mock.t.Fatalf("Default expectation is already set for the AccountUsecase.FindListInMap method")
	}

	if len(mmFindListInMap.expectations) > 0 {
		mmFindListInMap.mock.t.Fatalf("Some expectations are already set for the AccountUsecase.FindListInMap method")
	}

	mmFindListInMap.mock.funcFindListInMap = f
	mmFindListInMap.mock.funcFindListInMapOrigin = minimock.CallerInfo(1)
	return mmFindListInMap.mock
}

// When sets expectation for the AccountUsecase.FindListInMap which will trigger the result defined by the following
// Then helper
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) When(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) *AccountUsecaseMockFindListInMapExpectation {
	if mmFindListInMap.mock.funcFindListInMap != nil {
		mmFindListInMap.mock.t.Fatalf("AccountUsecaseMock.FindListInMap mock is already set by Set")
	}

	expectation := &AccountUsecaseMockFindListInMapExpectation{
		mock:               mmFindListInMap.mock,
		params:             &AccountUsecaseMockFindListInMapParams{ctx, listOptions, queryParams},
		expectationOrigins: AccountUsecaseMockFindListInMapExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindListInMap.expectations = append(mmFindListInMap.expectations, expectation)
	return expectation
}

// Then sets up AccountUsecase.FindListInMap return parameters for the expectation previously defined by the When method
func (e *AccountUsecaseMockFindListInMapExpectation) Then(resItems map[uuid.UUID]*mm_usecase.AccountDTO, err error) *AccountUsecaseMock {
	e.results = &AccountUsecaseMockFindListInMapResults{resItems, err}
	return e.mock
}

// Times sets number of times AccountUsecase.FindListInMap should be invoked
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) Times(n uint64) *mAccountUsecaseMockFindListInMap {
	if n == 0 {
		mmFindListInMap.mock.t.Fatalf("Times of AccountUsecaseMock.FindListInMap mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindListInMap.expectedInvocations, n)
	mmFindListInMap.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindListInMap
}

func (mmFindListInMap *mAccountUsecaseMockFindListInMap) invocationsDone() bool {
	if len(mmFindListInMap.expectations) == 0 && mmFindListInMap.defaultExpectation == nil && mmFindListInMap.mock.funcFindListInMap == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindListInMap.mock.afterFindListInMapCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindListInMap.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindListInMap implements mm_usecase.AccountUsecase
func (mmFindListInMap *AccountUsecaseMock) FindListInMap(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (resItems map[uuid.UUID]*mm_usecase.AccountDTO, err error) {
	mm_atomic.AddUint64(&mmFindListInMap.beforeFindListInMapCounter, 1)
	defer mm_atomic.AddUint64(&mmFindListInMap.afterFindListInMapCounter, 1)

	mmFindListInMap.t.Helper()

	if mmFindListInMap.inspectFuncFindListInMap != nil {
		mmFindListInMap.inspectFuncFindListInMap(ctx, listOptions, queryParams)
	}

	mm_params := AccountUsecaseMockFindListInMapParams{ctx, listOptions, queryParams}

	// Record call args
	mmFindListInMap.FindListInMapMock.mutex.Lock()
	mmFindListInMap.FindListInMapMock.callArgs = append(mmFindListInMap.FindListInMapMock.callArgs, &mm_params)
	mmFindListInMap.FindListInMapMock.mutex.Unlock()

	for _, e := range mmFindListInMap.FindListInMapMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resItems, e.results.err
		}
	}

	if mmFindListInMap.FindListInMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindListInMap.FindListInMapMock.defaultExpectation.Counter, 1)
		mm_want := mmFindListInMap.FindListInMapMock.defaultExpectation.params
		mm_want_ptrs := mmFindListInMap.FindListInMapMock.defaultExpectation.paramPtrs

		mm_got := AccountUsecaseMockFindListInMapParams{ctx, listOptions, queryParams}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindListInMap.t.Errorf("AccountUsecaseMock.FindListInMap got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindListInMap.FindListInMapMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.listOptions != nil && !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) {
				mmFindListInMap.t.Errorf("AccountUsecaseMock.FindListInMap got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindListInMap.FindListInMapMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
			}

			if mm_want_ptrs.queryParams != nil && !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) {
				mmFindListInMap.t.Errorf("AccountUsecaseMock.FindListInMap got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindListInMap.FindListInMapMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindListInMap.t.Errorf("AccountUsecaseMock.FindListInMap got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindListInMap.FindListInMapMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindListInMap.FindListInMapMock.defaultExpectation.results
		if mm_results == nil {
			mmFindListInMap.t.Fatal("No results are set for the AccountUsecaseMock.FindListInMap")
		}
		return (*mm_results).resItems, (*mm_results).err
	}
	if mmFindListInMap.funcFindListInMap != nil {
		return mmFindListInMap.funcFindListInMap(ctx, listOptions, queryParams)
	}
	mmFindListInMap.t.Fatalf("Unexpected call to AccountUsecaseMock.FindListInMap. %v %v %v", ctx, listOptions, queryParams)
	return
}

// FindListInMapAfterCounter returns a count of finished AccountUsecaseMock.FindListInMap invocations
func (mmFindListInMap *AccountUsecaseMock) FindListInMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindListInMap.afterFindListInMapCounter)
}

// FindListInMapBeforeCounter returns a count of AccountUsecaseMock.FindListInMap invocations
func (mmFindListInMap *AccountUsecaseMock) FindListInMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindListInMap.beforeFindListInMapCounter)
}

// Calls returns a list of arguments used in each call to AccountUsecaseMock.FindListInMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindListInMap *mAccountUsecaseMockFindListInMap) Calls() []*AccountUsecaseMockFindListInMapParams {
	mmFindListInMap.mutex.RLock()

	argCopy := make([]*AccountUsecaseMockFindListInMapParams, len(mmFindListInMap.callArgs))
	copy(argCopy, mmFindListInMap.callArgs)

	mmFindListInMap.mutex.RUnlock()

	return argCopy
}

// MinimockFindListInMapDone returns true if the count of the FindListInMap invocations corresponds
// the number of defined expectations
func (m *AccountUsecaseMock) MinimockFindListInMapDone() bool {
	if m.FindListInMapMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindListInMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindListInMapMock.invocationsDone()
}

// MinimockFindListInMapInspect logs each unmet expectation
func (m *AccountUsecaseMock) MinimockFindListInMapInspect() {
	for _, e := range m.FindListInMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccountUsecaseMock.FindListInMap at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindListInMapCounter := mm_atomic.LoadUint64(&m.afterFindListInMapCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindListInMapMock.defaultExpectation != nil && afterFindListInMapCounter < 1 {
		if m.FindListInMapMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AccountUsecaseMock.FindListInMap at\n%s", m.FindListInMapMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AccountUsecaseMock.FindListInMap at\n%s with params: %#v", m.FindListInMapMock.defaultExpectation.expectationOrigins.origin, *m.FindListInMapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindListInMap != nil && afterFindListInMapCounter < 1 {
		m.t.Errorf("Expected call to AccountUsecaseMock.FindListInMap at\n%s", m.funcFindListInMapOrigin)
	}

	if !m.FindListInMapMock.invocationsDone() && afterFindListInMapCounter > 0 {
		m.t.Errorf("Expected %d calls to AccountUsecaseMock.FindListInMap at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindListInMapMock.expectedInvocations), m.FindListInMapMock.expectedInvocationsOrigin, afterFindListInMapCounter)
	}
}

type mAccountUsecaseMockFindOneByEmail struct {
	optional           bool
	mock               *AccountUsecaseMock
	defaultExpectation *AccountUsecaseMockFindOneByEmailExpectation
	expectations       []*AccountUsecaseMockFindOneByEmailExpectation

	callArgs []*AccountUsecaseMockFindOneByEmailParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AccountUsecaseMockFindOneByEmailExpectation specifies expectation struct of the AccountUsecase.FindOneByEmail
type AccountUsecaseMockFindOneByEmailExpectation struct {
	mock               *AccountUsecaseMock
	params             *AccountUsecaseMockFindOneByEmailParams
	paramPtrs          *AccountUsecaseMockFindOneByEmailParamPtrs
	expectationOrigins AccountUsecaseMockFindOneByEmailExpectationOrigins
	results            *AccountUsecaseMockFindOneByEmailResults
	returnOrigin       string
	Counter            uint64
}

// AccountUsecaseMockFindOneByEmailParams contains parameters of the AccountUsecase.FindOneByEmail
type AccountUsecaseMockFindOneByEmailParams struct {
	ctx         context.Context
	email       string
	queryParams *uctypes.QueryGetOneParams
}

// AccountUsecaseMockFindOneByEmailParamPtrs contains pointers to parameters of the AccountUsecase.FindOneByEmail
type AccountUsecaseMockFindOneByEmailParamPtrs struct {
	ctx         *context.Context
	email       *string
	queryParams **uctypes.QueryGetOneParams
}

// AccountUsecaseMockFindOneByEmailResults contains results of the AccountUsecase.FindOneByEmail
type AccountUsecaseMockFindOneByEmailResults struct {
	resAccount *mm_usecase.AccountDTO
	err        error
}

// AccountUsecaseMockFindOneByEmailOrigins contains origins of expectations of the AccountUsecase.FindOneByEmail
type AccountUsecaseMockFindOneByEmailExpectationOrigins struct {
	origin            string
	originCtx         string
	originEmail       string
	originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) Optional() *mAccountUsecaseMockFindOneByEmail {
	mmFindOneByEmail.optional = true
	return mmFindOneByEmail
}

// Expect sets up expected params for AccountUsecase.FindOneByEmail
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) Expect(ctx context.Context, email string, queryParams *uctypes.QueryGetOneParams) *mAccountUsecaseMockFindOneByEmail {
	if mmFindOneByEmail.mock.funcFindOneByEmail != nil {
		mmFindOneByEmail.mock.t.Fatalf("AccountUsecaseMock.FindOneByEmail mock is already set by Set")
	}

	if mmFindOneByEmail.defaultExpectation == nil {
		mmFindOneByEmail.defaultExpectation = &AccountUsecaseMockFindOneByEmailExpectation{}
	}

	if mmFindOneByEmail.defaultExpectation.paramPtrs != nil {
		mmFindOneByEmail.mock.t.Fatalf("AccountUsecaseMock.FindOneByEmail mock is already set by ExpectParams functions")
	}

	mmFindOneByEmail.defaultExpectation.params = &AccountUsecaseMockFindOneByEmailParams{ctx, email, queryParams}
	mmFindOneByEmail.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindOneByEmail.expectations {
		if minimock.Equal(e.params, mmFindOneByEmail.defaultExpectation.params) {
			mmFindOneByEmail.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindOneByEmail.defaultExpectation.params)
		}
	}

	return mmFindOneByEmail
}

// ExpectCtxParam1 sets up expected param ctx for AccountUsecase.FindOneByEmail
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) ExpectCtxParam1(ctx context.Context) *mAccountUsecaseMockFindOneByEmail {
	if mmFindOneByEmail.mock.funcFindOneByEmail != nil {
		mmFindOneByEmail.mock.t.Fatalf("AccountUsecaseMock.FindOneByEmail mock is already set by Set")
	}

	if mmFindOneByEmail.defaultExpectation == nil {
		mmFindOneByEmail.defaultExpectation = &AccountUsecaseMockFindOneByEmailExpectation{}
	}

	if mmFindOneByEmail.defaultExpectation.params != nil {
		mmFindOneByEmail.mock.t.Fatalf("AccountUsecaseMock.FindOneByEmail mock is already set by Expect")
	}

	if mmFindOneByEmail.defaultExpectation.paramPtrs == nil {
		mmFindOneByEmail.defaultExpectation.paramPtrs = &AccountUsecaseMockFindOneByEmailParamPtrs{}
	}
	mmFindOneByEmail.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindOneByEmail.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindOneByEmail
}

// ExpectEmailParam2 sets up expected param email for AccountUsecase.FindOneByEmail
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) ExpectEmailParam2(email string) *mAccountUsecaseMockFindOneByEmail {
	if mmFindOneByEmail.mock.funcFindOneByEmail != nil {
		mmFindOneByEmail.mock.t.Fatalf("AccountUsecaseMock.FindOneByEmail mock is already set by Set")
	}

	if mmFindOneByEmail.defaultExpectation == nil {
		mmFindOneByEmail.defaultExpectation = &AccountUsecaseMockFindOneByEmailExpectation{}
	}

	if mmFindOneByEmail.defaultExpectation.params != nil {
		mmFindOneByEmail.mock.t.Fatalf("AccountUsecaseMock.FindOneByEmail mock is already set by Expect")
	}

	if mmFindOneByEmail.defaultExpectation.paramPtrs == nil {
		mmFindOneByEmail.defaultExpectation.paramPtrs = &AccountUsecaseMockFindOneByEmailParamPtrs{}
	}
	mmFindOneByEmail.defaultExpectation.paramPtrs.email = &email
	mmFindOneByEmail.defaultExpectation.expectationOrigins.originEmail = minimock.CallerInfo(1)

	return mmFindOneByEmail
}

// ExpectQueryParamsParam3 sets up expected param queryParams for AccountUsecase.FindOneByEmail
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetOneParams) *mAccountUsecaseMockFindOneByEmail {
	if mmFindOneByEmail.mock.funcFindOneByEmail != nil {
		mmFindOneByEmail.mock.t.Fatalf("AccountUsecaseMock.FindOneByEmail mock is already set by Set")
	}

	if mmFindOneByEmail.defaultExpectation == nil {
		mmFindOneByEmail.defaultExpectation = &AccountUsecaseMockFindOneByEmailExpectation{}
	}

	if mmFindOneByEmail.defaultExpectation.params != nil {
		mmFindOneByEmail.mock.t.Fatalf("AccountUsecaseMock.FindOneByEmail mock is already set by Expect")
	}

	if mmFindOneByEmail.defaultExpectation.paramPtrs == nil {
		mmFindOneByEmail.defaultExpectation.paramPtrs = &AccountUsecaseMockFindOneByEmailParamPtrs{}
	}
	mmFindOneByEmail.defaultExpectation.paramPtrs.queryParams = &queryParams
	mmFindOneByEmail.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

	return mmFindOneByEmail
}

// Inspect accepts an inspector function that has same arguments as the AccountUsecase.FindOneByEmail
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) Inspect(f func(ctx context.Context, email string, queryParams *uctypes.QueryGetOneParams)) *mAccountUsecaseMockFindOneByEmail {
	if mmFindOneByEmail.mock.inspectFuncFindOneByEmail != nil {
		mmFindOneByEmail.mock.t.Fatalf("Inspect function is already set for AccountUsecaseMock.FindOneByEmail")
	}

	mmFindOneByEmail.mock.inspectFuncFindOneByEmail = f

	return mmFindOneByEmail
}

// Return sets up results that will be returned by AccountUsecase.FindOneByEmail
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) Return(resAccount *mm_usecase.AccountDTO, err error) *AccountUsecaseMock {
	if mmFindOneByEmail.mock.funcFindOneByEmail != nil {
		mmFindOneByEmail.mock.t.Fatalf("AccountUsecaseMock.FindOneByEmail mock is already set by Set")
	}

	if mmFindOneByEmail.defaultExpectation == nil {
		mmFindOneByEmail.defaultExpectation = &AccountUsecaseMockFindOneByEmailExpectation{mock: mmFindOneByEmail.mock}
	}
	mmFindOneByEmail.defaultExpectation.results = &AccountUsecaseMockFindOneByEmailResults{resAccount, err}
	mmFindOneByEmail.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindOneByEmail.mock
}

// Set uses given function f to mock the AccountUsecase.FindOneByEmail method
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) Set(f func(ctx context.Context, email string, queryParams *uctypes.QueryGetOneParams) (resAccount *mm_usecase.AccountDTO, err error)) *AccountUsecaseMock {
	if mmFindOneByEmail.defaultExpectation != nil {
		mmFindOneByEmail.mock.t.Fatalf("Default expectation is already set for the AccountUsecase.FindOneByEmail method")
	}

	if len(mmFindOneByEmail.expectations) > 0 {
		mmFindOneByEmail.mock.t.Fatalf("Some expectations are already set for the AccountUsecase.FindOneByEmail method")
	}

	mmFindOneByEmail.mock.funcFindOneByEmail = f
	mmFindOneByEmail.mock.funcFindOneByEmailOrigin = minimock.CallerInfo(1)
	return mmFindOneByEmail.mock
}

// When sets expectation for the AccountUsecase.FindOneByEmail which will trigger the result defined by the following
// Then helper
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) When(ctx context.Context, email string, queryParams *uctypes.QueryGetOneParams) *AccountUsecaseMockFindOneByEmailExpectation {
	if mmFindOneByEmail.mock.funcFindOneByEmail != nil {
		mmFindOneByEmail.mock.t.Fatalf("AccountUsecaseMock.FindOneByEmail mock is already set by Set")
	}

	expectation := &AccountUsecaseMockFindOneByEmailExpectation{
		mock:               mmFindOneByEmail.mock,
		params:             &AccountUsecaseMockFindOneByEmailParams{ctx, email, queryParams},
		expectationOrigins: AccountUsecaseMockFindOneByEmailExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindOneByEmail.expectations = append(mmFindOneByEmail.expectations, expectation)
	return expectation
}

// Then sets up AccountUsecase.FindOneByEmail return parameters for the expectation previously defined by the When method
func (e *AccountUsecaseMockFindOneByEmailExpectation) Then(resAccount *mm_usecase.AccountDTO, err error) *AccountUsecaseMock {
	e.results = &AccountUsecaseMockFindOneByEmailResults{resAccount, err}
	return e.mock
}

// Times sets number of times AccountUsecase.FindOneByEmail should be invoked
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) Times(n uint64) *mAccountUsecaseMockFindOneByEmail {
	if n == 0 {
		mmFindOneByEmail.mock.t.Fatalf("Times of AccountUsecaseMock.FindOneByEmail mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindOneByEmail.expectedInvocations, n)
	mmFindOneByEmail.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindOneByEmail
}

func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) invocationsDone() bool {
	if len(mmFindOneByEmail.expectations) == 0 && mmFindOneByEmail.defaultExpectation == nil && mmFindOneByEmail.mock.funcFindOneByEmail == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindOneByEmail.mock.afterFindOneByEmailCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindOneByEmail.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindOneByEmail implements mm_usecase.AccountUsecase
func (mmFindOneByEmail *AccountUsecaseMock) FindOneByEmail(ctx context.Context, email string, queryParams *uctypes.QueryGetOneParams) (resAccount *mm_usecase.AccountDTO, err error) {
	mm_atomic.AddUint64(&mmFindOneByEmail.beforeFindOneByEmailCounter, 1)
	defer mm_atomic.AddUint64(&mmFindOneByEmail.afterFindOneByEmailCounter, 1)

	mmFindOneByEmail.t.Helper()

	if mmFindOneByEmail.inspectFuncFindOneByEmail != nil {
		mmFindOneByEmail.inspectFuncFindOneByEmail(ctx, email, queryParams)
	}

	mm_params := AccountUsecaseMockFindOneByEmailParams{ctx, email, queryParams}

	// Record call args
	mmFindOneByEmail.FindOneByEmailMock.mutex.Lock()
	mmFindOneByEmail.FindOneByEmailMock.callArgs = append(mmFindOneByEmail.FindOneByEmailMock.callArgs, &mm_params)
	mmFindOneByEmail.FindOneByEmailMock.mutex.Unlock()

	for _, e := range mmFindOneByEmail.FindOneByEmailMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resAccount, e.results.err
		}
	}

	if mmFindOneByEmail.FindOneByEmailMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.Counter, 1)
		mm_want := mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.params
		mm_want_ptrs := mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.paramPtrs

		mm_got := AccountUsecaseMockFindOneByEmailParams{ctx, email, queryParams}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindOneByEmail.t.Errorf("AccountUsecaseMock.FindOneByEmail got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.email != nil && !minimock.Equal(*mm_want_ptrs.email, mm_got.email) {
				mmFindOneByEmail.t.Errorf("AccountUsecaseMock.FindOneByEmail got unexpected parameter email, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.expectationOrigins.originEmail, *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
			}

			if mm_want_ptrs.queryParams != nil && !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) {
				mmFindOneByEmail.t.Errorf("AccountUsecaseMock.FindOneByEmail got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindOneByEmail.t.Errorf("AccountUsecaseMock.FindOneByEmail got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindOneByEmail.FindOneByEmailMock.defaultExpectation.results
		if mm_results == nil {
			mmFindOneByEmail.t.Fatal("No results are set for the AccountUsecaseMock.FindOneByEmail")
		}
		return (*mm_results).resAccount, (*mm_results).err
	}
	if mmFindOneByEmail.funcFindOneByEmail != nil {
		return mmFindOneByEmail.funcFindOneByEmail(ctx, email, queryParams)
	}
	mmFindOneByEmail.t.Fatalf("Unexpected call to AccountUsecaseMock.FindOneByEmail. %v %v %v", ctx, email, queryParams)
	return
}

// FindOneByEmailAfterCounter returns a count of finished AccountUsecaseMock.FindOneByEmail invocations
func (mmFindOneByEmail *AccountUsecaseMock) FindOneByEmailAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindOneByEmail.afterFindOneByEmailCounter)
}

// FindOneByEmailBeforeCounter returns a count of AccountUsecaseMock.FindOneByEmail invocations
func (mmFindOneByEmail *AccountUsecaseMock) FindOneByEmailBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindOneByEmail.beforeFindOneByEmailCounter)
}

// Calls returns a list of arguments used in each call to AccountUsecaseMock.FindOneByEmail.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindOneByEmail *mAccountUsecaseMockFindOneByEmail) Calls() []*AccountUsecaseMockFindOneByEmailParams {
	mmFindOneByEmail.mutex.RLock()

	argCopy := make([]*AccountUsecaseMockFindOneByEmailParams, len(mmFindOneByEmail.callArgs))
	copy(argCopy, mmFindOneByEmail.callArgs)

	mmFindOneByEmail.mutex.RUnlock()

	return argCopy
}

// MinimockFindOneByEmailDone returns true if the count of the FindOneByEmail invocations corresponds
// the number of defined expectations
func (m *AccountUsecaseMock) MinimockFindOneByEmailDone() bool {
	if m.FindOneByEmailMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindOneByEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindOneByEmailMock.invocationsDone()
}

// MinimockFindOneByEmailInspect logs each unmet expectation
func (m *AccountUsecaseMock) MinimockFindOneByEmailInspect() {
	for _, e := range m.FindOneByEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccountUsecaseMock.FindOneByEmail at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindOneByEmailCounter := mm_atomic.LoadUint64(&m.afterFindOneByEmailCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindOneByEmailMock.defaultExpectation != nil && afterFindOneByEmailCounter < 1 {
		if m.FindOneByEmailMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AccountUsecaseMock.FindOneByEmail at\n%s", m.FindOneByEmailMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AccountUsecaseMock.FindOneByEmail at\n%s with params: %#v", m.FindOneByEmailMock.defaultExpectation.expectationOrigins.origin, *m.FindOneByEmailMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindOneByEmail != nil && afterFindOneByEmailCounter < 1 {
		m.t.Errorf("Expected call to AccountUsecaseMock.FindOneByEmail at\n%s", m.funcFindOneByEmailOrigin)
	}

	if !m.FindOneByEmailMock.invocationsDone() && afterFindOneByEmailCounter > 0 {
		m.t.Errorf("Expected %d calls to AccountUsecaseMock.FindOneByEmail at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindOneByEmailMock.expectedInvocations), m.FindOneByEmailMock.expectedInvocationsOrigin, afterFindOneByEmailCounter)
	}
}

type mAccountUsecaseMockFindOneByID struct {
	optional           bool
	mock               *AccountUsecaseMock
	defaultExpectation *AccountUsecaseMockFindOneByIDExpectation
	expectations       []*AccountUsecaseMockFindOneByIDExpectation

	callArgs []*AccountUsecaseMockFindOneByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AccountUsecaseMockFindOneByIDExpectation specifies expectation struct of the AccountUsecase.FindOneByID
type AccountUsecaseMockFindOneByIDExpectation struct {
	mock               *AccountUsecaseMock
	params             *AccountUsecaseMockFindOneByIDParams
	paramPtrs          *AccountUsecaseMockFindOneByIDParamPtrs
	expectationOrigins AccountUsecaseMockFindOneByIDExpectationOrigins
	results            *AccountUsecaseMockFindOneByIDResults
	returnOrigin       string
	Counter            uint64
}

// AccountUsecaseMockFindOneByIDParams contains parameters of the AccountUsecase.FindOneByID
type AccountUsecaseMockFindOneByIDParams struct {
	ctx         context.Context
	id          uuid.UUID
	queryParams *uctypes.QueryGetOneParams
}

// AccountUsecaseMockFindOneByIDParamPtrs contains pointers to parameters of the AccountUsecase.FindOneByID
type AccountUsecaseMockFindOneByIDParamPtrs struct {
	ctx         *context.Context
	id          *uuid.UUID
	queryParams **uctypes.QueryGetOneParams
}

// AccountUsecaseMockFindOneByIDResults contains results of the AccountUsecase.FindOneByID
type AccountUsecaseMockFindOneByIDResults struct {
	resAccount *mm_usecase.AccountDTO
	err        error
}

// AccountUsecaseMockFindOneByIDOrigins contains origins of expectations of the AccountUsecase.FindOneByID
type AccountUsecaseMockFindOneByIDExpectationOrigins struct {
	origin            string
	originCtx         string
	originId          string
	originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) Optional() *mAccountUsecaseMockFindOneByID {
	mmFindOneByID.optional = true
	return mmFindOneByID
}

// Expect sets up expected params for AccountUsecase.FindOneByID
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) Expect(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *mAccountUsecaseMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("AccountUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &AccountUsecaseMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.paramPtrs != nil {
		mmFindOneByID.mock.t.Fatalf("AccountUsecaseMock.FindOneByID mock is already set by ExpectParams functions")
	}

	mmFindOneByID.defaultExpectation.params = &AccountUsecaseMockFindOneByIDParams{ctx, id, queryParams}
	mmFindOneByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindOneByID.expectations {
		if minimock.Equal(e.params, mmFindOneByID.defaultExpectation.params) {
			mmFindOneByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindOneByID.defaultExpectation.params)
		}
	}

	return mmFindOneByID
}

// ExpectCtxParam1 sets up expected param ctx for AccountUsecase.FindOneByID
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) ExpectCtxParam1(ctx context.Context) *mAccountUsecaseMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("AccountUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &AccountUsecaseMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.params != nil {
		mmFindOneByID.mock.t.Fatalf("AccountUsecaseMock.FindOneByID mock is already set by Expect")
	}

	if mmFindOneByID.defaultExpectation.paramPtrs == nil {
		mmFindOneByID.defaultExpectation.paramPtrs = &AccountUsecaseMockFindOneByIDParamPtrs{}
	}
	mmFindOneByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindOneByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindOneByID
}

// ExpectIdParam2 sets up expected param id for AccountUsecase.FindOneByID
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) ExpectIdParam2(id uuid.UUID) *mAccountUsecaseMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("AccountUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &AccountUsecaseMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.params != nil {
		mmFindOneByID.mock.t.Fatalf("AccountUsecaseMock.FindOneByID mock is already set by Expect")
	}

	if mmFindOneByID.defaultExpectation.paramPtrs == nil {
		mmFindOneByID.defaultExpectation.paramPtrs = &AccountUsecaseMockFindOneByIDParamPtrs{}
	}
	mmFindOneByID.defaultExpectation.paramPtrs.id = &id
	mmFindOneByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmFindOneByID
}

// ExpectQueryParamsParam3 sets up expected param queryParams for AccountUsecase.FindOneByID
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetOneParams) *mAccountUsecaseMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("AccountUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &AccountUsecaseMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.params != nil {
		mmFindOneByID.mock.t.Fatalf("AccountUsecaseMock.FindOneByID mock is already set by Expect")
	}

	if mmFindOneByID.defaultExpectation.paramPtrs == nil {
		mmFindOneByID.defaultExpectation.paramPtrs = &AccountUsecaseMockFindOneByIDParamPtrs{}
	}
	mmFindOneByID.defaultExpectation.paramPtrs.queryParams = &queryParams
	mmFindOneByID.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

	return mmFindOneByID
}

// Inspect accepts an inspector function that has same arguments as the AccountUsecase.FindOneByID
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) Inspect(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)) *mAccountUsecaseMockFindOneByID {
	if mmFindOneByID.mock.inspectFuncFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("Inspect function is already set for AccountUsecaseMock.FindOneByID")
	}

	mmFindOneByID.mock.inspectFuncFindOneByID = f

	return mmFindOneByID
}

// Return sets up results that will be returned by AccountUsecase.FindOneByID
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) Return(resAccount *mm_usecase.AccountDTO, err error) *AccountUsecaseMock {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("AccountUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &AccountUsecaseMockFindOneByIDExpectation{mock: mmFindOneByID.mock}
	}
	mmFindOneByID.defaultExpectation.results = &AccountUsecaseMockFindOneByIDResults{resAccount, err}
	mmFindOneByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindOneByID.mock
}

// Set uses given function f to mock the AccountUsecase.FindOneByID method
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) Set(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (resAccount *mm_usecase.AccountDTO, err error)) *AccountUsecaseMock {
	if mmFindOneByID.defaultExpectation != nil {
		mmFindOneByID.mock.t.Fatalf("Default expectation is already set for the AccountUsecase.FindOneByID method")
	}

	if len(mmFindOneByID.expectations) > 0 {
		mmFindOneByID.mock.t.Fatalf("Some expectations are already set for the AccountUsecase.FindOneByID method")
	}

	mmFindOneByID.mock.funcFindOneByID = f
	mmFindOneByID.mock.funcFindOneByIDOrigin = minimock.CallerInfo(1)
	return mmFindOneByID.mock
}

// When sets expectation for the AccountUsecase.FindOneByID which will trigger the result defined by the following
// Then helper
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) When(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *AccountUsecaseMockFindOneByIDExpectation {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("AccountUsecaseMock.FindOneByID mock is already set by Set")
	}

	expectation := &AccountUsecaseMockFindOneByIDExpectation{
		mock:               mmFindOneByID.mock,
		params:             &AccountUsecaseMockFindOneByIDParams{ctx, id, queryParams},
		expectationOrigins: AccountUsecaseMockFindOneByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindOneByID.expectations = append(mmFindOneByID.expectations, expectation)
	return expectation
}

// Then sets up AccountUsecase.FindOneByID return parameters for the expectation previously defined by the When method
func (e *AccountUsecaseMockFindOneByIDExpectation) Then(resAccount *mm_usecase.AccountDTO, err error) *AccountUsecaseMock {
	e.results = &AccountUsecaseMockFindOneByIDResults{resAccount, err}
	return e.mock
}

// Times sets number of times AccountUsecase.FindOneByID should be invoked
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) Times(n uint64) *mAccountUsecaseMockFindOneByID {
	if n == 0 {
		mmFindOneByID.mock.t.Fatalf("Times of AccountUsecaseMock.FindOneByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindOneByID.expectedInvocations, n)
	mmFindOneByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindOneByID
}

func (mmFindOneByID *mAccountUsecaseMockFindOneByID) invocationsDone() bool {
	if len(mmFindOneByID.expectations) == 0 && mmFindOneByID.defaultExpectation == nil && mmFindOneByID.mock.funcFindOneByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindOneByID.mock.afterFindOneByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindOneByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindOneByID implements mm_usecase.AccountUsecase
func (mmFindOneByID *AccountUsecaseMock) FindOneByID(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (resAccount *mm_usecase.AccountDTO, err error) {
	mm_atomic.AddUint64(&mmFindOneByID.beforeFindOneByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmFindOneByID.afterFindOneByIDCounter, 1)

	mmFindOneByID.t.Helper()

	if mmFindOneByID.inspectFuncFindOneByID != nil {
		mmFindOneByID.inspectFuncFindOneByID(ctx, id, queryParams)
	}

	mm_params := AccountUsecaseMockFindOneByIDParams{ctx, id, queryParams}

	// Record call args
	mmFindOneByID.FindOneByIDMock.mutex.Lock()
	mmFindOneByID.FindOneByIDMock.callArgs = append(mmFindOneByID.FindOneByIDMock.callArgs, &mm_params)
	mmFindOneByID.FindOneByIDMock.mutex.Unlock()

	for _, e := range mmFindOneByID.FindOneByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resAccount, e.results.err
		}
	}

	if mmFindOneByID.FindOneByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindOneByID.FindOneByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmFindOneByID.FindOneByIDMock.defaultExpectation.params
		mm_want_ptrs := mmFindOneByID.FindOneByIDMock.defaultExpectation.paramPtrs

		mm_got := AccountUsecaseMockFindOneByIDParams{ctx, id, queryParams}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindOneByID.t.Errorf("AccountUsecaseMock.FindOneByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmFindOneByID.t.Errorf("AccountUsecaseMock.FindOneByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.queryParams != nil && !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) {
				mmFindOneByID.t.Errorf("AccountUsecaseMock.FindOneByID got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindOneByID.t.Errorf("AccountUsecaseMock.FindOneByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindOneByID.FindOneByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmFindOneByID.t.Fatal("No results are set for the AccountUsecaseMock.FindOneByID")
		}
		return (*mm_results).resAccount, (*mm_results).err
	}
	if mmFindOneByID.funcFindOneByID != nil {
		return mmFindOneByID.funcFindOneByID(ctx, id, queryParams)
	}
	mmFindOneByID.t.Fatalf("Unexpected call to AccountUsecaseMock.FindOneByID. %v %v %v", ctx, id, queryParams)
	return
}

// FindOneByIDAfterCounter returns a count of finished AccountUsecaseMock.FindOneByID invocations
func (mmFindOneByID *AccountUsecaseMock) FindOneByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindOneByID.afterFindOneByIDCounter)
}

// FindOneByIDBeforeCounter returns a count of AccountUsecaseMock.FindOneByID invocations
func (mmFindOneByID *AccountUsecaseMock) FindOneByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindOneByID.beforeFindOneByIDCounter)
}

// Calls returns a list of arguments used in each call to AccountUsecaseMock.FindOneByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindOneByID *mAccountUsecaseMockFindOneByID) Calls() []*AccountUsecaseMockFindOneByIDParams {
	mmFindOneByID.mutex.RLock()

	argCopy := make([]*AccountUsecaseMockFindOneByIDParams, len(mmFindOneByID.callArgs))
	copy(argCopy, mmFindOneByID.callArgs)

	mmFindOneByID.mutex.RUnlock()

	return argCopy
}

// MinimockFindOneByIDDone returns true if the count of the FindOneByID invocations corresponds
// the number of defined expectations
func (m *AccountUsecaseMock) MinimockFindOneByIDDone() bool {
	if m.FindOneByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindOneByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindOneByIDMock.invocationsDone()
}

// MinimockFindOneByIDInspect logs each unmet expectation
func (m *AccountUsecaseMock) MinimockFindOneByIDInspect() {
	for _, e := range m.FindOneByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccountUsecaseMock.FindOneByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindOneByIDCounter := mm_atomic.LoadUint64(&m.afterFindOneByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindOneByIDMock.defaultExpectation != nil && afterFindOneByIDCounter < 1 {
		if m.FindOneByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AccountUsecaseMock.FindOneByID at\n%s", m.FindOneByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AccountUsecaseMock.FindOneByID at\n%s with params: %#v", m.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *m.FindOneByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindOneByID != nil && afterFindOneByIDCounter < 1 {
		m.t.Errorf("Expected call to AccountUsecaseMock.FindOneByID at\n%s", m.funcFindOneByIDOrigin)
	}

	if !m.FindOneByIDMock.invocationsDone() && afterFindOneByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to AccountUsecaseMock.FindOneByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindOneByIDMock.expectedInvocations), m.FindOneByIDMock.expectedInvocationsOrigin, afterFindOneByIDCounter)
	}
}

type mAccountUsecaseMockFindPagedList struct {
	optional           bool
	mock               *AccountUsecaseMock
	defaultExpectation *AccountUsecaseMockFindPagedListExpectation
	expectations       []*AccountUsecaseMockFindPagedListExpectation

	callArgs []*AccountUsecaseMockFindPagedListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AccountUsecaseMockFindPagedListExpectation specifies expectation struct of the AccountUsecase.FindPagedList
type AccountUsecaseMockFindPagedListExpectation struct {
	mock               *AccountUsecaseMock
	params             *AccountUsecaseMockFindPagedListParams
	paramPtrs          *AccountUsecaseMockFindPagedListParamPtrs
	expectationOrigins AccountUsecaseMockFindPagedListExpectationOrigins
	results            *AccountUsecaseMockFindPagedListResults
	returnOrigin       string
	Counter            uint64
}

// AccountUsecaseMockFindPagedListParams contains parameters of the AccountUsecase.FindPagedList
type AccountUsecaseMockFindPagedListParams struct {
	ctx         context.Context
	listOptions *mm_usecase.AccountListOptions
	queryParams *uctypes.QueryGetListParams
}

// AccountUsecaseMockFindPagedListParamPtrs contains pointers to parameters of the AccountUsecase.FindPagedList
type AccountUsecaseMockFindPagedListParamPtrs struct {
	ctx         *context.Context
	listOptions **mm_usecase.AccountListOptions
	queryParams **uctypes.QueryGetListParams
}

// AccountUsecaseMockFindPagedListResults contains results of the AccountUsecase.FindPagedList
type AccountUsecaseMockFindPagedListResults struct {
	resItems []*mm_usecase.AccountDTO
	total    uint64
	err      error
}

// AccountUsecaseMockFindPagedListOrigins contains origins of expectations of the AccountUsecase.FindPagedList
type AccountUsecaseMockFindPagedListExpectationOrigins struct {
	origin            string
	originCtx         string
	originListOptions string
	originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) Optional() *mAccountUsecaseMockFindPagedList {
	mmFindPagedList.optional = true
	return mmFindPagedList
}

// Expect sets up expected params for AccountUsecase.FindPagedList
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) Expect(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) *mAccountUsecaseMockFindPagedList {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("AccountUsecaseMock.FindPagedList mock is already set by Set")
	}

	if mmFindPagedList.defaultExpectation == nil {
		mmFindPagedList.defaultExpectation = &AccountUsecaseMockFindPagedListExpectation{}
	}

	if mmFindPagedList.defaultExpectation.paramPtrs != nil {
		mmFindPagedList.mock.t.Fatalf("AccountUsecaseMock.FindPagedList mock is already set by ExpectParams functions")
	}

	mmFindPagedList.defaultExpectation.params = &AccountUsecaseMockFindPagedListParams{ctx, listOptions, queryParams}
	mmFindPagedList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindPagedList.expectations {
		if minimock.Equal(e.params, mmFindPagedList.defaultExpectation.params) {
			mmFindPagedList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindPagedList.defaultExpectation.params)
		}
	}

	return mmFindPagedList
}

// ExpectCtxParam1 sets up expected param ctx for AccountUsecase.FindPagedList
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) ExpectCtxParam1(ctx context.Context) *mAccountUsecaseMockFindPagedList {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("AccountUsecaseMock.FindPagedList mock is already set by Set")
	}

	if mmFindPagedList.defaultExpectation == nil {
		mmFindPagedList.defaultExpectation = &AccountUsecaseMockFindPagedListExpectation{}
	}

	if mmFindPagedList.defaultExpectation.params != nil {
		mmFindPagedList.mock.t.Fatalf("AccountUsecaseMock.FindPagedList mock is already set by Expect")
	}

	if mmFindPagedList.defaultExpectation.paramPtrs == nil {
		mmFindPagedList.defaultExpectation.paramPtrs = &AccountUsecaseMockFindPagedListParamPtrs{}
	}
	mmFindPagedList.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindPagedList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindPagedList
}

// ExpectListOptionsParam2 sets up expected param listOptions for AccountUsecase.FindPagedList
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) ExpectListOptionsParam2(listOptions *mm_usecase.AccountListOptions) *mAccountUsecaseMockFindPagedList {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("AccountUsecaseMock.FindPagedList mock is already set by Set")
	}

	if mmFindPagedList.defaultExpectation == nil {
		mmFindPagedList.defaultExpectation = &AccountUsecaseMockFindPagedListExpectation{}
	}

	if mmFindPagedList.defaultExpectation.params != nil {
		mmFindPagedList.mock.t.Fatalf("AccountUsecaseMock.FindPagedList mock is already set by Expect")
	}

	if mmFindPagedList.defaultExpectation.paramPtrs == nil {
		mmFindPagedList.defaultExpectation.paramPtrs = &AccountUsecaseMockFindPagedListParamPtrs{}
	}
	mmFindPagedList.defaultExpectation.paramPtrs.listOptions = &listOptions
	mmFindPagedList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

	return mmFindPagedList
}

// ExpectQueryParamsParam3 sets up expected param queryParams for AccountUsecase.FindPagedList
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mAccountUsecaseMockFindPagedList {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("AccountUsecaseMock.FindPagedList mock is already set by Set")
	}

	if mmFindPagedList.defaultExpectation == nil {
		mmFindPagedList.defaultExpectation = &AccountUsecaseMockFindPagedListExpectation{}
	}

	if mmFindPagedList.defaultExpectation.params != nil {
		mmFindPagedList.mock.t.Fatalf("AccountUsecaseMock.FindPagedList mock is already set by Expect")
	}

	if mmFindPagedList.defaultExpectation.paramPtrs == nil {
		mmFindPagedList.defaultExpectation.paramPtrs = &AccountUsecaseMockFindPagedListParamPtrs{}
	}
	mmFindPagedList.defaultExpectation.paramPtrs.queryParams = &queryParams
	mmFindPagedList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

	return mmFindPagedList
}

// Inspect accepts an inspector function that has same arguments as the AccountUsecase.FindPagedList
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams)) *mAccountUsecaseMockFindPagedList {
	if mmFindPagedList.mock.inspectFuncFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("Inspect function is already set for AccountUsecaseMock.FindPagedList")
	}

	mmFindPagedList.mock.inspectFuncFindPagedList = f

	return mmFindPagedList
}

// Return sets up results that will be returned by AccountUsecase.FindPagedList
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) Return(resItems []*mm_usecase.AccountDTO, total uint64, err error) *AccountUsecaseMock {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("AccountUsecaseMock.FindPagedList mock is already set by Set")
	}

	if mmFindPagedList.defaultExpectation == nil {
		mmFindPagedList.defaultExpectation = &AccountUsecaseMockFindPagedListExpectation{mock: mmFindPagedList.mock}
	}
	mmFindPagedList.defaultExpectation.results = &AccountUsecaseMockFindPagedListResults{resItems, total, err}
	mmFindPagedList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindPagedList.mock
}

// Set uses given function f to mock the AccountUsecase.FindPagedList method
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) Set(f func(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.AccountDTO, total uint64, err error)) *AccountUsecaseMock {
	if mmFindPagedList.defaultExpectation != nil {
		mmFindPagedList.mock.t.Fatalf("Default expectation is already set for the AccountUsecase.FindPagedList method")
	}

	if len(mmFindPagedList.expectations) > 0 {
		mmFindPagedList.mock.t.Fatalf("Some expectations are already set for the AccountUsecase.FindPagedList method")
	}

	mmFindPagedList.mock.funcFindPagedList = f
	mmFindPagedList.mock.funcFindPagedListOrigin = minimock.CallerInfo(1)
	return mmFindPagedList.mock
}

// When sets expectation for the AccountUsecase.FindPagedList which will trigger the result defined by the following
// Then helper
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) When(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) *AccountUsecaseMockFindPagedListExpectation {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("AccountUsecaseMock.FindPagedList mock is already set by Set")
	}

	expectation := &AccountUsecaseMockFindPagedListExpectation{
		mock:               mmFindPagedList.mock,
		params:             &AccountUsecaseMockFindPagedListParams{ctx, listOptions, queryParams},
		expectationOrigins: AccountUsecaseMockFindPagedListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindPagedList.expectations = append(mmFindPagedList.expectations, expectation)
	return expectation
}

// Then sets up AccountUsecase.FindPagedList return parameters for the expectation previously defined by the When method
func (e *AccountUsecaseMockFindPagedListExpectation) Then(resItems []*mm_usecase.AccountDTO, total uint64, err error) *AccountUsecaseMock {
	e.results = &AccountUsecaseMockFindPagedListResults{resItems, total, err}
	return e.mock
}

// Times sets number of times AccountUsecase.FindPagedList should be invoked
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) Times(n uint64) *mAccountUsecaseMockFindPagedList {
	if n == 0 {
		mmFindPagedList.mock.t.Fatalf("Times of AccountUsecaseMock.FindPagedList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindPagedList.expectedInvocations, n)
	mmFindPagedList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindPagedList
}

func (mmFindPagedList *mAccountUsecaseMockFindPagedList) invocationsDone() bool {
	if len(mmFindPagedList.expectations) == 0 && mmFindPagedList.defaultExpectation == nil && mmFindPagedList.mock.funcFindPagedList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindPagedList.mock.afterFindPagedListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindPagedList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindPagedList implements mm_usecase.AccountUsecase
func (mmFindPagedList *AccountUsecaseMock) FindPagedList(ctx context.Context, listOptions *mm_usecase.AccountListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.AccountDTO, total uint64, err error) {
	mm_atomic.AddUint64(&mmFindPagedList.beforeFindPagedListCounter, 1)
	defer mm_atomic.AddUint64(&mmFindPagedList.afterFindPagedListCounter, 1)

	mmFindPagedList.t.Helper()

	if mmFindPagedList.inspectFuncFindPagedList != nil {
		mmFindPagedList.inspectFuncFindPagedList(ctx, listOptions, queryParams)
	}

	mm_params := AccountUsecaseMockFindPagedListParams{ctx, listOptions, queryParams}

	// Record call args
	mmFindPagedList.FindPagedListMock.mutex.Lock()
	mmFindPagedList.FindPagedListMock.callArgs = append(mmFindPagedList.FindPagedListMock.callArgs, &mm_params)
	mmFindPagedList.FindPagedListMock.mutex.Unlock()

	for _, e := range mmFindPagedList.FindPagedListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resItems, e.results.total, e.results.err
		}
	}

	if mmFindPagedList.FindPagedListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindPagedList.FindPagedListMock.defaultExpectation.Counter, 1)
		mm_want := mmFindPagedList.FindPagedListMock.defaultExpectation.params
		mm_want_ptrs := mmFindPagedList.FindPagedListMock.defaultExpectation.paramPtrs

		mm_got := AccountUsecaseMockFindPagedListParams{ctx, listOptions, queryParams}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindPagedList.t.Errorf("AccountUsecaseMock.FindPagedList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.listOptions != nil && !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) {
				mmFindPagedList.t.Errorf("AccountUsecaseMock.FindPagedList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
			}

			if mm_want_ptrs.queryParams != nil && !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) {
				mmFindPagedList.t.Errorf("AccountUsecaseMock.FindPagedList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindPagedList.t.Errorf("AccountUsecaseMock.FindPagedList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindPagedList.FindPagedListMock.defaultExpectation.results
		if mm_results == nil {
			mmFindPagedList.t.Fatal("No results are set for the AccountUsecaseMock.FindPagedList")
		}
		return (*mm_results).resItems, (*mm_results).total, (*mm_results).err
	}
	if mmFindPagedList.funcFindPagedList != nil {
		return mmFindPagedList.funcFindPagedList(ctx, listOptions, queryParams)
	}
	mmFindPagedList.t.Fatalf("Unexpected call to AccountUsecaseMock.FindPagedList. %v %v %v", ctx, listOptions, queryParams)
	return
}

// FindPagedListAfterCounter returns a count of finished AccountUsecaseMock.FindPagedList invocations
func (mmFindPagedList *AccountUsecaseMock) FindPagedListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindPagedList.afterFindPagedListCounter)
}

// FindPagedListBeforeCounter returns a count of AccountUsecaseMock.FindPagedList invocations
func (mmFindPagedList *AccountUsecaseMock) FindPagedListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindPagedList.beforeFindPagedListCounter)
}

// Calls returns a list of arguments used in each call to AccountUsecaseMock.FindPagedList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindPagedList *mAccountUsecaseMockFindPagedList) Calls() []*AccountUsecaseMockFindPagedListParams {
	mmFindPagedList.mutex.RLock()

	argCopy := make([]*AccountUsecaseMockFindPagedListParams, len(mmFindPagedList.callArgs))
	copy(argCopy, mmFindPagedList.callArgs)

	mmFindPagedList.mutex.RUnlock()

	return argCopy
}

// MinimockFindPagedListDone returns true if the count of the FindPagedList invocations corresponds
// the number of defined expectations
func (m *AccountUsecaseMock) MinimockFindPagedListDone() bool {
	if m.FindPagedListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindPagedListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindPagedListMock.invocationsDone()
}

// MinimockFindPagedListInspect logs each unmet expectation
func (m *AccountUsecaseMock) MinimockFindPagedListInspect() {
	for _, e := range m.FindPagedListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccountUsecaseMock.FindPagedList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindPagedListCounter := mm_atomic.LoadUint64(&m.afterFindPagedListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindPagedListMock.defaultExpectation != nil && afterFindPagedListCounter < 1 {
		if m.FindPagedListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AccountUsecaseMock.FindPagedList at\n%s", m.FindPagedListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AccountUsecaseMock.FindPagedList at\n%s with params: %#v", m.FindPagedListMock.defaultExpectation.expectationOrigins.origin, *m.FindPagedListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindPagedList != nil && afterFindPagedListCounter < 1 {
		m.t.Errorf("Expected call to AccountUsecaseMock.FindPagedList at\n%s", m.funcFindPagedListOrigin)
	}

	if !m.FindPagedListMock.invocationsDone() && afterFindPagedListCounter > 0 {
		m.t.Errorf("Expected %d calls to AccountUsecaseMock.FindPagedList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindPagedListMock.expectedInvocations), m.FindPagedListMock.expectedInvocationsOrigin, afterFindPagedListCounter)
	}
}

type mAccountUsecaseMockPatchAccountByDTO struct {
	optional           bool
	mock               *AccountUsecaseMock
	defaultExpectation *AccountUsecaseMockPatchAccountByDTOExpectation
	expectations       []*AccountUsecaseMockPatchAccountByDTOExpectation

	callArgs []*AccountUsecaseMockPatchAccountByDTOParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AccountUsecaseMockPatchAccountByDTOExpectation specifies expectation struct of the AccountUsecase.PatchAccountByDTO
type AccountUsecaseMockPatchAccountByDTOExpectation struct {
	mock               *AccountUsecaseMock
	params             *AccountUsecaseMockPatchAccountByDTOParams
	paramPtrs          *AccountUsecaseMockPatchAccountByDTOParamPtrs
	expectationOrigins AccountUsecaseMockPatchAccountByDTOExpectationOrigins
	results            *AccountUsecaseMockPatchAccountByDTOResults
	returnOrigin       string
	Counter            uint64
}

// AccountUsecaseMockPatchAccountByDTOParams contains parameters of the AccountUsecase.PatchAccountByDTO
type AccountUsecaseMockPatchAccountByDTOParams struct {
	ctx              context.Context
	id               uuid.UUID
	in               mm_usecase.PatchAccountDataInput
	skipVersionCheck bool
}

// AccountUsecaseMockPatchAccountByDTOParamPtrs contains pointers to parameters of the AccountUsecase.PatchAccountByDTO
type AccountUsecaseMockPatchAccountByDTOParamPtrs struct {
	ctx              *context.Context
	id               *uuid.UUID
	in               *mm_usecase.PatchAccountDataInput
	skipVersionCheck *bool
}

// AccountUsecaseMockPatchAccountByDTOResults contains results of the AccountUsecase.PatchAccountByDTO
type AccountUsecaseMockPatchAccountByDTOResults struct {
	err error
}

// AccountUsecaseMockPatchAccountByDTOOrigins contains origins of expectations of the AccountUsecase.PatchAccountByDTO
type AccountUsecaseMockPatchAccountByDTOExpectationOrigins struct {
	origin                 string
	originCtx              string
	originId               string
	originIn               string
	originSkipVersionCheck string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) Optional() *mAccountUsecaseMockPatchAccountByDTO {
	mmPatchAccountByDTO.optional = true
	return mmPatchAccountByDTO
}

// Expect sets up expected params for AccountUsecase.PatchAccountByDTO
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) Expect(ctx context.Context, id uuid.UUID, in mm_usecase.PatchAccountDataInput, skipVersionCheck bool) *mAccountUsecaseMockPatchAccountByDTO {
	if mmPatchAccountByDTO.mock.funcPatchAccountByDTO != nil {
		mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Set")
	}

	if mmPatchAccountByDTO.defaultExpectation == nil {
		mmPatchAccountByDTO.defaultExpectation = &AccountUsecaseMockPatchAccountByDTOExpectation{}
	}

	if mmPatchAccountByDTO.defaultExpectation.paramPtrs != nil {
		mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by ExpectParams functions")
	}

	mmPatchAccountByDTO.defaultExpectation.params = &AccountUsecaseMockPatchAccountByDTOParams{ctx, id, in, skipVersionCheck}
	mmPatchAccountByDTO.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPatchAccountByDTO.expectations {
		if minimock.Equal(e.params, mmPatchAccountByDTO.defaultExpectation.params) {
			mmPatchAccountByDTO.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPatchAccountByDTO.defaultExpectation.params)
		}
	}

	return mmPatchAccountByDTO
}

// ExpectCtxParam1 sets up expected param ctx for AccountUsecase.PatchAccountByDTO
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) ExpectCtxParam1(ctx context.Context) *mAccountUsecaseMockPatchAccountByDTO {
	if mmPatchAccountByDTO.mock.funcPatchAccountByDTO != nil {
		mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Set")
	}

	if mmPatchAccountByDTO.defaultExpectation == nil {
		mmPatchAccountByDTO.defaultExpectation = &AccountUsecaseMockPatchAccountByDTOExpectation{}
	}

	if mmPatchAccountByDTO.defaultExpectation.params != nil {
		mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Expect")
	}

	if mmPatchAccountByDTO.defaultExpectation.paramPtrs == nil {
		mmPatchAccountByDTO.defaultExpectation.paramPtrs = &AccountUsecaseMockPatchAccountByDTOParamPtrs{}
	}
	mmPatchAccountByDTO.defaultExpectation.paramPtrs.ctx = &ctx
	mmPatchAccountByDTO.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPatchAccountByDTO
}

// ExpectIdParam2 sets up expected param id for AccountUsecase.PatchAccountByDTO
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) ExpectIdParam2(id uuid.UUID) *mAccountUsecaseMockPatchAccountByDTO {
	if mmPatchAccountByDTO.mock.funcPatchAccountByDTO != nil {
		mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Set")
	}

	if mmPatchAccountByDTO.defaultExpectation == nil {
		mmPatchAccountByDTO.defaultExpectation = &AccountUsecaseMockPatchAccountByDTOExpectation{}
	}

	if mmPatchAccountByDTO.defaultExpectation.params != nil {
		mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Expect")
	}

	if mmPatchAccountByDTO.defaultExpectation.paramPtrs == nil {
		mmPatchAccountByDTO.defaultExpectation.paramPtrs = &AccountUsecaseMockPatchAccountByDTOParamPtrs{}
	}
	mmPatchAccountByDTO.defaultExpectation.paramPtrs.id = &id
	mmPatchAccountByDTO.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmPatchAccountByDTO
}

// ExpectInParam3 sets up expected param in for AccountUsecase.PatchAccountByDTO
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) ExpectInParam3(in mm_usecase.PatchAccountDataInput) *mAccountUsecaseMockPatchAccountByDTO {
	if mmPatchAccountByDTO.mock.funcPatchAccountByDTO != nil {
		mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Set")
	}

	if mmPatchAccountByDTO.defaultExpectation == nil {
		mmPatchAccountByDTO.defaultExpectation = &AccountUsecaseMockPatchAccountByDTOExpectation{}
	}

	if mmPatchAccountByDTO.defaultExpectation.params != nil {
		mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Expect")
	}

	if mmPatchAccountByDTO.defaultExpectation.paramPtrs == nil {
		mmPatchAccountByDTO.defaultExpectation.paramPtrs = &AccountUsecaseMockPatchAccountByDTOParamPtrs{}
	}
	mmPatchAccountByDTO.defaultExpectation.paramPtrs.in = &in
	mmPatchAccountByDTO.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmPatchAccountByDTO
}

// ExpectSkipVersionCheckParam4 sets up expected param skipVersionCheck for AccountUsecase.PatchAccountByDTO
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) ExpectSkipVersionCheckParam4(skipVersionCheck bool) *mAccountUsecaseMockPatchAccountByDTO {
	if mmPatchAccountByDTO.mock.funcPatchAccountByDTO != nil {
		mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Set")
	}

	if mmPatchAccountByDTO.defaultExpectation == nil {
		mmPatchAccountByDTO.defaultExpectation = &AccountUsecaseMockPatchAccountByDTOExpectation{}
	}

	if mmPatchAccountByDTO.defaultExpectation.params != nil {
		mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Expect")
	}

	if mmPatchAccountByDTO.defaultExpectation.paramPtrs == nil {
		mmPatchAccountByDTO.defaultExpectation.paramPtrs = &AccountUsecaseMockPatchAccountByDTOParamPtrs{}
	}
	mmPatchAccountByDTO.defaultExpectation.paramPtrs.skipVersionCheck = &skipVersionCheck
	mmPatchAccountByDTO.defaultExpectation.expectationOrigins.originSkipVersionCheck = minimock.CallerInfo(1)

	return mmPatchAccountByDTO
}

// Inspect accepts an inspector function that has same arguments as the AccountUsecase.PatchAccountByDTO
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) Inspect(f func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchAccountDataInput, skipVersionCheck bool)) *mAccountUsecaseMockPatchAccountByDTO {
	if mmPatchAccountByDTO.mock.inspectFuncPatchAccountByDTO != nil {
		mmPatchAccountByDTO.mock.t.Fatalf("Inspect function is already set for AccountUsecaseMock.PatchAccountByDTO")
	}

	mmPatchAccountByDTO.mock.inspectFuncPatchAccountByDTO = f

	return mmPatchAccountByDTO
}

// Return sets up results that will be returned by AccountUsecase.PatchAccountByDTO
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) Return(err error) *AccountUsecaseMock {
	if mmPatchAccountByDTO.mock.funcPatchAccountByDTO != nil {
		mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Set")
	}

	if mmPatchAccountByDTO.defaultExpectation == nil {
		mmPatchAccountByDTO.defaultExpectation = &AccountUsecaseMockPatchAccountByDTOExpectation{mock: mmPatchAccountByDTO.mock}
	}
	mmPatchAccountByDTO.defaultExpectation.results = &AccountUsecaseMockPatchAccountByDTOResults{err}
	mmPatchAccountByDTO.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPatchAccountByDTO.mock
}

// Set uses given function f to mock the AccountUsecase.PatchAccountByDTO method
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) Set(f func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchAccountDataInput, skipVersionCheck bool) (err error)) *AccountUsecaseMock {
	if mmPatchAccountByDTO.defaultExpectation != nil {
		mmPatchAccountByDTO.mock.t.Fatalf("Default expectation is already set for the AccountUsecase.PatchAccountByDTO method")
	}

	if len(mmPatchAccountByDTO.expectations) > 0 {
		mmPatchAccountByDTO.mock.t.Fatalf("Some expectations are already set for the AccountUsecase.PatchAccountByDTO method")
	}

	mmPatchAccountByDTO.mock.funcPatchAccountByDTO = f
	mmPatchAccountByDTO.mock.funcPatchAccountByDTOOrigin = minimock.CallerInfo(1)
	return mmPatchAccountByDTO.mock
}

// When sets expectation for the AccountUsecase.PatchAccountByDTO which will trigger the result defined by the following
// Then helper
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) When(ctx context.Context, id uuid.UUID, in mm_usecase.PatchAccountDataInput, skipVersionCheck bool) *AccountUsecaseMockPatchAccountByDTOExpectation {
	if mmPatchAccountByDTO.mock.funcPatchAccountByDTO != nil {
		mmPatchAccountByDTO.mock.t.Fatalf("AccountUsecaseMock.PatchAccountByDTO mock is already set by Set")
	}

	expectation := &AccountUsecaseMockPatchAccountByDTOExpectation{
		mock:               mmPatchAccountByDTO.mock,
		params:             &AccountUsecaseMockPatchAccountByDTOParams{ctx, id, in, skipVersionCheck},
		expectationOrigins: AccountUsecaseMockPatchAccountByDTOExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPatchAccountByDTO.expectations = append(mmPatchAccountByDTO.expectations, expectation)
	return expectation
}

// Then sets up AccountUsecase.PatchAccountByDTO return parameters for the expectation previously defined by the When method
func (e *AccountUsecaseMockPatchAccountByDTOExpectation) Then(err error) *AccountUsecaseMock {
	e.results = &AccountUsecaseMockPatchAccountByDTOResults{err}
	return e.mock
}

// Times sets number of times AccountUsecase.PatchAccountByDTO should be invoked
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) Times(n uint64) *mAccountUsecaseMockPatchAccountByDTO {
	if n == 0 {
		mmPatchAccountByDTO.mock.t.Fatalf("Times of AccountUsecaseMock.PatchAccountByDTO mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPatchAccountByDTO.expectedInvocations, n)
	mmPatchAccountByDTO.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPatchAccountByDTO
}

func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) invocationsDone() bool {
	if len(mmPatchAccountByDTO.expectations) == 0 && mmPatchAccountByDTO.defaultExpectation == nil && mmPatchAccountByDTO.mock.funcPatchAccountByDTO == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPatchAccountByDTO.mock.afterPatchAccountByDTOCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPatchAccountByDTO.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PatchAccountByDTO implements mm_usecase.AccountUsecase
func (mmPatchAccountByDTO *AccountUsecaseMock) PatchAccountByDTO(ctx context.Context, id uuid.UUID, in mm_usecase.PatchAccountDataInput, skipVersionCheck bool) (err error) {
	mm_atomic.AddUint64(&mmPatchAccountByDTO.beforePatchAccountByDTOCounter, 1)
	defer mm_atomic.AddUint64(&mmPatchAccountByDTO.afterPatchAccountByDTOCounter, 1)

	mmPatchAccountByDTO.t.Helper()

	if mmPatchAccountByDTO.inspectFuncPatchAccountByDTO != nil {
		mmPatchAccountByDTO.inspectFuncPatchAccountByDTO(ctx, id, in, skipVersionCheck)
	}

	mm_params := AccountUsecaseMockPatchAccountByDTOParams{ctx, id, in, skipVersionCheck}

	// Record call args
	mmPatchAccountByDTO.PatchAccountByDTOMock.mutex.Lock()
	mmPatchAccountByDTO.PatchAccountByDTOMock.callArgs = append(mmPatchAccountByDTO.PatchAccountByDTOMock.callArgs, &mm_params)
	mmPatchAccountByDTO.PatchAccountByDTOMock.mutex.Unlock()

	for _, e := range mmPatchAccountByDTO.PatchAccountByDTOMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPatchAccountByDTO.PatchAccountByDTOMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPatchAccountByDTO.PatchAccountByDTOMock.defaultExpectation.Counter, 1)
		mm_want := mmPatchAccountByDTO.PatchAccountByDTOMock.defaultExpectation.params
		mm_want_ptrs := mmPatchAccountByDTO.PatchAccountByDTOMock.defaultExpectation.paramPtrs

		mm_got := AccountUsecaseMockPatchAccountByDTOParams{ctx, id, in, skipVersionCheck}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPatchAccountByDTO.t.Errorf("AccountUsecaseMock.PatchAccountByDTO got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatchAccountByDTO.PatchAccountByDTOMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmPatchAccountByDTO.t.Errorf("AccountUsecaseMock.PatchAccountByDTO got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatchAccountByDTO.PatchAccountByDTOMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmPatchAccountByDTO.t.Errorf("AccountUsecaseMock.PatchAccountByDTO got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatchAccountByDTO.PatchAccountByDTOMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.skipVersionCheck != nil && !minimock.Equal(*mm_want_ptrs.skipVersionCheck, mm_got.skipVersionCheck) {
				mmPatchAccountByDTO.t.Errorf("AccountUsecaseMock.PatchAccountByDTO got unexpected parameter skipVersionCheck, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatchAccountByDTO.PatchAccountByDTOMock.defaultExpectation.expectationOrigins.originSkipVersionCheck, *mm_want_ptrs.skipVersionCheck, mm_got.skipVersionCheck, minimock.Diff(*mm_want_ptrs.skipVersionCheck, mm_got.skipVersionCheck))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPatchAccountByDTO.t.Errorf("AccountUsecaseMock.PatchAccountByDTO got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPatchAccountByDTO.PatchAccountByDTOMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPatchAccountByDTO.PatchAccountByDTOMock.defaultExpectation.results
		if mm_results == nil {
			mmPatchAccountByDTO.t.Fatal("No results are set for the AccountUsecaseMock.PatchAccountByDTO")
		}
		return (*mm_results).err
	}
	if mmPatchAccountByDTO.funcPatchAccountByDTO != nil {
		return mmPatchAccountByDTO.funcPatchAccountByDTO(ctx, id, in, skipVersionCheck)
	}
	mmPatchAccountByDTO.t.Fatalf("Unexpected call to AccountUsecaseMock.PatchAccountByDTO. %v %v %v %v", ctx, id, in, skipVersionCheck)
	return
}

// PatchAccountByDTOAfterCounter returns a count of finished AccountUsecaseMock.PatchAccountByDTO invocations
func (mmPatchAccountByDTO *AccountUsecaseMock) PatchAccountByDTOAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPatchAccountByDTO.afterPatchAccountByDTOCounter)
}

// PatchAccountByDTOBeforeCounter returns a count of AccountUsecaseMock.PatchAccountByDTO invocations
func (mmPatchAccountByDTO *AccountUsecaseMock) PatchAccountByDTOBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPatchAccountByDTO.beforePatchAccountByDTOCounter)
}

// Calls returns a list of arguments used in each call to AccountUsecaseMock.PatchAccountByDTO.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPatchAccountByDTO *mAccountUsecaseMockPatchAccountByDTO) Calls() []*AccountUsecaseMockPatchAccountByDTOParams {
	mmPatchAccountByDTO.mutex.RLock()

	argCopy := make([]*AccountUsecaseMockPatchAccountByDTOParams, len(mmPatchAccountByDTO.callArgs))
	copy(argCopy, mmPatchAccountByDTO.callArgs)

	mmPatchAccountByDTO.mutex.RUnlock()

	return argCopy
}

// MinimockPatchAccountByDTODone returns true if the count of the PatchAccountByDTO invocations corresponds
// the number of defined expectations
func (m *AccountUsecaseMock) MinimockPatchAccountByDTODone() bool {
	if m.PatchAccountByDTOMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PatchAccountByDTOMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PatchAccountByDTOMock.invocationsDone()
}

// MinimockPatchAccountByDTOInspect logs each unmet expectation
func (m *AccountUsecaseMock) MinimockPatchAccountByDTOInspect() {
	for _, e := range m.PatchAccountByDTOMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccountUsecaseMock.PatchAccountByDTO at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPatchAccountByDTOCounter := mm_atomic.LoadUint64(&m.afterPatchAccountByDTOCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PatchAccountByDTOMock.defaultExpectation != nil && afterPatchAccountByDTOCounter < 1 {
		if m.PatchAccountByDTOMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AccountUsecaseMock.PatchAccountByDTO at\n%s", m.PatchAccountByDTOMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AccountUsecaseMock.PatchAccountByDTO at\n%s with params: %#v", m.PatchAccountByDTOMock.defaultExpectation.expectationOrigins.origin, *m.PatchAccountByDTOMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPatchAccountByDTO != nil && afterPatchAccountByDTOCounter < 1 {
		m.t.Errorf("Expected call to AccountUsecaseMock.PatchAccountByDTO at\n%s", m.funcPatchAccountByDTOOrigin)
	}

	if !m.PatchAccountByDTOMock.invocationsDone() && afterPatchAccountByDTOCounter > 0 {
		m.t.Errorf("Expected %d calls to AccountUsecaseMock.PatchAccountByDTO at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PatchAccountByDTOMock.expectedInvocations), m.PatchAccountByDTOMock.expectedInvocationsOrigin, afterPatchAccountByDTOCounter)
	}
}

type mAccountUsecaseMockUpdateAccount struct {
	optional           bool
	mock               *AccountUsecaseMock
	defaultExpectation *AccountUsecaseMockUpdateAccountExpectation
	expectations       []*AccountUsecaseMockUpdateAccountExpectation

	callArgs []*AccountUsecaseMockUpdateAccountParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AccountUsecaseMockUpdateAccountExpectation specifies expectation struct of the AccountUsecase.UpdateAccount
type AccountUsecaseMockUpdateAccountExpectation struct {
	mock               *AccountUsecaseMock
	params             *AccountUsecaseMockUpdateAccountParams
	paramPtrs          *AccountUsecaseMockUpdateAccountParamPtrs
	expectationOrigins AccountUsecaseMockUpdateAccountExpectationOrigins
	results            *AccountUsecaseMockUpdateAccountResults
	returnOrigin       string
	Counter            uint64
}

// AccountUsecaseMockUpdateAccountParams contains parameters of the AccountUsecase.UpdateAccount
type AccountUsecaseMockUpdateAccountParams struct {
	ctx  context.Context
	item *entity.Account
}

// AccountUsecaseMockUpdateAccountParamPtrs contains pointers to parameters of the AccountUsecase.UpdateAccount
type AccountUsecaseMockUpdateAccountParamPtrs struct {
	ctx  *context.Context
	item **entity.Account
}

// AccountUsecaseMockUpdateAccountResults contains results of the AccountUsecase.UpdateAccount
type AccountUsecaseMockUpdateAccountResults struct {
	err error
}

// AccountUsecaseMockUpdateAccountOrigins contains origins of expectations of the AccountUsecase.UpdateAccount
type AccountUsecaseMockUpdateAccountExpectationOrigins struct {
	origin     string
	originCtx  string
	originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) Optional() *mAccountUsecaseMockUpdateAccount {
	mmUpdateAccount.optional = true
	return mmUpdateAccount
}

// Expect sets up expected params for AccountUsecase.UpdateAccount
func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) Expect(ctx context.Context, item *entity.Account) *mAccountUsecaseMockUpdateAccount {
	if mmUpdateAccount.mock.funcUpdateAccount != nil {
		mmUpdateAccount.mock.t.Fatalf("AccountUsecaseMock.UpdateAccount mock is already set by Set")
	}

	if mmUpdateAccount.defaultExpectation == nil {
		mmUpdateAccount.defaultExpectation = &AccountUsecaseMockUpdateAccountExpectation{}
	}

	if mmUpdateAccount.defaultExpectation.paramPtrs != nil {
		mmUpdateAccount.mock.t.Fatalf("AccountUsecaseMock.UpdateAccount mock is already set by ExpectParams functions")
	}

	mmUpdateAccount.defaultExpectation.params = &AccountUsecaseMockUpdateAccountParams{ctx, item}
	mmUpdateAccount.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateAccount.expectations {
		if minimock.Equal(e.params, mmUpdateAccount.defaultExpectation.params) {
			mmUpdateAccount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateAccount.defaultExpectation.params)
		}
	}

	return mmUpdateAccount
}

// ExpectCtxParam1 sets up expected param ctx for AccountUsecase.UpdateAccount
func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) ExpectCtxParam1(ctx context.Context) *mAccountUsecaseMockUpdateAccount {
	if mmUpdateAccount.mock.funcUpdateAccount != nil {
		mmUpdateAccount.mock.t.Fatalf("AccountUsecaseMock.UpdateAccount mock is already set by Set")
	}

	if mmUpdateAccount.defaultExpectation == nil {
		mmUpdateAccount.defaultExpectation = &AccountUsecaseMockUpdateAccountExpectation{}
	}

	if mmUpdateAccount.defaultExpectation.params != nil {
		mmUpdateAccount.mock.t.Fatalf("AccountUsecaseMock.UpdateAccount mock is already set by Expect")
	}

	if mmUpdateAccount.defaultExpectation.paramPtrs == nil {
		mmUpdateAccount.defaultExpectation.paramPtrs = &AccountUsecaseMockUpdateAccountParamPtrs{}
	}
	mmUpdateAccount.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateAccount.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateAccount
}

// ExpectItemParam2 sets up expected param item for AccountUsecase.UpdateAccount
func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) ExpectItemParam2(item *entity.Account) *mAccountUsecaseMockUpdateAccount {
	if mmUpdateAccount.mock.funcUpdateAccount != nil {
		mmUpdateAccount.mock.t.Fatalf("AccountUsecaseMock.UpdateAccount mock is already set by Set")
	}

	if mmUpdateAccount.defaultExpectation == nil {
		mmUpdateAccount.defaultExpectation = &AccountUsecaseMockUpdateAccountExpectation{}
	}

	if mmUpdateAccount.defaultExpectation.params != nil {
		mmUpdateAccount.mock.t.Fatalf("AccountUsecaseMock.UpdateAccount mock is already set by Expect")
	}

	if mmUpdateAccount.defaultExpectation.paramPtrs == nil {
		mmUpdateAccount.defaultExpectation.paramPtrs = &AccountUsecaseMockUpdateAccountParamPtrs{}
	}
	mmUpdateAccount.defaultExpectation.paramPtrs.item = &item
	mmUpdateAccount.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmUpdateAccount
}

// Inspect accepts an inspector function that has same arguments as the AccountUsecase.UpdateAccount
func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) Inspect(f func(ctx context.Context, item *entity.Account)) *mAccountUsecaseMockUpdateAccount {
	if mmUpdateAccount.mock.inspectFuncUpdateAccount != nil {
		mmUpdateAccount.mock.t.Fatalf("Inspect function is already set for AccountUsecaseMock.UpdateAccount")
	}

	mmUpdateAccount.mock.inspectFuncUpdateAccount = f

	return mmUpdateAccount
}

// Return sets up results that will be returned by AccountUsecase.UpdateAccount
func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) Return(err error) *AccountUsecaseMock {
	if mmUpdateAccount.mock.funcUpdateAccount != nil {
		mmUpdateAccount.mock.t.Fatalf("AccountUsecaseMock.UpdateAccount mock is already set by Set")
	}

	if mmUpdateAccount.defaultExpectation == nil {
		mmUpdateAccount.defaultExpectation = &AccountUsecaseMockUpdateAccountExpectation{mock: mmUpdateAccount.mock}
	}
	mmUpdateAccount.defaultExpectation.results = &AccountUsecaseMockUpdateAccountResults{err}
	mmUpdateAccount.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateAccount.mock
}

// Set uses given function f to mock the AccountUsecase.UpdateAccount method
func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) Set(f func(ctx context.Context, item *entity.Account) (err error)) *AccountUsecaseMock {
	if mmUpdateAccount.defaultExpectation != nil {
		mmUpdateAccount.mock.t.Fatalf("Default expectation is already set for the AccountUsecase.UpdateAccount method")
	}

	if len(mmUpdateAccount.expectations) > 0 {
		mmUpdateAccount.mock.t.Fatalf("Some expectations are already set for the AccountUsecase.UpdateAccount method")
	}

	mmUpdateAccount.mock.funcUpdateAccount = f
	mmUpdateAccount.mock.funcUpdateAccountOrigin = minimock.CallerInfo(1)
	return mmUpdateAccount.mock
}

// When sets expectation for the AccountUsecase.UpdateAccount which will trigger the result defined by the following
// Then helper
func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) When(ctx context.Context, item *entity.Account) *AccountUsecaseMockUpdateAccountExpectation {
	if mmUpdateAccount.mock.funcUpdateAccount != nil {
		mmUpdateAccount.mock.t.Fatalf("AccountUsecaseMock.UpdateAccount mock is already set by Set")
	}

	expectation := &AccountUsecaseMockUpdateAccountExpectation{
		mock:               mmUpdateAccount.mock,
		params:             &AccountUsecaseMockUpdateAccountParams{ctx, item},
		expectationOrigins: AccountUsecaseMockUpdateAccountExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateAccount.expectations = append(mmUpdateAccount.expectations, expectation)
	return expectation
}

// Then sets up AccountUsecase.UpdateAccount return parameters for the expectation previously defined by the When method
func (e *AccountUsecaseMockUpdateAccountExpectation) Then(err error) *AccountUsecaseMock {
	e.results = &AccountUsecaseMockUpdateAccountResults{err}
	return e.mock
}

// Times sets number of times AccountUsecase.UpdateAccount should be invoked
func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) Times(n uint64) *mAccountUsecaseMockUpdateAccount {
	if n == 0 {
		mmUpdateAccount.mock.t.Fatalf("Times of AccountUsecaseMock.UpdateAccount mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateAccount.expectedInvocations, n)
	mmUpdateAccount.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateAccount
}

func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) invocationsDone() bool {
	if len(mmUpdateAccount.expectations) == 0 && mmUpdateAccount.defaultExpectation == nil && mmUpdateAccount.mock.funcUpdateAccount == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateAccount.mock.afterUpdateAccountCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateAccount.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateAccount implements mm_usecase.AccountUsecase
func (mmUpdateAccount *AccountUsecaseMock) UpdateAccount(ctx context.Context, item *entity.Account) (err error) {
	mm_atomic.AddUint64(&mmUpdateAccount.beforeUpdateAccountCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateAccount.afterUpdateAccountCounter, 1)

	mmUpdateAccount.t.Helper()

	if mmUpdateAccount.inspectFuncUpdateAccount != nil {
		mmUpdateAccount.inspectFuncUpdateAccount(ctx, item)
	}

	mm_params := AccountUsecaseMockUpdateAccountParams{ctx, item}

	// Record call args
	mmUpdateAccount.UpdateAccountMock.mutex.Lock()
	mmUpdateAccount.UpdateAccountMock.callArgs = append(mmUpdateAccount.UpdateAccountMock.callArgs, &mm_params)
	mmUpdateAccount.UpdateAccountMock.mutex.Unlock()

	for _, e := range mmUpdateAccount.UpdateAccountMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateAccount.UpdateAccountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateAccount.UpdateAccountMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateAccount.UpdateAccountMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateAccount.UpdateAccountMock.defaultExpectation.paramPtrs

		mm_got := AccountUsecaseMockUpdateAccountParams{ctx, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateAccount.t.Errorf("AccountUsecaseMock.UpdateAccount got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateAccount.UpdateAccountMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmUpdateAccount.t.Errorf("AccountUsecaseMock.UpdateAccount got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateAccount.UpdateAccountMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateAccount.t.Errorf("AccountUsecaseMock.UpdateAccount got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateAccount.UpdateAccountMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateAccount.UpdateAccountMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateAccount.t.Fatal("No results are set for the AccountUsecaseMock.UpdateAccount")
		}
		return (*mm_results).err
	}
	if mmUpdateAccount.funcUpdateAccount != nil {
		return mmUpdateAccount.funcUpdateAccount(ctx, item)
	}
	mmUpdateAccount.t.Fatalf("Unexpected call to AccountUsecaseMock.UpdateAccount. %v %v", ctx, item)
	return
}

// UpdateAccountAfterCounter returns a count of finished AccountUsecaseMock.UpdateAccount invocations
func (mmUpdateAccount *AccountUsecaseMock) UpdateAccountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateAccount.afterUpdateAccountCounter)
}

// UpdateAccountBeforeCounter returns a count of AccountUsecaseMock.UpdateAccount invocations
func (mmUpdateAccount *AccountUsecaseMock) UpdateAccountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateAccount.beforeUpdateAccountCounter)
}

// Calls returns a list of arguments used in each call to AccountUsecaseMock.UpdateAccount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateAccount *mAccountUsecaseMockUpdateAccount) Calls() []*AccountUsecaseMockUpdateAccountParams {
	mmUpdateAccount.mutex.RLock()

	argCopy := make([]*AccountUsecaseMockUpdateAccountParams, len(mmUpdateAccount.callArgs))
	copy(argCopy, mmUpdateAccount.callArgs)

	mmUpdateAccount.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateAccountDone returns true if the count of the UpdateAccount invocations corresponds
// the number of defined expectations
func (m *AccountUsecaseMock) MinimockUpdateAccountDone() bool {
	if m.UpdateAccountMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateAccountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateAccountMock.invocationsDone()
}

// MinimockUpdateAccountInspect logs each unmet expectation
func (m *AccountUsecaseMock) MinimockUpdateAccountInspect() {
	for _, e := range m.UpdateAccountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccountUsecaseMock.UpdateAccount at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateAccountCounter := mm_atomic.LoadUint64(&m.afterUpdateAccountCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateAccountMock.defaultExpectation != nil && afterUpdateAccountCounter < 1 {
		if m.UpdateAccountMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AccountUsecaseMock.UpdateAccount at\n%s", m.UpdateAccountMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AccountUsecaseMock.UpdateAccount at\n%s with params: %#v", m.UpdateAccountMock.defaultExpectation.expectationOrigins.origin, *m.UpdateAccountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateAccount != nil && afterUpdateAccountCounter < 1 {
		m.t.Errorf("Expected call to AccountUsecaseMock.UpdateAccount at\n%s", m.funcUpdateAccountOrigin)
	}

	if !m.UpdateAccountMock.invocationsDone() && afterUpdateAccountCounter > 0 {
		m.t.Errorf("Expected %d calls to AccountUsecaseMock.UpdateAccount at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateAccountMock.expectedInvocations), m.UpdateAccountMock.expectedInvocationsOrigin, afterUpdateAccountCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AccountUsecaseMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateAccountByDTOInspect()

			m.MinimockFindListInspect()

			m.MinimockFindListInMapInspect()

			m.MinimockFindOneByEmailInspect()

			m.MinimockFindOneByIDInspect()

			m.MinimockFindPagedListInspect()

			m.MinimockPatchAccountByDTOInspect()

			m.MinimockUpdateAccountInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AccountUsecaseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AccountUsecaseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateAccountByDTODone() &&
		m.MinimockFindListDone() &&
		m.MinimockFindListInMapDone() &&
		m.MinimockFindOneByEmailDone() &&
		m.MinimockFindOneByIDDone() &&
		m.MinimockFindPagedListDone() &&
		m.MinimockPatchAccountByDTODone() &&
		m.MinimockUpdateAccountDone()
}
