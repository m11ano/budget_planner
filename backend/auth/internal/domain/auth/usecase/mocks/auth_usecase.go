// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase.AuthUsecase -o auth_usecase.go -n AuthUsecaseMock -p mocks

import (
	"context"
	"net"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
	"github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/entity"
	mm_usecase "github.com/m11ano/budget_planner/backend/auth/internal/domain/auth/usecase"
	"github.com/m11ano/budget_planner/backend/auth/pkg/auth"
)

// AuthUsecaseMock implements mm_usecase.AuthUsecase
type AuthUsecaseMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGenerateNewClaims          func(ctx context.Context, refresh *entity.SessionRefreshClaims, ip net.IP) (res *mm_usecase.AuthSessionDTO, err error)
	funcGenerateNewClaimsOrigin    string
	inspectFuncGenerateNewClaims   func(ctx context.Context, refresh *entity.SessionRefreshClaims, ip net.IP)
	afterGenerateNewClaimsCounter  uint64
	beforeGenerateNewClaimsCounter uint64
	GenerateNewClaimsMock          mAuthUsecaseMockGenerateNewClaims

	funcIsSessionConfirmed          func(ctx context.Context, sessionID uuid.UUID) (res bool, err error)
	funcIsSessionConfirmedOrigin    string
	inspectFuncIsSessionConfirmed   func(ctx context.Context, sessionID uuid.UUID)
	afterIsSessionConfirmedCounter  uint64
	beforeIsSessionConfirmedCounter uint64
	IsSessionConfirmedMock          mAuthUsecaseMockIsSessionConfirmed

	funcIssueAccessJWT          func(access *auth.SessionAccessClaims) (resToken string, err error)
	funcIssueAccessJWTOrigin    string
	inspectFuncIssueAccessJWT   func(access *auth.SessionAccessClaims)
	afterIssueAccessJWTCounter  uint64
	beforeIssueAccessJWTCounter uint64
	IssueAccessJWTMock          mAuthUsecaseMockIssueAccessJWT

	funcIssueRefreshJWT          func(refresh *entity.SessionRefreshClaims) (resToken string, err error)
	funcIssueRefreshJWTOrigin    string
	inspectFuncIssueRefreshJWT   func(refresh *entity.SessionRefreshClaims)
	afterIssueRefreshJWTCounter  uint64
	beforeIssueRefreshJWTCounter uint64
	IssueRefreshJWTMock          mAuthUsecaseMockIssueRefreshJWT

	funcLoginByEmail          func(ctx context.Context, email string, password string, ip net.IP) (res *mm_usecase.AuthSessionDTO, err error)
	funcLoginByEmailOrigin    string
	inspectFuncLoginByEmail   func(ctx context.Context, email string, password string, ip net.IP)
	afterLoginByEmailCounter  uint64
	beforeLoginByEmailCounter uint64
	LoginByEmailMock          mAuthUsecaseMockLoginByEmail

	funcParseRefreshToken          func(token string, validate bool) (res *entity.SessionRefreshClaims, err error)
	funcParseRefreshTokenOrigin    string
	inspectFuncParseRefreshToken   func(token string, validate bool)
	afterParseRefreshTokenCounter  uint64
	beforeParseRefreshTokenCounter uint64
	ParseRefreshTokenMock          mAuthUsecaseMockParseRefreshToken
}

// NewAuthUsecaseMock returns a mock for mm_usecase.AuthUsecase
func NewAuthUsecaseMock(t minimock.Tester) *AuthUsecaseMock {
	m := &AuthUsecaseMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GenerateNewClaimsMock = mAuthUsecaseMockGenerateNewClaims{mock: m}
	m.GenerateNewClaimsMock.callArgs = []*AuthUsecaseMockGenerateNewClaimsParams{}

	m.IsSessionConfirmedMock = mAuthUsecaseMockIsSessionConfirmed{mock: m}
	m.IsSessionConfirmedMock.callArgs = []*AuthUsecaseMockIsSessionConfirmedParams{}

	m.IssueAccessJWTMock = mAuthUsecaseMockIssueAccessJWT{mock: m}
	m.IssueAccessJWTMock.callArgs = []*AuthUsecaseMockIssueAccessJWTParams{}

	m.IssueRefreshJWTMock = mAuthUsecaseMockIssueRefreshJWT{mock: m}
	m.IssueRefreshJWTMock.callArgs = []*AuthUsecaseMockIssueRefreshJWTParams{}

	m.LoginByEmailMock = mAuthUsecaseMockLoginByEmail{mock: m}
	m.LoginByEmailMock.callArgs = []*AuthUsecaseMockLoginByEmailParams{}

	m.ParseRefreshTokenMock = mAuthUsecaseMockParseRefreshToken{mock: m}
	m.ParseRefreshTokenMock.callArgs = []*AuthUsecaseMockParseRefreshTokenParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAuthUsecaseMockGenerateNewClaims struct {
	optional           bool
	mock               *AuthUsecaseMock
	defaultExpectation *AuthUsecaseMockGenerateNewClaimsExpectation
	expectations       []*AuthUsecaseMockGenerateNewClaimsExpectation

	callArgs []*AuthUsecaseMockGenerateNewClaimsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthUsecaseMockGenerateNewClaimsExpectation specifies expectation struct of the AuthUsecase.GenerateNewClaims
type AuthUsecaseMockGenerateNewClaimsExpectation struct {
	mock               *AuthUsecaseMock
	params             *AuthUsecaseMockGenerateNewClaimsParams
	paramPtrs          *AuthUsecaseMockGenerateNewClaimsParamPtrs
	expectationOrigins AuthUsecaseMockGenerateNewClaimsExpectationOrigins
	results            *AuthUsecaseMockGenerateNewClaimsResults
	returnOrigin       string
	Counter            uint64
}

// AuthUsecaseMockGenerateNewClaimsParams contains parameters of the AuthUsecase.GenerateNewClaims
type AuthUsecaseMockGenerateNewClaimsParams struct {
	ctx     context.Context
	refresh *entity.SessionRefreshClaims
	ip      net.IP
}

// AuthUsecaseMockGenerateNewClaimsParamPtrs contains pointers to parameters of the AuthUsecase.GenerateNewClaims
type AuthUsecaseMockGenerateNewClaimsParamPtrs struct {
	ctx     *context.Context
	refresh **entity.SessionRefreshClaims
	ip      *net.IP
}

// AuthUsecaseMockGenerateNewClaimsResults contains results of the AuthUsecase.GenerateNewClaims
type AuthUsecaseMockGenerateNewClaimsResults struct {
	res *mm_usecase.AuthSessionDTO
	err error
}

// AuthUsecaseMockGenerateNewClaimsOrigins contains origins of expectations of the AuthUsecase.GenerateNewClaims
type AuthUsecaseMockGenerateNewClaimsExpectationOrigins struct {
	origin        string
	originCtx     string
	originRefresh string
	originIp      string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) Optional() *mAuthUsecaseMockGenerateNewClaims {
	mmGenerateNewClaims.optional = true
	return mmGenerateNewClaims
}

// Expect sets up expected params for AuthUsecase.GenerateNewClaims
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) Expect(ctx context.Context, refresh *entity.SessionRefreshClaims, ip net.IP) *mAuthUsecaseMockGenerateNewClaims {
	if mmGenerateNewClaims.mock.funcGenerateNewClaims != nil {
		mmGenerateNewClaims.mock.t.Fatalf("AuthUsecaseMock.GenerateNewClaims mock is already set by Set")
	}

	if mmGenerateNewClaims.defaultExpectation == nil {
		mmGenerateNewClaims.defaultExpectation = &AuthUsecaseMockGenerateNewClaimsExpectation{}
	}

	if mmGenerateNewClaims.defaultExpectation.paramPtrs != nil {
		mmGenerateNewClaims.mock.t.Fatalf("AuthUsecaseMock.GenerateNewClaims mock is already set by ExpectParams functions")
	}

	mmGenerateNewClaims.defaultExpectation.params = &AuthUsecaseMockGenerateNewClaimsParams{ctx, refresh, ip}
	mmGenerateNewClaims.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGenerateNewClaims.expectations {
		if minimock.Equal(e.params, mmGenerateNewClaims.defaultExpectation.params) {
			mmGenerateNewClaims.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGenerateNewClaims.defaultExpectation.params)
		}
	}

	return mmGenerateNewClaims
}

// ExpectCtxParam1 sets up expected param ctx for AuthUsecase.GenerateNewClaims
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) ExpectCtxParam1(ctx context.Context) *mAuthUsecaseMockGenerateNewClaims {
	if mmGenerateNewClaims.mock.funcGenerateNewClaims != nil {
		mmGenerateNewClaims.mock.t.Fatalf("AuthUsecaseMock.GenerateNewClaims mock is already set by Set")
	}

	if mmGenerateNewClaims.defaultExpectation == nil {
		mmGenerateNewClaims.defaultExpectation = &AuthUsecaseMockGenerateNewClaimsExpectation{}
	}

	if mmGenerateNewClaims.defaultExpectation.params != nil {
		mmGenerateNewClaims.mock.t.Fatalf("AuthUsecaseMock.GenerateNewClaims mock is already set by Expect")
	}

	if mmGenerateNewClaims.defaultExpectation.paramPtrs == nil {
		mmGenerateNewClaims.defaultExpectation.paramPtrs = &AuthUsecaseMockGenerateNewClaimsParamPtrs{}
	}
	mmGenerateNewClaims.defaultExpectation.paramPtrs.ctx = &ctx
	mmGenerateNewClaims.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGenerateNewClaims
}

// ExpectRefreshParam2 sets up expected param refresh for AuthUsecase.GenerateNewClaims
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) ExpectRefreshParam2(refresh *entity.SessionRefreshClaims) *mAuthUsecaseMockGenerateNewClaims {
	if mmGenerateNewClaims.mock.funcGenerateNewClaims != nil {
		mmGenerateNewClaims.mock.t.Fatalf("AuthUsecaseMock.GenerateNewClaims mock is already set by Set")
	}

	if mmGenerateNewClaims.defaultExpectation == nil {
		mmGenerateNewClaims.defaultExpectation = &AuthUsecaseMockGenerateNewClaimsExpectation{}
	}

	if mmGenerateNewClaims.defaultExpectation.params != nil {
		mmGenerateNewClaims.mock.t.Fatalf("AuthUsecaseMock.GenerateNewClaims mock is already set by Expect")
	}

	if mmGenerateNewClaims.defaultExpectation.paramPtrs == nil {
		mmGenerateNewClaims.defaultExpectation.paramPtrs = &AuthUsecaseMockGenerateNewClaimsParamPtrs{}
	}
	mmGenerateNewClaims.defaultExpectation.paramPtrs.refresh = &refresh
	mmGenerateNewClaims.defaultExpectation.expectationOrigins.originRefresh = minimock.CallerInfo(1)

	return mmGenerateNewClaims
}

// ExpectIpParam3 sets up expected param ip for AuthUsecase.GenerateNewClaims
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) ExpectIpParam3(ip net.IP) *mAuthUsecaseMockGenerateNewClaims {
	if mmGenerateNewClaims.mock.funcGenerateNewClaims != nil {
		mmGenerateNewClaims.mock.t.Fatalf("AuthUsecaseMock.GenerateNewClaims mock is already set by Set")
	}

	if mmGenerateNewClaims.defaultExpectation == nil {
		mmGenerateNewClaims.defaultExpectation = &AuthUsecaseMockGenerateNewClaimsExpectation{}
	}

	if mmGenerateNewClaims.defaultExpectation.params != nil {
		mmGenerateNewClaims.mock.t.Fatalf("AuthUsecaseMock.GenerateNewClaims mock is already set by Expect")
	}

	if mmGenerateNewClaims.defaultExpectation.paramPtrs == nil {
		mmGenerateNewClaims.defaultExpectation.paramPtrs = &AuthUsecaseMockGenerateNewClaimsParamPtrs{}
	}
	mmGenerateNewClaims.defaultExpectation.paramPtrs.ip = &ip
	mmGenerateNewClaims.defaultExpectation.expectationOrigins.originIp = minimock.CallerInfo(1)

	return mmGenerateNewClaims
}

// Inspect accepts an inspector function that has same arguments as the AuthUsecase.GenerateNewClaims
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) Inspect(f func(ctx context.Context, refresh *entity.SessionRefreshClaims, ip net.IP)) *mAuthUsecaseMockGenerateNewClaims {
	if mmGenerateNewClaims.mock.inspectFuncGenerateNewClaims != nil {
		mmGenerateNewClaims.mock.t.Fatalf("Inspect function is already set for AuthUsecaseMock.GenerateNewClaims")
	}

	mmGenerateNewClaims.mock.inspectFuncGenerateNewClaims = f

	return mmGenerateNewClaims
}

// Return sets up results that will be returned by AuthUsecase.GenerateNewClaims
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) Return(res *mm_usecase.AuthSessionDTO, err error) *AuthUsecaseMock {
	if mmGenerateNewClaims.mock.funcGenerateNewClaims != nil {
		mmGenerateNewClaims.mock.t.Fatalf("AuthUsecaseMock.GenerateNewClaims mock is already set by Set")
	}

	if mmGenerateNewClaims.defaultExpectation == nil {
		mmGenerateNewClaims.defaultExpectation = &AuthUsecaseMockGenerateNewClaimsExpectation{mock: mmGenerateNewClaims.mock}
	}
	mmGenerateNewClaims.defaultExpectation.results = &AuthUsecaseMockGenerateNewClaimsResults{res, err}
	mmGenerateNewClaims.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGenerateNewClaims.mock
}

// Set uses given function f to mock the AuthUsecase.GenerateNewClaims method
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) Set(f func(ctx context.Context, refresh *entity.SessionRefreshClaims, ip net.IP) (res *mm_usecase.AuthSessionDTO, err error)) *AuthUsecaseMock {
	if mmGenerateNewClaims.defaultExpectation != nil {
		mmGenerateNewClaims.mock.t.Fatalf("Default expectation is already set for the AuthUsecase.GenerateNewClaims method")
	}

	if len(mmGenerateNewClaims.expectations) > 0 {
		mmGenerateNewClaims.mock.t.Fatalf("Some expectations are already set for the AuthUsecase.GenerateNewClaims method")
	}

	mmGenerateNewClaims.mock.funcGenerateNewClaims = f
	mmGenerateNewClaims.mock.funcGenerateNewClaimsOrigin = minimock.CallerInfo(1)
	return mmGenerateNewClaims.mock
}

// When sets expectation for the AuthUsecase.GenerateNewClaims which will trigger the result defined by the following
// Then helper
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) When(ctx context.Context, refresh *entity.SessionRefreshClaims, ip net.IP) *AuthUsecaseMockGenerateNewClaimsExpectation {
	if mmGenerateNewClaims.mock.funcGenerateNewClaims != nil {
		mmGenerateNewClaims.mock.t.Fatalf("AuthUsecaseMock.GenerateNewClaims mock is already set by Set")
	}

	expectation := &AuthUsecaseMockGenerateNewClaimsExpectation{
		mock:               mmGenerateNewClaims.mock,
		params:             &AuthUsecaseMockGenerateNewClaimsParams{ctx, refresh, ip},
		expectationOrigins: AuthUsecaseMockGenerateNewClaimsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGenerateNewClaims.expectations = append(mmGenerateNewClaims.expectations, expectation)
	return expectation
}

// Then sets up AuthUsecase.GenerateNewClaims return parameters for the expectation previously defined by the When method
func (e *AuthUsecaseMockGenerateNewClaimsExpectation) Then(res *mm_usecase.AuthSessionDTO, err error) *AuthUsecaseMock {
	e.results = &AuthUsecaseMockGenerateNewClaimsResults{res, err}
	return e.mock
}

// Times sets number of times AuthUsecase.GenerateNewClaims should be invoked
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) Times(n uint64) *mAuthUsecaseMockGenerateNewClaims {
	if n == 0 {
		mmGenerateNewClaims.mock.t.Fatalf("Times of AuthUsecaseMock.GenerateNewClaims mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGenerateNewClaims.expectedInvocations, n)
	mmGenerateNewClaims.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGenerateNewClaims
}

func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) invocationsDone() bool {
	if len(mmGenerateNewClaims.expectations) == 0 && mmGenerateNewClaims.defaultExpectation == nil && mmGenerateNewClaims.mock.funcGenerateNewClaims == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGenerateNewClaims.mock.afterGenerateNewClaimsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGenerateNewClaims.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GenerateNewClaims implements mm_usecase.AuthUsecase
func (mmGenerateNewClaims *AuthUsecaseMock) GenerateNewClaims(ctx context.Context, refresh *entity.SessionRefreshClaims, ip net.IP) (res *mm_usecase.AuthSessionDTO, err error) {
	mm_atomic.AddUint64(&mmGenerateNewClaims.beforeGenerateNewClaimsCounter, 1)
	defer mm_atomic.AddUint64(&mmGenerateNewClaims.afterGenerateNewClaimsCounter, 1)

	mmGenerateNewClaims.t.Helper()

	if mmGenerateNewClaims.inspectFuncGenerateNewClaims != nil {
		mmGenerateNewClaims.inspectFuncGenerateNewClaims(ctx, refresh, ip)
	}

	mm_params := AuthUsecaseMockGenerateNewClaimsParams{ctx, refresh, ip}

	// Record call args
	mmGenerateNewClaims.GenerateNewClaimsMock.mutex.Lock()
	mmGenerateNewClaims.GenerateNewClaimsMock.callArgs = append(mmGenerateNewClaims.GenerateNewClaimsMock.callArgs, &mm_params)
	mmGenerateNewClaims.GenerateNewClaimsMock.mutex.Unlock()

	for _, e := range mmGenerateNewClaims.GenerateNewClaimsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.res, e.results.err
		}
	}

	if mmGenerateNewClaims.GenerateNewClaimsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGenerateNewClaims.GenerateNewClaimsMock.defaultExpectation.Counter, 1)
		mm_want := mmGenerateNewClaims.GenerateNewClaimsMock.defaultExpectation.params
		mm_want_ptrs := mmGenerateNewClaims.GenerateNewClaimsMock.defaultExpectation.paramPtrs

		mm_got := AuthUsecaseMockGenerateNewClaimsParams{ctx, refresh, ip}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGenerateNewClaims.t.Errorf("AuthUsecaseMock.GenerateNewClaims got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGenerateNewClaims.GenerateNewClaimsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.refresh != nil && !minimock.Equal(*mm_want_ptrs.refresh, mm_got.refresh) {
				mmGenerateNewClaims.t.Errorf("AuthUsecaseMock.GenerateNewClaims got unexpected parameter refresh, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGenerateNewClaims.GenerateNewClaimsMock.defaultExpectation.expectationOrigins.originRefresh, *mm_want_ptrs.refresh, mm_got.refresh, minimock.Diff(*mm_want_ptrs.refresh, mm_got.refresh))
			}

			if mm_want_ptrs.ip != nil && !minimock.Equal(*mm_want_ptrs.ip, mm_got.ip) {
				mmGenerateNewClaims.t.Errorf("AuthUsecaseMock.GenerateNewClaims got unexpected parameter ip, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGenerateNewClaims.GenerateNewClaimsMock.defaultExpectation.expectationOrigins.originIp, *mm_want_ptrs.ip, mm_got.ip, minimock.Diff(*mm_want_ptrs.ip, mm_got.ip))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGenerateNewClaims.t.Errorf("AuthUsecaseMock.GenerateNewClaims got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGenerateNewClaims.GenerateNewClaimsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGenerateNewClaims.GenerateNewClaimsMock.defaultExpectation.results
		if mm_results == nil {
			mmGenerateNewClaims.t.Fatal("No results are set for the AuthUsecaseMock.GenerateNewClaims")
		}
		return (*mm_results).res, (*mm_results).err
	}
	if mmGenerateNewClaims.funcGenerateNewClaims != nil {
		return mmGenerateNewClaims.funcGenerateNewClaims(ctx, refresh, ip)
	}
	mmGenerateNewClaims.t.Fatalf("Unexpected call to AuthUsecaseMock.GenerateNewClaims. %v %v %v", ctx, refresh, ip)
	return
}

// GenerateNewClaimsAfterCounter returns a count of finished AuthUsecaseMock.GenerateNewClaims invocations
func (mmGenerateNewClaims *AuthUsecaseMock) GenerateNewClaimsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateNewClaims.afterGenerateNewClaimsCounter)
}

// GenerateNewClaimsBeforeCounter returns a count of AuthUsecaseMock.GenerateNewClaims invocations
func (mmGenerateNewClaims *AuthUsecaseMock) GenerateNewClaimsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateNewClaims.beforeGenerateNewClaimsCounter)
}

// Calls returns a list of arguments used in each call to AuthUsecaseMock.GenerateNewClaims.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGenerateNewClaims *mAuthUsecaseMockGenerateNewClaims) Calls() []*AuthUsecaseMockGenerateNewClaimsParams {
	mmGenerateNewClaims.mutex.RLock()

	argCopy := make([]*AuthUsecaseMockGenerateNewClaimsParams, len(mmGenerateNewClaims.callArgs))
	copy(argCopy, mmGenerateNewClaims.callArgs)

	mmGenerateNewClaims.mutex.RUnlock()

	return argCopy
}

// MinimockGenerateNewClaimsDone returns true if the count of the GenerateNewClaims invocations corresponds
// the number of defined expectations
func (m *AuthUsecaseMock) MinimockGenerateNewClaimsDone() bool {
	if m.GenerateNewClaimsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GenerateNewClaimsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GenerateNewClaimsMock.invocationsDone()
}

// MinimockGenerateNewClaimsInspect logs each unmet expectation
func (m *AuthUsecaseMock) MinimockGenerateNewClaimsInspect() {
	for _, e := range m.GenerateNewClaimsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthUsecaseMock.GenerateNewClaims at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGenerateNewClaimsCounter := mm_atomic.LoadUint64(&m.afterGenerateNewClaimsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GenerateNewClaimsMock.defaultExpectation != nil && afterGenerateNewClaimsCounter < 1 {
		if m.GenerateNewClaimsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthUsecaseMock.GenerateNewClaims at\n%s", m.GenerateNewClaimsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthUsecaseMock.GenerateNewClaims at\n%s with params: %#v", m.GenerateNewClaimsMock.defaultExpectation.expectationOrigins.origin, *m.GenerateNewClaimsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGenerateNewClaims != nil && afterGenerateNewClaimsCounter < 1 {
		m.t.Errorf("Expected call to AuthUsecaseMock.GenerateNewClaims at\n%s", m.funcGenerateNewClaimsOrigin)
	}

	if !m.GenerateNewClaimsMock.invocationsDone() && afterGenerateNewClaimsCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthUsecaseMock.GenerateNewClaims at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GenerateNewClaimsMock.expectedInvocations), m.GenerateNewClaimsMock.expectedInvocationsOrigin, afterGenerateNewClaimsCounter)
	}
}

type mAuthUsecaseMockIsSessionConfirmed struct {
	optional           bool
	mock               *AuthUsecaseMock
	defaultExpectation *AuthUsecaseMockIsSessionConfirmedExpectation
	expectations       []*AuthUsecaseMockIsSessionConfirmedExpectation

	callArgs []*AuthUsecaseMockIsSessionConfirmedParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthUsecaseMockIsSessionConfirmedExpectation specifies expectation struct of the AuthUsecase.IsSessionConfirmed
type AuthUsecaseMockIsSessionConfirmedExpectation struct {
	mock               *AuthUsecaseMock
	params             *AuthUsecaseMockIsSessionConfirmedParams
	paramPtrs          *AuthUsecaseMockIsSessionConfirmedParamPtrs
	expectationOrigins AuthUsecaseMockIsSessionConfirmedExpectationOrigins
	results            *AuthUsecaseMockIsSessionConfirmedResults
	returnOrigin       string
	Counter            uint64
}

// AuthUsecaseMockIsSessionConfirmedParams contains parameters of the AuthUsecase.IsSessionConfirmed
type AuthUsecaseMockIsSessionConfirmedParams struct {
	ctx       context.Context
	sessionID uuid.UUID
}

// AuthUsecaseMockIsSessionConfirmedParamPtrs contains pointers to parameters of the AuthUsecase.IsSessionConfirmed
type AuthUsecaseMockIsSessionConfirmedParamPtrs struct {
	ctx       *context.Context
	sessionID *uuid.UUID
}

// AuthUsecaseMockIsSessionConfirmedResults contains results of the AuthUsecase.IsSessionConfirmed
type AuthUsecaseMockIsSessionConfirmedResults struct {
	res bool
	err error
}

// AuthUsecaseMockIsSessionConfirmedOrigins contains origins of expectations of the AuthUsecase.IsSessionConfirmed
type AuthUsecaseMockIsSessionConfirmedExpectationOrigins struct {
	origin          string
	originCtx       string
	originSessionID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) Optional() *mAuthUsecaseMockIsSessionConfirmed {
	mmIsSessionConfirmed.optional = true
	return mmIsSessionConfirmed
}

// Expect sets up expected params for AuthUsecase.IsSessionConfirmed
func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) Expect(ctx context.Context, sessionID uuid.UUID) *mAuthUsecaseMockIsSessionConfirmed {
	if mmIsSessionConfirmed.mock.funcIsSessionConfirmed != nil {
		mmIsSessionConfirmed.mock.t.Fatalf("AuthUsecaseMock.IsSessionConfirmed mock is already set by Set")
	}

	if mmIsSessionConfirmed.defaultExpectation == nil {
		mmIsSessionConfirmed.defaultExpectation = &AuthUsecaseMockIsSessionConfirmedExpectation{}
	}

	if mmIsSessionConfirmed.defaultExpectation.paramPtrs != nil {
		mmIsSessionConfirmed.mock.t.Fatalf("AuthUsecaseMock.IsSessionConfirmed mock is already set by ExpectParams functions")
	}

	mmIsSessionConfirmed.defaultExpectation.params = &AuthUsecaseMockIsSessionConfirmedParams{ctx, sessionID}
	mmIsSessionConfirmed.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsSessionConfirmed.expectations {
		if minimock.Equal(e.params, mmIsSessionConfirmed.defaultExpectation.params) {
			mmIsSessionConfirmed.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsSessionConfirmed.defaultExpectation.params)
		}
	}

	return mmIsSessionConfirmed
}

// ExpectCtxParam1 sets up expected param ctx for AuthUsecase.IsSessionConfirmed
func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) ExpectCtxParam1(ctx context.Context) *mAuthUsecaseMockIsSessionConfirmed {
	if mmIsSessionConfirmed.mock.funcIsSessionConfirmed != nil {
		mmIsSessionConfirmed.mock.t.Fatalf("AuthUsecaseMock.IsSessionConfirmed mock is already set by Set")
	}

	if mmIsSessionConfirmed.defaultExpectation == nil {
		mmIsSessionConfirmed.defaultExpectation = &AuthUsecaseMockIsSessionConfirmedExpectation{}
	}

	if mmIsSessionConfirmed.defaultExpectation.params != nil {
		mmIsSessionConfirmed.mock.t.Fatalf("AuthUsecaseMock.IsSessionConfirmed mock is already set by Expect")
	}

	if mmIsSessionConfirmed.defaultExpectation.paramPtrs == nil {
		mmIsSessionConfirmed.defaultExpectation.paramPtrs = &AuthUsecaseMockIsSessionConfirmedParamPtrs{}
	}
	mmIsSessionConfirmed.defaultExpectation.paramPtrs.ctx = &ctx
	mmIsSessionConfirmed.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIsSessionConfirmed
}

// ExpectSessionIDParam2 sets up expected param sessionID for AuthUsecase.IsSessionConfirmed
func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) ExpectSessionIDParam2(sessionID uuid.UUID) *mAuthUsecaseMockIsSessionConfirmed {
	if mmIsSessionConfirmed.mock.funcIsSessionConfirmed != nil {
		mmIsSessionConfirmed.mock.t.Fatalf("AuthUsecaseMock.IsSessionConfirmed mock is already set by Set")
	}

	if mmIsSessionConfirmed.defaultExpectation == nil {
		mmIsSessionConfirmed.defaultExpectation = &AuthUsecaseMockIsSessionConfirmedExpectation{}
	}

	if mmIsSessionConfirmed.defaultExpectation.params != nil {
		mmIsSessionConfirmed.mock.t.Fatalf("AuthUsecaseMock.IsSessionConfirmed mock is already set by Expect")
	}

	if mmIsSessionConfirmed.defaultExpectation.paramPtrs == nil {
		mmIsSessionConfirmed.defaultExpectation.paramPtrs = &AuthUsecaseMockIsSessionConfirmedParamPtrs{}
	}
	mmIsSessionConfirmed.defaultExpectation.paramPtrs.sessionID = &sessionID
	mmIsSessionConfirmed.defaultExpectation.expectationOrigins.originSessionID = minimock.CallerInfo(1)

	return mmIsSessionConfirmed
}

// Inspect accepts an inspector function that has same arguments as the AuthUsecase.IsSessionConfirmed
func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) Inspect(f func(ctx context.Context, sessionID uuid.UUID)) *mAuthUsecaseMockIsSessionConfirmed {
	if mmIsSessionConfirmed.mock.inspectFuncIsSessionConfirmed != nil {
		mmIsSessionConfirmed.mock.t.Fatalf("Inspect function is already set for AuthUsecaseMock.IsSessionConfirmed")
	}

	mmIsSessionConfirmed.mock.inspectFuncIsSessionConfirmed = f

	return mmIsSessionConfirmed
}

// Return sets up results that will be returned by AuthUsecase.IsSessionConfirmed
func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) Return(res bool, err error) *AuthUsecaseMock {
	if mmIsSessionConfirmed.mock.funcIsSessionConfirmed != nil {
		mmIsSessionConfirmed.mock.t.Fatalf("AuthUsecaseMock.IsSessionConfirmed mock is already set by Set")
	}

	if mmIsSessionConfirmed.defaultExpectation == nil {
		mmIsSessionConfirmed.defaultExpectation = &AuthUsecaseMockIsSessionConfirmedExpectation{mock: mmIsSessionConfirmed.mock}
	}
	mmIsSessionConfirmed.defaultExpectation.results = &AuthUsecaseMockIsSessionConfirmedResults{res, err}
	mmIsSessionConfirmed.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsSessionConfirmed.mock
}

// Set uses given function f to mock the AuthUsecase.IsSessionConfirmed method
func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) Set(f func(ctx context.Context, sessionID uuid.UUID) (res bool, err error)) *AuthUsecaseMock {
	if mmIsSessionConfirmed.defaultExpectation != nil {
		mmIsSessionConfirmed.mock.t.Fatalf("Default expectation is already set for the AuthUsecase.IsSessionConfirmed method")
	}

	if len(mmIsSessionConfirmed.expectations) > 0 {
		mmIsSessionConfirmed.mock.t.Fatalf("Some expectations are already set for the AuthUsecase.IsSessionConfirmed method")
	}

	mmIsSessionConfirmed.mock.funcIsSessionConfirmed = f
	mmIsSessionConfirmed.mock.funcIsSessionConfirmedOrigin = minimock.CallerInfo(1)
	return mmIsSessionConfirmed.mock
}

// When sets expectation for the AuthUsecase.IsSessionConfirmed which will trigger the result defined by the following
// Then helper
func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) When(ctx context.Context, sessionID uuid.UUID) *AuthUsecaseMockIsSessionConfirmedExpectation {
	if mmIsSessionConfirmed.mock.funcIsSessionConfirmed != nil {
		mmIsSessionConfirmed.mock.t.Fatalf("AuthUsecaseMock.IsSessionConfirmed mock is already set by Set")
	}

	expectation := &AuthUsecaseMockIsSessionConfirmedExpectation{
		mock:               mmIsSessionConfirmed.mock,
		params:             &AuthUsecaseMockIsSessionConfirmedParams{ctx, sessionID},
		expectationOrigins: AuthUsecaseMockIsSessionConfirmedExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsSessionConfirmed.expectations = append(mmIsSessionConfirmed.expectations, expectation)
	return expectation
}

// Then sets up AuthUsecase.IsSessionConfirmed return parameters for the expectation previously defined by the When method
func (e *AuthUsecaseMockIsSessionConfirmedExpectation) Then(res bool, err error) *AuthUsecaseMock {
	e.results = &AuthUsecaseMockIsSessionConfirmedResults{res, err}
	return e.mock
}

// Times sets number of times AuthUsecase.IsSessionConfirmed should be invoked
func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) Times(n uint64) *mAuthUsecaseMockIsSessionConfirmed {
	if n == 0 {
		mmIsSessionConfirmed.mock.t.Fatalf("Times of AuthUsecaseMock.IsSessionConfirmed mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsSessionConfirmed.expectedInvocations, n)
	mmIsSessionConfirmed.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsSessionConfirmed
}

func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) invocationsDone() bool {
	if len(mmIsSessionConfirmed.expectations) == 0 && mmIsSessionConfirmed.defaultExpectation == nil && mmIsSessionConfirmed.mock.funcIsSessionConfirmed == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsSessionConfirmed.mock.afterIsSessionConfirmedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsSessionConfirmed.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsSessionConfirmed implements mm_usecase.AuthUsecase
func (mmIsSessionConfirmed *AuthUsecaseMock) IsSessionConfirmed(ctx context.Context, sessionID uuid.UUID) (res bool, err error) {
	mm_atomic.AddUint64(&mmIsSessionConfirmed.beforeIsSessionConfirmedCounter, 1)
	defer mm_atomic.AddUint64(&mmIsSessionConfirmed.afterIsSessionConfirmedCounter, 1)

	mmIsSessionConfirmed.t.Helper()

	if mmIsSessionConfirmed.inspectFuncIsSessionConfirmed != nil {
		mmIsSessionConfirmed.inspectFuncIsSessionConfirmed(ctx, sessionID)
	}

	mm_params := AuthUsecaseMockIsSessionConfirmedParams{ctx, sessionID}

	// Record call args
	mmIsSessionConfirmed.IsSessionConfirmedMock.mutex.Lock()
	mmIsSessionConfirmed.IsSessionConfirmedMock.callArgs = append(mmIsSessionConfirmed.IsSessionConfirmedMock.callArgs, &mm_params)
	mmIsSessionConfirmed.IsSessionConfirmedMock.mutex.Unlock()

	for _, e := range mmIsSessionConfirmed.IsSessionConfirmedMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.res, e.results.err
		}
	}

	if mmIsSessionConfirmed.IsSessionConfirmedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsSessionConfirmed.IsSessionConfirmedMock.defaultExpectation.Counter, 1)
		mm_want := mmIsSessionConfirmed.IsSessionConfirmedMock.defaultExpectation.params
		mm_want_ptrs := mmIsSessionConfirmed.IsSessionConfirmedMock.defaultExpectation.paramPtrs

		mm_got := AuthUsecaseMockIsSessionConfirmedParams{ctx, sessionID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIsSessionConfirmed.t.Errorf("AuthUsecaseMock.IsSessionConfirmed got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsSessionConfirmed.IsSessionConfirmedMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sessionID != nil && !minimock.Equal(*mm_want_ptrs.sessionID, mm_got.sessionID) {
				mmIsSessionConfirmed.t.Errorf("AuthUsecaseMock.IsSessionConfirmed got unexpected parameter sessionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsSessionConfirmed.IsSessionConfirmedMock.defaultExpectation.expectationOrigins.originSessionID, *mm_want_ptrs.sessionID, mm_got.sessionID, minimock.Diff(*mm_want_ptrs.sessionID, mm_got.sessionID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsSessionConfirmed.t.Errorf("AuthUsecaseMock.IsSessionConfirmed got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsSessionConfirmed.IsSessionConfirmedMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsSessionConfirmed.IsSessionConfirmedMock.defaultExpectation.results
		if mm_results == nil {
			mmIsSessionConfirmed.t.Fatal("No results are set for the AuthUsecaseMock.IsSessionConfirmed")
		}
		return (*mm_results).res, (*mm_results).err
	}
	if mmIsSessionConfirmed.funcIsSessionConfirmed != nil {
		return mmIsSessionConfirmed.funcIsSessionConfirmed(ctx, sessionID)
	}
	mmIsSessionConfirmed.t.Fatalf("Unexpected call to AuthUsecaseMock.IsSessionConfirmed. %v %v", ctx, sessionID)
	return
}

// IsSessionConfirmedAfterCounter returns a count of finished AuthUsecaseMock.IsSessionConfirmed invocations
func (mmIsSessionConfirmed *AuthUsecaseMock) IsSessionConfirmedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsSessionConfirmed.afterIsSessionConfirmedCounter)
}

// IsSessionConfirmedBeforeCounter returns a count of AuthUsecaseMock.IsSessionConfirmed invocations
func (mmIsSessionConfirmed *AuthUsecaseMock) IsSessionConfirmedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsSessionConfirmed.beforeIsSessionConfirmedCounter)
}

// Calls returns a list of arguments used in each call to AuthUsecaseMock.IsSessionConfirmed.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsSessionConfirmed *mAuthUsecaseMockIsSessionConfirmed) Calls() []*AuthUsecaseMockIsSessionConfirmedParams {
	mmIsSessionConfirmed.mutex.RLock()

	argCopy := make([]*AuthUsecaseMockIsSessionConfirmedParams, len(mmIsSessionConfirmed.callArgs))
	copy(argCopy, mmIsSessionConfirmed.callArgs)

	mmIsSessionConfirmed.mutex.RUnlock()

	return argCopy
}

// MinimockIsSessionConfirmedDone returns true if the count of the IsSessionConfirmed invocations corresponds
// the number of defined expectations
func (m *AuthUsecaseMock) MinimockIsSessionConfirmedDone() bool {
	if m.IsSessionConfirmedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsSessionConfirmedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsSessionConfirmedMock.invocationsDone()
}

// MinimockIsSessionConfirmedInspect logs each unmet expectation
func (m *AuthUsecaseMock) MinimockIsSessionConfirmedInspect() {
	for _, e := range m.IsSessionConfirmedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthUsecaseMock.IsSessionConfirmed at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsSessionConfirmedCounter := mm_atomic.LoadUint64(&m.afterIsSessionConfirmedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsSessionConfirmedMock.defaultExpectation != nil && afterIsSessionConfirmedCounter < 1 {
		if m.IsSessionConfirmedMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthUsecaseMock.IsSessionConfirmed at\n%s", m.IsSessionConfirmedMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthUsecaseMock.IsSessionConfirmed at\n%s with params: %#v", m.IsSessionConfirmedMock.defaultExpectation.expectationOrigins.origin, *m.IsSessionConfirmedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsSessionConfirmed != nil && afterIsSessionConfirmedCounter < 1 {
		m.t.Errorf("Expected call to AuthUsecaseMock.IsSessionConfirmed at\n%s", m.funcIsSessionConfirmedOrigin)
	}

	if !m.IsSessionConfirmedMock.invocationsDone() && afterIsSessionConfirmedCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthUsecaseMock.IsSessionConfirmed at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsSessionConfirmedMock.expectedInvocations), m.IsSessionConfirmedMock.expectedInvocationsOrigin, afterIsSessionConfirmedCounter)
	}
}

type mAuthUsecaseMockIssueAccessJWT struct {
	optional           bool
	mock               *AuthUsecaseMock
	defaultExpectation *AuthUsecaseMockIssueAccessJWTExpectation
	expectations       []*AuthUsecaseMockIssueAccessJWTExpectation

	callArgs []*AuthUsecaseMockIssueAccessJWTParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthUsecaseMockIssueAccessJWTExpectation specifies expectation struct of the AuthUsecase.IssueAccessJWT
type AuthUsecaseMockIssueAccessJWTExpectation struct {
	mock               *AuthUsecaseMock
	params             *AuthUsecaseMockIssueAccessJWTParams
	paramPtrs          *AuthUsecaseMockIssueAccessJWTParamPtrs
	expectationOrigins AuthUsecaseMockIssueAccessJWTExpectationOrigins
	results            *AuthUsecaseMockIssueAccessJWTResults
	returnOrigin       string
	Counter            uint64
}

// AuthUsecaseMockIssueAccessJWTParams contains parameters of the AuthUsecase.IssueAccessJWT
type AuthUsecaseMockIssueAccessJWTParams struct {
	access *auth.SessionAccessClaims
}

// AuthUsecaseMockIssueAccessJWTParamPtrs contains pointers to parameters of the AuthUsecase.IssueAccessJWT
type AuthUsecaseMockIssueAccessJWTParamPtrs struct {
	access **auth.SessionAccessClaims
}

// AuthUsecaseMockIssueAccessJWTResults contains results of the AuthUsecase.IssueAccessJWT
type AuthUsecaseMockIssueAccessJWTResults struct {
	resToken string
	err      error
}

// AuthUsecaseMockIssueAccessJWTOrigins contains origins of expectations of the AuthUsecase.IssueAccessJWT
type AuthUsecaseMockIssueAccessJWTExpectationOrigins struct {
	origin       string
	originAccess string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIssueAccessJWT *mAuthUsecaseMockIssueAccessJWT) Optional() *mAuthUsecaseMockIssueAccessJWT {
	mmIssueAccessJWT.optional = true
	return mmIssueAccessJWT
}

// Expect sets up expected params for AuthUsecase.IssueAccessJWT
func (mmIssueAccessJWT *mAuthUsecaseMockIssueAccessJWT) Expect(access *auth.SessionAccessClaims) *mAuthUsecaseMockIssueAccessJWT {
	if mmIssueAccessJWT.mock.funcIssueAccessJWT != nil {
		mmIssueAccessJWT.mock.t.Fatalf("AuthUsecaseMock.IssueAccessJWT mock is already set by Set")
	}

	if mmIssueAccessJWT.defaultExpectation == nil {
		mmIssueAccessJWT.defaultExpectation = &AuthUsecaseMockIssueAccessJWTExpectation{}
	}

	if mmIssueAccessJWT.defaultExpectation.paramPtrs != nil {
		mmIssueAccessJWT.mock.t.Fatalf("AuthUsecaseMock.IssueAccessJWT mock is already set by ExpectParams functions")
	}

	mmIssueAccessJWT.defaultExpectation.params = &AuthUsecaseMockIssueAccessJWTParams{access}
	mmIssueAccessJWT.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIssueAccessJWT.expectations {
		if minimock.Equal(e.params, mmIssueAccessJWT.defaultExpectation.params) {
			mmIssueAccessJWT.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIssueAccessJWT.defaultExpectation.params)
		}
	}

	return mmIssueAccessJWT
}

// ExpectAccessParam1 sets up expected param access for AuthUsecase.IssueAccessJWT
func (mmIssueAccessJWT *mAuthUsecaseMockIssueAccessJWT) ExpectAccessParam1(access *auth.SessionAccessClaims) *mAuthUsecaseMockIssueAccessJWT {
	if mmIssueAccessJWT.mock.funcIssueAccessJWT != nil {
		mmIssueAccessJWT.mock.t.Fatalf("AuthUsecaseMock.IssueAccessJWT mock is already set by Set")
	}

	if mmIssueAccessJWT.defaultExpectation == nil {
		mmIssueAccessJWT.defaultExpectation = &AuthUsecaseMockIssueAccessJWTExpectation{}
	}

	if mmIssueAccessJWT.defaultExpectation.params != nil {
		mmIssueAccessJWT.mock.t.Fatalf("AuthUsecaseMock.IssueAccessJWT mock is already set by Expect")
	}

	if mmIssueAccessJWT.defaultExpectation.paramPtrs == nil {
		mmIssueAccessJWT.defaultExpectation.paramPtrs = &AuthUsecaseMockIssueAccessJWTParamPtrs{}
	}
	mmIssueAccessJWT.defaultExpectation.paramPtrs.access = &access
	mmIssueAccessJWT.defaultExpectation.expectationOrigins.originAccess = minimock.CallerInfo(1)

	return mmIssueAccessJWT
}

// Inspect accepts an inspector function that has same arguments as the AuthUsecase.IssueAccessJWT
func (mmIssueAccessJWT *mAuthUsecaseMockIssueAccessJWT) Inspect(f func(access *auth.SessionAccessClaims)) *mAuthUsecaseMockIssueAccessJWT {
	if mmIssueAccessJWT.mock.inspectFuncIssueAccessJWT != nil {
		mmIssueAccessJWT.mock.t.Fatalf("Inspect function is already set for AuthUsecaseMock.IssueAccessJWT")
	}

	mmIssueAccessJWT.mock.inspectFuncIssueAccessJWT = f

	return mmIssueAccessJWT
}

// Return sets up results that will be returned by AuthUsecase.IssueAccessJWT
func (mmIssueAccessJWT *mAuthUsecaseMockIssueAccessJWT) Return(resToken string, err error) *AuthUsecaseMock {
	if mmIssueAccessJWT.mock.funcIssueAccessJWT != nil {
		mmIssueAccessJWT.mock.t.Fatalf("AuthUsecaseMock.IssueAccessJWT mock is already set by Set")
	}

	if mmIssueAccessJWT.defaultExpectation == nil {
		mmIssueAccessJWT.defaultExpectation = &AuthUsecaseMockIssueAccessJWTExpectation{mock: mmIssueAccessJWT.mock}
	}
	mmIssueAccessJWT.defaultExpectation.results = &AuthUsecaseMockIssueAccessJWTResults{resToken, err}
	mmIssueAccessJWT.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIssueAccessJWT.mock
}

// Set uses given function f to mock the AuthUsecase.IssueAccessJWT method
func (mmIssueAccessJWT *mAuthUsecaseMockIssueAccessJWT) Set(f func(access *auth.SessionAccessClaims) (resToken string, err error)) *AuthUsecaseMock {
	if mmIssueAccessJWT.defaultExpectation != nil {
		mmIssueAccessJWT.mock.t.Fatalf("Default expectation is already set for the AuthUsecase.IssueAccessJWT method")
	}

	if len(mmIssueAccessJWT.expectations) > 0 {
		mmIssueAccessJWT.mock.t.Fatalf("Some expectations are already set for the AuthUsecase.IssueAccessJWT method")
	}

	mmIssueAccessJWT.mock.funcIssueAccessJWT = f
	mmIssueAccessJWT.mock.funcIssueAccessJWTOrigin = minimock.CallerInfo(1)
	return mmIssueAccessJWT.mock
}

// When sets expectation for the AuthUsecase.IssueAccessJWT which will trigger the result defined by the following
// Then helper
func (mmIssueAccessJWT *mAuthUsecaseMockIssueAccessJWT) When(access *auth.SessionAccessClaims) *AuthUsecaseMockIssueAccessJWTExpectation {
	if mmIssueAccessJWT.mock.funcIssueAccessJWT != nil {
		mmIssueAccessJWT.mock.t.Fatalf("AuthUsecaseMock.IssueAccessJWT mock is already set by Set")
	}

	expectation := &AuthUsecaseMockIssueAccessJWTExpectation{
		mock:               mmIssueAccessJWT.mock,
		params:             &AuthUsecaseMockIssueAccessJWTParams{access},
		expectationOrigins: AuthUsecaseMockIssueAccessJWTExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIssueAccessJWT.expectations = append(mmIssueAccessJWT.expectations, expectation)
	return expectation
}

// Then sets up AuthUsecase.IssueAccessJWT return parameters for the expectation previously defined by the When method
func (e *AuthUsecaseMockIssueAccessJWTExpectation) Then(resToken string, err error) *AuthUsecaseMock {
	e.results = &AuthUsecaseMockIssueAccessJWTResults{resToken, err}
	return e.mock
}

// Times sets number of times AuthUsecase.IssueAccessJWT should be invoked
func (mmIssueAccessJWT *mAuthUsecaseMockIssueAccessJWT) Times(n uint64) *mAuthUsecaseMockIssueAccessJWT {
	if n == 0 {
		mmIssueAccessJWT.mock.t.Fatalf("Times of AuthUsecaseMock.IssueAccessJWT mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIssueAccessJWT.expectedInvocations, n)
	mmIssueAccessJWT.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIssueAccessJWT
}

func (mmIssueAccessJWT *mAuthUsecaseMockIssueAccessJWT) invocationsDone() bool {
	if len(mmIssueAccessJWT.expectations) == 0 && mmIssueAccessJWT.defaultExpectation == nil && mmIssueAccessJWT.mock.funcIssueAccessJWT == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIssueAccessJWT.mock.afterIssueAccessJWTCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIssueAccessJWT.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IssueAccessJWT implements mm_usecase.AuthUsecase
func (mmIssueAccessJWT *AuthUsecaseMock) IssueAccessJWT(access *auth.SessionAccessClaims) (resToken string, err error) {
	mm_atomic.AddUint64(&mmIssueAccessJWT.beforeIssueAccessJWTCounter, 1)
	defer mm_atomic.AddUint64(&mmIssueAccessJWT.afterIssueAccessJWTCounter, 1)

	mmIssueAccessJWT.t.Helper()

	if mmIssueAccessJWT.inspectFuncIssueAccessJWT != nil {
		mmIssueAccessJWT.inspectFuncIssueAccessJWT(access)
	}

	mm_params := AuthUsecaseMockIssueAccessJWTParams{access}

	// Record call args
	mmIssueAccessJWT.IssueAccessJWTMock.mutex.Lock()
	mmIssueAccessJWT.IssueAccessJWTMock.callArgs = append(mmIssueAccessJWT.IssueAccessJWTMock.callArgs, &mm_params)
	mmIssueAccessJWT.IssueAccessJWTMock.mutex.Unlock()

	for _, e := range mmIssueAccessJWT.IssueAccessJWTMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resToken, e.results.err
		}
	}

	if mmIssueAccessJWT.IssueAccessJWTMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIssueAccessJWT.IssueAccessJWTMock.defaultExpectation.Counter, 1)
		mm_want := mmIssueAccessJWT.IssueAccessJWTMock.defaultExpectation.params
		mm_want_ptrs := mmIssueAccessJWT.IssueAccessJWTMock.defaultExpectation.paramPtrs

		mm_got := AuthUsecaseMockIssueAccessJWTParams{access}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.access != nil && !minimock.Equal(*mm_want_ptrs.access, mm_got.access) {
				mmIssueAccessJWT.t.Errorf("AuthUsecaseMock.IssueAccessJWT got unexpected parameter access, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIssueAccessJWT.IssueAccessJWTMock.defaultExpectation.expectationOrigins.originAccess, *mm_want_ptrs.access, mm_got.access, minimock.Diff(*mm_want_ptrs.access, mm_got.access))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIssueAccessJWT.t.Errorf("AuthUsecaseMock.IssueAccessJWT got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIssueAccessJWT.IssueAccessJWTMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIssueAccessJWT.IssueAccessJWTMock.defaultExpectation.results
		if mm_results == nil {
			mmIssueAccessJWT.t.Fatal("No results are set for the AuthUsecaseMock.IssueAccessJWT")
		}
		return (*mm_results).resToken, (*mm_results).err
	}
	if mmIssueAccessJWT.funcIssueAccessJWT != nil {
		return mmIssueAccessJWT.funcIssueAccessJWT(access)
	}
	mmIssueAccessJWT.t.Fatalf("Unexpected call to AuthUsecaseMock.IssueAccessJWT. %v", access)
	return
}

// IssueAccessJWTAfterCounter returns a count of finished AuthUsecaseMock.IssueAccessJWT invocations
func (mmIssueAccessJWT *AuthUsecaseMock) IssueAccessJWTAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIssueAccessJWT.afterIssueAccessJWTCounter)
}

// IssueAccessJWTBeforeCounter returns a count of AuthUsecaseMock.IssueAccessJWT invocations
func (mmIssueAccessJWT *AuthUsecaseMock) IssueAccessJWTBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIssueAccessJWT.beforeIssueAccessJWTCounter)
}

// Calls returns a list of arguments used in each call to AuthUsecaseMock.IssueAccessJWT.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIssueAccessJWT *mAuthUsecaseMockIssueAccessJWT) Calls() []*AuthUsecaseMockIssueAccessJWTParams {
	mmIssueAccessJWT.mutex.RLock()

	argCopy := make([]*AuthUsecaseMockIssueAccessJWTParams, len(mmIssueAccessJWT.callArgs))
	copy(argCopy, mmIssueAccessJWT.callArgs)

	mmIssueAccessJWT.mutex.RUnlock()

	return argCopy
}

// MinimockIssueAccessJWTDone returns true if the count of the IssueAccessJWT invocations corresponds
// the number of defined expectations
func (m *AuthUsecaseMock) MinimockIssueAccessJWTDone() bool {
	if m.IssueAccessJWTMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IssueAccessJWTMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IssueAccessJWTMock.invocationsDone()
}

// MinimockIssueAccessJWTInspect logs each unmet expectation
func (m *AuthUsecaseMock) MinimockIssueAccessJWTInspect() {
	for _, e := range m.IssueAccessJWTMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthUsecaseMock.IssueAccessJWT at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIssueAccessJWTCounter := mm_atomic.LoadUint64(&m.afterIssueAccessJWTCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IssueAccessJWTMock.defaultExpectation != nil && afterIssueAccessJWTCounter < 1 {
		if m.IssueAccessJWTMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthUsecaseMock.IssueAccessJWT at\n%s", m.IssueAccessJWTMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthUsecaseMock.IssueAccessJWT at\n%s with params: %#v", m.IssueAccessJWTMock.defaultExpectation.expectationOrigins.origin, *m.IssueAccessJWTMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIssueAccessJWT != nil && afterIssueAccessJWTCounter < 1 {
		m.t.Errorf("Expected call to AuthUsecaseMock.IssueAccessJWT at\n%s", m.funcIssueAccessJWTOrigin)
	}

	if !m.IssueAccessJWTMock.invocationsDone() && afterIssueAccessJWTCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthUsecaseMock.IssueAccessJWT at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IssueAccessJWTMock.expectedInvocations), m.IssueAccessJWTMock.expectedInvocationsOrigin, afterIssueAccessJWTCounter)
	}
}

type mAuthUsecaseMockIssueRefreshJWT struct {
	optional           bool
	mock               *AuthUsecaseMock
	defaultExpectation *AuthUsecaseMockIssueRefreshJWTExpectation
	expectations       []*AuthUsecaseMockIssueRefreshJWTExpectation

	callArgs []*AuthUsecaseMockIssueRefreshJWTParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthUsecaseMockIssueRefreshJWTExpectation specifies expectation struct of the AuthUsecase.IssueRefreshJWT
type AuthUsecaseMockIssueRefreshJWTExpectation struct {
	mock               *AuthUsecaseMock
	params             *AuthUsecaseMockIssueRefreshJWTParams
	paramPtrs          *AuthUsecaseMockIssueRefreshJWTParamPtrs
	expectationOrigins AuthUsecaseMockIssueRefreshJWTExpectationOrigins
	results            *AuthUsecaseMockIssueRefreshJWTResults
	returnOrigin       string
	Counter            uint64
}

// AuthUsecaseMockIssueRefreshJWTParams contains parameters of the AuthUsecase.IssueRefreshJWT
type AuthUsecaseMockIssueRefreshJWTParams struct {
	refresh *entity.SessionRefreshClaims
}

// AuthUsecaseMockIssueRefreshJWTParamPtrs contains pointers to parameters of the AuthUsecase.IssueRefreshJWT
type AuthUsecaseMockIssueRefreshJWTParamPtrs struct {
	refresh **entity.SessionRefreshClaims
}

// AuthUsecaseMockIssueRefreshJWTResults contains results of the AuthUsecase.IssueRefreshJWT
type AuthUsecaseMockIssueRefreshJWTResults struct {
	resToken string
	err      error
}

// AuthUsecaseMockIssueRefreshJWTOrigins contains origins of expectations of the AuthUsecase.IssueRefreshJWT
type AuthUsecaseMockIssueRefreshJWTExpectationOrigins struct {
	origin        string
	originRefresh string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIssueRefreshJWT *mAuthUsecaseMockIssueRefreshJWT) Optional() *mAuthUsecaseMockIssueRefreshJWT {
	mmIssueRefreshJWT.optional = true
	return mmIssueRefreshJWT
}

// Expect sets up expected params for AuthUsecase.IssueRefreshJWT
func (mmIssueRefreshJWT *mAuthUsecaseMockIssueRefreshJWT) Expect(refresh *entity.SessionRefreshClaims) *mAuthUsecaseMockIssueRefreshJWT {
	if mmIssueRefreshJWT.mock.funcIssueRefreshJWT != nil {
		mmIssueRefreshJWT.mock.t.Fatalf("AuthUsecaseMock.IssueRefreshJWT mock is already set by Set")
	}

	if mmIssueRefreshJWT.defaultExpectation == nil {
		mmIssueRefreshJWT.defaultExpectation = &AuthUsecaseMockIssueRefreshJWTExpectation{}
	}

	if mmIssueRefreshJWT.defaultExpectation.paramPtrs != nil {
		mmIssueRefreshJWT.mock.t.Fatalf("AuthUsecaseMock.IssueRefreshJWT mock is already set by ExpectParams functions")
	}

	mmIssueRefreshJWT.defaultExpectation.params = &AuthUsecaseMockIssueRefreshJWTParams{refresh}
	mmIssueRefreshJWT.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIssueRefreshJWT.expectations {
		if minimock.Equal(e.params, mmIssueRefreshJWT.defaultExpectation.params) {
			mmIssueRefreshJWT.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIssueRefreshJWT.defaultExpectation.params)
		}
	}

	return mmIssueRefreshJWT
}

// ExpectRefreshParam1 sets up expected param refresh for AuthUsecase.IssueRefreshJWT
func (mmIssueRefreshJWT *mAuthUsecaseMockIssueRefreshJWT) ExpectRefreshParam1(refresh *entity.SessionRefreshClaims) *mAuthUsecaseMockIssueRefreshJWT {
	if mmIssueRefreshJWT.mock.funcIssueRefreshJWT != nil {
		mmIssueRefreshJWT.mock.t.Fatalf("AuthUsecaseMock.IssueRefreshJWT mock is already set by Set")
	}

	if mmIssueRefreshJWT.defaultExpectation == nil {
		mmIssueRefreshJWT.defaultExpectation = &AuthUsecaseMockIssueRefreshJWTExpectation{}
	}

	if mmIssueRefreshJWT.defaultExpectation.params != nil {
		mmIssueRefreshJWT.mock.t.Fatalf("AuthUsecaseMock.IssueRefreshJWT mock is already set by Expect")
	}

	if mmIssueRefreshJWT.defaultExpectation.paramPtrs == nil {
		mmIssueRefreshJWT.defaultExpectation.paramPtrs = &AuthUsecaseMockIssueRefreshJWTParamPtrs{}
	}
	mmIssueRefreshJWT.defaultExpectation.paramPtrs.refresh = &refresh
	mmIssueRefreshJWT.defaultExpectation.expectationOrigins.originRefresh = minimock.CallerInfo(1)

	return mmIssueRefreshJWT
}

// Inspect accepts an inspector function that has same arguments as the AuthUsecase.IssueRefreshJWT
func (mmIssueRefreshJWT *mAuthUsecaseMockIssueRefreshJWT) Inspect(f func(refresh *entity.SessionRefreshClaims)) *mAuthUsecaseMockIssueRefreshJWT {
	if mmIssueRefreshJWT.mock.inspectFuncIssueRefreshJWT != nil {
		mmIssueRefreshJWT.mock.t.Fatalf("Inspect function is already set for AuthUsecaseMock.IssueRefreshJWT")
	}

	mmIssueRefreshJWT.mock.inspectFuncIssueRefreshJWT = f

	return mmIssueRefreshJWT
}

// Return sets up results that will be returned by AuthUsecase.IssueRefreshJWT
func (mmIssueRefreshJWT *mAuthUsecaseMockIssueRefreshJWT) Return(resToken string, err error) *AuthUsecaseMock {
	if mmIssueRefreshJWT.mock.funcIssueRefreshJWT != nil {
		mmIssueRefreshJWT.mock.t.Fatalf("AuthUsecaseMock.IssueRefreshJWT mock is already set by Set")
	}

	if mmIssueRefreshJWT.defaultExpectation == nil {
		mmIssueRefreshJWT.defaultExpectation = &AuthUsecaseMockIssueRefreshJWTExpectation{mock: mmIssueRefreshJWT.mock}
	}
	mmIssueRefreshJWT.defaultExpectation.results = &AuthUsecaseMockIssueRefreshJWTResults{resToken, err}
	mmIssueRefreshJWT.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIssueRefreshJWT.mock
}

// Set uses given function f to mock the AuthUsecase.IssueRefreshJWT method
func (mmIssueRefreshJWT *mAuthUsecaseMockIssueRefreshJWT) Set(f func(refresh *entity.SessionRefreshClaims) (resToken string, err error)) *AuthUsecaseMock {
	if mmIssueRefreshJWT.defaultExpectation != nil {
		mmIssueRefreshJWT.mock.t.Fatalf("Default expectation is already set for the AuthUsecase.IssueRefreshJWT method")
	}

	if len(mmIssueRefreshJWT.expectations) > 0 {
		mmIssueRefreshJWT.mock.t.Fatalf("Some expectations are already set for the AuthUsecase.IssueRefreshJWT method")
	}

	mmIssueRefreshJWT.mock.funcIssueRefreshJWT = f
	mmIssueRefreshJWT.mock.funcIssueRefreshJWTOrigin = minimock.CallerInfo(1)
	return mmIssueRefreshJWT.mock
}

// When sets expectation for the AuthUsecase.IssueRefreshJWT which will trigger the result defined by the following
// Then helper
func (mmIssueRefreshJWT *mAuthUsecaseMockIssueRefreshJWT) When(refresh *entity.SessionRefreshClaims) *AuthUsecaseMockIssueRefreshJWTExpectation {
	if mmIssueRefreshJWT.mock.funcIssueRefreshJWT != nil {
		mmIssueRefreshJWT.mock.t.Fatalf("AuthUsecaseMock.IssueRefreshJWT mock is already set by Set")
	}

	expectation := &AuthUsecaseMockIssueRefreshJWTExpectation{
		mock:               mmIssueRefreshJWT.mock,
		params:             &AuthUsecaseMockIssueRefreshJWTParams{refresh},
		expectationOrigins: AuthUsecaseMockIssueRefreshJWTExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIssueRefreshJWT.expectations = append(mmIssueRefreshJWT.expectations, expectation)
	return expectation
}

// Then sets up AuthUsecase.IssueRefreshJWT return parameters for the expectation previously defined by the When method
func (e *AuthUsecaseMockIssueRefreshJWTExpectation) Then(resToken string, err error) *AuthUsecaseMock {
	e.results = &AuthUsecaseMockIssueRefreshJWTResults{resToken, err}
	return e.mock
}

// Times sets number of times AuthUsecase.IssueRefreshJWT should be invoked
func (mmIssueRefreshJWT *mAuthUsecaseMockIssueRefreshJWT) Times(n uint64) *mAuthUsecaseMockIssueRefreshJWT {
	if n == 0 {
		mmIssueRefreshJWT.mock.t.Fatalf("Times of AuthUsecaseMock.IssueRefreshJWT mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIssueRefreshJWT.expectedInvocations, n)
	mmIssueRefreshJWT.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIssueRefreshJWT
}

func (mmIssueRefreshJWT *mAuthUsecaseMockIssueRefreshJWT) invocationsDone() bool {
	if len(mmIssueRefreshJWT.expectations) == 0 && mmIssueRefreshJWT.defaultExpectation == nil && mmIssueRefreshJWT.mock.funcIssueRefreshJWT == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIssueRefreshJWT.mock.afterIssueRefreshJWTCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIssueRefreshJWT.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IssueRefreshJWT implements mm_usecase.AuthUsecase
func (mmIssueRefreshJWT *AuthUsecaseMock) IssueRefreshJWT(refresh *entity.SessionRefreshClaims) (resToken string, err error) {
	mm_atomic.AddUint64(&mmIssueRefreshJWT.beforeIssueRefreshJWTCounter, 1)
	defer mm_atomic.AddUint64(&mmIssueRefreshJWT.afterIssueRefreshJWTCounter, 1)

	mmIssueRefreshJWT.t.Helper()

	if mmIssueRefreshJWT.inspectFuncIssueRefreshJWT != nil {
		mmIssueRefreshJWT.inspectFuncIssueRefreshJWT(refresh)
	}

	mm_params := AuthUsecaseMockIssueRefreshJWTParams{refresh}

	// Record call args
	mmIssueRefreshJWT.IssueRefreshJWTMock.mutex.Lock()
	mmIssueRefreshJWT.IssueRefreshJWTMock.callArgs = append(mmIssueRefreshJWT.IssueRefreshJWTMock.callArgs, &mm_params)
	mmIssueRefreshJWT.IssueRefreshJWTMock.mutex.Unlock()

	for _, e := range mmIssueRefreshJWT.IssueRefreshJWTMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resToken, e.results.err
		}
	}

	if mmIssueRefreshJWT.IssueRefreshJWTMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIssueRefreshJWT.IssueRefreshJWTMock.defaultExpectation.Counter, 1)
		mm_want := mmIssueRefreshJWT.IssueRefreshJWTMock.defaultExpectation.params
		mm_want_ptrs := mmIssueRefreshJWT.IssueRefreshJWTMock.defaultExpectation.paramPtrs

		mm_got := AuthUsecaseMockIssueRefreshJWTParams{refresh}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.refresh != nil && !minimock.Equal(*mm_want_ptrs.refresh, mm_got.refresh) {
				mmIssueRefreshJWT.t.Errorf("AuthUsecaseMock.IssueRefreshJWT got unexpected parameter refresh, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIssueRefreshJWT.IssueRefreshJWTMock.defaultExpectation.expectationOrigins.originRefresh, *mm_want_ptrs.refresh, mm_got.refresh, minimock.Diff(*mm_want_ptrs.refresh, mm_got.refresh))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIssueRefreshJWT.t.Errorf("AuthUsecaseMock.IssueRefreshJWT got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIssueRefreshJWT.IssueRefreshJWTMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIssueRefreshJWT.IssueRefreshJWTMock.defaultExpectation.results
		if mm_results == nil {
			mmIssueRefreshJWT.t.Fatal("No results are set for the AuthUsecaseMock.IssueRefreshJWT")
		}
		return (*mm_results).resToken, (*mm_results).err
	}
	if mmIssueRefreshJWT.funcIssueRefreshJWT != nil {
		return mmIssueRefreshJWT.funcIssueRefreshJWT(refresh)
	}
	mmIssueRefreshJWT.t.Fatalf("Unexpected call to AuthUsecaseMock.IssueRefreshJWT. %v", refresh)
	return
}

// IssueRefreshJWTAfterCounter returns a count of finished AuthUsecaseMock.IssueRefreshJWT invocations
func (mmIssueRefreshJWT *AuthUsecaseMock) IssueRefreshJWTAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIssueRefreshJWT.afterIssueRefreshJWTCounter)
}

// IssueRefreshJWTBeforeCounter returns a count of AuthUsecaseMock.IssueRefreshJWT invocations
func (mmIssueRefreshJWT *AuthUsecaseMock) IssueRefreshJWTBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIssueRefreshJWT.beforeIssueRefreshJWTCounter)
}

// Calls returns a list of arguments used in each call to AuthUsecaseMock.IssueRefreshJWT.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIssueRefreshJWT *mAuthUsecaseMockIssueRefreshJWT) Calls() []*AuthUsecaseMockIssueRefreshJWTParams {
	mmIssueRefreshJWT.mutex.RLock()

	argCopy := make([]*AuthUsecaseMockIssueRefreshJWTParams, len(mmIssueRefreshJWT.callArgs))
	copy(argCopy, mmIssueRefreshJWT.callArgs)

	mmIssueRefreshJWT.mutex.RUnlock()

	return argCopy
}

// MinimockIssueRefreshJWTDone returns true if the count of the IssueRefreshJWT invocations corresponds
// the number of defined expectations
func (m *AuthUsecaseMock) MinimockIssueRefreshJWTDone() bool {
	if m.IssueRefreshJWTMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IssueRefreshJWTMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IssueRefreshJWTMock.invocationsDone()
}

// MinimockIssueRefreshJWTInspect logs each unmet expectation
func (m *AuthUsecaseMock) MinimockIssueRefreshJWTInspect() {
	for _, e := range m.IssueRefreshJWTMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthUsecaseMock.IssueRefreshJWT at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIssueRefreshJWTCounter := mm_atomic.LoadUint64(&m.afterIssueRefreshJWTCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IssueRefreshJWTMock.defaultExpectation != nil && afterIssueRefreshJWTCounter < 1 {
		if m.IssueRefreshJWTMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthUsecaseMock.IssueRefreshJWT at\n%s", m.IssueRefreshJWTMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthUsecaseMock.IssueRefreshJWT at\n%s with params: %#v", m.IssueRefreshJWTMock.defaultExpectation.expectationOrigins.origin, *m.IssueRefreshJWTMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIssueRefreshJWT != nil && afterIssueRefreshJWTCounter < 1 {
		m.t.Errorf("Expected call to AuthUsecaseMock.IssueRefreshJWT at\n%s", m.funcIssueRefreshJWTOrigin)
	}

	if !m.IssueRefreshJWTMock.invocationsDone() && afterIssueRefreshJWTCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthUsecaseMock.IssueRefreshJWT at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IssueRefreshJWTMock.expectedInvocations), m.IssueRefreshJWTMock.expectedInvocationsOrigin, afterIssueRefreshJWTCounter)
	}
}

type mAuthUsecaseMockLoginByEmail struct {
	optional           bool
	mock               *AuthUsecaseMock
	defaultExpectation *AuthUsecaseMockLoginByEmailExpectation
	expectations       []*AuthUsecaseMockLoginByEmailExpectation

	callArgs []*AuthUsecaseMockLoginByEmailParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthUsecaseMockLoginByEmailExpectation specifies expectation struct of the AuthUsecase.LoginByEmail
type AuthUsecaseMockLoginByEmailExpectation struct {
	mock               *AuthUsecaseMock
	params             *AuthUsecaseMockLoginByEmailParams
	paramPtrs          *AuthUsecaseMockLoginByEmailParamPtrs
	expectationOrigins AuthUsecaseMockLoginByEmailExpectationOrigins
	results            *AuthUsecaseMockLoginByEmailResults
	returnOrigin       string
	Counter            uint64
}

// AuthUsecaseMockLoginByEmailParams contains parameters of the AuthUsecase.LoginByEmail
type AuthUsecaseMockLoginByEmailParams struct {
	ctx      context.Context
	email    string
	password string
	ip       net.IP
}

// AuthUsecaseMockLoginByEmailParamPtrs contains pointers to parameters of the AuthUsecase.LoginByEmail
type AuthUsecaseMockLoginByEmailParamPtrs struct {
	ctx      *context.Context
	email    *string
	password *string
	ip       *net.IP
}

// AuthUsecaseMockLoginByEmailResults contains results of the AuthUsecase.LoginByEmail
type AuthUsecaseMockLoginByEmailResults struct {
	res *mm_usecase.AuthSessionDTO
	err error
}

// AuthUsecaseMockLoginByEmailOrigins contains origins of expectations of the AuthUsecase.LoginByEmail
type AuthUsecaseMockLoginByEmailExpectationOrigins struct {
	origin         string
	originCtx      string
	originEmail    string
	originPassword string
	originIp       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) Optional() *mAuthUsecaseMockLoginByEmail {
	mmLoginByEmail.optional = true
	return mmLoginByEmail
}

// Expect sets up expected params for AuthUsecase.LoginByEmail
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) Expect(ctx context.Context, email string, password string, ip net.IP) *mAuthUsecaseMockLoginByEmail {
	if mmLoginByEmail.mock.funcLoginByEmail != nil {
		mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Set")
	}

	if mmLoginByEmail.defaultExpectation == nil {
		mmLoginByEmail.defaultExpectation = &AuthUsecaseMockLoginByEmailExpectation{}
	}

	if mmLoginByEmail.defaultExpectation.paramPtrs != nil {
		mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by ExpectParams functions")
	}

	mmLoginByEmail.defaultExpectation.params = &AuthUsecaseMockLoginByEmailParams{ctx, email, password, ip}
	mmLoginByEmail.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLoginByEmail.expectations {
		if minimock.Equal(e.params, mmLoginByEmail.defaultExpectation.params) {
			mmLoginByEmail.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLoginByEmail.defaultExpectation.params)
		}
	}

	return mmLoginByEmail
}

// ExpectCtxParam1 sets up expected param ctx for AuthUsecase.LoginByEmail
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) ExpectCtxParam1(ctx context.Context) *mAuthUsecaseMockLoginByEmail {
	if mmLoginByEmail.mock.funcLoginByEmail != nil {
		mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Set")
	}

	if mmLoginByEmail.defaultExpectation == nil {
		mmLoginByEmail.defaultExpectation = &AuthUsecaseMockLoginByEmailExpectation{}
	}

	if mmLoginByEmail.defaultExpectation.params != nil {
		mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Expect")
	}

	if mmLoginByEmail.defaultExpectation.paramPtrs == nil {
		mmLoginByEmail.defaultExpectation.paramPtrs = &AuthUsecaseMockLoginByEmailParamPtrs{}
	}
	mmLoginByEmail.defaultExpectation.paramPtrs.ctx = &ctx
	mmLoginByEmail.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLoginByEmail
}

// ExpectEmailParam2 sets up expected param email for AuthUsecase.LoginByEmail
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) ExpectEmailParam2(email string) *mAuthUsecaseMockLoginByEmail {
	if mmLoginByEmail.mock.funcLoginByEmail != nil {
		mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Set")
	}

	if mmLoginByEmail.defaultExpectation == nil {
		mmLoginByEmail.defaultExpectation = &AuthUsecaseMockLoginByEmailExpectation{}
	}

	if mmLoginByEmail.defaultExpectation.params != nil {
		mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Expect")
	}

	if mmLoginByEmail.defaultExpectation.paramPtrs == nil {
		mmLoginByEmail.defaultExpectation.paramPtrs = &AuthUsecaseMockLoginByEmailParamPtrs{}
	}
	mmLoginByEmail.defaultExpectation.paramPtrs.email = &email
	mmLoginByEmail.defaultExpectation.expectationOrigins.originEmail = minimock.CallerInfo(1)

	return mmLoginByEmail
}

// ExpectPasswordParam3 sets up expected param password for AuthUsecase.LoginByEmail
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) ExpectPasswordParam3(password string) *mAuthUsecaseMockLoginByEmail {
	if mmLoginByEmail.mock.funcLoginByEmail != nil {
		mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Set")
	}

	if mmLoginByEmail.defaultExpectation == nil {
		mmLoginByEmail.defaultExpectation = &AuthUsecaseMockLoginByEmailExpectation{}
	}

	if mmLoginByEmail.defaultExpectation.params != nil {
		mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Expect")
	}

	if mmLoginByEmail.defaultExpectation.paramPtrs == nil {
		mmLoginByEmail.defaultExpectation.paramPtrs = &AuthUsecaseMockLoginByEmailParamPtrs{}
	}
	mmLoginByEmail.defaultExpectation.paramPtrs.password = &password
	mmLoginByEmail.defaultExpectation.expectationOrigins.originPassword = minimock.CallerInfo(1)

	return mmLoginByEmail
}

// ExpectIpParam4 sets up expected param ip for AuthUsecase.LoginByEmail
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) ExpectIpParam4(ip net.IP) *mAuthUsecaseMockLoginByEmail {
	if mmLoginByEmail.mock.funcLoginByEmail != nil {
		mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Set")
	}

	if mmLoginByEmail.defaultExpectation == nil {
		mmLoginByEmail.defaultExpectation = &AuthUsecaseMockLoginByEmailExpectation{}
	}

	if mmLoginByEmail.defaultExpectation.params != nil {
		mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Expect")
	}

	if mmLoginByEmail.defaultExpectation.paramPtrs == nil {
		mmLoginByEmail.defaultExpectation.paramPtrs = &AuthUsecaseMockLoginByEmailParamPtrs{}
	}
	mmLoginByEmail.defaultExpectation.paramPtrs.ip = &ip
	mmLoginByEmail.defaultExpectation.expectationOrigins.originIp = minimock.CallerInfo(1)

	return mmLoginByEmail
}

// Inspect accepts an inspector function that has same arguments as the AuthUsecase.LoginByEmail
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) Inspect(f func(ctx context.Context, email string, password string, ip net.IP)) *mAuthUsecaseMockLoginByEmail {
	if mmLoginByEmail.mock.inspectFuncLoginByEmail != nil {
		mmLoginByEmail.mock.t.Fatalf("Inspect function is already set for AuthUsecaseMock.LoginByEmail")
	}

	mmLoginByEmail.mock.inspectFuncLoginByEmail = f

	return mmLoginByEmail
}

// Return sets up results that will be returned by AuthUsecase.LoginByEmail
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) Return(res *mm_usecase.AuthSessionDTO, err error) *AuthUsecaseMock {
	if mmLoginByEmail.mock.funcLoginByEmail != nil {
		mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Set")
	}

	if mmLoginByEmail.defaultExpectation == nil {
		mmLoginByEmail.defaultExpectation = &AuthUsecaseMockLoginByEmailExpectation{mock: mmLoginByEmail.mock}
	}
	mmLoginByEmail.defaultExpectation.results = &AuthUsecaseMockLoginByEmailResults{res, err}
	mmLoginByEmail.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLoginByEmail.mock
}

// Set uses given function f to mock the AuthUsecase.LoginByEmail method
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) Set(f func(ctx context.Context, email string, password string, ip net.IP) (res *mm_usecase.AuthSessionDTO, err error)) *AuthUsecaseMock {
	if mmLoginByEmail.defaultExpectation != nil {
		mmLoginByEmail.mock.t.Fatalf("Default expectation is already set for the AuthUsecase.LoginByEmail method")
	}

	if len(mmLoginByEmail.expectations) > 0 {
		mmLoginByEmail.mock.t.Fatalf("Some expectations are already set for the AuthUsecase.LoginByEmail method")
	}

	mmLoginByEmail.mock.funcLoginByEmail = f
	mmLoginByEmail.mock.funcLoginByEmailOrigin = minimock.CallerInfo(1)
	return mmLoginByEmail.mock
}

// When sets expectation for the AuthUsecase.LoginByEmail which will trigger the result defined by the following
// Then helper
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) When(ctx context.Context, email string, password string, ip net.IP) *AuthUsecaseMockLoginByEmailExpectation {
	if mmLoginByEmail.mock.funcLoginByEmail != nil {
		mmLoginByEmail.mock.t.Fatalf("AuthUsecaseMock.LoginByEmail mock is already set by Set")
	}

	expectation := &AuthUsecaseMockLoginByEmailExpectation{
		mock:               mmLoginByEmail.mock,
		params:             &AuthUsecaseMockLoginByEmailParams{ctx, email, password, ip},
		expectationOrigins: AuthUsecaseMockLoginByEmailExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLoginByEmail.expectations = append(mmLoginByEmail.expectations, expectation)
	return expectation
}

// Then sets up AuthUsecase.LoginByEmail return parameters for the expectation previously defined by the When method
func (e *AuthUsecaseMockLoginByEmailExpectation) Then(res *mm_usecase.AuthSessionDTO, err error) *AuthUsecaseMock {
	e.results = &AuthUsecaseMockLoginByEmailResults{res, err}
	return e.mock
}

// Times sets number of times AuthUsecase.LoginByEmail should be invoked
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) Times(n uint64) *mAuthUsecaseMockLoginByEmail {
	if n == 0 {
		mmLoginByEmail.mock.t.Fatalf("Times of AuthUsecaseMock.LoginByEmail mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLoginByEmail.expectedInvocations, n)
	mmLoginByEmail.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLoginByEmail
}

func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) invocationsDone() bool {
	if len(mmLoginByEmail.expectations) == 0 && mmLoginByEmail.defaultExpectation == nil && mmLoginByEmail.mock.funcLoginByEmail == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLoginByEmail.mock.afterLoginByEmailCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLoginByEmail.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// LoginByEmail implements mm_usecase.AuthUsecase
func (mmLoginByEmail *AuthUsecaseMock) LoginByEmail(ctx context.Context, email string, password string, ip net.IP) (res *mm_usecase.AuthSessionDTO, err error) {
	mm_atomic.AddUint64(&mmLoginByEmail.beforeLoginByEmailCounter, 1)
	defer mm_atomic.AddUint64(&mmLoginByEmail.afterLoginByEmailCounter, 1)

	mmLoginByEmail.t.Helper()

	if mmLoginByEmail.inspectFuncLoginByEmail != nil {
		mmLoginByEmail.inspectFuncLoginByEmail(ctx, email, password, ip)
	}

	mm_params := AuthUsecaseMockLoginByEmailParams{ctx, email, password, ip}

	// Record call args
	mmLoginByEmail.LoginByEmailMock.mutex.Lock()
	mmLoginByEmail.LoginByEmailMock.callArgs = append(mmLoginByEmail.LoginByEmailMock.callArgs, &mm_params)
	mmLoginByEmail.LoginByEmailMock.mutex.Unlock()

	for _, e := range mmLoginByEmail.LoginByEmailMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.res, e.results.err
		}
	}

	if mmLoginByEmail.LoginByEmailMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLoginByEmail.LoginByEmailMock.defaultExpectation.Counter, 1)
		mm_want := mmLoginByEmail.LoginByEmailMock.defaultExpectation.params
		mm_want_ptrs := mmLoginByEmail.LoginByEmailMock.defaultExpectation.paramPtrs

		mm_got := AuthUsecaseMockLoginByEmailParams{ctx, email, password, ip}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLoginByEmail.t.Errorf("AuthUsecaseMock.LoginByEmail got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLoginByEmail.LoginByEmailMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.email != nil && !minimock.Equal(*mm_want_ptrs.email, mm_got.email) {
				mmLoginByEmail.t.Errorf("AuthUsecaseMock.LoginByEmail got unexpected parameter email, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLoginByEmail.LoginByEmailMock.defaultExpectation.expectationOrigins.originEmail, *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmLoginByEmail.t.Errorf("AuthUsecaseMock.LoginByEmail got unexpected parameter password, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLoginByEmail.LoginByEmailMock.defaultExpectation.expectationOrigins.originPassword, *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

			if mm_want_ptrs.ip != nil && !minimock.Equal(*mm_want_ptrs.ip, mm_got.ip) {
				mmLoginByEmail.t.Errorf("AuthUsecaseMock.LoginByEmail got unexpected parameter ip, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLoginByEmail.LoginByEmailMock.defaultExpectation.expectationOrigins.originIp, *mm_want_ptrs.ip, mm_got.ip, minimock.Diff(*mm_want_ptrs.ip, mm_got.ip))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLoginByEmail.t.Errorf("AuthUsecaseMock.LoginByEmail got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLoginByEmail.LoginByEmailMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLoginByEmail.LoginByEmailMock.defaultExpectation.results
		if mm_results == nil {
			mmLoginByEmail.t.Fatal("No results are set for the AuthUsecaseMock.LoginByEmail")
		}
		return (*mm_results).res, (*mm_results).err
	}
	if mmLoginByEmail.funcLoginByEmail != nil {
		return mmLoginByEmail.funcLoginByEmail(ctx, email, password, ip)
	}
	mmLoginByEmail.t.Fatalf("Unexpected call to AuthUsecaseMock.LoginByEmail. %v %v %v %v", ctx, email, password, ip)
	return
}

// LoginByEmailAfterCounter returns a count of finished AuthUsecaseMock.LoginByEmail invocations
func (mmLoginByEmail *AuthUsecaseMock) LoginByEmailAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoginByEmail.afterLoginByEmailCounter)
}

// LoginByEmailBeforeCounter returns a count of AuthUsecaseMock.LoginByEmail invocations
func (mmLoginByEmail *AuthUsecaseMock) LoginByEmailBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoginByEmail.beforeLoginByEmailCounter)
}

// Calls returns a list of arguments used in each call to AuthUsecaseMock.LoginByEmail.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLoginByEmail *mAuthUsecaseMockLoginByEmail) Calls() []*AuthUsecaseMockLoginByEmailParams {
	mmLoginByEmail.mutex.RLock()

	argCopy := make([]*AuthUsecaseMockLoginByEmailParams, len(mmLoginByEmail.callArgs))
	copy(argCopy, mmLoginByEmail.callArgs)

	mmLoginByEmail.mutex.RUnlock()

	return argCopy
}

// MinimockLoginByEmailDone returns true if the count of the LoginByEmail invocations corresponds
// the number of defined expectations
func (m *AuthUsecaseMock) MinimockLoginByEmailDone() bool {
	if m.LoginByEmailMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoginByEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoginByEmailMock.invocationsDone()
}

// MinimockLoginByEmailInspect logs each unmet expectation
func (m *AuthUsecaseMock) MinimockLoginByEmailInspect() {
	for _, e := range m.LoginByEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthUsecaseMock.LoginByEmail at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLoginByEmailCounter := mm_atomic.LoadUint64(&m.afterLoginByEmailCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoginByEmailMock.defaultExpectation != nil && afterLoginByEmailCounter < 1 {
		if m.LoginByEmailMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthUsecaseMock.LoginByEmail at\n%s", m.LoginByEmailMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthUsecaseMock.LoginByEmail at\n%s with params: %#v", m.LoginByEmailMock.defaultExpectation.expectationOrigins.origin, *m.LoginByEmailMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLoginByEmail != nil && afterLoginByEmailCounter < 1 {
		m.t.Errorf("Expected call to AuthUsecaseMock.LoginByEmail at\n%s", m.funcLoginByEmailOrigin)
	}

	if !m.LoginByEmailMock.invocationsDone() && afterLoginByEmailCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthUsecaseMock.LoginByEmail at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LoginByEmailMock.expectedInvocations), m.LoginByEmailMock.expectedInvocationsOrigin, afterLoginByEmailCounter)
	}
}

type mAuthUsecaseMockParseRefreshToken struct {
	optional           bool
	mock               *AuthUsecaseMock
	defaultExpectation *AuthUsecaseMockParseRefreshTokenExpectation
	expectations       []*AuthUsecaseMockParseRefreshTokenExpectation

	callArgs []*AuthUsecaseMockParseRefreshTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthUsecaseMockParseRefreshTokenExpectation specifies expectation struct of the AuthUsecase.ParseRefreshToken
type AuthUsecaseMockParseRefreshTokenExpectation struct {
	mock               *AuthUsecaseMock
	params             *AuthUsecaseMockParseRefreshTokenParams
	paramPtrs          *AuthUsecaseMockParseRefreshTokenParamPtrs
	expectationOrigins AuthUsecaseMockParseRefreshTokenExpectationOrigins
	results            *AuthUsecaseMockParseRefreshTokenResults
	returnOrigin       string
	Counter            uint64
}

// AuthUsecaseMockParseRefreshTokenParams contains parameters of the AuthUsecase.ParseRefreshToken
type AuthUsecaseMockParseRefreshTokenParams struct {
	token    string
	validate bool
}

// AuthUsecaseMockParseRefreshTokenParamPtrs contains pointers to parameters of the AuthUsecase.ParseRefreshToken
type AuthUsecaseMockParseRefreshTokenParamPtrs struct {
	token    *string
	validate *bool
}

// AuthUsecaseMockParseRefreshTokenResults contains results of the AuthUsecase.ParseRefreshToken
type AuthUsecaseMockParseRefreshTokenResults struct {
	res *entity.SessionRefreshClaims
	err error
}

// AuthUsecaseMockParseRefreshTokenOrigins contains origins of expectations of the AuthUsecase.ParseRefreshToken
type AuthUsecaseMockParseRefreshTokenExpectationOrigins struct {
	origin         string
	originToken    string
	originValidate string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) Optional() *mAuthUsecaseMockParseRefreshToken {
	mmParseRefreshToken.optional = true
	return mmParseRefreshToken
}

// Expect sets up expected params for AuthUsecase.ParseRefreshToken
func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) Expect(token string, validate bool) *mAuthUsecaseMockParseRefreshToken {
	if mmParseRefreshToken.mock.funcParseRefreshToken != nil {
		mmParseRefreshToken.mock.t.Fatalf("AuthUsecaseMock.ParseRefreshToken mock is already set by Set")
	}

	if mmParseRefreshToken.defaultExpectation == nil {
		mmParseRefreshToken.defaultExpectation = &AuthUsecaseMockParseRefreshTokenExpectation{}
	}

	if mmParseRefreshToken.defaultExpectation.paramPtrs != nil {
		mmParseRefreshToken.mock.t.Fatalf("AuthUsecaseMock.ParseRefreshToken mock is already set by ExpectParams functions")
	}

	mmParseRefreshToken.defaultExpectation.params = &AuthUsecaseMockParseRefreshTokenParams{token, validate}
	mmParseRefreshToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmParseRefreshToken.expectations {
		if minimock.Equal(e.params, mmParseRefreshToken.defaultExpectation.params) {
			mmParseRefreshToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmParseRefreshToken.defaultExpectation.params)
		}
	}

	return mmParseRefreshToken
}

// ExpectTokenParam1 sets up expected param token for AuthUsecase.ParseRefreshToken
func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) ExpectTokenParam1(token string) *mAuthUsecaseMockParseRefreshToken {
	if mmParseRefreshToken.mock.funcParseRefreshToken != nil {
		mmParseRefreshToken.mock.t.Fatalf("AuthUsecaseMock.ParseRefreshToken mock is already set by Set")
	}

	if mmParseRefreshToken.defaultExpectation == nil {
		mmParseRefreshToken.defaultExpectation = &AuthUsecaseMockParseRefreshTokenExpectation{}
	}

	if mmParseRefreshToken.defaultExpectation.params != nil {
		mmParseRefreshToken.mock.t.Fatalf("AuthUsecaseMock.ParseRefreshToken mock is already set by Expect")
	}

	if mmParseRefreshToken.defaultExpectation.paramPtrs == nil {
		mmParseRefreshToken.defaultExpectation.paramPtrs = &AuthUsecaseMockParseRefreshTokenParamPtrs{}
	}
	mmParseRefreshToken.defaultExpectation.paramPtrs.token = &token
	mmParseRefreshToken.defaultExpectation.expectationOrigins.originToken = minimock.CallerInfo(1)

	return mmParseRefreshToken
}

// ExpectValidateParam2 sets up expected param validate for AuthUsecase.ParseRefreshToken
func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) ExpectValidateParam2(validate bool) *mAuthUsecaseMockParseRefreshToken {
	if mmParseRefreshToken.mock.funcParseRefreshToken != nil {
		mmParseRefreshToken.mock.t.Fatalf("AuthUsecaseMock.ParseRefreshToken mock is already set by Set")
	}

	if mmParseRefreshToken.defaultExpectation == nil {
		mmParseRefreshToken.defaultExpectation = &AuthUsecaseMockParseRefreshTokenExpectation{}
	}

	if mmParseRefreshToken.defaultExpectation.params != nil {
		mmParseRefreshToken.mock.t.Fatalf("AuthUsecaseMock.ParseRefreshToken mock is already set by Expect")
	}

	if mmParseRefreshToken.defaultExpectation.paramPtrs == nil {
		mmParseRefreshToken.defaultExpectation.paramPtrs = &AuthUsecaseMockParseRefreshTokenParamPtrs{}
	}
	mmParseRefreshToken.defaultExpectation.paramPtrs.validate = &validate
	mmParseRefreshToken.defaultExpectation.expectationOrigins.originValidate = minimock.CallerInfo(1)

	return mmParseRefreshToken
}

// Inspect accepts an inspector function that has same arguments as the AuthUsecase.ParseRefreshToken
func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) Inspect(f func(token string, validate bool)) *mAuthUsecaseMockParseRefreshToken {
	if mmParseRefreshToken.mock.inspectFuncParseRefreshToken != nil {
		mmParseRefreshToken.mock.t.Fatalf("Inspect function is already set for AuthUsecaseMock.ParseRefreshToken")
	}

	mmParseRefreshToken.mock.inspectFuncParseRefreshToken = f

	return mmParseRefreshToken
}

// Return sets up results that will be returned by AuthUsecase.ParseRefreshToken
func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) Return(res *entity.SessionRefreshClaims, err error) *AuthUsecaseMock {
	if mmParseRefreshToken.mock.funcParseRefreshToken != nil {
		mmParseRefreshToken.mock.t.Fatalf("AuthUsecaseMock.ParseRefreshToken mock is already set by Set")
	}

	if mmParseRefreshToken.defaultExpectation == nil {
		mmParseRefreshToken.defaultExpectation = &AuthUsecaseMockParseRefreshTokenExpectation{mock: mmParseRefreshToken.mock}
	}
	mmParseRefreshToken.defaultExpectation.results = &AuthUsecaseMockParseRefreshTokenResults{res, err}
	mmParseRefreshToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmParseRefreshToken.mock
}

// Set uses given function f to mock the AuthUsecase.ParseRefreshToken method
func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) Set(f func(token string, validate bool) (res *entity.SessionRefreshClaims, err error)) *AuthUsecaseMock {
	if mmParseRefreshToken.defaultExpectation != nil {
		mmParseRefreshToken.mock.t.Fatalf("Default expectation is already set for the AuthUsecase.ParseRefreshToken method")
	}

	if len(mmParseRefreshToken.expectations) > 0 {
		mmParseRefreshToken.mock.t.Fatalf("Some expectations are already set for the AuthUsecase.ParseRefreshToken method")
	}

	mmParseRefreshToken.mock.funcParseRefreshToken = f
	mmParseRefreshToken.mock.funcParseRefreshTokenOrigin = minimock.CallerInfo(1)
	return mmParseRefreshToken.mock
}

// When sets expectation for the AuthUsecase.ParseRefreshToken which will trigger the result defined by the following
// Then helper
func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) When(token string, validate bool) *AuthUsecaseMockParseRefreshTokenExpectation {
	if mmParseRefreshToken.mock.funcParseRefreshToken != nil {
		mmParseRefreshToken.mock.t.Fatalf("AuthUsecaseMock.ParseRefreshToken mock is already set by Set")
	}

	expectation := &AuthUsecaseMockParseRefreshTokenExpectation{
		mock:               mmParseRefreshToken.mock,
		params:             &AuthUsecaseMockParseRefreshTokenParams{token, validate},
		expectationOrigins: AuthUsecaseMockParseRefreshTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmParseRefreshToken.expectations = append(mmParseRefreshToken.expectations, expectation)
	return expectation
}

// Then sets up AuthUsecase.ParseRefreshToken return parameters for the expectation previously defined by the When method
func (e *AuthUsecaseMockParseRefreshTokenExpectation) Then(res *entity.SessionRefreshClaims, err error) *AuthUsecaseMock {
	e.results = &AuthUsecaseMockParseRefreshTokenResults{res, err}
	return e.mock
}

// Times sets number of times AuthUsecase.ParseRefreshToken should be invoked
func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) Times(n uint64) *mAuthUsecaseMockParseRefreshToken {
	if n == 0 {
		mmParseRefreshToken.mock.t.Fatalf("Times of AuthUsecaseMock.ParseRefreshToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmParseRefreshToken.expectedInvocations, n)
	mmParseRefreshToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmParseRefreshToken
}

func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) invocationsDone() bool {
	if len(mmParseRefreshToken.expectations) == 0 && mmParseRefreshToken.defaultExpectation == nil && mmParseRefreshToken.mock.funcParseRefreshToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmParseRefreshToken.mock.afterParseRefreshTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmParseRefreshToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ParseRefreshToken implements mm_usecase.AuthUsecase
func (mmParseRefreshToken *AuthUsecaseMock) ParseRefreshToken(token string, validate bool) (res *entity.SessionRefreshClaims, err error) {
	mm_atomic.AddUint64(&mmParseRefreshToken.beforeParseRefreshTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmParseRefreshToken.afterParseRefreshTokenCounter, 1)

	mmParseRefreshToken.t.Helper()

	if mmParseRefreshToken.inspectFuncParseRefreshToken != nil {
		mmParseRefreshToken.inspectFuncParseRefreshToken(token, validate)
	}

	mm_params := AuthUsecaseMockParseRefreshTokenParams{token, validate}

	// Record call args
	mmParseRefreshToken.ParseRefreshTokenMock.mutex.Lock()
	mmParseRefreshToken.ParseRefreshTokenMock.callArgs = append(mmParseRefreshToken.ParseRefreshTokenMock.callArgs, &mm_params)
	mmParseRefreshToken.ParseRefreshTokenMock.mutex.Unlock()

	for _, e := range mmParseRefreshToken.ParseRefreshTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.res, e.results.err
		}
	}

	if mmParseRefreshToken.ParseRefreshTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmParseRefreshToken.ParseRefreshTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmParseRefreshToken.ParseRefreshTokenMock.defaultExpectation.params
		mm_want_ptrs := mmParseRefreshToken.ParseRefreshTokenMock.defaultExpectation.paramPtrs

		mm_got := AuthUsecaseMockParseRefreshTokenParams{token, validate}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.token != nil && !minimock.Equal(*mm_want_ptrs.token, mm_got.token) {
				mmParseRefreshToken.t.Errorf("AuthUsecaseMock.ParseRefreshToken got unexpected parameter token, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmParseRefreshToken.ParseRefreshTokenMock.defaultExpectation.expectationOrigins.originToken, *mm_want_ptrs.token, mm_got.token, minimock.Diff(*mm_want_ptrs.token, mm_got.token))
			}

			if mm_want_ptrs.validate != nil && !minimock.Equal(*mm_want_ptrs.validate, mm_got.validate) {
				mmParseRefreshToken.t.Errorf("AuthUsecaseMock.ParseRefreshToken got unexpected parameter validate, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmParseRefreshToken.ParseRefreshTokenMock.defaultExpectation.expectationOrigins.originValidate, *mm_want_ptrs.validate, mm_got.validate, minimock.Diff(*mm_want_ptrs.validate, mm_got.validate))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmParseRefreshToken.t.Errorf("AuthUsecaseMock.ParseRefreshToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmParseRefreshToken.ParseRefreshTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmParseRefreshToken.ParseRefreshTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmParseRefreshToken.t.Fatal("No results are set for the AuthUsecaseMock.ParseRefreshToken")
		}
		return (*mm_results).res, (*mm_results).err
	}
	if mmParseRefreshToken.funcParseRefreshToken != nil {
		return mmParseRefreshToken.funcParseRefreshToken(token, validate)
	}
	mmParseRefreshToken.t.Fatalf("Unexpected call to AuthUsecaseMock.ParseRefreshToken. %v %v", token, validate)
	return
}

// ParseRefreshTokenAfterCounter returns a count of finished AuthUsecaseMock.ParseRefreshToken invocations
func (mmParseRefreshToken *AuthUsecaseMock) ParseRefreshTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParseRefreshToken.afterParseRefreshTokenCounter)
}

// ParseRefreshTokenBeforeCounter returns a count of AuthUsecaseMock.ParseRefreshToken invocations
func (mmParseRefreshToken *AuthUsecaseMock) ParseRefreshTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParseRefreshToken.beforeParseRefreshTokenCounter)
}

// Calls returns a list of arguments used in each call to AuthUsecaseMock.ParseRefreshToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmParseRefreshToken *mAuthUsecaseMockParseRefreshToken) Calls() []*AuthUsecaseMockParseRefreshTokenParams {
	mmParseRefreshToken.mutex.RLock()

	argCopy := make([]*AuthUsecaseMockParseRefreshTokenParams, len(mmParseRefreshToken.callArgs))
	copy(argCopy, mmParseRefreshToken.callArgs)

	mmParseRefreshToken.mutex.RUnlock()

	return argCopy
}

// MinimockParseRefreshTokenDone returns true if the count of the ParseRefreshToken invocations corresponds
// the number of defined expectations
func (m *AuthUsecaseMock) MinimockParseRefreshTokenDone() bool {
	if m.ParseRefreshTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ParseRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ParseRefreshTokenMock.invocationsDone()
}

// MinimockParseRefreshTokenInspect logs each unmet expectation
func (m *AuthUsecaseMock) MinimockParseRefreshTokenInspect() {
	for _, e := range m.ParseRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthUsecaseMock.ParseRefreshToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterParseRefreshTokenCounter := mm_atomic.LoadUint64(&m.afterParseRefreshTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ParseRefreshTokenMock.defaultExpectation != nil && afterParseRefreshTokenCounter < 1 {
		if m.ParseRefreshTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthUsecaseMock.ParseRefreshToken at\n%s", m.ParseRefreshTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthUsecaseMock.ParseRefreshToken at\n%s with params: %#v", m.ParseRefreshTokenMock.defaultExpectation.expectationOrigins.origin, *m.ParseRefreshTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParseRefreshToken != nil && afterParseRefreshTokenCounter < 1 {
		m.t.Errorf("Expected call to AuthUsecaseMock.ParseRefreshToken at\n%s", m.funcParseRefreshTokenOrigin)
	}

	if !m.ParseRefreshTokenMock.invocationsDone() && afterParseRefreshTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthUsecaseMock.ParseRefreshToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ParseRefreshTokenMock.expectedInvocations), m.ParseRefreshTokenMock.expectedInvocationsOrigin, afterParseRefreshTokenCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthUsecaseMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGenerateNewClaimsInspect()

			m.MinimockIsSessionConfirmedInspect()

			m.MinimockIssueAccessJWTInspect()

			m.MinimockIssueRefreshJWTInspect()

			m.MinimockLoginByEmailInspect()

			m.MinimockParseRefreshTokenInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthUsecaseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthUsecaseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGenerateNewClaimsDone() &&
		m.MinimockIsSessionConfirmedDone() &&
		m.MinimockIssueAccessJWTDone() &&
		m.MinimockIssueRefreshJWTDone() &&
		m.MinimockLoginByEmailDone() &&
		m.MinimockParseRefreshTokenDone()
}
