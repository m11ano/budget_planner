// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase.BudgetCacheRepository -o budget_cache_repository.go -n BudgetCacheRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
)

// BudgetCacheRepositoryMock implements mm_usecase.BudgetCacheRepository
type BudgetCacheRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClearForPrefixes          func(ctx context.Context, prefixes ...string) (err error)
	funcClearForPrefixesOrigin    string
	inspectFuncClearForPrefixes   func(ctx context.Context, prefixes ...string)
	afterClearForPrefixesCounter  uint64
	beforeClearForPrefixesCounter uint64
	ClearForPrefixesMock          mBudgetCacheRepositoryMockClearForPrefixes

	funcGetBudget          func(ctx context.Context, key string) (item *entity.Budget, err error)
	funcGetBudgetOrigin    string
	inspectFuncGetBudget   func(ctx context.Context, key string)
	afterGetBudgetCounter  uint64
	beforeGetBudgetCounter uint64
	GetBudgetMock          mBudgetCacheRepositoryMockGetBudget

	funcGetBudgetsList          func(ctx context.Context, key string) (items []*entity.Budget, err error)
	funcGetBudgetsListOrigin    string
	inspectFuncGetBudgetsList   func(ctx context.Context, key string)
	afterGetBudgetsListCounter  uint64
	beforeGetBudgetsListCounter uint64
	GetBudgetsListMock          mBudgetCacheRepositoryMockGetBudgetsList

	funcGetBudgetsPagedList          func(ctx context.Context, key string) (items []*entity.Budget, total uint64, err error)
	funcGetBudgetsPagedListOrigin    string
	inspectFuncGetBudgetsPagedList   func(ctx context.Context, key string)
	afterGetBudgetsPagedListCounter  uint64
	beforeGetBudgetsPagedListCounter uint64
	GetBudgetsPagedListMock          mBudgetCacheRepositoryMockGetBudgetsPagedList

	funcSaveBudget          func(ctx context.Context, key string, item *entity.Budget, ttl time.Duration) (err error)
	funcSaveBudgetOrigin    string
	inspectFuncSaveBudget   func(ctx context.Context, key string, item *entity.Budget, ttl time.Duration)
	afterSaveBudgetCounter  uint64
	beforeSaveBudgetCounter uint64
	SaveBudgetMock          mBudgetCacheRepositoryMockSaveBudget

	funcSaveBudgetsList          func(ctx context.Context, key string, items []*entity.Budget, ttl time.Duration) (err error)
	funcSaveBudgetsListOrigin    string
	inspectFuncSaveBudgetsList   func(ctx context.Context, key string, items []*entity.Budget, ttl time.Duration)
	afterSaveBudgetsListCounter  uint64
	beforeSaveBudgetsListCounter uint64
	SaveBudgetsListMock          mBudgetCacheRepositoryMockSaveBudgetsList

	funcSaveBudgetsPagedList          func(ctx context.Context, key string, items []*entity.Budget, total uint64, ttl time.Duration) (err error)
	funcSaveBudgetsPagedListOrigin    string
	inspectFuncSaveBudgetsPagedList   func(ctx context.Context, key string, items []*entity.Budget, total uint64, ttl time.Duration)
	afterSaveBudgetsPagedListCounter  uint64
	beforeSaveBudgetsPagedListCounter uint64
	SaveBudgetsPagedListMock          mBudgetCacheRepositoryMockSaveBudgetsPagedList
}

// NewBudgetCacheRepositoryMock returns a mock for mm_usecase.BudgetCacheRepository
func NewBudgetCacheRepositoryMock(t minimock.Tester) *BudgetCacheRepositoryMock {
	m := &BudgetCacheRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ClearForPrefixesMock = mBudgetCacheRepositoryMockClearForPrefixes{mock: m}
	m.ClearForPrefixesMock.callArgs = []*BudgetCacheRepositoryMockClearForPrefixesParams{}

	m.GetBudgetMock = mBudgetCacheRepositoryMockGetBudget{mock: m}
	m.GetBudgetMock.callArgs = []*BudgetCacheRepositoryMockGetBudgetParams{}

	m.GetBudgetsListMock = mBudgetCacheRepositoryMockGetBudgetsList{mock: m}
	m.GetBudgetsListMock.callArgs = []*BudgetCacheRepositoryMockGetBudgetsListParams{}

	m.GetBudgetsPagedListMock = mBudgetCacheRepositoryMockGetBudgetsPagedList{mock: m}
	m.GetBudgetsPagedListMock.callArgs = []*BudgetCacheRepositoryMockGetBudgetsPagedListParams{}

	m.SaveBudgetMock = mBudgetCacheRepositoryMockSaveBudget{mock: m}
	m.SaveBudgetMock.callArgs = []*BudgetCacheRepositoryMockSaveBudgetParams{}

	m.SaveBudgetsListMock = mBudgetCacheRepositoryMockSaveBudgetsList{mock: m}
	m.SaveBudgetsListMock.callArgs = []*BudgetCacheRepositoryMockSaveBudgetsListParams{}

	m.SaveBudgetsPagedListMock = mBudgetCacheRepositoryMockSaveBudgetsPagedList{mock: m}
	m.SaveBudgetsPagedListMock.callArgs = []*BudgetCacheRepositoryMockSaveBudgetsPagedListParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mBudgetCacheRepositoryMockClearForPrefixes struct {
	optional           bool
	mock               *BudgetCacheRepositoryMock
	defaultExpectation *BudgetCacheRepositoryMockClearForPrefixesExpectation
	expectations       []*BudgetCacheRepositoryMockClearForPrefixesExpectation

	callArgs []*BudgetCacheRepositoryMockClearForPrefixesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BudgetCacheRepositoryMockClearForPrefixesExpectation specifies expectation struct of the BudgetCacheRepository.ClearForPrefixes
type BudgetCacheRepositoryMockClearForPrefixesExpectation struct {
	mock               *BudgetCacheRepositoryMock
	params             *BudgetCacheRepositoryMockClearForPrefixesParams
	paramPtrs          *BudgetCacheRepositoryMockClearForPrefixesParamPtrs
	expectationOrigins BudgetCacheRepositoryMockClearForPrefixesExpectationOrigins
	results            *BudgetCacheRepositoryMockClearForPrefixesResults
	returnOrigin       string
	Counter            uint64
}

// BudgetCacheRepositoryMockClearForPrefixesParams contains parameters of the BudgetCacheRepository.ClearForPrefixes
type BudgetCacheRepositoryMockClearForPrefixesParams struct {
	ctx      context.Context
	prefixes []string
}

// BudgetCacheRepositoryMockClearForPrefixesParamPtrs contains pointers to parameters of the BudgetCacheRepository.ClearForPrefixes
type BudgetCacheRepositoryMockClearForPrefixesParamPtrs struct {
	ctx      *context.Context
	prefixes *[]string
}

// BudgetCacheRepositoryMockClearForPrefixesResults contains results of the BudgetCacheRepository.ClearForPrefixes
type BudgetCacheRepositoryMockClearForPrefixesResults struct {
	err error
}

// BudgetCacheRepositoryMockClearForPrefixesOrigins contains origins of expectations of the BudgetCacheRepository.ClearForPrefixes
type BudgetCacheRepositoryMockClearForPrefixesExpectationOrigins struct {
	origin         string
	originCtx      string
	originPrefixes string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) Optional() *mBudgetCacheRepositoryMockClearForPrefixes {
	mmClearForPrefixes.optional = true
	return mmClearForPrefixes
}

// Expect sets up expected params for BudgetCacheRepository.ClearForPrefixes
func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) Expect(ctx context.Context, prefixes ...string) *mBudgetCacheRepositoryMockClearForPrefixes {
	if mmClearForPrefixes.mock.funcClearForPrefixes != nil {
		mmClearForPrefixes.mock.t.Fatalf("BudgetCacheRepositoryMock.ClearForPrefixes mock is already set by Set")
	}

	if mmClearForPrefixes.defaultExpectation == nil {
		mmClearForPrefixes.defaultExpectation = &BudgetCacheRepositoryMockClearForPrefixesExpectation{}
	}

	if mmClearForPrefixes.defaultExpectation.paramPtrs != nil {
		mmClearForPrefixes.mock.t.Fatalf("BudgetCacheRepositoryMock.ClearForPrefixes mock is already set by ExpectParams functions")
	}

	mmClearForPrefixes.defaultExpectation.params = &BudgetCacheRepositoryMockClearForPrefixesParams{ctx, prefixes}
	mmClearForPrefixes.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmClearForPrefixes.expectations {
		if minimock.Equal(e.params, mmClearForPrefixes.defaultExpectation.params) {
			mmClearForPrefixes.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClearForPrefixes.defaultExpectation.params)
		}
	}

	return mmClearForPrefixes
}

// ExpectCtxParam1 sets up expected param ctx for BudgetCacheRepository.ClearForPrefixes
func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) ExpectCtxParam1(ctx context.Context) *mBudgetCacheRepositoryMockClearForPrefixes {
	if mmClearForPrefixes.mock.funcClearForPrefixes != nil {
		mmClearForPrefixes.mock.t.Fatalf("BudgetCacheRepositoryMock.ClearForPrefixes mock is already set by Set")
	}

	if mmClearForPrefixes.defaultExpectation == nil {
		mmClearForPrefixes.defaultExpectation = &BudgetCacheRepositoryMockClearForPrefixesExpectation{}
	}

	if mmClearForPrefixes.defaultExpectation.params != nil {
		mmClearForPrefixes.mock.t.Fatalf("BudgetCacheRepositoryMock.ClearForPrefixes mock is already set by Expect")
	}

	if mmClearForPrefixes.defaultExpectation.paramPtrs == nil {
		mmClearForPrefixes.defaultExpectation.paramPtrs = &BudgetCacheRepositoryMockClearForPrefixesParamPtrs{}
	}
	mmClearForPrefixes.defaultExpectation.paramPtrs.ctx = &ctx
	mmClearForPrefixes.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmClearForPrefixes
}

// ExpectPrefixesParam2 sets up expected param prefixes for BudgetCacheRepository.ClearForPrefixes
func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) ExpectPrefixesParam2(prefixes ...string) *mBudgetCacheRepositoryMockClearForPrefixes {
	if mmClearForPrefixes.mock.funcClearForPrefixes != nil {
		mmClearForPrefixes.mock.t.Fatalf("BudgetCacheRepositoryMock.ClearForPrefixes mock is already set by Set")
	}

	if mmClearForPrefixes.defaultExpectation == nil {
		mmClearForPrefixes.defaultExpectation = &BudgetCacheRepositoryMockClearForPrefixesExpectation{}
	}

	if mmClearForPrefixes.defaultExpectation.params != nil {
		mmClearForPrefixes.mock.t.Fatalf("BudgetCacheRepositoryMock.ClearForPrefixes mock is already set by Expect")
	}

	if mmClearForPrefixes.defaultExpectation.paramPtrs == nil {
		mmClearForPrefixes.defaultExpectation.paramPtrs = &BudgetCacheRepositoryMockClearForPrefixesParamPtrs{}
	}
	mmClearForPrefixes.defaultExpectation.paramPtrs.prefixes = &prefixes
	mmClearForPrefixes.defaultExpectation.expectationOrigins.originPrefixes = minimock.CallerInfo(1)

	return mmClearForPrefixes
}

// Inspect accepts an inspector function that has same arguments as the BudgetCacheRepository.ClearForPrefixes
func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) Inspect(f func(ctx context.Context, prefixes ...string)) *mBudgetCacheRepositoryMockClearForPrefixes {
	if mmClearForPrefixes.mock.inspectFuncClearForPrefixes != nil {
		mmClearForPrefixes.mock.t.Fatalf("Inspect function is already set for BudgetCacheRepositoryMock.ClearForPrefixes")
	}

	mmClearForPrefixes.mock.inspectFuncClearForPrefixes = f

	return mmClearForPrefixes
}

// Return sets up results that will be returned by BudgetCacheRepository.ClearForPrefixes
func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) Return(err error) *BudgetCacheRepositoryMock {
	if mmClearForPrefixes.mock.funcClearForPrefixes != nil {
		mmClearForPrefixes.mock.t.Fatalf("BudgetCacheRepositoryMock.ClearForPrefixes mock is already set by Set")
	}

	if mmClearForPrefixes.defaultExpectation == nil {
		mmClearForPrefixes.defaultExpectation = &BudgetCacheRepositoryMockClearForPrefixesExpectation{mock: mmClearForPrefixes.mock}
	}
	mmClearForPrefixes.defaultExpectation.results = &BudgetCacheRepositoryMockClearForPrefixesResults{err}
	mmClearForPrefixes.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClearForPrefixes.mock
}

// Set uses given function f to mock the BudgetCacheRepository.ClearForPrefixes method
func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) Set(f func(ctx context.Context, prefixes ...string) (err error)) *BudgetCacheRepositoryMock {
	if mmClearForPrefixes.defaultExpectation != nil {
		mmClearForPrefixes.mock.t.Fatalf("Default expectation is already set for the BudgetCacheRepository.ClearForPrefixes method")
	}

	if len(mmClearForPrefixes.expectations) > 0 {
		mmClearForPrefixes.mock.t.Fatalf("Some expectations are already set for the BudgetCacheRepository.ClearForPrefixes method")
	}

	mmClearForPrefixes.mock.funcClearForPrefixes = f
	mmClearForPrefixes.mock.funcClearForPrefixesOrigin = minimock.CallerInfo(1)
	return mmClearForPrefixes.mock
}

// When sets expectation for the BudgetCacheRepository.ClearForPrefixes which will trigger the result defined by the following
// Then helper
func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) When(ctx context.Context, prefixes ...string) *BudgetCacheRepositoryMockClearForPrefixesExpectation {
	if mmClearForPrefixes.mock.funcClearForPrefixes != nil {
		mmClearForPrefixes.mock.t.Fatalf("BudgetCacheRepositoryMock.ClearForPrefixes mock is already set by Set")
	}

	expectation := &BudgetCacheRepositoryMockClearForPrefixesExpectation{
		mock:               mmClearForPrefixes.mock,
		params:             &BudgetCacheRepositoryMockClearForPrefixesParams{ctx, prefixes},
		expectationOrigins: BudgetCacheRepositoryMockClearForPrefixesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmClearForPrefixes.expectations = append(mmClearForPrefixes.expectations, expectation)
	return expectation
}

// Then sets up BudgetCacheRepository.ClearForPrefixes return parameters for the expectation previously defined by the When method
func (e *BudgetCacheRepositoryMockClearForPrefixesExpectation) Then(err error) *BudgetCacheRepositoryMock {
	e.results = &BudgetCacheRepositoryMockClearForPrefixesResults{err}
	return e.mock
}

// Times sets number of times BudgetCacheRepository.ClearForPrefixes should be invoked
func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) Times(n uint64) *mBudgetCacheRepositoryMockClearForPrefixes {
	if n == 0 {
		mmClearForPrefixes.mock.t.Fatalf("Times of BudgetCacheRepositoryMock.ClearForPrefixes mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClearForPrefixes.expectedInvocations, n)
	mmClearForPrefixes.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClearForPrefixes
}

func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) invocationsDone() bool {
	if len(mmClearForPrefixes.expectations) == 0 && mmClearForPrefixes.defaultExpectation == nil && mmClearForPrefixes.mock.funcClearForPrefixes == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClearForPrefixes.mock.afterClearForPrefixesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClearForPrefixes.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ClearForPrefixes implements mm_usecase.BudgetCacheRepository
func (mmClearForPrefixes *BudgetCacheRepositoryMock) ClearForPrefixes(ctx context.Context, prefixes ...string) (err error) {
	mm_atomic.AddUint64(&mmClearForPrefixes.beforeClearForPrefixesCounter, 1)
	defer mm_atomic.AddUint64(&mmClearForPrefixes.afterClearForPrefixesCounter, 1)

	mmClearForPrefixes.t.Helper()

	if mmClearForPrefixes.inspectFuncClearForPrefixes != nil {
		mmClearForPrefixes.inspectFuncClearForPrefixes(ctx, prefixes...)
	}

	mm_params := BudgetCacheRepositoryMockClearForPrefixesParams{ctx, prefixes}

	// Record call args
	mmClearForPrefixes.ClearForPrefixesMock.mutex.Lock()
	mmClearForPrefixes.ClearForPrefixesMock.callArgs = append(mmClearForPrefixes.ClearForPrefixesMock.callArgs, &mm_params)
	mmClearForPrefixes.ClearForPrefixesMock.mutex.Unlock()

	for _, e := range mmClearForPrefixes.ClearForPrefixesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmClearForPrefixes.ClearForPrefixesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClearForPrefixes.ClearForPrefixesMock.defaultExpectation.Counter, 1)
		mm_want := mmClearForPrefixes.ClearForPrefixesMock.defaultExpectation.params
		mm_want_ptrs := mmClearForPrefixes.ClearForPrefixesMock.defaultExpectation.paramPtrs

		mm_got := BudgetCacheRepositoryMockClearForPrefixesParams{ctx, prefixes}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmClearForPrefixes.t.Errorf("BudgetCacheRepositoryMock.ClearForPrefixes got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClearForPrefixes.ClearForPrefixesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.prefixes != nil && !minimock.Equal(*mm_want_ptrs.prefixes, mm_got.prefixes) {
				mmClearForPrefixes.t.Errorf("BudgetCacheRepositoryMock.ClearForPrefixes got unexpected parameter prefixes, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClearForPrefixes.ClearForPrefixesMock.defaultExpectation.expectationOrigins.originPrefixes, *mm_want_ptrs.prefixes, mm_got.prefixes, minimock.Diff(*mm_want_ptrs.prefixes, mm_got.prefixes))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClearForPrefixes.t.Errorf("BudgetCacheRepositoryMock.ClearForPrefixes got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmClearForPrefixes.ClearForPrefixesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClearForPrefixes.ClearForPrefixesMock.defaultExpectation.results
		if mm_results == nil {
			mmClearForPrefixes.t.Fatal("No results are set for the BudgetCacheRepositoryMock.ClearForPrefixes")
		}
		return (*mm_results).err
	}
	if mmClearForPrefixes.funcClearForPrefixes != nil {
		return mmClearForPrefixes.funcClearForPrefixes(ctx, prefixes...)
	}
	mmClearForPrefixes.t.Fatalf("Unexpected call to BudgetCacheRepositoryMock.ClearForPrefixes. %v %v", ctx, prefixes)
	return
}

// ClearForPrefixesAfterCounter returns a count of finished BudgetCacheRepositoryMock.ClearForPrefixes invocations
func (mmClearForPrefixes *BudgetCacheRepositoryMock) ClearForPrefixesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearForPrefixes.afterClearForPrefixesCounter)
}

// ClearForPrefixesBeforeCounter returns a count of BudgetCacheRepositoryMock.ClearForPrefixes invocations
func (mmClearForPrefixes *BudgetCacheRepositoryMock) ClearForPrefixesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearForPrefixes.beforeClearForPrefixesCounter)
}

// Calls returns a list of arguments used in each call to BudgetCacheRepositoryMock.ClearForPrefixes.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) Calls() []*BudgetCacheRepositoryMockClearForPrefixesParams {
	mmClearForPrefixes.mutex.RLock()

	argCopy := make([]*BudgetCacheRepositoryMockClearForPrefixesParams, len(mmClearForPrefixes.callArgs))
	copy(argCopy, mmClearForPrefixes.callArgs)

	mmClearForPrefixes.mutex.RUnlock()

	return argCopy
}

// MinimockClearForPrefixesDone returns true if the count of the ClearForPrefixes invocations corresponds
// the number of defined expectations
func (m *BudgetCacheRepositoryMock) MinimockClearForPrefixesDone() bool {
	if m.ClearForPrefixesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ClearForPrefixesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ClearForPrefixesMock.invocationsDone()
}

// MinimockClearForPrefixesInspect logs each unmet expectation
func (m *BudgetCacheRepositoryMock) MinimockClearForPrefixesInspect() {
	for _, e := range m.ClearForPrefixesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BudgetCacheRepositoryMock.ClearForPrefixes at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterClearForPrefixesCounter := mm_atomic.LoadUint64(&m.afterClearForPrefixesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ClearForPrefixesMock.defaultExpectation != nil && afterClearForPrefixesCounter < 1 {
		if m.ClearForPrefixesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BudgetCacheRepositoryMock.ClearForPrefixes at\n%s", m.ClearForPrefixesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BudgetCacheRepositoryMock.ClearForPrefixes at\n%s with params: %#v", m.ClearForPrefixesMock.defaultExpectation.expectationOrigins.origin, *m.ClearForPrefixesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClearForPrefixes != nil && afterClearForPrefixesCounter < 1 {
		m.t.Errorf("Expected call to BudgetCacheRepositoryMock.ClearForPrefixes at\n%s", m.funcClearForPrefixesOrigin)
	}

	if !m.ClearForPrefixesMock.invocationsDone() && afterClearForPrefixesCounter > 0 {
		m.t.Errorf("Expected %d calls to BudgetCacheRepositoryMock.ClearForPrefixes at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ClearForPrefixesMock.expectedInvocations), m.ClearForPrefixesMock.expectedInvocationsOrigin, afterClearForPrefixesCounter)
	}
}

type mBudgetCacheRepositoryMockGetBudget struct {
	optional           bool
	mock               *BudgetCacheRepositoryMock
	defaultExpectation *BudgetCacheRepositoryMockGetBudgetExpectation
	expectations       []*BudgetCacheRepositoryMockGetBudgetExpectation

	callArgs []*BudgetCacheRepositoryMockGetBudgetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BudgetCacheRepositoryMockGetBudgetExpectation specifies expectation struct of the BudgetCacheRepository.GetBudget
type BudgetCacheRepositoryMockGetBudgetExpectation struct {
	mock               *BudgetCacheRepositoryMock
	params             *BudgetCacheRepositoryMockGetBudgetParams
	paramPtrs          *BudgetCacheRepositoryMockGetBudgetParamPtrs
	expectationOrigins BudgetCacheRepositoryMockGetBudgetExpectationOrigins
	results            *BudgetCacheRepositoryMockGetBudgetResults
	returnOrigin       string
	Counter            uint64
}

// BudgetCacheRepositoryMockGetBudgetParams contains parameters of the BudgetCacheRepository.GetBudget
type BudgetCacheRepositoryMockGetBudgetParams struct {
	ctx context.Context
	key string
}

// BudgetCacheRepositoryMockGetBudgetParamPtrs contains pointers to parameters of the BudgetCacheRepository.GetBudget
type BudgetCacheRepositoryMockGetBudgetParamPtrs struct {
	ctx *context.Context
	key *string
}

// BudgetCacheRepositoryMockGetBudgetResults contains results of the BudgetCacheRepository.GetBudget
type BudgetCacheRepositoryMockGetBudgetResults struct {
	item *entity.Budget
	err  error
}

// BudgetCacheRepositoryMockGetBudgetOrigins contains origins of expectations of the BudgetCacheRepository.GetBudget
type BudgetCacheRepositoryMockGetBudgetExpectationOrigins struct {
	origin    string
	originCtx string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) Optional() *mBudgetCacheRepositoryMockGetBudget {
	mmGetBudget.optional = true
	return mmGetBudget
}

// Expect sets up expected params for BudgetCacheRepository.GetBudget
func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) Expect(ctx context.Context, key string) *mBudgetCacheRepositoryMockGetBudget {
	if mmGetBudget.mock.funcGetBudget != nil {
		mmGetBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudget mock is already set by Set")
	}

	if mmGetBudget.defaultExpectation == nil {
		mmGetBudget.defaultExpectation = &BudgetCacheRepositoryMockGetBudgetExpectation{}
	}

	if mmGetBudget.defaultExpectation.paramPtrs != nil {
		mmGetBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudget mock is already set by ExpectParams functions")
	}

	mmGetBudget.defaultExpectation.params = &BudgetCacheRepositoryMockGetBudgetParams{ctx, key}
	mmGetBudget.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetBudget.expectations {
		if minimock.Equal(e.params, mmGetBudget.defaultExpectation.params) {
			mmGetBudget.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBudget.defaultExpectation.params)
		}
	}

	return mmGetBudget
}

// ExpectCtxParam1 sets up expected param ctx for BudgetCacheRepository.GetBudget
func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) ExpectCtxParam1(ctx context.Context) *mBudgetCacheRepositoryMockGetBudget {
	if mmGetBudget.mock.funcGetBudget != nil {
		mmGetBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudget mock is already set by Set")
	}

	if mmGetBudget.defaultExpectation == nil {
		mmGetBudget.defaultExpectation = &BudgetCacheRepositoryMockGetBudgetExpectation{}
	}

	if mmGetBudget.defaultExpectation.params != nil {
		mmGetBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudget mock is already set by Expect")
	}

	if mmGetBudget.defaultExpectation.paramPtrs == nil {
		mmGetBudget.defaultExpectation.paramPtrs = &BudgetCacheRepositoryMockGetBudgetParamPtrs{}
	}
	mmGetBudget.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetBudget.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetBudget
}

// ExpectKeyParam2 sets up expected param key for BudgetCacheRepository.GetBudget
func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) ExpectKeyParam2(key string) *mBudgetCacheRepositoryMockGetBudget {
	if mmGetBudget.mock.funcGetBudget != nil {
		mmGetBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudget mock is already set by Set")
	}

	if mmGetBudget.defaultExpectation == nil {
		mmGetBudget.defaultExpectation = &BudgetCacheRepositoryMockGetBudgetExpectation{}
	}

	if mmGetBudget.defaultExpectation.params != nil {
		mmGetBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudget mock is already set by Expect")
	}

	if mmGetBudget.defaultExpectation.paramPtrs == nil {
		mmGetBudget.defaultExpectation.paramPtrs = &BudgetCacheRepositoryMockGetBudgetParamPtrs{}
	}
	mmGetBudget.defaultExpectation.paramPtrs.key = &key
	mmGetBudget.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmGetBudget
}

// Inspect accepts an inspector function that has same arguments as the BudgetCacheRepository.GetBudget
func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) Inspect(f func(ctx context.Context, key string)) *mBudgetCacheRepositoryMockGetBudget {
	if mmGetBudget.mock.inspectFuncGetBudget != nil {
		mmGetBudget.mock.t.Fatalf("Inspect function is already set for BudgetCacheRepositoryMock.GetBudget")
	}

	mmGetBudget.mock.inspectFuncGetBudget = f

	return mmGetBudget
}

// Return sets up results that will be returned by BudgetCacheRepository.GetBudget
func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) Return(item *entity.Budget, err error) *BudgetCacheRepositoryMock {
	if mmGetBudget.mock.funcGetBudget != nil {
		mmGetBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudget mock is already set by Set")
	}

	if mmGetBudget.defaultExpectation == nil {
		mmGetBudget.defaultExpectation = &BudgetCacheRepositoryMockGetBudgetExpectation{mock: mmGetBudget.mock}
	}
	mmGetBudget.defaultExpectation.results = &BudgetCacheRepositoryMockGetBudgetResults{item, err}
	mmGetBudget.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetBudget.mock
}

// Set uses given function f to mock the BudgetCacheRepository.GetBudget method
func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) Set(f func(ctx context.Context, key string) (item *entity.Budget, err error)) *BudgetCacheRepositoryMock {
	if mmGetBudget.defaultExpectation != nil {
		mmGetBudget.mock.t.Fatalf("Default expectation is already set for the BudgetCacheRepository.GetBudget method")
	}

	if len(mmGetBudget.expectations) > 0 {
		mmGetBudget.mock.t.Fatalf("Some expectations are already set for the BudgetCacheRepository.GetBudget method")
	}

	mmGetBudget.mock.funcGetBudget = f
	mmGetBudget.mock.funcGetBudgetOrigin = minimock.CallerInfo(1)
	return mmGetBudget.mock
}

// When sets expectation for the BudgetCacheRepository.GetBudget which will trigger the result defined by the following
// Then helper
func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) When(ctx context.Context, key string) *BudgetCacheRepositoryMockGetBudgetExpectation {
	if mmGetBudget.mock.funcGetBudget != nil {
		mmGetBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudget mock is already set by Set")
	}

	expectation := &BudgetCacheRepositoryMockGetBudgetExpectation{
		mock:               mmGetBudget.mock,
		params:             &BudgetCacheRepositoryMockGetBudgetParams{ctx, key},
		expectationOrigins: BudgetCacheRepositoryMockGetBudgetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetBudget.expectations = append(mmGetBudget.expectations, expectation)
	return expectation
}

// Then sets up BudgetCacheRepository.GetBudget return parameters for the expectation previously defined by the When method
func (e *BudgetCacheRepositoryMockGetBudgetExpectation) Then(item *entity.Budget, err error) *BudgetCacheRepositoryMock {
	e.results = &BudgetCacheRepositoryMockGetBudgetResults{item, err}
	return e.mock
}

// Times sets number of times BudgetCacheRepository.GetBudget should be invoked
func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) Times(n uint64) *mBudgetCacheRepositoryMockGetBudget {
	if n == 0 {
		mmGetBudget.mock.t.Fatalf("Times of BudgetCacheRepositoryMock.GetBudget mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBudget.expectedInvocations, n)
	mmGetBudget.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetBudget
}

func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) invocationsDone() bool {
	if len(mmGetBudget.expectations) == 0 && mmGetBudget.defaultExpectation == nil && mmGetBudget.mock.funcGetBudget == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBudget.mock.afterGetBudgetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBudget.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBudget implements mm_usecase.BudgetCacheRepository
func (mmGetBudget *BudgetCacheRepositoryMock) GetBudget(ctx context.Context, key string) (item *entity.Budget, err error) {
	mm_atomic.AddUint64(&mmGetBudget.beforeGetBudgetCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBudget.afterGetBudgetCounter, 1)

	mmGetBudget.t.Helper()

	if mmGetBudget.inspectFuncGetBudget != nil {
		mmGetBudget.inspectFuncGetBudget(ctx, key)
	}

	mm_params := BudgetCacheRepositoryMockGetBudgetParams{ctx, key}

	// Record call args
	mmGetBudget.GetBudgetMock.mutex.Lock()
	mmGetBudget.GetBudgetMock.callArgs = append(mmGetBudget.GetBudgetMock.callArgs, &mm_params)
	mmGetBudget.GetBudgetMock.mutex.Unlock()

	for _, e := range mmGetBudget.GetBudgetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.item, e.results.err
		}
	}

	if mmGetBudget.GetBudgetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBudget.GetBudgetMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBudget.GetBudgetMock.defaultExpectation.params
		mm_want_ptrs := mmGetBudget.GetBudgetMock.defaultExpectation.paramPtrs

		mm_got := BudgetCacheRepositoryMockGetBudgetParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBudget.t.Errorf("BudgetCacheRepositoryMock.GetBudget got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBudget.GetBudgetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmGetBudget.t.Errorf("BudgetCacheRepositoryMock.GetBudget got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBudget.GetBudgetMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBudget.t.Errorf("BudgetCacheRepositoryMock.GetBudget got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetBudget.GetBudgetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBudget.GetBudgetMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBudget.t.Fatal("No results are set for the BudgetCacheRepositoryMock.GetBudget")
		}
		return (*mm_results).item, (*mm_results).err
	}
	if mmGetBudget.funcGetBudget != nil {
		return mmGetBudget.funcGetBudget(ctx, key)
	}
	mmGetBudget.t.Fatalf("Unexpected call to BudgetCacheRepositoryMock.GetBudget. %v %v", ctx, key)
	return
}

// GetBudgetAfterCounter returns a count of finished BudgetCacheRepositoryMock.GetBudget invocations
func (mmGetBudget *BudgetCacheRepositoryMock) GetBudgetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBudget.afterGetBudgetCounter)
}

// GetBudgetBeforeCounter returns a count of BudgetCacheRepositoryMock.GetBudget invocations
func (mmGetBudget *BudgetCacheRepositoryMock) GetBudgetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBudget.beforeGetBudgetCounter)
}

// Calls returns a list of arguments used in each call to BudgetCacheRepositoryMock.GetBudget.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) Calls() []*BudgetCacheRepositoryMockGetBudgetParams {
	mmGetBudget.mutex.RLock()

	argCopy := make([]*BudgetCacheRepositoryMockGetBudgetParams, len(mmGetBudget.callArgs))
	copy(argCopy, mmGetBudget.callArgs)

	mmGetBudget.mutex.RUnlock()

	return argCopy
}

// MinimockGetBudgetDone returns true if the count of the GetBudget invocations corresponds
// the number of defined expectations
func (m *BudgetCacheRepositoryMock) MinimockGetBudgetDone() bool {
	if m.GetBudgetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBudgetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBudgetMock.invocationsDone()
}

// MinimockGetBudgetInspect logs each unmet expectation
func (m *BudgetCacheRepositoryMock) MinimockGetBudgetInspect() {
	for _, e := range m.GetBudgetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudget at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetBudgetCounter := mm_atomic.LoadUint64(&m.afterGetBudgetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBudgetMock.defaultExpectation != nil && afterGetBudgetCounter < 1 {
		if m.GetBudgetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudget at\n%s", m.GetBudgetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudget at\n%s with params: %#v", m.GetBudgetMock.defaultExpectation.expectationOrigins.origin, *m.GetBudgetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBudget != nil && afterGetBudgetCounter < 1 {
		m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudget at\n%s", m.funcGetBudgetOrigin)
	}

	if !m.GetBudgetMock.invocationsDone() && afterGetBudgetCounter > 0 {
		m.t.Errorf("Expected %d calls to BudgetCacheRepositoryMock.GetBudget at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetBudgetMock.expectedInvocations), m.GetBudgetMock.expectedInvocationsOrigin, afterGetBudgetCounter)
	}
}

type mBudgetCacheRepositoryMockGetBudgetsList struct {
	optional           bool
	mock               *BudgetCacheRepositoryMock
	defaultExpectation *BudgetCacheRepositoryMockGetBudgetsListExpectation
	expectations       []*BudgetCacheRepositoryMockGetBudgetsListExpectation

	callArgs []*BudgetCacheRepositoryMockGetBudgetsListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BudgetCacheRepositoryMockGetBudgetsListExpectation specifies expectation struct of the BudgetCacheRepository.GetBudgetsList
type BudgetCacheRepositoryMockGetBudgetsListExpectation struct {
	mock               *BudgetCacheRepositoryMock
	params             *BudgetCacheRepositoryMockGetBudgetsListParams
	paramPtrs          *BudgetCacheRepositoryMockGetBudgetsListParamPtrs
	expectationOrigins BudgetCacheRepositoryMockGetBudgetsListExpectationOrigins
	results            *BudgetCacheRepositoryMockGetBudgetsListResults
	returnOrigin       string
	Counter            uint64
}

// BudgetCacheRepositoryMockGetBudgetsListParams contains parameters of the BudgetCacheRepository.GetBudgetsList
type BudgetCacheRepositoryMockGetBudgetsListParams struct {
	ctx context.Context
	key string
}

// BudgetCacheRepositoryMockGetBudgetsListParamPtrs contains pointers to parameters of the BudgetCacheRepository.GetBudgetsList
type BudgetCacheRepositoryMockGetBudgetsListParamPtrs struct {
	ctx *context.Context
	key *string
}

// BudgetCacheRepositoryMockGetBudgetsListResults contains results of the BudgetCacheRepository.GetBudgetsList
type BudgetCacheRepositoryMockGetBudgetsListResults struct {
	items []*entity.Budget
	err   error
}

// BudgetCacheRepositoryMockGetBudgetsListOrigins contains origins of expectations of the BudgetCacheRepository.GetBudgetsList
type BudgetCacheRepositoryMockGetBudgetsListExpectationOrigins struct {
	origin    string
	originCtx string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) Optional() *mBudgetCacheRepositoryMockGetBudgetsList {
	mmGetBudgetsList.optional = true
	return mmGetBudgetsList
}

// Expect sets up expected params for BudgetCacheRepository.GetBudgetsList
func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) Expect(ctx context.Context, key string) *mBudgetCacheRepositoryMockGetBudgetsList {
	if mmGetBudgetsList.mock.funcGetBudgetsList != nil {
		mmGetBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsList mock is already set by Set")
	}

	if mmGetBudgetsList.defaultExpectation == nil {
		mmGetBudgetsList.defaultExpectation = &BudgetCacheRepositoryMockGetBudgetsListExpectation{}
	}

	if mmGetBudgetsList.defaultExpectation.paramPtrs != nil {
		mmGetBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsList mock is already set by ExpectParams functions")
	}

	mmGetBudgetsList.defaultExpectation.params = &BudgetCacheRepositoryMockGetBudgetsListParams{ctx, key}
	mmGetBudgetsList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetBudgetsList.expectations {
		if minimock.Equal(e.params, mmGetBudgetsList.defaultExpectation.params) {
			mmGetBudgetsList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBudgetsList.defaultExpectation.params)
		}
	}

	return mmGetBudgetsList
}

// ExpectCtxParam1 sets up expected param ctx for BudgetCacheRepository.GetBudgetsList
func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) ExpectCtxParam1(ctx context.Context) *mBudgetCacheRepositoryMockGetBudgetsList {
	if mmGetBudgetsList.mock.funcGetBudgetsList != nil {
		mmGetBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsList mock is already set by Set")
	}

	if mmGetBudgetsList.defaultExpectation == nil {
		mmGetBudgetsList.defaultExpectation = &BudgetCacheRepositoryMockGetBudgetsListExpectation{}
	}

	if mmGetBudgetsList.defaultExpectation.params != nil {
		mmGetBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsList mock is already set by Expect")
	}

	if mmGetBudgetsList.defaultExpectation.paramPtrs == nil {
		mmGetBudgetsList.defaultExpectation.paramPtrs = &BudgetCacheRepositoryMockGetBudgetsListParamPtrs{}
	}
	mmGetBudgetsList.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetBudgetsList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetBudgetsList
}

// ExpectKeyParam2 sets up expected param key for BudgetCacheRepository.GetBudgetsList
func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) ExpectKeyParam2(key string) *mBudgetCacheRepositoryMockGetBudgetsList {
	if mmGetBudgetsList.mock.funcGetBudgetsList != nil {
		mmGetBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsList mock is already set by Set")
	}

	if mmGetBudgetsList.defaultExpectation == nil {
		mmGetBudgetsList.defaultExpectation = &BudgetCacheRepositoryMockGetBudgetsListExpectation{}
	}

	if mmGetBudgetsList.defaultExpectation.params != nil {
		mmGetBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsList mock is already set by Expect")
	}

	if mmGetBudgetsList.defaultExpectation.paramPtrs == nil {
		mmGetBudgetsList.defaultExpectation.paramPtrs = &BudgetCacheRepositoryMockGetBudgetsListParamPtrs{}
	}
	mmGetBudgetsList.defaultExpectation.paramPtrs.key = &key
	mmGetBudgetsList.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmGetBudgetsList
}

// Inspect accepts an inspector function that has same arguments as the BudgetCacheRepository.GetBudgetsList
func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) Inspect(f func(ctx context.Context, key string)) *mBudgetCacheRepositoryMockGetBudgetsList {
	if mmGetBudgetsList.mock.inspectFuncGetBudgetsList != nil {
		mmGetBudgetsList.mock.t.Fatalf("Inspect function is already set for BudgetCacheRepositoryMock.GetBudgetsList")
	}

	mmGetBudgetsList.mock.inspectFuncGetBudgetsList = f

	return mmGetBudgetsList
}

// Return sets up results that will be returned by BudgetCacheRepository.GetBudgetsList
func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) Return(items []*entity.Budget, err error) *BudgetCacheRepositoryMock {
	if mmGetBudgetsList.mock.funcGetBudgetsList != nil {
		mmGetBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsList mock is already set by Set")
	}

	if mmGetBudgetsList.defaultExpectation == nil {
		mmGetBudgetsList.defaultExpectation = &BudgetCacheRepositoryMockGetBudgetsListExpectation{mock: mmGetBudgetsList.mock}
	}
	mmGetBudgetsList.defaultExpectation.results = &BudgetCacheRepositoryMockGetBudgetsListResults{items, err}
	mmGetBudgetsList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetBudgetsList.mock
}

// Set uses given function f to mock the BudgetCacheRepository.GetBudgetsList method
func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) Set(f func(ctx context.Context, key string) (items []*entity.Budget, err error)) *BudgetCacheRepositoryMock {
	if mmGetBudgetsList.defaultExpectation != nil {
		mmGetBudgetsList.mock.t.Fatalf("Default expectation is already set for the BudgetCacheRepository.GetBudgetsList method")
	}

	if len(mmGetBudgetsList.expectations) > 0 {
		mmGetBudgetsList.mock.t.Fatalf("Some expectations are already set for the BudgetCacheRepository.GetBudgetsList method")
	}

	mmGetBudgetsList.mock.funcGetBudgetsList = f
	mmGetBudgetsList.mock.funcGetBudgetsListOrigin = minimock.CallerInfo(1)
	return mmGetBudgetsList.mock
}

// When sets expectation for the BudgetCacheRepository.GetBudgetsList which will trigger the result defined by the following
// Then helper
func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) When(ctx context.Context, key string) *BudgetCacheRepositoryMockGetBudgetsListExpectation {
	if mmGetBudgetsList.mock.funcGetBudgetsList != nil {
		mmGetBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsList mock is already set by Set")
	}

	expectation := &BudgetCacheRepositoryMockGetBudgetsListExpectation{
		mock:               mmGetBudgetsList.mock,
		params:             &BudgetCacheRepositoryMockGetBudgetsListParams{ctx, key},
		expectationOrigins: BudgetCacheRepositoryMockGetBudgetsListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetBudgetsList.expectations = append(mmGetBudgetsList.expectations, expectation)
	return expectation
}

// Then sets up BudgetCacheRepository.GetBudgetsList return parameters for the expectation previously defined by the When method
func (e *BudgetCacheRepositoryMockGetBudgetsListExpectation) Then(items []*entity.Budget, err error) *BudgetCacheRepositoryMock {
	e.results = &BudgetCacheRepositoryMockGetBudgetsListResults{items, err}
	return e.mock
}

// Times sets number of times BudgetCacheRepository.GetBudgetsList should be invoked
func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) Times(n uint64) *mBudgetCacheRepositoryMockGetBudgetsList {
	if n == 0 {
		mmGetBudgetsList.mock.t.Fatalf("Times of BudgetCacheRepositoryMock.GetBudgetsList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBudgetsList.expectedInvocations, n)
	mmGetBudgetsList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetBudgetsList
}

func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) invocationsDone() bool {
	if len(mmGetBudgetsList.expectations) == 0 && mmGetBudgetsList.defaultExpectation == nil && mmGetBudgetsList.mock.funcGetBudgetsList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBudgetsList.mock.afterGetBudgetsListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBudgetsList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBudgetsList implements mm_usecase.BudgetCacheRepository
func (mmGetBudgetsList *BudgetCacheRepositoryMock) GetBudgetsList(ctx context.Context, key string) (items []*entity.Budget, err error) {
	mm_atomic.AddUint64(&mmGetBudgetsList.beforeGetBudgetsListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBudgetsList.afterGetBudgetsListCounter, 1)

	mmGetBudgetsList.t.Helper()

	if mmGetBudgetsList.inspectFuncGetBudgetsList != nil {
		mmGetBudgetsList.inspectFuncGetBudgetsList(ctx, key)
	}

	mm_params := BudgetCacheRepositoryMockGetBudgetsListParams{ctx, key}

	// Record call args
	mmGetBudgetsList.GetBudgetsListMock.mutex.Lock()
	mmGetBudgetsList.GetBudgetsListMock.callArgs = append(mmGetBudgetsList.GetBudgetsListMock.callArgs, &mm_params)
	mmGetBudgetsList.GetBudgetsListMock.mutex.Unlock()

	for _, e := range mmGetBudgetsList.GetBudgetsListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.items, e.results.err
		}
	}

	if mmGetBudgetsList.GetBudgetsListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBudgetsList.GetBudgetsListMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBudgetsList.GetBudgetsListMock.defaultExpectation.params
		mm_want_ptrs := mmGetBudgetsList.GetBudgetsListMock.defaultExpectation.paramPtrs

		mm_got := BudgetCacheRepositoryMockGetBudgetsListParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBudgetsList.t.Errorf("BudgetCacheRepositoryMock.GetBudgetsList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBudgetsList.GetBudgetsListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmGetBudgetsList.t.Errorf("BudgetCacheRepositoryMock.GetBudgetsList got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBudgetsList.GetBudgetsListMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBudgetsList.t.Errorf("BudgetCacheRepositoryMock.GetBudgetsList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetBudgetsList.GetBudgetsListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBudgetsList.GetBudgetsListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBudgetsList.t.Fatal("No results are set for the BudgetCacheRepositoryMock.GetBudgetsList")
		}
		return (*mm_results).items, (*mm_results).err
	}
	if mmGetBudgetsList.funcGetBudgetsList != nil {
		return mmGetBudgetsList.funcGetBudgetsList(ctx, key)
	}
	mmGetBudgetsList.t.Fatalf("Unexpected call to BudgetCacheRepositoryMock.GetBudgetsList. %v %v", ctx, key)
	return
}

// GetBudgetsListAfterCounter returns a count of finished BudgetCacheRepositoryMock.GetBudgetsList invocations
func (mmGetBudgetsList *BudgetCacheRepositoryMock) GetBudgetsListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBudgetsList.afterGetBudgetsListCounter)
}

// GetBudgetsListBeforeCounter returns a count of BudgetCacheRepositoryMock.GetBudgetsList invocations
func (mmGetBudgetsList *BudgetCacheRepositoryMock) GetBudgetsListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBudgetsList.beforeGetBudgetsListCounter)
}

// Calls returns a list of arguments used in each call to BudgetCacheRepositoryMock.GetBudgetsList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) Calls() []*BudgetCacheRepositoryMockGetBudgetsListParams {
	mmGetBudgetsList.mutex.RLock()

	argCopy := make([]*BudgetCacheRepositoryMockGetBudgetsListParams, len(mmGetBudgetsList.callArgs))
	copy(argCopy, mmGetBudgetsList.callArgs)

	mmGetBudgetsList.mutex.RUnlock()

	return argCopy
}

// MinimockGetBudgetsListDone returns true if the count of the GetBudgetsList invocations corresponds
// the number of defined expectations
func (m *BudgetCacheRepositoryMock) MinimockGetBudgetsListDone() bool {
	if m.GetBudgetsListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBudgetsListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBudgetsListMock.invocationsDone()
}

// MinimockGetBudgetsListInspect logs each unmet expectation
func (m *BudgetCacheRepositoryMock) MinimockGetBudgetsListInspect() {
	for _, e := range m.GetBudgetsListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudgetsList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetBudgetsListCounter := mm_atomic.LoadUint64(&m.afterGetBudgetsListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBudgetsListMock.defaultExpectation != nil && afterGetBudgetsListCounter < 1 {
		if m.GetBudgetsListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudgetsList at\n%s", m.GetBudgetsListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudgetsList at\n%s with params: %#v", m.GetBudgetsListMock.defaultExpectation.expectationOrigins.origin, *m.GetBudgetsListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBudgetsList != nil && afterGetBudgetsListCounter < 1 {
		m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudgetsList at\n%s", m.funcGetBudgetsListOrigin)
	}

	if !m.GetBudgetsListMock.invocationsDone() && afterGetBudgetsListCounter > 0 {
		m.t.Errorf("Expected %d calls to BudgetCacheRepositoryMock.GetBudgetsList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetBudgetsListMock.expectedInvocations), m.GetBudgetsListMock.expectedInvocationsOrigin, afterGetBudgetsListCounter)
	}
}

type mBudgetCacheRepositoryMockGetBudgetsPagedList struct {
	optional           bool
	mock               *BudgetCacheRepositoryMock
	defaultExpectation *BudgetCacheRepositoryMockGetBudgetsPagedListExpectation
	expectations       []*BudgetCacheRepositoryMockGetBudgetsPagedListExpectation

	callArgs []*BudgetCacheRepositoryMockGetBudgetsPagedListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BudgetCacheRepositoryMockGetBudgetsPagedListExpectation specifies expectation struct of the BudgetCacheRepository.GetBudgetsPagedList
type BudgetCacheRepositoryMockGetBudgetsPagedListExpectation struct {
	mock               *BudgetCacheRepositoryMock
	params             *BudgetCacheRepositoryMockGetBudgetsPagedListParams
	paramPtrs          *BudgetCacheRepositoryMockGetBudgetsPagedListParamPtrs
	expectationOrigins BudgetCacheRepositoryMockGetBudgetsPagedListExpectationOrigins
	results            *BudgetCacheRepositoryMockGetBudgetsPagedListResults
	returnOrigin       string
	Counter            uint64
}

// BudgetCacheRepositoryMockGetBudgetsPagedListParams contains parameters of the BudgetCacheRepository.GetBudgetsPagedList
type BudgetCacheRepositoryMockGetBudgetsPagedListParams struct {
	ctx context.Context
	key string
}

// BudgetCacheRepositoryMockGetBudgetsPagedListParamPtrs contains pointers to parameters of the BudgetCacheRepository.GetBudgetsPagedList
type BudgetCacheRepositoryMockGetBudgetsPagedListParamPtrs struct {
	ctx *context.Context
	key *string
}

// BudgetCacheRepositoryMockGetBudgetsPagedListResults contains results of the BudgetCacheRepository.GetBudgetsPagedList
type BudgetCacheRepositoryMockGetBudgetsPagedListResults struct {
	items []*entity.Budget
	total uint64
	err   error
}

// BudgetCacheRepositoryMockGetBudgetsPagedListOrigins contains origins of expectations of the BudgetCacheRepository.GetBudgetsPagedList
type BudgetCacheRepositoryMockGetBudgetsPagedListExpectationOrigins struct {
	origin    string
	originCtx string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) Optional() *mBudgetCacheRepositoryMockGetBudgetsPagedList {
	mmGetBudgetsPagedList.optional = true
	return mmGetBudgetsPagedList
}

// Expect sets up expected params for BudgetCacheRepository.GetBudgetsPagedList
func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) Expect(ctx context.Context, key string) *mBudgetCacheRepositoryMockGetBudgetsPagedList {
	if mmGetBudgetsPagedList.mock.funcGetBudgetsPagedList != nil {
		mmGetBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsPagedList mock is already set by Set")
	}

	if mmGetBudgetsPagedList.defaultExpectation == nil {
		mmGetBudgetsPagedList.defaultExpectation = &BudgetCacheRepositoryMockGetBudgetsPagedListExpectation{}
	}

	if mmGetBudgetsPagedList.defaultExpectation.paramPtrs != nil {
		mmGetBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsPagedList mock is already set by ExpectParams functions")
	}

	mmGetBudgetsPagedList.defaultExpectation.params = &BudgetCacheRepositoryMockGetBudgetsPagedListParams{ctx, key}
	mmGetBudgetsPagedList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetBudgetsPagedList.expectations {
		if minimock.Equal(e.params, mmGetBudgetsPagedList.defaultExpectation.params) {
			mmGetBudgetsPagedList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBudgetsPagedList.defaultExpectation.params)
		}
	}

	return mmGetBudgetsPagedList
}

// ExpectCtxParam1 sets up expected param ctx for BudgetCacheRepository.GetBudgetsPagedList
func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) ExpectCtxParam1(ctx context.Context) *mBudgetCacheRepositoryMockGetBudgetsPagedList {
	if mmGetBudgetsPagedList.mock.funcGetBudgetsPagedList != nil {
		mmGetBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsPagedList mock is already set by Set")
	}

	if mmGetBudgetsPagedList.defaultExpectation == nil {
		mmGetBudgetsPagedList.defaultExpectation = &BudgetCacheRepositoryMockGetBudgetsPagedListExpectation{}
	}

	if mmGetBudgetsPagedList.defaultExpectation.params != nil {
		mmGetBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsPagedList mock is already set by Expect")
	}

	if mmGetBudgetsPagedList.defaultExpectation.paramPtrs == nil {
		mmGetBudgetsPagedList.defaultExpectation.paramPtrs = &BudgetCacheRepositoryMockGetBudgetsPagedListParamPtrs{}
	}
	mmGetBudgetsPagedList.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetBudgetsPagedList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetBudgetsPagedList
}

// ExpectKeyParam2 sets up expected param key for BudgetCacheRepository.GetBudgetsPagedList
func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) ExpectKeyParam2(key string) *mBudgetCacheRepositoryMockGetBudgetsPagedList {
	if mmGetBudgetsPagedList.mock.funcGetBudgetsPagedList != nil {
		mmGetBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsPagedList mock is already set by Set")
	}

	if mmGetBudgetsPagedList.defaultExpectation == nil {
		mmGetBudgetsPagedList.defaultExpectation = &BudgetCacheRepositoryMockGetBudgetsPagedListExpectation{}
	}

	if mmGetBudgetsPagedList.defaultExpectation.params != nil {
		mmGetBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsPagedList mock is already set by Expect")
	}

	if mmGetBudgetsPagedList.defaultExpectation.paramPtrs == nil {
		mmGetBudgetsPagedList.defaultExpectation.paramPtrs = &BudgetCacheRepositoryMockGetBudgetsPagedListParamPtrs{}
	}
	mmGetBudgetsPagedList.defaultExpectation.paramPtrs.key = &key
	mmGetBudgetsPagedList.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmGetBudgetsPagedList
}

// Inspect accepts an inspector function that has same arguments as the BudgetCacheRepository.GetBudgetsPagedList
func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) Inspect(f func(ctx context.Context, key string)) *mBudgetCacheRepositoryMockGetBudgetsPagedList {
	if mmGetBudgetsPagedList.mock.inspectFuncGetBudgetsPagedList != nil {
		mmGetBudgetsPagedList.mock.t.Fatalf("Inspect function is already set for BudgetCacheRepositoryMock.GetBudgetsPagedList")
	}

	mmGetBudgetsPagedList.mock.inspectFuncGetBudgetsPagedList = f

	return mmGetBudgetsPagedList
}

// Return sets up results that will be returned by BudgetCacheRepository.GetBudgetsPagedList
func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) Return(items []*entity.Budget, total uint64, err error) *BudgetCacheRepositoryMock {
	if mmGetBudgetsPagedList.mock.funcGetBudgetsPagedList != nil {
		mmGetBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsPagedList mock is already set by Set")
	}

	if mmGetBudgetsPagedList.defaultExpectation == nil {
		mmGetBudgetsPagedList.defaultExpectation = &BudgetCacheRepositoryMockGetBudgetsPagedListExpectation{mock: mmGetBudgetsPagedList.mock}
	}
	mmGetBudgetsPagedList.defaultExpectation.results = &BudgetCacheRepositoryMockGetBudgetsPagedListResults{items, total, err}
	mmGetBudgetsPagedList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetBudgetsPagedList.mock
}

// Set uses given function f to mock the BudgetCacheRepository.GetBudgetsPagedList method
func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) Set(f func(ctx context.Context, key string) (items []*entity.Budget, total uint64, err error)) *BudgetCacheRepositoryMock {
	if mmGetBudgetsPagedList.defaultExpectation != nil {
		mmGetBudgetsPagedList.mock.t.Fatalf("Default expectation is already set for the BudgetCacheRepository.GetBudgetsPagedList method")
	}

	if len(mmGetBudgetsPagedList.expectations) > 0 {
		mmGetBudgetsPagedList.mock.t.Fatalf("Some expectations are already set for the BudgetCacheRepository.GetBudgetsPagedList method")
	}

	mmGetBudgetsPagedList.mock.funcGetBudgetsPagedList = f
	mmGetBudgetsPagedList.mock.funcGetBudgetsPagedListOrigin = minimock.CallerInfo(1)
	return mmGetBudgetsPagedList.mock
}

// When sets expectation for the BudgetCacheRepository.GetBudgetsPagedList which will trigger the result defined by the following
// Then helper
func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) When(ctx context.Context, key string) *BudgetCacheRepositoryMockGetBudgetsPagedListExpectation {
	if mmGetBudgetsPagedList.mock.funcGetBudgetsPagedList != nil {
		mmGetBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsPagedList mock is already set by Set")
	}

	expectation := &BudgetCacheRepositoryMockGetBudgetsPagedListExpectation{
		mock:               mmGetBudgetsPagedList.mock,
		params:             &BudgetCacheRepositoryMockGetBudgetsPagedListParams{ctx, key},
		expectationOrigins: BudgetCacheRepositoryMockGetBudgetsPagedListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetBudgetsPagedList.expectations = append(mmGetBudgetsPagedList.expectations, expectation)
	return expectation
}

// Then sets up BudgetCacheRepository.GetBudgetsPagedList return parameters for the expectation previously defined by the When method
func (e *BudgetCacheRepositoryMockGetBudgetsPagedListExpectation) Then(items []*entity.Budget, total uint64, err error) *BudgetCacheRepositoryMock {
	e.results = &BudgetCacheRepositoryMockGetBudgetsPagedListResults{items, total, err}
	return e.mock
}

// Times sets number of times BudgetCacheRepository.GetBudgetsPagedList should be invoked
func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) Times(n uint64) *mBudgetCacheRepositoryMockGetBudgetsPagedList {
	if n == 0 {
		mmGetBudgetsPagedList.mock.t.Fatalf("Times of BudgetCacheRepositoryMock.GetBudgetsPagedList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBudgetsPagedList.expectedInvocations, n)
	mmGetBudgetsPagedList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetBudgetsPagedList
}

func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) invocationsDone() bool {
	if len(mmGetBudgetsPagedList.expectations) == 0 && mmGetBudgetsPagedList.defaultExpectation == nil && mmGetBudgetsPagedList.mock.funcGetBudgetsPagedList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBudgetsPagedList.mock.afterGetBudgetsPagedListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBudgetsPagedList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBudgetsPagedList implements mm_usecase.BudgetCacheRepository
func (mmGetBudgetsPagedList *BudgetCacheRepositoryMock) GetBudgetsPagedList(ctx context.Context, key string) (items []*entity.Budget, total uint64, err error) {
	mm_atomic.AddUint64(&mmGetBudgetsPagedList.beforeGetBudgetsPagedListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBudgetsPagedList.afterGetBudgetsPagedListCounter, 1)

	mmGetBudgetsPagedList.t.Helper()

	if mmGetBudgetsPagedList.inspectFuncGetBudgetsPagedList != nil {
		mmGetBudgetsPagedList.inspectFuncGetBudgetsPagedList(ctx, key)
	}

	mm_params := BudgetCacheRepositoryMockGetBudgetsPagedListParams{ctx, key}

	// Record call args
	mmGetBudgetsPagedList.GetBudgetsPagedListMock.mutex.Lock()
	mmGetBudgetsPagedList.GetBudgetsPagedListMock.callArgs = append(mmGetBudgetsPagedList.GetBudgetsPagedListMock.callArgs, &mm_params)
	mmGetBudgetsPagedList.GetBudgetsPagedListMock.mutex.Unlock()

	for _, e := range mmGetBudgetsPagedList.GetBudgetsPagedListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.items, e.results.total, e.results.err
		}
	}

	if mmGetBudgetsPagedList.GetBudgetsPagedListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBudgetsPagedList.GetBudgetsPagedListMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBudgetsPagedList.GetBudgetsPagedListMock.defaultExpectation.params
		mm_want_ptrs := mmGetBudgetsPagedList.GetBudgetsPagedListMock.defaultExpectation.paramPtrs

		mm_got := BudgetCacheRepositoryMockGetBudgetsPagedListParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBudgetsPagedList.t.Errorf("BudgetCacheRepositoryMock.GetBudgetsPagedList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBudgetsPagedList.GetBudgetsPagedListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmGetBudgetsPagedList.t.Errorf("BudgetCacheRepositoryMock.GetBudgetsPagedList got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBudgetsPagedList.GetBudgetsPagedListMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBudgetsPagedList.t.Errorf("BudgetCacheRepositoryMock.GetBudgetsPagedList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetBudgetsPagedList.GetBudgetsPagedListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBudgetsPagedList.GetBudgetsPagedListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBudgetsPagedList.t.Fatal("No results are set for the BudgetCacheRepositoryMock.GetBudgetsPagedList")
		}
		return (*mm_results).items, (*mm_results).total, (*mm_results).err
	}
	if mmGetBudgetsPagedList.funcGetBudgetsPagedList != nil {
		return mmGetBudgetsPagedList.funcGetBudgetsPagedList(ctx, key)
	}
	mmGetBudgetsPagedList.t.Fatalf("Unexpected call to BudgetCacheRepositoryMock.GetBudgetsPagedList. %v %v", ctx, key)
	return
}

// GetBudgetsPagedListAfterCounter returns a count of finished BudgetCacheRepositoryMock.GetBudgetsPagedList invocations
func (mmGetBudgetsPagedList *BudgetCacheRepositoryMock) GetBudgetsPagedListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBudgetsPagedList.afterGetBudgetsPagedListCounter)
}

// GetBudgetsPagedListBeforeCounter returns a count of BudgetCacheRepositoryMock.GetBudgetsPagedList invocations
func (mmGetBudgetsPagedList *BudgetCacheRepositoryMock) GetBudgetsPagedListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBudgetsPagedList.beforeGetBudgetsPagedListCounter)
}

// Calls returns a list of arguments used in each call to BudgetCacheRepositoryMock.GetBudgetsPagedList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) Calls() []*BudgetCacheRepositoryMockGetBudgetsPagedListParams {
	mmGetBudgetsPagedList.mutex.RLock()

	argCopy := make([]*BudgetCacheRepositoryMockGetBudgetsPagedListParams, len(mmGetBudgetsPagedList.callArgs))
	copy(argCopy, mmGetBudgetsPagedList.callArgs)

	mmGetBudgetsPagedList.mutex.RUnlock()

	return argCopy
}

// MinimockGetBudgetsPagedListDone returns true if the count of the GetBudgetsPagedList invocations corresponds
// the number of defined expectations
func (m *BudgetCacheRepositoryMock) MinimockGetBudgetsPagedListDone() bool {
	if m.GetBudgetsPagedListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBudgetsPagedListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBudgetsPagedListMock.invocationsDone()
}

// MinimockGetBudgetsPagedListInspect logs each unmet expectation
func (m *BudgetCacheRepositoryMock) MinimockGetBudgetsPagedListInspect() {
	for _, e := range m.GetBudgetsPagedListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudgetsPagedList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetBudgetsPagedListCounter := mm_atomic.LoadUint64(&m.afterGetBudgetsPagedListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBudgetsPagedListMock.defaultExpectation != nil && afterGetBudgetsPagedListCounter < 1 {
		if m.GetBudgetsPagedListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudgetsPagedList at\n%s", m.GetBudgetsPagedListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudgetsPagedList at\n%s with params: %#v", m.GetBudgetsPagedListMock.defaultExpectation.expectationOrigins.origin, *m.GetBudgetsPagedListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBudgetsPagedList != nil && afterGetBudgetsPagedListCounter < 1 {
		m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudgetsPagedList at\n%s", m.funcGetBudgetsPagedListOrigin)
	}

	if !m.GetBudgetsPagedListMock.invocationsDone() && afterGetBudgetsPagedListCounter > 0 {
		m.t.Errorf("Expected %d calls to BudgetCacheRepositoryMock.GetBudgetsPagedList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetBudgetsPagedListMock.expectedInvocations), m.GetBudgetsPagedListMock.expectedInvocationsOrigin, afterGetBudgetsPagedListCounter)
	}
}

type mBudgetCacheRepositoryMockSaveBudget struct {
	optional           bool
	mock               *BudgetCacheRepositoryMock
	defaultExpectation *BudgetCacheRepositoryMockSaveBudgetExpectation
	expectations       []*BudgetCacheRepositoryMockSaveBudgetExpectation

	callArgs []*BudgetCacheRepositoryMockSaveBudgetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BudgetCacheRepositoryMockSaveBudgetExpectation specifies expectation struct of the BudgetCacheRepository.SaveBudget
type BudgetCacheRepositoryMockSaveBudgetExpectation struct {
	mock               *BudgetCacheRepositoryMock
	params             *BudgetCacheRepositoryMockSaveBudgetParams
	paramPtrs          *BudgetCacheRepositoryMockSaveBudgetParamPtrs
	expectationOrigins BudgetCacheRepositoryMockSaveBudgetExpectationOrigins
	results            *BudgetCacheRepositoryMockSaveBudgetResults
	returnOrigin       string
	Counter            uint64
}

// BudgetCacheRepositoryMockSaveBudgetParams contains parameters of the BudgetCacheRepository.SaveBudget
type BudgetCacheRepositoryMockSaveBudgetParams struct {
	ctx  context.Context
	key  string
	item *entity.Budget
	ttl  time.Duration
}

// BudgetCacheRepositoryMockSaveBudgetParamPtrs contains pointers to parameters of the BudgetCacheRepository.SaveBudget
type BudgetCacheRepositoryMockSaveBudgetParamPtrs struct {
	ctx  *context.Context
	key  *string
	item **entity.Budget
	ttl  *time.Duration
}

// BudgetCacheRepositoryMockSaveBudgetResults contains results of the BudgetCacheRepository.SaveBudget
type BudgetCacheRepositoryMockSaveBudgetResults struct {
	err error
}

// BudgetCacheRepositoryMockSaveBudgetOrigins contains origins of expectations of the BudgetCacheRepository.SaveBudget
type BudgetCacheRepositoryMockSaveBudgetExpectationOrigins struct {
	origin     string
	originCtx  string
	originKey  string
	originItem string
	originTtl  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) Optional() *mBudgetCacheRepositoryMockSaveBudget {
	mmSaveBudget.optional = true
	return mmSaveBudget
}

// Expect sets up expected params for BudgetCacheRepository.SaveBudget
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) Expect(ctx context.Context, key string, item *entity.Budget, ttl time.Duration) *mBudgetCacheRepositoryMockSaveBudget {
	if mmSaveBudget.mock.funcSaveBudget != nil {
		mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Set")
	}

	if mmSaveBudget.defaultExpectation == nil {
		mmSaveBudget.defaultExpectation = &BudgetCacheRepositoryMockSaveBudgetExpectation{}
	}

	if mmSaveBudget.defaultExpectation.paramPtrs != nil {
		mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by ExpectParams functions")
	}

	mmSaveBudget.defaultExpectation.params = &BudgetCacheRepositoryMockSaveBudgetParams{ctx, key, item, ttl}
	mmSaveBudget.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSaveBudget.expectations {
		if minimock.Equal(e.params, mmSaveBudget.defaultExpectation.params) {
			mmSaveBudget.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveBudget.defaultExpectation.params)
		}
	}

	return mmSaveBudget
}

// ExpectCtxParam1 sets up expected param ctx for BudgetCacheRepository.SaveBudget
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) ExpectCtxParam1(ctx context.Context) *mBudgetCacheRepositoryMockSaveBudget {
	if mmSaveBudget.mock.funcSaveBudget != nil {
		mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Set")
	}

	if mmSaveBudget.defaultExpectation == nil {
		mmSaveBudget.defaultExpectation = &BudgetCacheRepositoryMockSaveBudgetExpectation{}
	}

	if mmSaveBudget.defaultExpectation.params != nil {
		mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Expect")
	}

	if mmSaveBudget.defaultExpectation.paramPtrs == nil {
		mmSaveBudget.defaultExpectation.paramPtrs = &BudgetCacheRepositoryMockSaveBudgetParamPtrs{}
	}
	mmSaveBudget.defaultExpectation.paramPtrs.ctx = &ctx
	mmSaveBudget.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSaveBudget
}

// ExpectKeyParam2 sets up expected param key for BudgetCacheRepository.SaveBudget
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) ExpectKeyParam2(key string) *mBudgetCacheRepositoryMockSaveBudget {
	if mmSaveBudget.mock.funcSaveBudget != nil {
		mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Set")
	}

	if mmSaveBudget.defaultExpectation == nil {
		mmSaveBudget.defaultExpectation = &BudgetCacheRepositoryMockSaveBudgetExpectation{}
	}

	if mmSaveBudget.defaultExpectation.params != nil {
		mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Expect")
	}

	if mmSaveBudget.defaultExpectation.paramPtrs == nil {
		mmSaveBudget.defaultExpectation.paramPtrs = &BudgetCacheRepositoryMockSaveBudgetParamPtrs{}
	}
	mmSaveBudget.defaultExpectation.paramPtrs.key = &key
	mmSaveBudget.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmSaveBudget
}

// ExpectItemParam3 sets up expected param item for BudgetCacheRepository.SaveBudget
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) ExpectItemParam3(item *entity.Budget) *mBudgetCacheRepositoryMockSaveBudget {
	if mmSaveBudget.mock.funcSaveBudget != nil {
		mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Set")
	}

	if mmSaveBudget.defaultExpectation == nil {
		mmSaveBudget.defaultExpectation = &BudgetCacheRepositoryMockSaveBudgetExpectation{}
	}

	if mmSaveBudget.defaultExpectation.params != nil {
		mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Expect")
	}

	if mmSaveBudget.defaultExpectation.paramPtrs == nil {
		mmSaveBudget.defaultExpectation.paramPtrs = &BudgetCacheRepositoryMockSaveBudgetParamPtrs{}
	}
	mmSaveBudget.defaultExpectation.paramPtrs.item = &item
	mmSaveBudget.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmSaveBudget
}

// ExpectTtlParam4 sets up expected param ttl for BudgetCacheRepository.SaveBudget
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) ExpectTtlParam4(ttl time.Duration) *mBudgetCacheRepositoryMockSaveBudget {
	if mmSaveBudget.mock.funcSaveBudget != nil {
		mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Set")
	}

	if mmSaveBudget.defaultExpectation == nil {
		mmSaveBudget.defaultExpectation = &BudgetCacheRepositoryMockSaveBudgetExpectation{}
	}

	if mmSaveBudget.defaultExpectation.params != nil {
		mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Expect")
	}

	if mmSaveBudget.defaultExpectation.paramPtrs == nil {
		mmSaveBudget.defaultExpectation.paramPtrs = &BudgetCacheRepositoryMockSaveBudgetParamPtrs{}
	}
	mmSaveBudget.defaultExpectation.paramPtrs.ttl = &ttl
	mmSaveBudget.defaultExpectation.expectationOrigins.originTtl = minimock.CallerInfo(1)

	return mmSaveBudget
}

// Inspect accepts an inspector function that has same arguments as the BudgetCacheRepository.SaveBudget
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) Inspect(f func(ctx context.Context, key string, item *entity.Budget, ttl time.Duration)) *mBudgetCacheRepositoryMockSaveBudget {
	if mmSaveBudget.mock.inspectFuncSaveBudget != nil {
		mmSaveBudget.mock.t.Fatalf("Inspect function is already set for BudgetCacheRepositoryMock.SaveBudget")
	}

	mmSaveBudget.mock.inspectFuncSaveBudget = f

	return mmSaveBudget
}

// Return sets up results that will be returned by BudgetCacheRepository.SaveBudget
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) Return(err error) *BudgetCacheRepositoryMock {
	if mmSaveBudget.mock.funcSaveBudget != nil {
		mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Set")
	}

	if mmSaveBudget.defaultExpectation == nil {
		mmSaveBudget.defaultExpectation = &BudgetCacheRepositoryMockSaveBudgetExpectation{mock: mmSaveBudget.mock}
	}
	mmSaveBudget.defaultExpectation.results = &BudgetCacheRepositoryMockSaveBudgetResults{err}
	mmSaveBudget.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSaveBudget.mock
}

// Set uses given function f to mock the BudgetCacheRepository.SaveBudget method
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) Set(f func(ctx context.Context, key string, item *entity.Budget, ttl time.Duration) (err error)) *BudgetCacheRepositoryMock {
	if mmSaveBudget.defaultExpectation != nil {
		mmSaveBudget.mock.t.Fatalf("Default expectation is already set for the BudgetCacheRepository.SaveBudget method")
	}

	if len(mmSaveBudget.expectations) > 0 {
		mmSaveBudget.mock.t.Fatalf("Some expectations are already set for the BudgetCacheRepository.SaveBudget method")
	}

	mmSaveBudget.mock.funcSaveBudget = f
	mmSaveBudget.mock.funcSaveBudgetOrigin = minimock.CallerInfo(1)
	return mmSaveBudget.mock
}

// When sets expectation for the BudgetCacheRepository.SaveBudget which will trigger the result defined by the following
// Then helper
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) When(ctx context.Context, key string, item *entity.Budget, ttl time.Duration) *BudgetCacheRepositoryMockSaveBudgetExpectation {
	if mmSaveBudget.mock.funcSaveBudget != nil {
		mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Set")
	}

	expectation := &BudgetCacheRepositoryMockSaveBudgetExpectation{
		mock:               mmSaveBudget.mock,
		params:             &BudgetCacheRepositoryMockSaveBudgetParams{ctx, key, item, ttl},
		expectationOrigins: BudgetCacheRepositoryMockSaveBudgetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSaveBudget.expectations = append(mmSaveBudget.expectations, expectation)
	return expectation
}

// Then sets up BudgetCacheRepository.SaveBudget return parameters for the expectation previously defined by the When method
func (e *BudgetCacheRepositoryMockSaveBudgetExpectation) Then(err error) *BudgetCacheRepositoryMock {
	e.results = &BudgetCacheRepositoryMockSaveBudgetResults{err}
	return e.mock
}

// Times sets number of times BudgetCacheRepository.SaveBudget should be invoked
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) Times(n uint64) *mBudgetCacheRepositoryMockSaveBudget {
	if n == 0 {
		mmSaveBudget.mock.t.Fatalf("Times of BudgetCacheRepositoryMock.SaveBudget mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSaveBudget.expectedInvocations, n)
	mmSaveBudget.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSaveBudget
}

func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) invocationsDone() bool {
	if len(mmSaveBudget.expectations) == 0 && mmSaveBudget.defaultExpectation == nil && mmSaveBudget.mock.funcSaveBudget == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSaveBudget.mock.afterSaveBudgetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSaveBudget.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SaveBudget implements mm_usecase.BudgetCacheRepository
func (mmSaveBudget *BudgetCacheRepositoryMock) SaveBudget(ctx context.Context, key string, item *entity.Budget, ttl time.Duration) (err error) {
	mm_atomic.AddUint64(&mmSaveBudget.beforeSaveBudgetCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveBudget.afterSaveBudgetCounter, 1)

	mmSaveBudget.t.Helper()

	if mmSaveBudget.inspectFuncSaveBudget != nil {
		mmSaveBudget.inspectFuncSaveBudget(ctx, key, item, ttl)
	}

	mm_params := BudgetCacheRepositoryMockSaveBudgetParams{ctx, key, item, ttl}

	// Record call args
	mmSaveBudget.SaveBudgetMock.mutex.Lock()
	mmSaveBudget.SaveBudgetMock.callArgs = append(mmSaveBudget.SaveBudgetMock.callArgs, &mm_params)
	mmSaveBudget.SaveBudgetMock.mutex.Unlock()

	for _, e := range mmSaveBudget.SaveBudgetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveBudget.SaveBudgetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveBudget.SaveBudgetMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveBudget.SaveBudgetMock.defaultExpectation.params
		mm_want_ptrs := mmSaveBudget.SaveBudgetMock.defaultExpectation.paramPtrs

		mm_got := BudgetCacheRepositoryMockSaveBudgetParams{ctx, key, item, ttl}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSaveBudget.t.Errorf("BudgetCacheRepositoryMock.SaveBudget got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveBudget.SaveBudgetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmSaveBudget.t.Errorf("BudgetCacheRepositoryMock.SaveBudget got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveBudget.SaveBudgetMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmSaveBudget.t.Errorf("BudgetCacheRepositoryMock.SaveBudget got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveBudget.SaveBudgetMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

			if mm_want_ptrs.ttl != nil && !minimock.Equal(*mm_want_ptrs.ttl, mm_got.ttl) {
				mmSaveBudget.t.Errorf("BudgetCacheRepositoryMock.SaveBudget got unexpected parameter ttl, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveBudget.SaveBudgetMock.defaultExpectation.expectationOrigins.originTtl, *mm_want_ptrs.ttl, mm_got.ttl, minimock.Diff(*mm_want_ptrs.ttl, mm_got.ttl))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveBudget.t.Errorf("BudgetCacheRepositoryMock.SaveBudget got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSaveBudget.SaveBudgetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveBudget.SaveBudgetMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveBudget.t.Fatal("No results are set for the BudgetCacheRepositoryMock.SaveBudget")
		}
		return (*mm_results).err
	}
	if mmSaveBudget.funcSaveBudget != nil {
		return mmSaveBudget.funcSaveBudget(ctx, key, item, ttl)
	}
	mmSaveBudget.t.Fatalf("Unexpected call to BudgetCacheRepositoryMock.SaveBudget. %v %v %v %v", ctx, key, item, ttl)
	return
}

// SaveBudgetAfterCounter returns a count of finished BudgetCacheRepositoryMock.SaveBudget invocations
func (mmSaveBudget *BudgetCacheRepositoryMock) SaveBudgetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveBudget.afterSaveBudgetCounter)
}

// SaveBudgetBeforeCounter returns a count of BudgetCacheRepositoryMock.SaveBudget invocations
func (mmSaveBudget *BudgetCacheRepositoryMock) SaveBudgetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveBudget.beforeSaveBudgetCounter)
}

// Calls returns a list of arguments used in each call to BudgetCacheRepositoryMock.SaveBudget.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) Calls() []*BudgetCacheRepositoryMockSaveBudgetParams {
	mmSaveBudget.mutex.RLock()

	argCopy := make([]*BudgetCacheRepositoryMockSaveBudgetParams, len(mmSaveBudget.callArgs))
	copy(argCopy, mmSaveBudget.callArgs)

	mmSaveBudget.mutex.RUnlock()

	return argCopy
}

// MinimockSaveBudgetDone returns true if the count of the SaveBudget invocations corresponds
// the number of defined expectations
func (m *BudgetCacheRepositoryMock) MinimockSaveBudgetDone() bool {
	if m.SaveBudgetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveBudgetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveBudgetMock.invocationsDone()
}

// MinimockSaveBudgetInspect logs each unmet expectation
func (m *BudgetCacheRepositoryMock) MinimockSaveBudgetInspect() {
	for _, e := range m.SaveBudgetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudget at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveBudgetCounter := mm_atomic.LoadUint64(&m.afterSaveBudgetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveBudgetMock.defaultExpectation != nil && afterSaveBudgetCounter < 1 {
		if m.SaveBudgetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudget at\n%s", m.SaveBudgetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudget at\n%s with params: %#v", m.SaveBudgetMock.defaultExpectation.expectationOrigins.origin, *m.SaveBudgetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveBudget != nil && afterSaveBudgetCounter < 1 {
		m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudget at\n%s", m.funcSaveBudgetOrigin)
	}

	if !m.SaveBudgetMock.invocationsDone() && afterSaveBudgetCounter > 0 {
		m.t.Errorf("Expected %d calls to BudgetCacheRepositoryMock.SaveBudget at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveBudgetMock.expectedInvocations), m.SaveBudgetMock.expectedInvocationsOrigin, afterSaveBudgetCounter)
	}
}

type mBudgetCacheRepositoryMockSaveBudgetsList struct {
	optional           bool
	mock               *BudgetCacheRepositoryMock
	defaultExpectation *BudgetCacheRepositoryMockSaveBudgetsListExpectation
	expectations       []*BudgetCacheRepositoryMockSaveBudgetsListExpectation

	callArgs []*BudgetCacheRepositoryMockSaveBudgetsListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BudgetCacheRepositoryMockSaveBudgetsListExpectation specifies expectation struct of the BudgetCacheRepository.SaveBudgetsList
type BudgetCacheRepositoryMockSaveBudgetsListExpectation struct {
	mock               *BudgetCacheRepositoryMock
	params             *BudgetCacheRepositoryMockSaveBudgetsListParams
	paramPtrs          *BudgetCacheRepositoryMockSaveBudgetsListParamPtrs
	expectationOrigins BudgetCacheRepositoryMockSaveBudgetsListExpectationOrigins
	results            *BudgetCacheRepositoryMockSaveBudgetsListResults
	returnOrigin       string
	Counter            uint64
}

// BudgetCacheRepositoryMockSaveBudgetsListParams contains parameters of the BudgetCacheRepository.SaveBudgetsList
type BudgetCacheRepositoryMockSaveBudgetsListParams struct {
	ctx   context.Context
	key   string
	items []*entity.Budget
	ttl   time.Duration
}

// BudgetCacheRepositoryMockSaveBudgetsListParamPtrs contains pointers to parameters of the BudgetCacheRepository.SaveBudgetsList
type BudgetCacheRepositoryMockSaveBudgetsListParamPtrs struct {
	ctx   *context.Context
	key   *string
	items *[]*entity.Budget
	ttl   *time.Duration
}

// BudgetCacheRepositoryMockSaveBudgetsListResults contains results of the BudgetCacheRepository.SaveBudgetsList
type BudgetCacheRepositoryMockSaveBudgetsListResults struct {
	err error
}

// BudgetCacheRepositoryMockSaveBudgetsListOrigins contains origins of expectations of the BudgetCacheRepository.SaveBudgetsList
type BudgetCacheRepositoryMockSaveBudgetsListExpectationOrigins struct {
	origin      string
	originCtx   string
	originKey   string
	originItems string
	originTtl   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) Optional() *mBudgetCacheRepositoryMockSaveBudgetsList {
	mmSaveBudgetsList.optional = true
	return mmSaveBudgetsList
}

// Expect sets up expected params for BudgetCacheRepository.SaveBudgetsList
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) Expect(ctx context.Context, key string, items []*entity.Budget, ttl time.Duration) *mBudgetCacheRepositoryMockSaveBudgetsList {
	if mmSaveBudgetsList.mock.funcSaveBudgetsList != nil {
		mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Set")
	}

	if mmSaveBudgetsList.defaultExpectation == nil {
		mmSaveBudgetsList.defaultExpectation = &BudgetCacheRepositoryMockSaveBudgetsListExpectation{}
	}

	if mmSaveBudgetsList.defaultExpectation.paramPtrs != nil {
		mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by ExpectParams functions")
	}

	mmSaveBudgetsList.defaultExpectation.params = &BudgetCacheRepositoryMockSaveBudgetsListParams{ctx, key, items, ttl}
	mmSaveBudgetsList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSaveBudgetsList.expectations {
		if minimock.Equal(e.params, mmSaveBudgetsList.defaultExpectation.params) {
			mmSaveBudgetsList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveBudgetsList.defaultExpectation.params)
		}
	}

	return mmSaveBudgetsList
}

// ExpectCtxParam1 sets up expected param ctx for BudgetCacheRepository.SaveBudgetsList
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) ExpectCtxParam1(ctx context.Context) *mBudgetCacheRepositoryMockSaveBudgetsList {
	if mmSaveBudgetsList.mock.funcSaveBudgetsList != nil {
		mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Set")
	}

	if mmSaveBudgetsList.defaultExpectation == nil {
		mmSaveBudgetsList.defaultExpectation = &BudgetCacheRepositoryMockSaveBudgetsListExpectation{}
	}

	if mmSaveBudgetsList.defaultExpectation.params != nil {
		mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Expect")
	}

	if mmSaveBudgetsList.defaultExpectation.paramPtrs == nil {
		mmSaveBudgetsList.defaultExpectation.paramPtrs = &BudgetCacheRepositoryMockSaveBudgetsListParamPtrs{}
	}
	mmSaveBudgetsList.defaultExpectation.paramPtrs.ctx = &ctx
	mmSaveBudgetsList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSaveBudgetsList
}

// ExpectKeyParam2 sets up expected param key for BudgetCacheRepository.SaveBudgetsList
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) ExpectKeyParam2(key string) *mBudgetCacheRepositoryMockSaveBudgetsList {
	if mmSaveBudgetsList.mock.funcSaveBudgetsList != nil {
		mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Set")
	}

	if mmSaveBudgetsList.defaultExpectation == nil {
		mmSaveBudgetsList.defaultExpectation = &BudgetCacheRepositoryMockSaveBudgetsListExpectation{}
	}

	if mmSaveBudgetsList.defaultExpectation.params != nil {
		mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Expect")
	}

	if mmSaveBudgetsList.defaultExpectation.paramPtrs == nil {
		mmSaveBudgetsList.defaultExpectation.paramPtrs = &BudgetCacheRepositoryMockSaveBudgetsListParamPtrs{}
	}
	mmSaveBudgetsList.defaultExpectation.paramPtrs.key = &key
	mmSaveBudgetsList.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmSaveBudgetsList
}

// ExpectItemsParam3 sets up expected param items for BudgetCacheRepository.SaveBudgetsList
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) ExpectItemsParam3(items []*entity.Budget) *mBudgetCacheRepositoryMockSaveBudgetsList {
	if mmSaveBudgetsList.mock.funcSaveBudgetsList != nil {
		mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Set")
	}

	if mmSaveBudgetsList.defaultExpectation == nil {
		mmSaveBudgetsList.defaultExpectation = &BudgetCacheRepositoryMockSaveBudgetsListExpectation{}
	}

	if mmSaveBudgetsList.defaultExpectation.params != nil {
		mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Expect")
	}

	if mmSaveBudgetsList.defaultExpectation.paramPtrs == nil {
		mmSaveBudgetsList.defaultExpectation.paramPtrs = &BudgetCacheRepositoryMockSaveBudgetsListParamPtrs{}
	}
	mmSaveBudgetsList.defaultExpectation.paramPtrs.items = &items
	mmSaveBudgetsList.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmSaveBudgetsList
}

// ExpectTtlParam4 sets up expected param ttl for BudgetCacheRepository.SaveBudgetsList
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) ExpectTtlParam4(ttl time.Duration) *mBudgetCacheRepositoryMockSaveBudgetsList {
	if mmSaveBudgetsList.mock.funcSaveBudgetsList != nil {
		mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Set")
	}

	if mmSaveBudgetsList.defaultExpectation == nil {
		mmSaveBudgetsList.defaultExpectation = &BudgetCacheRepositoryMockSaveBudgetsListExpectation{}
	}

	if mmSaveBudgetsList.defaultExpectation.params != nil {
		mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Expect")
	}

	if mmSaveBudgetsList.defaultExpectation.paramPtrs == nil {
		mmSaveBudgetsList.defaultExpectation.paramPtrs = &BudgetCacheRepositoryMockSaveBudgetsListParamPtrs{}
	}
	mmSaveBudgetsList.defaultExpectation.paramPtrs.ttl = &ttl
	mmSaveBudgetsList.defaultExpectation.expectationOrigins.originTtl = minimock.CallerInfo(1)

	return mmSaveBudgetsList
}

// Inspect accepts an inspector function that has same arguments as the BudgetCacheRepository.SaveBudgetsList
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) Inspect(f func(ctx context.Context, key string, items []*entity.Budget, ttl time.Duration)) *mBudgetCacheRepositoryMockSaveBudgetsList {
	if mmSaveBudgetsList.mock.inspectFuncSaveBudgetsList != nil {
		mmSaveBudgetsList.mock.t.Fatalf("Inspect function is already set for BudgetCacheRepositoryMock.SaveBudgetsList")
	}

	mmSaveBudgetsList.mock.inspectFuncSaveBudgetsList = f

	return mmSaveBudgetsList
}

// Return sets up results that will be returned by BudgetCacheRepository.SaveBudgetsList
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) Return(err error) *BudgetCacheRepositoryMock {
	if mmSaveBudgetsList.mock.funcSaveBudgetsList != nil {
		mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Set")
	}

	if mmSaveBudgetsList.defaultExpectation == nil {
		mmSaveBudgetsList.defaultExpectation = &BudgetCacheRepositoryMockSaveBudgetsListExpectation{mock: mmSaveBudgetsList.mock}
	}
	mmSaveBudgetsList.defaultExpectation.results = &BudgetCacheRepositoryMockSaveBudgetsListResults{err}
	mmSaveBudgetsList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSaveBudgetsList.mock
}

// Set uses given function f to mock the BudgetCacheRepository.SaveBudgetsList method
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) Set(f func(ctx context.Context, key string, items []*entity.Budget, ttl time.Duration) (err error)) *BudgetCacheRepositoryMock {
	if mmSaveBudgetsList.defaultExpectation != nil {
		mmSaveBudgetsList.mock.t.Fatalf("Default expectation is already set for the BudgetCacheRepository.SaveBudgetsList method")
	}

	if len(mmSaveBudgetsList.expectations) > 0 {
		mmSaveBudgetsList.mock.t.Fatalf("Some expectations are already set for the BudgetCacheRepository.SaveBudgetsList method")
	}

	mmSaveBudgetsList.mock.funcSaveBudgetsList = f
	mmSaveBudgetsList.mock.funcSaveBudgetsListOrigin = minimock.CallerInfo(1)
	return mmSaveBudgetsList.mock
}

// When sets expectation for the BudgetCacheRepository.SaveBudgetsList which will trigger the result defined by the following
// Then helper
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) When(ctx context.Context, key string, items []*entity.Budget, ttl time.Duration) *BudgetCacheRepositoryMockSaveBudgetsListExpectation {
	if mmSaveBudgetsList.mock.funcSaveBudgetsList != nil {
		mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Set")
	}

	expectation := &BudgetCacheRepositoryMockSaveBudgetsListExpectation{
		mock:               mmSaveBudgetsList.mock,
		params:             &BudgetCacheRepositoryMockSaveBudgetsListParams{ctx, key, items, ttl},
		expectationOrigins: BudgetCacheRepositoryMockSaveBudgetsListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSaveBudgetsList.expectations = append(mmSaveBudgetsList.expectations, expectation)
	return expectation
}

// Then sets up BudgetCacheRepository.SaveBudgetsList return parameters for the expectation previously defined by the When method
func (e *BudgetCacheRepositoryMockSaveBudgetsListExpectation) Then(err error) *BudgetCacheRepositoryMock {
	e.results = &BudgetCacheRepositoryMockSaveBudgetsListResults{err}
	return e.mock
}

// Times sets number of times BudgetCacheRepository.SaveBudgetsList should be invoked
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) Times(n uint64) *mBudgetCacheRepositoryMockSaveBudgetsList {
	if n == 0 {
		mmSaveBudgetsList.mock.t.Fatalf("Times of BudgetCacheRepositoryMock.SaveBudgetsList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSaveBudgetsList.expectedInvocations, n)
	mmSaveBudgetsList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSaveBudgetsList
}

func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) invocationsDone() bool {
	if len(mmSaveBudgetsList.expectations) == 0 && mmSaveBudgetsList.defaultExpectation == nil && mmSaveBudgetsList.mock.funcSaveBudgetsList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSaveBudgetsList.mock.afterSaveBudgetsListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSaveBudgetsList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SaveBudgetsList implements mm_usecase.BudgetCacheRepository
func (mmSaveBudgetsList *BudgetCacheRepositoryMock) SaveBudgetsList(ctx context.Context, key string, items []*entity.Budget, ttl time.Duration) (err error) {
	mm_atomic.AddUint64(&mmSaveBudgetsList.beforeSaveBudgetsListCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveBudgetsList.afterSaveBudgetsListCounter, 1)

	mmSaveBudgetsList.t.Helper()

	if mmSaveBudgetsList.inspectFuncSaveBudgetsList != nil {
		mmSaveBudgetsList.inspectFuncSaveBudgetsList(ctx, key, items, ttl)
	}

	mm_params := BudgetCacheRepositoryMockSaveBudgetsListParams{ctx, key, items, ttl}

	// Record call args
	mmSaveBudgetsList.SaveBudgetsListMock.mutex.Lock()
	mmSaveBudgetsList.SaveBudgetsListMock.callArgs = append(mmSaveBudgetsList.SaveBudgetsListMock.callArgs, &mm_params)
	mmSaveBudgetsList.SaveBudgetsListMock.mutex.Unlock()

	for _, e := range mmSaveBudgetsList.SaveBudgetsListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveBudgetsList.SaveBudgetsListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveBudgetsList.SaveBudgetsListMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveBudgetsList.SaveBudgetsListMock.defaultExpectation.params
		mm_want_ptrs := mmSaveBudgetsList.SaveBudgetsListMock.defaultExpectation.paramPtrs

		mm_got := BudgetCacheRepositoryMockSaveBudgetsListParams{ctx, key, items, ttl}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSaveBudgetsList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveBudgetsList.SaveBudgetsListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmSaveBudgetsList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsList got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveBudgetsList.SaveBudgetsListMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmSaveBudgetsList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsList got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveBudgetsList.SaveBudgetsListMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

			if mm_want_ptrs.ttl != nil && !minimock.Equal(*mm_want_ptrs.ttl, mm_got.ttl) {
				mmSaveBudgetsList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsList got unexpected parameter ttl, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveBudgetsList.SaveBudgetsListMock.defaultExpectation.expectationOrigins.originTtl, *mm_want_ptrs.ttl, mm_got.ttl, minimock.Diff(*mm_want_ptrs.ttl, mm_got.ttl))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveBudgetsList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSaveBudgetsList.SaveBudgetsListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveBudgetsList.SaveBudgetsListMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveBudgetsList.t.Fatal("No results are set for the BudgetCacheRepositoryMock.SaveBudgetsList")
		}
		return (*mm_results).err
	}
	if mmSaveBudgetsList.funcSaveBudgetsList != nil {
		return mmSaveBudgetsList.funcSaveBudgetsList(ctx, key, items, ttl)
	}
	mmSaveBudgetsList.t.Fatalf("Unexpected call to BudgetCacheRepositoryMock.SaveBudgetsList. %v %v %v %v", ctx, key, items, ttl)
	return
}

// SaveBudgetsListAfterCounter returns a count of finished BudgetCacheRepositoryMock.SaveBudgetsList invocations
func (mmSaveBudgetsList *BudgetCacheRepositoryMock) SaveBudgetsListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveBudgetsList.afterSaveBudgetsListCounter)
}

// SaveBudgetsListBeforeCounter returns a count of BudgetCacheRepositoryMock.SaveBudgetsList invocations
func (mmSaveBudgetsList *BudgetCacheRepositoryMock) SaveBudgetsListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveBudgetsList.beforeSaveBudgetsListCounter)
}

// Calls returns a list of arguments used in each call to BudgetCacheRepositoryMock.SaveBudgetsList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) Calls() []*BudgetCacheRepositoryMockSaveBudgetsListParams {
	mmSaveBudgetsList.mutex.RLock()

	argCopy := make([]*BudgetCacheRepositoryMockSaveBudgetsListParams, len(mmSaveBudgetsList.callArgs))
	copy(argCopy, mmSaveBudgetsList.callArgs)

	mmSaveBudgetsList.mutex.RUnlock()

	return argCopy
}

// MinimockSaveBudgetsListDone returns true if the count of the SaveBudgetsList invocations corresponds
// the number of defined expectations
func (m *BudgetCacheRepositoryMock) MinimockSaveBudgetsListDone() bool {
	if m.SaveBudgetsListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveBudgetsListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveBudgetsListMock.invocationsDone()
}

// MinimockSaveBudgetsListInspect logs each unmet expectation
func (m *BudgetCacheRepositoryMock) MinimockSaveBudgetsListInspect() {
	for _, e := range m.SaveBudgetsListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudgetsList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveBudgetsListCounter := mm_atomic.LoadUint64(&m.afterSaveBudgetsListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveBudgetsListMock.defaultExpectation != nil && afterSaveBudgetsListCounter < 1 {
		if m.SaveBudgetsListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudgetsList at\n%s", m.SaveBudgetsListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudgetsList at\n%s with params: %#v", m.SaveBudgetsListMock.defaultExpectation.expectationOrigins.origin, *m.SaveBudgetsListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveBudgetsList != nil && afterSaveBudgetsListCounter < 1 {
		m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudgetsList at\n%s", m.funcSaveBudgetsListOrigin)
	}

	if !m.SaveBudgetsListMock.invocationsDone() && afterSaveBudgetsListCounter > 0 {
		m.t.Errorf("Expected %d calls to BudgetCacheRepositoryMock.SaveBudgetsList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveBudgetsListMock.expectedInvocations), m.SaveBudgetsListMock.expectedInvocationsOrigin, afterSaveBudgetsListCounter)
	}
}

type mBudgetCacheRepositoryMockSaveBudgetsPagedList struct {
	optional           bool
	mock               *BudgetCacheRepositoryMock
	defaultExpectation *BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation
	expectations       []*BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation

	callArgs []*BudgetCacheRepositoryMockSaveBudgetsPagedListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation specifies expectation struct of the BudgetCacheRepository.SaveBudgetsPagedList
type BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation struct {
	mock               *BudgetCacheRepositoryMock
	params             *BudgetCacheRepositoryMockSaveBudgetsPagedListParams
	paramPtrs          *BudgetCacheRepositoryMockSaveBudgetsPagedListParamPtrs
	expectationOrigins BudgetCacheRepositoryMockSaveBudgetsPagedListExpectationOrigins
	results            *BudgetCacheRepositoryMockSaveBudgetsPagedListResults
	returnOrigin       string
	Counter            uint64
}

// BudgetCacheRepositoryMockSaveBudgetsPagedListParams contains parameters of the BudgetCacheRepository.SaveBudgetsPagedList
type BudgetCacheRepositoryMockSaveBudgetsPagedListParams struct {
	ctx   context.Context
	key   string
	items []*entity.Budget
	total uint64
	ttl   time.Duration
}

// BudgetCacheRepositoryMockSaveBudgetsPagedListParamPtrs contains pointers to parameters of the BudgetCacheRepository.SaveBudgetsPagedList
type BudgetCacheRepositoryMockSaveBudgetsPagedListParamPtrs struct {
	ctx   *context.Context
	key   *string
	items *[]*entity.Budget
	total *uint64
	ttl   *time.Duration
}

// BudgetCacheRepositoryMockSaveBudgetsPagedListResults contains results of the BudgetCacheRepository.SaveBudgetsPagedList
type BudgetCacheRepositoryMockSaveBudgetsPagedListResults struct {
	err error
}

// BudgetCacheRepositoryMockSaveBudgetsPagedListOrigins contains origins of expectations of the BudgetCacheRepository.SaveBudgetsPagedList
type BudgetCacheRepositoryMockSaveBudgetsPagedListExpectationOrigins struct {
	origin      string
	originCtx   string
	originKey   string
	originItems string
	originTotal string
	originTtl   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) Optional() *mBudgetCacheRepositoryMockSaveBudgetsPagedList {
	mmSaveBudgetsPagedList.optional = true
	return mmSaveBudgetsPagedList
}

// Expect sets up expected params for BudgetCacheRepository.SaveBudgetsPagedList
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) Expect(ctx context.Context, key string, items []*entity.Budget, total uint64, ttl time.Duration) *mBudgetCacheRepositoryMockSaveBudgetsPagedList {
	if mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedList != nil {
		mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Set")
	}

	if mmSaveBudgetsPagedList.defaultExpectation == nil {
		mmSaveBudgetsPagedList.defaultExpectation = &BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation{}
	}

	if mmSaveBudgetsPagedList.defaultExpectation.paramPtrs != nil {
		mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by ExpectParams functions")
	}

	mmSaveBudgetsPagedList.defaultExpectation.params = &BudgetCacheRepositoryMockSaveBudgetsPagedListParams{ctx, key, items, total, ttl}
	mmSaveBudgetsPagedList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSaveBudgetsPagedList.expectations {
		if minimock.Equal(e.params, mmSaveBudgetsPagedList.defaultExpectation.params) {
			mmSaveBudgetsPagedList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveBudgetsPagedList.defaultExpectation.params)
		}
	}

	return mmSaveBudgetsPagedList
}

// ExpectCtxParam1 sets up expected param ctx for BudgetCacheRepository.SaveBudgetsPagedList
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) ExpectCtxParam1(ctx context.Context) *mBudgetCacheRepositoryMockSaveBudgetsPagedList {
	if mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedList != nil {
		mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Set")
	}

	if mmSaveBudgetsPagedList.defaultExpectation == nil {
		mmSaveBudgetsPagedList.defaultExpectation = &BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation{}
	}

	if mmSaveBudgetsPagedList.defaultExpectation.params != nil {
		mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Expect")
	}

	if mmSaveBudgetsPagedList.defaultExpectation.paramPtrs == nil {
		mmSaveBudgetsPagedList.defaultExpectation.paramPtrs = &BudgetCacheRepositoryMockSaveBudgetsPagedListParamPtrs{}
	}
	mmSaveBudgetsPagedList.defaultExpectation.paramPtrs.ctx = &ctx
	mmSaveBudgetsPagedList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSaveBudgetsPagedList
}

// ExpectKeyParam2 sets up expected param key for BudgetCacheRepository.SaveBudgetsPagedList
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) ExpectKeyParam2(key string) *mBudgetCacheRepositoryMockSaveBudgetsPagedList {
	if mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedList != nil {
		mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Set")
	}

	if mmSaveBudgetsPagedList.defaultExpectation == nil {
		mmSaveBudgetsPagedList.defaultExpectation = &BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation{}
	}

	if mmSaveBudgetsPagedList.defaultExpectation.params != nil {
		mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Expect")
	}

	if mmSaveBudgetsPagedList.defaultExpectation.paramPtrs == nil {
		mmSaveBudgetsPagedList.defaultExpectation.paramPtrs = &BudgetCacheRepositoryMockSaveBudgetsPagedListParamPtrs{}
	}
	mmSaveBudgetsPagedList.defaultExpectation.paramPtrs.key = &key
	mmSaveBudgetsPagedList.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmSaveBudgetsPagedList
}

// ExpectItemsParam3 sets up expected param items for BudgetCacheRepository.SaveBudgetsPagedList
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) ExpectItemsParam3(items []*entity.Budget) *mBudgetCacheRepositoryMockSaveBudgetsPagedList {
	if mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedList != nil {
		mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Set")
	}

	if mmSaveBudgetsPagedList.defaultExpectation == nil {
		mmSaveBudgetsPagedList.defaultExpectation = &BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation{}
	}

	if mmSaveBudgetsPagedList.defaultExpectation.params != nil {
		mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Expect")
	}

	if mmSaveBudgetsPagedList.defaultExpectation.paramPtrs == nil {
		mmSaveBudgetsPagedList.defaultExpectation.paramPtrs = &BudgetCacheRepositoryMockSaveBudgetsPagedListParamPtrs{}
	}
	mmSaveBudgetsPagedList.defaultExpectation.paramPtrs.items = &items
	mmSaveBudgetsPagedList.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmSaveBudgetsPagedList
}

// ExpectTotalParam4 sets up expected param total for BudgetCacheRepository.SaveBudgetsPagedList
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) ExpectTotalParam4(total uint64) *mBudgetCacheRepositoryMockSaveBudgetsPagedList {
	if mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedList != nil {
		mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Set")
	}

	if mmSaveBudgetsPagedList.defaultExpectation == nil {
		mmSaveBudgetsPagedList.defaultExpectation = &BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation{}
	}

	if mmSaveBudgetsPagedList.defaultExpectation.params != nil {
		mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Expect")
	}

	if mmSaveBudgetsPagedList.defaultExpectation.paramPtrs == nil {
		mmSaveBudgetsPagedList.defaultExpectation.paramPtrs = &BudgetCacheRepositoryMockSaveBudgetsPagedListParamPtrs{}
	}
	mmSaveBudgetsPagedList.defaultExpectation.paramPtrs.total = &total
	mmSaveBudgetsPagedList.defaultExpectation.expectationOrigins.originTotal = minimock.CallerInfo(1)

	return mmSaveBudgetsPagedList
}

// ExpectTtlParam5 sets up expected param ttl for BudgetCacheRepository.SaveBudgetsPagedList
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) ExpectTtlParam5(ttl time.Duration) *mBudgetCacheRepositoryMockSaveBudgetsPagedList {
	if mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedList != nil {
		mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Set")
	}

	if mmSaveBudgetsPagedList.defaultExpectation == nil {
		mmSaveBudgetsPagedList.defaultExpectation = &BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation{}
	}

	if mmSaveBudgetsPagedList.defaultExpectation.params != nil {
		mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Expect")
	}

	if mmSaveBudgetsPagedList.defaultExpectation.paramPtrs == nil {
		mmSaveBudgetsPagedList.defaultExpectation.paramPtrs = &BudgetCacheRepositoryMockSaveBudgetsPagedListParamPtrs{}
	}
	mmSaveBudgetsPagedList.defaultExpectation.paramPtrs.ttl = &ttl
	mmSaveBudgetsPagedList.defaultExpectation.expectationOrigins.originTtl = minimock.CallerInfo(1)

	return mmSaveBudgetsPagedList
}

// Inspect accepts an inspector function that has same arguments as the BudgetCacheRepository.SaveBudgetsPagedList
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) Inspect(f func(ctx context.Context, key string, items []*entity.Budget, total uint64, ttl time.Duration)) *mBudgetCacheRepositoryMockSaveBudgetsPagedList {
	if mmSaveBudgetsPagedList.mock.inspectFuncSaveBudgetsPagedList != nil {
		mmSaveBudgetsPagedList.mock.t.Fatalf("Inspect function is already set for BudgetCacheRepositoryMock.SaveBudgetsPagedList")
	}

	mmSaveBudgetsPagedList.mock.inspectFuncSaveBudgetsPagedList = f

	return mmSaveBudgetsPagedList
}

// Return sets up results that will be returned by BudgetCacheRepository.SaveBudgetsPagedList
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) Return(err error) *BudgetCacheRepositoryMock {
	if mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedList != nil {
		mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Set")
	}

	if mmSaveBudgetsPagedList.defaultExpectation == nil {
		mmSaveBudgetsPagedList.defaultExpectation = &BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation{mock: mmSaveBudgetsPagedList.mock}
	}
	mmSaveBudgetsPagedList.defaultExpectation.results = &BudgetCacheRepositoryMockSaveBudgetsPagedListResults{err}
	mmSaveBudgetsPagedList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSaveBudgetsPagedList.mock
}

// Set uses given function f to mock the BudgetCacheRepository.SaveBudgetsPagedList method
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) Set(f func(ctx context.Context, key string, items []*entity.Budget, total uint64, ttl time.Duration) (err error)) *BudgetCacheRepositoryMock {
	if mmSaveBudgetsPagedList.defaultExpectation != nil {
		mmSaveBudgetsPagedList.mock.t.Fatalf("Default expectation is already set for the BudgetCacheRepository.SaveBudgetsPagedList method")
	}

	if len(mmSaveBudgetsPagedList.expectations) > 0 {
		mmSaveBudgetsPagedList.mock.t.Fatalf("Some expectations are already set for the BudgetCacheRepository.SaveBudgetsPagedList method")
	}

	mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedList = f
	mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedListOrigin = minimock.CallerInfo(1)
	return mmSaveBudgetsPagedList.mock
}

// When sets expectation for the BudgetCacheRepository.SaveBudgetsPagedList which will trigger the result defined by the following
// Then helper
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) When(ctx context.Context, key string, items []*entity.Budget, total uint64, ttl time.Duration) *BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation {
	if mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedList != nil {
		mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Set")
	}

	expectation := &BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation{
		mock:               mmSaveBudgetsPagedList.mock,
		params:             &BudgetCacheRepositoryMockSaveBudgetsPagedListParams{ctx, key, items, total, ttl},
		expectationOrigins: BudgetCacheRepositoryMockSaveBudgetsPagedListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSaveBudgetsPagedList.expectations = append(mmSaveBudgetsPagedList.expectations, expectation)
	return expectation
}

// Then sets up BudgetCacheRepository.SaveBudgetsPagedList return parameters for the expectation previously defined by the When method
func (e *BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation) Then(err error) *BudgetCacheRepositoryMock {
	e.results = &BudgetCacheRepositoryMockSaveBudgetsPagedListResults{err}
	return e.mock
}

// Times sets number of times BudgetCacheRepository.SaveBudgetsPagedList should be invoked
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) Times(n uint64) *mBudgetCacheRepositoryMockSaveBudgetsPagedList {
	if n == 0 {
		mmSaveBudgetsPagedList.mock.t.Fatalf("Times of BudgetCacheRepositoryMock.SaveBudgetsPagedList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSaveBudgetsPagedList.expectedInvocations, n)
	mmSaveBudgetsPagedList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSaveBudgetsPagedList
}

func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) invocationsDone() bool {
	if len(mmSaveBudgetsPagedList.expectations) == 0 && mmSaveBudgetsPagedList.defaultExpectation == nil && mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSaveBudgetsPagedList.mock.afterSaveBudgetsPagedListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSaveBudgetsPagedList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SaveBudgetsPagedList implements mm_usecase.BudgetCacheRepository
func (mmSaveBudgetsPagedList *BudgetCacheRepositoryMock) SaveBudgetsPagedList(ctx context.Context, key string, items []*entity.Budget, total uint64, ttl time.Duration) (err error) {
	mm_atomic.AddUint64(&mmSaveBudgetsPagedList.beforeSaveBudgetsPagedListCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveBudgetsPagedList.afterSaveBudgetsPagedListCounter, 1)

	mmSaveBudgetsPagedList.t.Helper()

	if mmSaveBudgetsPagedList.inspectFuncSaveBudgetsPagedList != nil {
		mmSaveBudgetsPagedList.inspectFuncSaveBudgetsPagedList(ctx, key, items, total, ttl)
	}

	mm_params := BudgetCacheRepositoryMockSaveBudgetsPagedListParams{ctx, key, items, total, ttl}

	// Record call args
	mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.mutex.Lock()
	mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.callArgs = append(mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.callArgs, &mm_params)
	mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.mutex.Unlock()

	for _, e := range mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation.params
		mm_want_ptrs := mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation.paramPtrs

		mm_got := BudgetCacheRepositoryMockSaveBudgetsPagedListParams{ctx, key, items, total, ttl}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSaveBudgetsPagedList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsPagedList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmSaveBudgetsPagedList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsPagedList got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmSaveBudgetsPagedList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsPagedList got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

			if mm_want_ptrs.total != nil && !minimock.Equal(*mm_want_ptrs.total, mm_got.total) {
				mmSaveBudgetsPagedList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsPagedList got unexpected parameter total, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation.expectationOrigins.originTotal, *mm_want_ptrs.total, mm_got.total, minimock.Diff(*mm_want_ptrs.total, mm_got.total))
			}

			if mm_want_ptrs.ttl != nil && !minimock.Equal(*mm_want_ptrs.ttl, mm_got.ttl) {
				mmSaveBudgetsPagedList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsPagedList got unexpected parameter ttl, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation.expectationOrigins.originTtl, *mm_want_ptrs.ttl, mm_got.ttl, minimock.Diff(*mm_want_ptrs.ttl, mm_got.ttl))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveBudgetsPagedList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsPagedList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveBudgetsPagedList.t.Fatal("No results are set for the BudgetCacheRepositoryMock.SaveBudgetsPagedList")
		}
		return (*mm_results).err
	}
	if mmSaveBudgetsPagedList.funcSaveBudgetsPagedList != nil {
		return mmSaveBudgetsPagedList.funcSaveBudgetsPagedList(ctx, key, items, total, ttl)
	}
	mmSaveBudgetsPagedList.t.Fatalf("Unexpected call to BudgetCacheRepositoryMock.SaveBudgetsPagedList. %v %v %v %v %v", ctx, key, items, total, ttl)
	return
}

// SaveBudgetsPagedListAfterCounter returns a count of finished BudgetCacheRepositoryMock.SaveBudgetsPagedList invocations
func (mmSaveBudgetsPagedList *BudgetCacheRepositoryMock) SaveBudgetsPagedListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveBudgetsPagedList.afterSaveBudgetsPagedListCounter)
}

// SaveBudgetsPagedListBeforeCounter returns a count of BudgetCacheRepositoryMock.SaveBudgetsPagedList invocations
func (mmSaveBudgetsPagedList *BudgetCacheRepositoryMock) SaveBudgetsPagedListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveBudgetsPagedList.beforeSaveBudgetsPagedListCounter)
}

// Calls returns a list of arguments used in each call to BudgetCacheRepositoryMock.SaveBudgetsPagedList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) Calls() []*BudgetCacheRepositoryMockSaveBudgetsPagedListParams {
	mmSaveBudgetsPagedList.mutex.RLock()

	argCopy := make([]*BudgetCacheRepositoryMockSaveBudgetsPagedListParams, len(mmSaveBudgetsPagedList.callArgs))
	copy(argCopy, mmSaveBudgetsPagedList.callArgs)

	mmSaveBudgetsPagedList.mutex.RUnlock()

	return argCopy
}

// MinimockSaveBudgetsPagedListDone returns true if the count of the SaveBudgetsPagedList invocations corresponds
// the number of defined expectations
func (m *BudgetCacheRepositoryMock) MinimockSaveBudgetsPagedListDone() bool {
	if m.SaveBudgetsPagedListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveBudgetsPagedListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveBudgetsPagedListMock.invocationsDone()
}

// MinimockSaveBudgetsPagedListInspect logs each unmet expectation
func (m *BudgetCacheRepositoryMock) MinimockSaveBudgetsPagedListInspect() {
	for _, e := range m.SaveBudgetsPagedListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudgetsPagedList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveBudgetsPagedListCounter := mm_atomic.LoadUint64(&m.afterSaveBudgetsPagedListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveBudgetsPagedListMock.defaultExpectation != nil && afterSaveBudgetsPagedListCounter < 1 {
		if m.SaveBudgetsPagedListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudgetsPagedList at\n%s", m.SaveBudgetsPagedListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudgetsPagedList at\n%s with params: %#v", m.SaveBudgetsPagedListMock.defaultExpectation.expectationOrigins.origin, *m.SaveBudgetsPagedListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveBudgetsPagedList != nil && afterSaveBudgetsPagedListCounter < 1 {
		m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudgetsPagedList at\n%s", m.funcSaveBudgetsPagedListOrigin)
	}

	if !m.SaveBudgetsPagedListMock.invocationsDone() && afterSaveBudgetsPagedListCounter > 0 {
		m.t.Errorf("Expected %d calls to BudgetCacheRepositoryMock.SaveBudgetsPagedList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveBudgetsPagedListMock.expectedInvocations), m.SaveBudgetsPagedListMock.expectedInvocationsOrigin, afterSaveBudgetsPagedListCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *BudgetCacheRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockClearForPrefixesInspect()

			m.MinimockGetBudgetInspect()

			m.MinimockGetBudgetsListInspect()

			m.MinimockGetBudgetsPagedListInspect()

			m.MinimockSaveBudgetInspect()

			m.MinimockSaveBudgetsListInspect()

			m.MinimockSaveBudgetsPagedListInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *BudgetCacheRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *BudgetCacheRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockClearForPrefixesDone() &&
		m.MinimockGetBudgetDone() &&
		m.MinimockGetBudgetsListDone() &&
		m.MinimockGetBudgetsPagedListDone() &&
		m.MinimockSaveBudgetDone() &&
		m.MinimockSaveBudgetsListDone() &&
		m.MinimockSaveBudgetsPagedListDone()
}
