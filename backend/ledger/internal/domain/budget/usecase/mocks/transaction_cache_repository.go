// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase.TransactionCacheRepository -o transaction_cache_repository.go -n TransactionCacheRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
)

// TransactionCacheRepositoryMock implements mm_usecase.TransactionCacheRepository
type TransactionCacheRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetReports          func(ctx context.Context, key string) (items []*entity.ReportItem, err error)
	funcGetReportsOrigin    string
	inspectFuncGetReports   func(ctx context.Context, key string)
	afterGetReportsCounter  uint64
	beforeGetReportsCounter uint64
	GetReportsMock          mTransactionCacheRepositoryMockGetReports

	funcSaveReports          func(ctx context.Context, key string, items []*entity.ReportItem, ttl *time.Duration) (err error)
	funcSaveReportsOrigin    string
	inspectFuncSaveReports   func(ctx context.Context, key string, items []*entity.ReportItem, ttl *time.Duration)
	afterSaveReportsCounter  uint64
	beforeSaveReportsCounter uint64
	SaveReportsMock          mTransactionCacheRepositoryMockSaveReports
}

// NewTransactionCacheRepositoryMock returns a mock for mm_usecase.TransactionCacheRepository
func NewTransactionCacheRepositoryMock(t minimock.Tester) *TransactionCacheRepositoryMock {
	m := &TransactionCacheRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetReportsMock = mTransactionCacheRepositoryMockGetReports{mock: m}
	m.GetReportsMock.callArgs = []*TransactionCacheRepositoryMockGetReportsParams{}

	m.SaveReportsMock = mTransactionCacheRepositoryMockSaveReports{mock: m}
	m.SaveReportsMock.callArgs = []*TransactionCacheRepositoryMockSaveReportsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTransactionCacheRepositoryMockGetReports struct {
	optional           bool
	mock               *TransactionCacheRepositoryMock
	defaultExpectation *TransactionCacheRepositoryMockGetReportsExpectation
	expectations       []*TransactionCacheRepositoryMockGetReportsExpectation

	callArgs []*TransactionCacheRepositoryMockGetReportsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionCacheRepositoryMockGetReportsExpectation specifies expectation struct of the TransactionCacheRepository.GetReports
type TransactionCacheRepositoryMockGetReportsExpectation struct {
	mock               *TransactionCacheRepositoryMock
	params             *TransactionCacheRepositoryMockGetReportsParams
	paramPtrs          *TransactionCacheRepositoryMockGetReportsParamPtrs
	expectationOrigins TransactionCacheRepositoryMockGetReportsExpectationOrigins
	results            *TransactionCacheRepositoryMockGetReportsResults
	returnOrigin       string
	Counter            uint64
}

// TransactionCacheRepositoryMockGetReportsParams contains parameters of the TransactionCacheRepository.GetReports
type TransactionCacheRepositoryMockGetReportsParams struct {
	ctx context.Context
	key string
}

// TransactionCacheRepositoryMockGetReportsParamPtrs contains pointers to parameters of the TransactionCacheRepository.GetReports
type TransactionCacheRepositoryMockGetReportsParamPtrs struct {
	ctx *context.Context
	key *string
}

// TransactionCacheRepositoryMockGetReportsResults contains results of the TransactionCacheRepository.GetReports
type TransactionCacheRepositoryMockGetReportsResults struct {
	items []*entity.ReportItem
	err   error
}

// TransactionCacheRepositoryMockGetReportsOrigins contains origins of expectations of the TransactionCacheRepository.GetReports
type TransactionCacheRepositoryMockGetReportsExpectationOrigins struct {
	origin    string
	originCtx string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReports *mTransactionCacheRepositoryMockGetReports) Optional() *mTransactionCacheRepositoryMockGetReports {
	mmGetReports.optional = true
	return mmGetReports
}

// Expect sets up expected params for TransactionCacheRepository.GetReports
func (mmGetReports *mTransactionCacheRepositoryMockGetReports) Expect(ctx context.Context, key string) *mTransactionCacheRepositoryMockGetReports {
	if mmGetReports.mock.funcGetReports != nil {
		mmGetReports.mock.t.Fatalf("TransactionCacheRepositoryMock.GetReports mock is already set by Set")
	}

	if mmGetReports.defaultExpectation == nil {
		mmGetReports.defaultExpectation = &TransactionCacheRepositoryMockGetReportsExpectation{}
	}

	if mmGetReports.defaultExpectation.paramPtrs != nil {
		mmGetReports.mock.t.Fatalf("TransactionCacheRepositoryMock.GetReports mock is already set by ExpectParams functions")
	}

	mmGetReports.defaultExpectation.params = &TransactionCacheRepositoryMockGetReportsParams{ctx, key}
	mmGetReports.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetReports.expectations {
		if minimock.Equal(e.params, mmGetReports.defaultExpectation.params) {
			mmGetReports.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReports.defaultExpectation.params)
		}
	}

	return mmGetReports
}

// ExpectCtxParam1 sets up expected param ctx for TransactionCacheRepository.GetReports
func (mmGetReports *mTransactionCacheRepositoryMockGetReports) ExpectCtxParam1(ctx context.Context) *mTransactionCacheRepositoryMockGetReports {
	if mmGetReports.mock.funcGetReports != nil {
		mmGetReports.mock.t.Fatalf("TransactionCacheRepositoryMock.GetReports mock is already set by Set")
	}

	if mmGetReports.defaultExpectation == nil {
		mmGetReports.defaultExpectation = &TransactionCacheRepositoryMockGetReportsExpectation{}
	}

	if mmGetReports.defaultExpectation.params != nil {
		mmGetReports.mock.t.Fatalf("TransactionCacheRepositoryMock.GetReports mock is already set by Expect")
	}

	if mmGetReports.defaultExpectation.paramPtrs == nil {
		mmGetReports.defaultExpectation.paramPtrs = &TransactionCacheRepositoryMockGetReportsParamPtrs{}
	}
	mmGetReports.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetReports.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetReports
}

// ExpectKeyParam2 sets up expected param key for TransactionCacheRepository.GetReports
func (mmGetReports *mTransactionCacheRepositoryMockGetReports) ExpectKeyParam2(key string) *mTransactionCacheRepositoryMockGetReports {
	if mmGetReports.mock.funcGetReports != nil {
		mmGetReports.mock.t.Fatalf("TransactionCacheRepositoryMock.GetReports mock is already set by Set")
	}

	if mmGetReports.defaultExpectation == nil {
		mmGetReports.defaultExpectation = &TransactionCacheRepositoryMockGetReportsExpectation{}
	}

	if mmGetReports.defaultExpectation.params != nil {
		mmGetReports.mock.t.Fatalf("TransactionCacheRepositoryMock.GetReports mock is already set by Expect")
	}

	if mmGetReports.defaultExpectation.paramPtrs == nil {
		mmGetReports.defaultExpectation.paramPtrs = &TransactionCacheRepositoryMockGetReportsParamPtrs{}
	}
	mmGetReports.defaultExpectation.paramPtrs.key = &key
	mmGetReports.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmGetReports
}

// Inspect accepts an inspector function that has same arguments as the TransactionCacheRepository.GetReports
func (mmGetReports *mTransactionCacheRepositoryMockGetReports) Inspect(f func(ctx context.Context, key string)) *mTransactionCacheRepositoryMockGetReports {
	if mmGetReports.mock.inspectFuncGetReports != nil {
		mmGetReports.mock.t.Fatalf("Inspect function is already set for TransactionCacheRepositoryMock.GetReports")
	}

	mmGetReports.mock.inspectFuncGetReports = f

	return mmGetReports
}

// Return sets up results that will be returned by TransactionCacheRepository.GetReports
func (mmGetReports *mTransactionCacheRepositoryMockGetReports) Return(items []*entity.ReportItem, err error) *TransactionCacheRepositoryMock {
	if mmGetReports.mock.funcGetReports != nil {
		mmGetReports.mock.t.Fatalf("TransactionCacheRepositoryMock.GetReports mock is already set by Set")
	}

	if mmGetReports.defaultExpectation == nil {
		mmGetReports.defaultExpectation = &TransactionCacheRepositoryMockGetReportsExpectation{mock: mmGetReports.mock}
	}
	mmGetReports.defaultExpectation.results = &TransactionCacheRepositoryMockGetReportsResults{items, err}
	mmGetReports.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetReports.mock
}

// Set uses given function f to mock the TransactionCacheRepository.GetReports method
func (mmGetReports *mTransactionCacheRepositoryMockGetReports) Set(f func(ctx context.Context, key string) (items []*entity.ReportItem, err error)) *TransactionCacheRepositoryMock {
	if mmGetReports.defaultExpectation != nil {
		mmGetReports.mock.t.Fatalf("Default expectation is already set for the TransactionCacheRepository.GetReports method")
	}

	if len(mmGetReports.expectations) > 0 {
		mmGetReports.mock.t.Fatalf("Some expectations are already set for the TransactionCacheRepository.GetReports method")
	}

	mmGetReports.mock.funcGetReports = f
	mmGetReports.mock.funcGetReportsOrigin = minimock.CallerInfo(1)
	return mmGetReports.mock
}

// When sets expectation for the TransactionCacheRepository.GetReports which will trigger the result defined by the following
// Then helper
func (mmGetReports *mTransactionCacheRepositoryMockGetReports) When(ctx context.Context, key string) *TransactionCacheRepositoryMockGetReportsExpectation {
	if mmGetReports.mock.funcGetReports != nil {
		mmGetReports.mock.t.Fatalf("TransactionCacheRepositoryMock.GetReports mock is already set by Set")
	}

	expectation := &TransactionCacheRepositoryMockGetReportsExpectation{
		mock:               mmGetReports.mock,
		params:             &TransactionCacheRepositoryMockGetReportsParams{ctx, key},
		expectationOrigins: TransactionCacheRepositoryMockGetReportsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetReports.expectations = append(mmGetReports.expectations, expectation)
	return expectation
}

// Then sets up TransactionCacheRepository.GetReports return parameters for the expectation previously defined by the When method
func (e *TransactionCacheRepositoryMockGetReportsExpectation) Then(items []*entity.ReportItem, err error) *TransactionCacheRepositoryMock {
	e.results = &TransactionCacheRepositoryMockGetReportsResults{items, err}
	return e.mock
}

// Times sets number of times TransactionCacheRepository.GetReports should be invoked
func (mmGetReports *mTransactionCacheRepositoryMockGetReports) Times(n uint64) *mTransactionCacheRepositoryMockGetReports {
	if n == 0 {
		mmGetReports.mock.t.Fatalf("Times of TransactionCacheRepositoryMock.GetReports mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetReports.expectedInvocations, n)
	mmGetReports.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetReports
}

func (mmGetReports *mTransactionCacheRepositoryMockGetReports) invocationsDone() bool {
	if len(mmGetReports.expectations) == 0 && mmGetReports.defaultExpectation == nil && mmGetReports.mock.funcGetReports == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetReports.mock.afterGetReportsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetReports.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetReports implements mm_usecase.TransactionCacheRepository
func (mmGetReports *TransactionCacheRepositoryMock) GetReports(ctx context.Context, key string) (items []*entity.ReportItem, err error) {
	mm_atomic.AddUint64(&mmGetReports.beforeGetReportsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReports.afterGetReportsCounter, 1)

	mmGetReports.t.Helper()

	if mmGetReports.inspectFuncGetReports != nil {
		mmGetReports.inspectFuncGetReports(ctx, key)
	}

	mm_params := TransactionCacheRepositoryMockGetReportsParams{ctx, key}

	// Record call args
	mmGetReports.GetReportsMock.mutex.Lock()
	mmGetReports.GetReportsMock.callArgs = append(mmGetReports.GetReportsMock.callArgs, &mm_params)
	mmGetReports.GetReportsMock.mutex.Unlock()

	for _, e := range mmGetReports.GetReportsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.items, e.results.err
		}
	}

	if mmGetReports.GetReportsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReports.GetReportsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReports.GetReportsMock.defaultExpectation.params
		mm_want_ptrs := mmGetReports.GetReportsMock.defaultExpectation.paramPtrs

		mm_got := TransactionCacheRepositoryMockGetReportsParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetReports.t.Errorf("TransactionCacheRepositoryMock.GetReports got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReports.GetReportsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmGetReports.t.Errorf("TransactionCacheRepositoryMock.GetReports got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReports.GetReportsMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReports.t.Errorf("TransactionCacheRepositoryMock.GetReports got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetReports.GetReportsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReports.GetReportsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReports.t.Fatal("No results are set for the TransactionCacheRepositoryMock.GetReports")
		}
		return (*mm_results).items, (*mm_results).err
	}
	if mmGetReports.funcGetReports != nil {
		return mmGetReports.funcGetReports(ctx, key)
	}
	mmGetReports.t.Fatalf("Unexpected call to TransactionCacheRepositoryMock.GetReports. %v %v", ctx, key)
	return
}

// GetReportsAfterCounter returns a count of finished TransactionCacheRepositoryMock.GetReports invocations
func (mmGetReports *TransactionCacheRepositoryMock) GetReportsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReports.afterGetReportsCounter)
}

// GetReportsBeforeCounter returns a count of TransactionCacheRepositoryMock.GetReports invocations
func (mmGetReports *TransactionCacheRepositoryMock) GetReportsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReports.beforeGetReportsCounter)
}

// Calls returns a list of arguments used in each call to TransactionCacheRepositoryMock.GetReports.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReports *mTransactionCacheRepositoryMockGetReports) Calls() []*TransactionCacheRepositoryMockGetReportsParams {
	mmGetReports.mutex.RLock()

	argCopy := make([]*TransactionCacheRepositoryMockGetReportsParams, len(mmGetReports.callArgs))
	copy(argCopy, mmGetReports.callArgs)

	mmGetReports.mutex.RUnlock()

	return argCopy
}

// MinimockGetReportsDone returns true if the count of the GetReports invocations corresponds
// the number of defined expectations
func (m *TransactionCacheRepositoryMock) MinimockGetReportsDone() bool {
	if m.GetReportsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetReportsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetReportsMock.invocationsDone()
}

// MinimockGetReportsInspect logs each unmet expectation
func (m *TransactionCacheRepositoryMock) MinimockGetReportsInspect() {
	for _, e := range m.GetReportsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionCacheRepositoryMock.GetReports at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetReportsCounter := mm_atomic.LoadUint64(&m.afterGetReportsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetReportsMock.defaultExpectation != nil && afterGetReportsCounter < 1 {
		if m.GetReportsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionCacheRepositoryMock.GetReports at\n%s", m.GetReportsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionCacheRepositoryMock.GetReports at\n%s with params: %#v", m.GetReportsMock.defaultExpectation.expectationOrigins.origin, *m.GetReportsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReports != nil && afterGetReportsCounter < 1 {
		m.t.Errorf("Expected call to TransactionCacheRepositoryMock.GetReports at\n%s", m.funcGetReportsOrigin)
	}

	if !m.GetReportsMock.invocationsDone() && afterGetReportsCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionCacheRepositoryMock.GetReports at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetReportsMock.expectedInvocations), m.GetReportsMock.expectedInvocationsOrigin, afterGetReportsCounter)
	}
}

type mTransactionCacheRepositoryMockSaveReports struct {
	optional           bool
	mock               *TransactionCacheRepositoryMock
	defaultExpectation *TransactionCacheRepositoryMockSaveReportsExpectation
	expectations       []*TransactionCacheRepositoryMockSaveReportsExpectation

	callArgs []*TransactionCacheRepositoryMockSaveReportsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionCacheRepositoryMockSaveReportsExpectation specifies expectation struct of the TransactionCacheRepository.SaveReports
type TransactionCacheRepositoryMockSaveReportsExpectation struct {
	mock               *TransactionCacheRepositoryMock
	params             *TransactionCacheRepositoryMockSaveReportsParams
	paramPtrs          *TransactionCacheRepositoryMockSaveReportsParamPtrs
	expectationOrigins TransactionCacheRepositoryMockSaveReportsExpectationOrigins
	results            *TransactionCacheRepositoryMockSaveReportsResults
	returnOrigin       string
	Counter            uint64
}

// TransactionCacheRepositoryMockSaveReportsParams contains parameters of the TransactionCacheRepository.SaveReports
type TransactionCacheRepositoryMockSaveReportsParams struct {
	ctx   context.Context
	key   string
	items []*entity.ReportItem
	ttl   *time.Duration
}

// TransactionCacheRepositoryMockSaveReportsParamPtrs contains pointers to parameters of the TransactionCacheRepository.SaveReports
type TransactionCacheRepositoryMockSaveReportsParamPtrs struct {
	ctx   *context.Context
	key   *string
	items *[]*entity.ReportItem
	ttl   **time.Duration
}

// TransactionCacheRepositoryMockSaveReportsResults contains results of the TransactionCacheRepository.SaveReports
type TransactionCacheRepositoryMockSaveReportsResults struct {
	err error
}

// TransactionCacheRepositoryMockSaveReportsOrigins contains origins of expectations of the TransactionCacheRepository.SaveReports
type TransactionCacheRepositoryMockSaveReportsExpectationOrigins struct {
	origin      string
	originCtx   string
	originKey   string
	originItems string
	originTtl   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) Optional() *mTransactionCacheRepositoryMockSaveReports {
	mmSaveReports.optional = true
	return mmSaveReports
}

// Expect sets up expected params for TransactionCacheRepository.SaveReports
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) Expect(ctx context.Context, key string, items []*entity.ReportItem, ttl *time.Duration) *mTransactionCacheRepositoryMockSaveReports {
	if mmSaveReports.mock.funcSaveReports != nil {
		mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Set")
	}

	if mmSaveReports.defaultExpectation == nil {
		mmSaveReports.defaultExpectation = &TransactionCacheRepositoryMockSaveReportsExpectation{}
	}

	if mmSaveReports.defaultExpectation.paramPtrs != nil {
		mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by ExpectParams functions")
	}

	mmSaveReports.defaultExpectation.params = &TransactionCacheRepositoryMockSaveReportsParams{ctx, key, items, ttl}
	mmSaveReports.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSaveReports.expectations {
		if minimock.Equal(e.params, mmSaveReports.defaultExpectation.params) {
			mmSaveReports.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveReports.defaultExpectation.params)
		}
	}

	return mmSaveReports
}

// ExpectCtxParam1 sets up expected param ctx for TransactionCacheRepository.SaveReports
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) ExpectCtxParam1(ctx context.Context) *mTransactionCacheRepositoryMockSaveReports {
	if mmSaveReports.mock.funcSaveReports != nil {
		mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Set")
	}

	if mmSaveReports.defaultExpectation == nil {
		mmSaveReports.defaultExpectation = &TransactionCacheRepositoryMockSaveReportsExpectation{}
	}

	if mmSaveReports.defaultExpectation.params != nil {
		mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Expect")
	}

	if mmSaveReports.defaultExpectation.paramPtrs == nil {
		mmSaveReports.defaultExpectation.paramPtrs = &TransactionCacheRepositoryMockSaveReportsParamPtrs{}
	}
	mmSaveReports.defaultExpectation.paramPtrs.ctx = &ctx
	mmSaveReports.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSaveReports
}

// ExpectKeyParam2 sets up expected param key for TransactionCacheRepository.SaveReports
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) ExpectKeyParam2(key string) *mTransactionCacheRepositoryMockSaveReports {
	if mmSaveReports.mock.funcSaveReports != nil {
		mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Set")
	}

	if mmSaveReports.defaultExpectation == nil {
		mmSaveReports.defaultExpectation = &TransactionCacheRepositoryMockSaveReportsExpectation{}
	}

	if mmSaveReports.defaultExpectation.params != nil {
		mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Expect")
	}

	if mmSaveReports.defaultExpectation.paramPtrs == nil {
		mmSaveReports.defaultExpectation.paramPtrs = &TransactionCacheRepositoryMockSaveReportsParamPtrs{}
	}
	mmSaveReports.defaultExpectation.paramPtrs.key = &key
	mmSaveReports.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmSaveReports
}

// ExpectItemsParam3 sets up expected param items for TransactionCacheRepository.SaveReports
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) ExpectItemsParam3(items []*entity.ReportItem) *mTransactionCacheRepositoryMockSaveReports {
	if mmSaveReports.mock.funcSaveReports != nil {
		mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Set")
	}

	if mmSaveReports.defaultExpectation == nil {
		mmSaveReports.defaultExpectation = &TransactionCacheRepositoryMockSaveReportsExpectation{}
	}

	if mmSaveReports.defaultExpectation.params != nil {
		mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Expect")
	}

	if mmSaveReports.defaultExpectation.paramPtrs == nil {
		mmSaveReports.defaultExpectation.paramPtrs = &TransactionCacheRepositoryMockSaveReportsParamPtrs{}
	}
	mmSaveReports.defaultExpectation.paramPtrs.items = &items
	mmSaveReports.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmSaveReports
}

// ExpectTtlParam4 sets up expected param ttl for TransactionCacheRepository.SaveReports
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) ExpectTtlParam4(ttl *time.Duration) *mTransactionCacheRepositoryMockSaveReports {
	if mmSaveReports.mock.funcSaveReports != nil {
		mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Set")
	}

	if mmSaveReports.defaultExpectation == nil {
		mmSaveReports.defaultExpectation = &TransactionCacheRepositoryMockSaveReportsExpectation{}
	}

	if mmSaveReports.defaultExpectation.params != nil {
		mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Expect")
	}

	if mmSaveReports.defaultExpectation.paramPtrs == nil {
		mmSaveReports.defaultExpectation.paramPtrs = &TransactionCacheRepositoryMockSaveReportsParamPtrs{}
	}
	mmSaveReports.defaultExpectation.paramPtrs.ttl = &ttl
	mmSaveReports.defaultExpectation.expectationOrigins.originTtl = minimock.CallerInfo(1)

	return mmSaveReports
}

// Inspect accepts an inspector function that has same arguments as the TransactionCacheRepository.SaveReports
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) Inspect(f func(ctx context.Context, key string, items []*entity.ReportItem, ttl *time.Duration)) *mTransactionCacheRepositoryMockSaveReports {
	if mmSaveReports.mock.inspectFuncSaveReports != nil {
		mmSaveReports.mock.t.Fatalf("Inspect function is already set for TransactionCacheRepositoryMock.SaveReports")
	}

	mmSaveReports.mock.inspectFuncSaveReports = f

	return mmSaveReports
}

// Return sets up results that will be returned by TransactionCacheRepository.SaveReports
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) Return(err error) *TransactionCacheRepositoryMock {
	if mmSaveReports.mock.funcSaveReports != nil {
		mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Set")
	}

	if mmSaveReports.defaultExpectation == nil {
		mmSaveReports.defaultExpectation = &TransactionCacheRepositoryMockSaveReportsExpectation{mock: mmSaveReports.mock}
	}
	mmSaveReports.defaultExpectation.results = &TransactionCacheRepositoryMockSaveReportsResults{err}
	mmSaveReports.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSaveReports.mock
}

// Set uses given function f to mock the TransactionCacheRepository.SaveReports method
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) Set(f func(ctx context.Context, key string, items []*entity.ReportItem, ttl *time.Duration) (err error)) *TransactionCacheRepositoryMock {
	if mmSaveReports.defaultExpectation != nil {
		mmSaveReports.mock.t.Fatalf("Default expectation is already set for the TransactionCacheRepository.SaveReports method")
	}

	if len(mmSaveReports.expectations) > 0 {
		mmSaveReports.mock.t.Fatalf("Some expectations are already set for the TransactionCacheRepository.SaveReports method")
	}

	mmSaveReports.mock.funcSaveReports = f
	mmSaveReports.mock.funcSaveReportsOrigin = minimock.CallerInfo(1)
	return mmSaveReports.mock
}

// When sets expectation for the TransactionCacheRepository.SaveReports which will trigger the result defined by the following
// Then helper
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) When(ctx context.Context, key string, items []*entity.ReportItem, ttl *time.Duration) *TransactionCacheRepositoryMockSaveReportsExpectation {
	if mmSaveReports.mock.funcSaveReports != nil {
		mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Set")
	}

	expectation := &TransactionCacheRepositoryMockSaveReportsExpectation{
		mock:               mmSaveReports.mock,
		params:             &TransactionCacheRepositoryMockSaveReportsParams{ctx, key, items, ttl},
		expectationOrigins: TransactionCacheRepositoryMockSaveReportsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSaveReports.expectations = append(mmSaveReports.expectations, expectation)
	return expectation
}

// Then sets up TransactionCacheRepository.SaveReports return parameters for the expectation previously defined by the When method
func (e *TransactionCacheRepositoryMockSaveReportsExpectation) Then(err error) *TransactionCacheRepositoryMock {
	e.results = &TransactionCacheRepositoryMockSaveReportsResults{err}
	return e.mock
}

// Times sets number of times TransactionCacheRepository.SaveReports should be invoked
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) Times(n uint64) *mTransactionCacheRepositoryMockSaveReports {
	if n == 0 {
		mmSaveReports.mock.t.Fatalf("Times of TransactionCacheRepositoryMock.SaveReports mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSaveReports.expectedInvocations, n)
	mmSaveReports.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSaveReports
}

func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) invocationsDone() bool {
	if len(mmSaveReports.expectations) == 0 && mmSaveReports.defaultExpectation == nil && mmSaveReports.mock.funcSaveReports == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSaveReports.mock.afterSaveReportsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSaveReports.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SaveReports implements mm_usecase.TransactionCacheRepository
func (mmSaveReports *TransactionCacheRepositoryMock) SaveReports(ctx context.Context, key string, items []*entity.ReportItem, ttl *time.Duration) (err error) {
	mm_atomic.AddUint64(&mmSaveReports.beforeSaveReportsCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveReports.afterSaveReportsCounter, 1)

	mmSaveReports.t.Helper()

	if mmSaveReports.inspectFuncSaveReports != nil {
		mmSaveReports.inspectFuncSaveReports(ctx, key, items, ttl)
	}

	mm_params := TransactionCacheRepositoryMockSaveReportsParams{ctx, key, items, ttl}

	// Record call args
	mmSaveReports.SaveReportsMock.mutex.Lock()
	mmSaveReports.SaveReportsMock.callArgs = append(mmSaveReports.SaveReportsMock.callArgs, &mm_params)
	mmSaveReports.SaveReportsMock.mutex.Unlock()

	for _, e := range mmSaveReports.SaveReportsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveReports.SaveReportsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveReports.SaveReportsMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveReports.SaveReportsMock.defaultExpectation.params
		mm_want_ptrs := mmSaveReports.SaveReportsMock.defaultExpectation.paramPtrs

		mm_got := TransactionCacheRepositoryMockSaveReportsParams{ctx, key, items, ttl}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSaveReports.t.Errorf("TransactionCacheRepositoryMock.SaveReports got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveReports.SaveReportsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmSaveReports.t.Errorf("TransactionCacheRepositoryMock.SaveReports got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveReports.SaveReportsMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmSaveReports.t.Errorf("TransactionCacheRepositoryMock.SaveReports got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveReports.SaveReportsMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

			if mm_want_ptrs.ttl != nil && !minimock.Equal(*mm_want_ptrs.ttl, mm_got.ttl) {
				mmSaveReports.t.Errorf("TransactionCacheRepositoryMock.SaveReports got unexpected parameter ttl, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveReports.SaveReportsMock.defaultExpectation.expectationOrigins.originTtl, *mm_want_ptrs.ttl, mm_got.ttl, minimock.Diff(*mm_want_ptrs.ttl, mm_got.ttl))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveReports.t.Errorf("TransactionCacheRepositoryMock.SaveReports got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSaveReports.SaveReportsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveReports.SaveReportsMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveReports.t.Fatal("No results are set for the TransactionCacheRepositoryMock.SaveReports")
		}
		return (*mm_results).err
	}
	if mmSaveReports.funcSaveReports != nil {
		return mmSaveReports.funcSaveReports(ctx, key, items, ttl)
	}
	mmSaveReports.t.Fatalf("Unexpected call to TransactionCacheRepositoryMock.SaveReports. %v %v %v %v", ctx, key, items, ttl)
	return
}

// SaveReportsAfterCounter returns a count of finished TransactionCacheRepositoryMock.SaveReports invocations
func (mmSaveReports *TransactionCacheRepositoryMock) SaveReportsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveReports.afterSaveReportsCounter)
}

// SaveReportsBeforeCounter returns a count of TransactionCacheRepositoryMock.SaveReports invocations
func (mmSaveReports *TransactionCacheRepositoryMock) SaveReportsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveReports.beforeSaveReportsCounter)
}

// Calls returns a list of arguments used in each call to TransactionCacheRepositoryMock.SaveReports.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) Calls() []*TransactionCacheRepositoryMockSaveReportsParams {
	mmSaveReports.mutex.RLock()

	argCopy := make([]*TransactionCacheRepositoryMockSaveReportsParams, len(mmSaveReports.callArgs))
	copy(argCopy, mmSaveReports.callArgs)

	mmSaveReports.mutex.RUnlock()

	return argCopy
}

// MinimockSaveReportsDone returns true if the count of the SaveReports invocations corresponds
// the number of defined expectations
func (m *TransactionCacheRepositoryMock) MinimockSaveReportsDone() bool {
	if m.SaveReportsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveReportsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveReportsMock.invocationsDone()
}

// MinimockSaveReportsInspect logs each unmet expectation
func (m *TransactionCacheRepositoryMock) MinimockSaveReportsInspect() {
	for _, e := range m.SaveReportsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionCacheRepositoryMock.SaveReports at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveReportsCounter := mm_atomic.LoadUint64(&m.afterSaveReportsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveReportsMock.defaultExpectation != nil && afterSaveReportsCounter < 1 {
		if m.SaveReportsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionCacheRepositoryMock.SaveReports at\n%s", m.SaveReportsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionCacheRepositoryMock.SaveReports at\n%s with params: %#v", m.SaveReportsMock.defaultExpectation.expectationOrigins.origin, *m.SaveReportsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveReports != nil && afterSaveReportsCounter < 1 {
		m.t.Errorf("Expected call to TransactionCacheRepositoryMock.SaveReports at\n%s", m.funcSaveReportsOrigin)
	}

	if !m.SaveReportsMock.invocationsDone() && afterSaveReportsCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionCacheRepositoryMock.SaveReports at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveReportsMock.expectedInvocations), m.SaveReportsMock.expectedInvocationsOrigin, afterSaveReportsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TransactionCacheRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetReportsInspect()

			m.MinimockSaveReportsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TransactionCacheRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TransactionCacheRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetReportsDone() &&
		m.MinimockSaveReportsDone()
}
