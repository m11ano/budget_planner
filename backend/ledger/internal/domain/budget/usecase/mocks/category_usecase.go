// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase.CategoryUsecase -o category_usecase.go -n CategoryUsecaseMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
	mm_usecase "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
)

// CategoryUsecaseMock implements mm_usecase.CategoryUsecase
type CategoryUsecaseMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcFindList          func(ctx context.Context, listOptions *mm_usecase.CategoryListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.CategoryDTO, err error)
	funcFindListOrigin    string
	inspectFuncFindList   func(ctx context.Context, listOptions *mm_usecase.CategoryListOptions, queryParams *uctypes.QueryGetListParams)
	afterFindListCounter  uint64
	beforeFindListCounter uint64
	FindListMock          mCategoryUsecaseMockFindList

	funcFindOneByID          func(ctx context.Context, id uint64, queryParams *uctypes.QueryGetOneParams) (resItem *mm_usecase.CategoryDTO, err error)
	funcFindOneByIDOrigin    string
	inspectFuncFindOneByID   func(ctx context.Context, id uint64, queryParams *uctypes.QueryGetOneParams)
	afterFindOneByIDCounter  uint64
	beforeFindOneByIDCounter uint64
	FindOneByIDMock          mCategoryUsecaseMockFindOneByID
}

// NewCategoryUsecaseMock returns a mock for mm_usecase.CategoryUsecase
func NewCategoryUsecaseMock(t minimock.Tester) *CategoryUsecaseMock {
	m := &CategoryUsecaseMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.FindListMock = mCategoryUsecaseMockFindList{mock: m}
	m.FindListMock.callArgs = []*CategoryUsecaseMockFindListParams{}

	m.FindOneByIDMock = mCategoryUsecaseMockFindOneByID{mock: m}
	m.FindOneByIDMock.callArgs = []*CategoryUsecaseMockFindOneByIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCategoryUsecaseMockFindList struct {
	optional           bool
	mock               *CategoryUsecaseMock
	defaultExpectation *CategoryUsecaseMockFindListExpectation
	expectations       []*CategoryUsecaseMockFindListExpectation

	callArgs []*CategoryUsecaseMockFindListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CategoryUsecaseMockFindListExpectation specifies expectation struct of the CategoryUsecase.FindList
type CategoryUsecaseMockFindListExpectation struct {
	mock               *CategoryUsecaseMock
	params             *CategoryUsecaseMockFindListParams
	paramPtrs          *CategoryUsecaseMockFindListParamPtrs
	expectationOrigins CategoryUsecaseMockFindListExpectationOrigins
	results            *CategoryUsecaseMockFindListResults
	returnOrigin       string
	Counter            uint64
}

// CategoryUsecaseMockFindListParams contains parameters of the CategoryUsecase.FindList
type CategoryUsecaseMockFindListParams struct {
	ctx         context.Context
	listOptions *mm_usecase.CategoryListOptions
	queryParams *uctypes.QueryGetListParams
}

// CategoryUsecaseMockFindListParamPtrs contains pointers to parameters of the CategoryUsecase.FindList
type CategoryUsecaseMockFindListParamPtrs struct {
	ctx         *context.Context
	listOptions **mm_usecase.CategoryListOptions
	queryParams **uctypes.QueryGetListParams
}

// CategoryUsecaseMockFindListResults contains results of the CategoryUsecase.FindList
type CategoryUsecaseMockFindListResults struct {
	resItems []*mm_usecase.CategoryDTO
	err      error
}

// CategoryUsecaseMockFindListOrigins contains origins of expectations of the CategoryUsecase.FindList
type CategoryUsecaseMockFindListExpectationOrigins struct {
	origin            string
	originCtx         string
	originListOptions string
	originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindList *mCategoryUsecaseMockFindList) Optional() *mCategoryUsecaseMockFindList {
	mmFindList.optional = true
	return mmFindList
}

// Expect sets up expected params for CategoryUsecase.FindList
func (mmFindList *mCategoryUsecaseMockFindList) Expect(ctx context.Context, listOptions *mm_usecase.CategoryListOptions, queryParams *uctypes.QueryGetListParams) *mCategoryUsecaseMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("CategoryUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &CategoryUsecaseMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.paramPtrs != nil {
		mmFindList.mock.t.Fatalf("CategoryUsecaseMock.FindList mock is already set by ExpectParams functions")
	}

	mmFindList.defaultExpectation.params = &CategoryUsecaseMockFindListParams{ctx, listOptions, queryParams}
	mmFindList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindList.expectations {
		if minimock.Equal(e.params, mmFindList.defaultExpectation.params) {
			mmFindList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindList.defaultExpectation.params)
		}
	}

	return mmFindList
}

// ExpectCtxParam1 sets up expected param ctx for CategoryUsecase.FindList
func (mmFindList *mCategoryUsecaseMockFindList) ExpectCtxParam1(ctx context.Context) *mCategoryUsecaseMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("CategoryUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &CategoryUsecaseMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.params != nil {
		mmFindList.mock.t.Fatalf("CategoryUsecaseMock.FindList mock is already set by Expect")
	}

	if mmFindList.defaultExpectation.paramPtrs == nil {
		mmFindList.defaultExpectation.paramPtrs = &CategoryUsecaseMockFindListParamPtrs{}
	}
	mmFindList.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindList
}

// ExpectListOptionsParam2 sets up expected param listOptions for CategoryUsecase.FindList
func (mmFindList *mCategoryUsecaseMockFindList) ExpectListOptionsParam2(listOptions *mm_usecase.CategoryListOptions) *mCategoryUsecaseMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("CategoryUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &CategoryUsecaseMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.params != nil {
		mmFindList.mock.t.Fatalf("CategoryUsecaseMock.FindList mock is already set by Expect")
	}

	if mmFindList.defaultExpectation.paramPtrs == nil {
		mmFindList.defaultExpectation.paramPtrs = &CategoryUsecaseMockFindListParamPtrs{}
	}
	mmFindList.defaultExpectation.paramPtrs.listOptions = &listOptions
	mmFindList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

	return mmFindList
}

// ExpectQueryParamsParam3 sets up expected param queryParams for CategoryUsecase.FindList
func (mmFindList *mCategoryUsecaseMockFindList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mCategoryUsecaseMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("CategoryUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &CategoryUsecaseMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.params != nil {
		mmFindList.mock.t.Fatalf("CategoryUsecaseMock.FindList mock is already set by Expect")
	}

	if mmFindList.defaultExpectation.paramPtrs == nil {
		mmFindList.defaultExpectation.paramPtrs = &CategoryUsecaseMockFindListParamPtrs{}
	}
	mmFindList.defaultExpectation.paramPtrs.queryParams = &queryParams
	mmFindList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

	return mmFindList
}

// Inspect accepts an inspector function that has same arguments as the CategoryUsecase.FindList
func (mmFindList *mCategoryUsecaseMockFindList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.CategoryListOptions, queryParams *uctypes.QueryGetListParams)) *mCategoryUsecaseMockFindList {
	if mmFindList.mock.inspectFuncFindList != nil {
		mmFindList.mock.t.Fatalf("Inspect function is already set for CategoryUsecaseMock.FindList")
	}

	mmFindList.mock.inspectFuncFindList = f

	return mmFindList
}

// Return sets up results that will be returned by CategoryUsecase.FindList
func (mmFindList *mCategoryUsecaseMockFindList) Return(resItems []*mm_usecase.CategoryDTO, err error) *CategoryUsecaseMock {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("CategoryUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &CategoryUsecaseMockFindListExpectation{mock: mmFindList.mock}
	}
	mmFindList.defaultExpectation.results = &CategoryUsecaseMockFindListResults{resItems, err}
	mmFindList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindList.mock
}

// Set uses given function f to mock the CategoryUsecase.FindList method
func (mmFindList *mCategoryUsecaseMockFindList) Set(f func(ctx context.Context, listOptions *mm_usecase.CategoryListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.CategoryDTO, err error)) *CategoryUsecaseMock {
	if mmFindList.defaultExpectation != nil {
		mmFindList.mock.t.Fatalf("Default expectation is already set for the CategoryUsecase.FindList method")
	}

	if len(mmFindList.expectations) > 0 {
		mmFindList.mock.t.Fatalf("Some expectations are already set for the CategoryUsecase.FindList method")
	}

	mmFindList.mock.funcFindList = f
	mmFindList.mock.funcFindListOrigin = minimock.CallerInfo(1)
	return mmFindList.mock
}

// When sets expectation for the CategoryUsecase.FindList which will trigger the result defined by the following
// Then helper
func (mmFindList *mCategoryUsecaseMockFindList) When(ctx context.Context, listOptions *mm_usecase.CategoryListOptions, queryParams *uctypes.QueryGetListParams) *CategoryUsecaseMockFindListExpectation {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("CategoryUsecaseMock.FindList mock is already set by Set")
	}

	expectation := &CategoryUsecaseMockFindListExpectation{
		mock:               mmFindList.mock,
		params:             &CategoryUsecaseMockFindListParams{ctx, listOptions, queryParams},
		expectationOrigins: CategoryUsecaseMockFindListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindList.expectations = append(mmFindList.expectations, expectation)
	return expectation
}

// Then sets up CategoryUsecase.FindList return parameters for the expectation previously defined by the When method
func (e *CategoryUsecaseMockFindListExpectation) Then(resItems []*mm_usecase.CategoryDTO, err error) *CategoryUsecaseMock {
	e.results = &CategoryUsecaseMockFindListResults{resItems, err}
	return e.mock
}

// Times sets number of times CategoryUsecase.FindList should be invoked
func (mmFindList *mCategoryUsecaseMockFindList) Times(n uint64) *mCategoryUsecaseMockFindList {
	if n == 0 {
		mmFindList.mock.t.Fatalf("Times of CategoryUsecaseMock.FindList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindList.expectedInvocations, n)
	mmFindList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindList
}

func (mmFindList *mCategoryUsecaseMockFindList) invocationsDone() bool {
	if len(mmFindList.expectations) == 0 && mmFindList.defaultExpectation == nil && mmFindList.mock.funcFindList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindList.mock.afterFindListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindList implements mm_usecase.CategoryUsecase
func (mmFindList *CategoryUsecaseMock) FindList(ctx context.Context, listOptions *mm_usecase.CategoryListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.CategoryDTO, err error) {
	mm_atomic.AddUint64(&mmFindList.beforeFindListCounter, 1)
	defer mm_atomic.AddUint64(&mmFindList.afterFindListCounter, 1)

	mmFindList.t.Helper()

	if mmFindList.inspectFuncFindList != nil {
		mmFindList.inspectFuncFindList(ctx, listOptions, queryParams)
	}

	mm_params := CategoryUsecaseMockFindListParams{ctx, listOptions, queryParams}

	// Record call args
	mmFindList.FindListMock.mutex.Lock()
	mmFindList.FindListMock.callArgs = append(mmFindList.FindListMock.callArgs, &mm_params)
	mmFindList.FindListMock.mutex.Unlock()

	for _, e := range mmFindList.FindListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resItems, e.results.err
		}
	}

	if mmFindList.FindListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindList.FindListMock.defaultExpectation.Counter, 1)
		mm_want := mmFindList.FindListMock.defaultExpectation.params
		mm_want_ptrs := mmFindList.FindListMock.defaultExpectation.paramPtrs

		mm_got := CategoryUsecaseMockFindListParams{ctx, listOptions, queryParams}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindList.t.Errorf("CategoryUsecaseMock.FindList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindList.FindListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.listOptions != nil && !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) {
				mmFindList.t.Errorf("CategoryUsecaseMock.FindList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindList.FindListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
			}

			if mm_want_ptrs.queryParams != nil && !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) {
				mmFindList.t.Errorf("CategoryUsecaseMock.FindList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindList.FindListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindList.t.Errorf("CategoryUsecaseMock.FindList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindList.FindListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindList.FindListMock.defaultExpectation.results
		if mm_results == nil {
			mmFindList.t.Fatal("No results are set for the CategoryUsecaseMock.FindList")
		}
		return (*mm_results).resItems, (*mm_results).err
	}
	if mmFindList.funcFindList != nil {
		return mmFindList.funcFindList(ctx, listOptions, queryParams)
	}
	mmFindList.t.Fatalf("Unexpected call to CategoryUsecaseMock.FindList. %v %v %v", ctx, listOptions, queryParams)
	return
}

// FindListAfterCounter returns a count of finished CategoryUsecaseMock.FindList invocations
func (mmFindList *CategoryUsecaseMock) FindListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindList.afterFindListCounter)
}

// FindListBeforeCounter returns a count of CategoryUsecaseMock.FindList invocations
func (mmFindList *CategoryUsecaseMock) FindListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindList.beforeFindListCounter)
}

// Calls returns a list of arguments used in each call to CategoryUsecaseMock.FindList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindList *mCategoryUsecaseMockFindList) Calls() []*CategoryUsecaseMockFindListParams {
	mmFindList.mutex.RLock()

	argCopy := make([]*CategoryUsecaseMockFindListParams, len(mmFindList.callArgs))
	copy(argCopy, mmFindList.callArgs)

	mmFindList.mutex.RUnlock()

	return argCopy
}

// MinimockFindListDone returns true if the count of the FindList invocations corresponds
// the number of defined expectations
func (m *CategoryUsecaseMock) MinimockFindListDone() bool {
	if m.FindListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindListMock.invocationsDone()
}

// MinimockFindListInspect logs each unmet expectation
func (m *CategoryUsecaseMock) MinimockFindListInspect() {
	for _, e := range m.FindListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CategoryUsecaseMock.FindList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindListCounter := mm_atomic.LoadUint64(&m.afterFindListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindListMock.defaultExpectation != nil && afterFindListCounter < 1 {
		if m.FindListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CategoryUsecaseMock.FindList at\n%s", m.FindListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CategoryUsecaseMock.FindList at\n%s with params: %#v", m.FindListMock.defaultExpectation.expectationOrigins.origin, *m.FindListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindList != nil && afterFindListCounter < 1 {
		m.t.Errorf("Expected call to CategoryUsecaseMock.FindList at\n%s", m.funcFindListOrigin)
	}

	if !m.FindListMock.invocationsDone() && afterFindListCounter > 0 {
		m.t.Errorf("Expected %d calls to CategoryUsecaseMock.FindList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindListMock.expectedInvocations), m.FindListMock.expectedInvocationsOrigin, afterFindListCounter)
	}
}

type mCategoryUsecaseMockFindOneByID struct {
	optional           bool
	mock               *CategoryUsecaseMock
	defaultExpectation *CategoryUsecaseMockFindOneByIDExpectation
	expectations       []*CategoryUsecaseMockFindOneByIDExpectation

	callArgs []*CategoryUsecaseMockFindOneByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CategoryUsecaseMockFindOneByIDExpectation specifies expectation struct of the CategoryUsecase.FindOneByID
type CategoryUsecaseMockFindOneByIDExpectation struct {
	mock               *CategoryUsecaseMock
	params             *CategoryUsecaseMockFindOneByIDParams
	paramPtrs          *CategoryUsecaseMockFindOneByIDParamPtrs
	expectationOrigins CategoryUsecaseMockFindOneByIDExpectationOrigins
	results            *CategoryUsecaseMockFindOneByIDResults
	returnOrigin       string
	Counter            uint64
}

// CategoryUsecaseMockFindOneByIDParams contains parameters of the CategoryUsecase.FindOneByID
type CategoryUsecaseMockFindOneByIDParams struct {
	ctx         context.Context
	id          uint64
	queryParams *uctypes.QueryGetOneParams
}

// CategoryUsecaseMockFindOneByIDParamPtrs contains pointers to parameters of the CategoryUsecase.FindOneByID
type CategoryUsecaseMockFindOneByIDParamPtrs struct {
	ctx         *context.Context
	id          *uint64
	queryParams **uctypes.QueryGetOneParams
}

// CategoryUsecaseMockFindOneByIDResults contains results of the CategoryUsecase.FindOneByID
type CategoryUsecaseMockFindOneByIDResults struct {
	resItem *mm_usecase.CategoryDTO
	err     error
}

// CategoryUsecaseMockFindOneByIDOrigins contains origins of expectations of the CategoryUsecase.FindOneByID
type CategoryUsecaseMockFindOneByIDExpectationOrigins struct {
	origin            string
	originCtx         string
	originId          string
	originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) Optional() *mCategoryUsecaseMockFindOneByID {
	mmFindOneByID.optional = true
	return mmFindOneByID
}

// Expect sets up expected params for CategoryUsecase.FindOneByID
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) Expect(ctx context.Context, id uint64, queryParams *uctypes.QueryGetOneParams) *mCategoryUsecaseMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("CategoryUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &CategoryUsecaseMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.paramPtrs != nil {
		mmFindOneByID.mock.t.Fatalf("CategoryUsecaseMock.FindOneByID mock is already set by ExpectParams functions")
	}

	mmFindOneByID.defaultExpectation.params = &CategoryUsecaseMockFindOneByIDParams{ctx, id, queryParams}
	mmFindOneByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindOneByID.expectations {
		if minimock.Equal(e.params, mmFindOneByID.defaultExpectation.params) {
			mmFindOneByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindOneByID.defaultExpectation.params)
		}
	}

	return mmFindOneByID
}

// ExpectCtxParam1 sets up expected param ctx for CategoryUsecase.FindOneByID
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) ExpectCtxParam1(ctx context.Context) *mCategoryUsecaseMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("CategoryUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &CategoryUsecaseMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.params != nil {
		mmFindOneByID.mock.t.Fatalf("CategoryUsecaseMock.FindOneByID mock is already set by Expect")
	}

	if mmFindOneByID.defaultExpectation.paramPtrs == nil {
		mmFindOneByID.defaultExpectation.paramPtrs = &CategoryUsecaseMockFindOneByIDParamPtrs{}
	}
	mmFindOneByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindOneByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindOneByID
}

// ExpectIdParam2 sets up expected param id for CategoryUsecase.FindOneByID
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) ExpectIdParam2(id uint64) *mCategoryUsecaseMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("CategoryUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &CategoryUsecaseMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.params != nil {
		mmFindOneByID.mock.t.Fatalf("CategoryUsecaseMock.FindOneByID mock is already set by Expect")
	}

	if mmFindOneByID.defaultExpectation.paramPtrs == nil {
		mmFindOneByID.defaultExpectation.paramPtrs = &CategoryUsecaseMockFindOneByIDParamPtrs{}
	}
	mmFindOneByID.defaultExpectation.paramPtrs.id = &id
	mmFindOneByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmFindOneByID
}

// ExpectQueryParamsParam3 sets up expected param queryParams for CategoryUsecase.FindOneByID
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetOneParams) *mCategoryUsecaseMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("CategoryUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &CategoryUsecaseMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.params != nil {
		mmFindOneByID.mock.t.Fatalf("CategoryUsecaseMock.FindOneByID mock is already set by Expect")
	}

	if mmFindOneByID.defaultExpectation.paramPtrs == nil {
		mmFindOneByID.defaultExpectation.paramPtrs = &CategoryUsecaseMockFindOneByIDParamPtrs{}
	}
	mmFindOneByID.defaultExpectation.paramPtrs.queryParams = &queryParams
	mmFindOneByID.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

	return mmFindOneByID
}

// Inspect accepts an inspector function that has same arguments as the CategoryUsecase.FindOneByID
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) Inspect(f func(ctx context.Context, id uint64, queryParams *uctypes.QueryGetOneParams)) *mCategoryUsecaseMockFindOneByID {
	if mmFindOneByID.mock.inspectFuncFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("Inspect function is already set for CategoryUsecaseMock.FindOneByID")
	}

	mmFindOneByID.mock.inspectFuncFindOneByID = f

	return mmFindOneByID
}

// Return sets up results that will be returned by CategoryUsecase.FindOneByID
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) Return(resItem *mm_usecase.CategoryDTO, err error) *CategoryUsecaseMock {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("CategoryUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &CategoryUsecaseMockFindOneByIDExpectation{mock: mmFindOneByID.mock}
	}
	mmFindOneByID.defaultExpectation.results = &CategoryUsecaseMockFindOneByIDResults{resItem, err}
	mmFindOneByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindOneByID.mock
}

// Set uses given function f to mock the CategoryUsecase.FindOneByID method
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) Set(f func(ctx context.Context, id uint64, queryParams *uctypes.QueryGetOneParams) (resItem *mm_usecase.CategoryDTO, err error)) *CategoryUsecaseMock {
	if mmFindOneByID.defaultExpectation != nil {
		mmFindOneByID.mock.t.Fatalf("Default expectation is already set for the CategoryUsecase.FindOneByID method")
	}

	if len(mmFindOneByID.expectations) > 0 {
		mmFindOneByID.mock.t.Fatalf("Some expectations are already set for the CategoryUsecase.FindOneByID method")
	}

	mmFindOneByID.mock.funcFindOneByID = f
	mmFindOneByID.mock.funcFindOneByIDOrigin = minimock.CallerInfo(1)
	return mmFindOneByID.mock
}

// When sets expectation for the CategoryUsecase.FindOneByID which will trigger the result defined by the following
// Then helper
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) When(ctx context.Context, id uint64, queryParams *uctypes.QueryGetOneParams) *CategoryUsecaseMockFindOneByIDExpectation {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("CategoryUsecaseMock.FindOneByID mock is already set by Set")
	}

	expectation := &CategoryUsecaseMockFindOneByIDExpectation{
		mock:               mmFindOneByID.mock,
		params:             &CategoryUsecaseMockFindOneByIDParams{ctx, id, queryParams},
		expectationOrigins: CategoryUsecaseMockFindOneByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindOneByID.expectations = append(mmFindOneByID.expectations, expectation)
	return expectation
}

// Then sets up CategoryUsecase.FindOneByID return parameters for the expectation previously defined by the When method
func (e *CategoryUsecaseMockFindOneByIDExpectation) Then(resItem *mm_usecase.CategoryDTO, err error) *CategoryUsecaseMock {
	e.results = &CategoryUsecaseMockFindOneByIDResults{resItem, err}
	return e.mock
}

// Times sets number of times CategoryUsecase.FindOneByID should be invoked
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) Times(n uint64) *mCategoryUsecaseMockFindOneByID {
	if n == 0 {
		mmFindOneByID.mock.t.Fatalf("Times of CategoryUsecaseMock.FindOneByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindOneByID.expectedInvocations, n)
	mmFindOneByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindOneByID
}

func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) invocationsDone() bool {
	if len(mmFindOneByID.expectations) == 0 && mmFindOneByID.defaultExpectation == nil && mmFindOneByID.mock.funcFindOneByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindOneByID.mock.afterFindOneByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindOneByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindOneByID implements mm_usecase.CategoryUsecase
func (mmFindOneByID *CategoryUsecaseMock) FindOneByID(ctx context.Context, id uint64, queryParams *uctypes.QueryGetOneParams) (resItem *mm_usecase.CategoryDTO, err error) {
	mm_atomic.AddUint64(&mmFindOneByID.beforeFindOneByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmFindOneByID.afterFindOneByIDCounter, 1)

	mmFindOneByID.t.Helper()

	if mmFindOneByID.inspectFuncFindOneByID != nil {
		mmFindOneByID.inspectFuncFindOneByID(ctx, id, queryParams)
	}

	mm_params := CategoryUsecaseMockFindOneByIDParams{ctx, id, queryParams}

	// Record call args
	mmFindOneByID.FindOneByIDMock.mutex.Lock()
	mmFindOneByID.FindOneByIDMock.callArgs = append(mmFindOneByID.FindOneByIDMock.callArgs, &mm_params)
	mmFindOneByID.FindOneByIDMock.mutex.Unlock()

	for _, e := range mmFindOneByID.FindOneByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resItem, e.results.err
		}
	}

	if mmFindOneByID.FindOneByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindOneByID.FindOneByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmFindOneByID.FindOneByIDMock.defaultExpectation.params
		mm_want_ptrs := mmFindOneByID.FindOneByIDMock.defaultExpectation.paramPtrs

		mm_got := CategoryUsecaseMockFindOneByIDParams{ctx, id, queryParams}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindOneByID.t.Errorf("CategoryUsecaseMock.FindOneByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmFindOneByID.t.Errorf("CategoryUsecaseMock.FindOneByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.queryParams != nil && !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) {
				mmFindOneByID.t.Errorf("CategoryUsecaseMock.FindOneByID got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindOneByID.t.Errorf("CategoryUsecaseMock.FindOneByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindOneByID.FindOneByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmFindOneByID.t.Fatal("No results are set for the CategoryUsecaseMock.FindOneByID")
		}
		return (*mm_results).resItem, (*mm_results).err
	}
	if mmFindOneByID.funcFindOneByID != nil {
		return mmFindOneByID.funcFindOneByID(ctx, id, queryParams)
	}
	mmFindOneByID.t.Fatalf("Unexpected call to CategoryUsecaseMock.FindOneByID. %v %v %v", ctx, id, queryParams)
	return
}

// FindOneByIDAfterCounter returns a count of finished CategoryUsecaseMock.FindOneByID invocations
func (mmFindOneByID *CategoryUsecaseMock) FindOneByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindOneByID.afterFindOneByIDCounter)
}

// FindOneByIDBeforeCounter returns a count of CategoryUsecaseMock.FindOneByID invocations
func (mmFindOneByID *CategoryUsecaseMock) FindOneByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindOneByID.beforeFindOneByIDCounter)
}

// Calls returns a list of arguments used in each call to CategoryUsecaseMock.FindOneByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) Calls() []*CategoryUsecaseMockFindOneByIDParams {
	mmFindOneByID.mutex.RLock()

	argCopy := make([]*CategoryUsecaseMockFindOneByIDParams, len(mmFindOneByID.callArgs))
	copy(argCopy, mmFindOneByID.callArgs)

	mmFindOneByID.mutex.RUnlock()

	return argCopy
}

// MinimockFindOneByIDDone returns true if the count of the FindOneByID invocations corresponds
// the number of defined expectations
func (m *CategoryUsecaseMock) MinimockFindOneByIDDone() bool {
	if m.FindOneByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindOneByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindOneByIDMock.invocationsDone()
}

// MinimockFindOneByIDInspect logs each unmet expectation
func (m *CategoryUsecaseMock) MinimockFindOneByIDInspect() {
	for _, e := range m.FindOneByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CategoryUsecaseMock.FindOneByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindOneByIDCounter := mm_atomic.LoadUint64(&m.afterFindOneByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindOneByIDMock.defaultExpectation != nil && afterFindOneByIDCounter < 1 {
		if m.FindOneByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CategoryUsecaseMock.FindOneByID at\n%s", m.FindOneByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CategoryUsecaseMock.FindOneByID at\n%s with params: %#v", m.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *m.FindOneByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindOneByID != nil && afterFindOneByIDCounter < 1 {
		m.t.Errorf("Expected call to CategoryUsecaseMock.FindOneByID at\n%s", m.funcFindOneByIDOrigin)
	}

	if !m.FindOneByIDMock.invocationsDone() && afterFindOneByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to CategoryUsecaseMock.FindOneByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindOneByIDMock.expectedInvocations), m.FindOneByIDMock.expectedInvocationsOrigin, afterFindOneByIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CategoryUsecaseMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockFindListInspect()

			m.MinimockFindOneByIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CategoryUsecaseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CategoryUsecaseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockFindListDone() &&
		m.MinimockFindOneByIDDone()
}
