// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase.BudgetUsecase -o budget_usecase.go -n BudgetUsecaseMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
	"github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
	mm_usecase "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
)

// BudgetUsecaseMock implements mm_usecase.BudgetUsecase
type BudgetUsecaseMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateBudgetByDTO          func(ctx context.Context, in mm_usecase.CreateBudgetDataInput) (resBudgetDTO *mm_usecase.BudgetDTO, err error)
	funcCreateBudgetByDTOOrigin    string
	inspectFuncCreateBudgetByDTO   func(ctx context.Context, in mm_usecase.CreateBudgetDataInput)
	afterCreateBudgetByDTOCounter  uint64
	beforeCreateBudgetByDTOCounter uint64
	CreateBudgetByDTOMock          mBudgetUsecaseMockCreateBudgetByDTO

	funcDeleteBudgetByID          func(ctx context.Context, id uuid.UUID) (err error)
	funcDeleteBudgetByIDOrigin    string
	inspectFuncDeleteBudgetByID   func(ctx context.Context, id uuid.UUID)
	afterDeleteBudgetByIDCounter  uint64
	beforeDeleteBudgetByIDCounter uint64
	DeleteBudgetByIDMock          mBudgetUsecaseMockDeleteBudgetByID

	funcFindList          func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.BudgetDTO, cacheHit bool, err error)
	funcFindListOrigin    string
	inspectFuncFindList   func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams)
	afterFindListCounter  uint64
	beforeFindListCounter uint64
	FindListMock          mBudgetUsecaseMockFindList

	funcFindOneByID          func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (resItem *mm_usecase.BudgetDTO, cacheHit bool, err error)
	funcFindOneByIDOrigin    string
	inspectFuncFindOneByID   func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)
	afterFindOneByIDCounter  uint64
	beforeFindOneByIDCounter uint64
	FindOneByIDMock          mBudgetUsecaseMockFindOneByID

	funcFindPagedList          func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.BudgetDTO, total uint64, cacheHit bool, err error)
	funcFindPagedListOrigin    string
	inspectFuncFindPagedList   func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams)
	afterFindPagedListCounter  uint64
	beforeFindPagedListCounter uint64
	FindPagedListMock          mBudgetUsecaseMockFindPagedList

	funcPatchBudgetByDTO          func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchBudgetDataInput, skipVersionCheck bool) (err error)
	funcPatchBudgetByDTOOrigin    string
	inspectFuncPatchBudgetByDTO   func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchBudgetDataInput, skipVersionCheck bool)
	afterPatchBudgetByDTOCounter  uint64
	beforePatchBudgetByDTOCounter uint64
	PatchBudgetByDTOMock          mBudgetUsecaseMockPatchBudgetByDTO
}

// NewBudgetUsecaseMock returns a mock for mm_usecase.BudgetUsecase
func NewBudgetUsecaseMock(t minimock.Tester) *BudgetUsecaseMock {
	m := &BudgetUsecaseMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateBudgetByDTOMock = mBudgetUsecaseMockCreateBudgetByDTO{mock: m}
	m.CreateBudgetByDTOMock.callArgs = []*BudgetUsecaseMockCreateBudgetByDTOParams{}

	m.DeleteBudgetByIDMock = mBudgetUsecaseMockDeleteBudgetByID{mock: m}
	m.DeleteBudgetByIDMock.callArgs = []*BudgetUsecaseMockDeleteBudgetByIDParams{}

	m.FindListMock = mBudgetUsecaseMockFindList{mock: m}
	m.FindListMock.callArgs = []*BudgetUsecaseMockFindListParams{}

	m.FindOneByIDMock = mBudgetUsecaseMockFindOneByID{mock: m}
	m.FindOneByIDMock.callArgs = []*BudgetUsecaseMockFindOneByIDParams{}

	m.FindPagedListMock = mBudgetUsecaseMockFindPagedList{mock: m}
	m.FindPagedListMock.callArgs = []*BudgetUsecaseMockFindPagedListParams{}

	m.PatchBudgetByDTOMock = mBudgetUsecaseMockPatchBudgetByDTO{mock: m}
	m.PatchBudgetByDTOMock.callArgs = []*BudgetUsecaseMockPatchBudgetByDTOParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mBudgetUsecaseMockCreateBudgetByDTO struct {
	optional           bool
	mock               *BudgetUsecaseMock
	defaultExpectation *BudgetUsecaseMockCreateBudgetByDTOExpectation
	expectations       []*BudgetUsecaseMockCreateBudgetByDTOExpectation

	callArgs []*BudgetUsecaseMockCreateBudgetByDTOParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BudgetUsecaseMockCreateBudgetByDTOExpectation specifies expectation struct of the BudgetUsecase.CreateBudgetByDTO
type BudgetUsecaseMockCreateBudgetByDTOExpectation struct {
	mock               *BudgetUsecaseMock
	params             *BudgetUsecaseMockCreateBudgetByDTOParams
	paramPtrs          *BudgetUsecaseMockCreateBudgetByDTOParamPtrs
	expectationOrigins BudgetUsecaseMockCreateBudgetByDTOExpectationOrigins
	results            *BudgetUsecaseMockCreateBudgetByDTOResults
	returnOrigin       string
	Counter            uint64
}

// BudgetUsecaseMockCreateBudgetByDTOParams contains parameters of the BudgetUsecase.CreateBudgetByDTO
type BudgetUsecaseMockCreateBudgetByDTOParams struct {
	ctx context.Context
	in  mm_usecase.CreateBudgetDataInput
}

// BudgetUsecaseMockCreateBudgetByDTOParamPtrs contains pointers to parameters of the BudgetUsecase.CreateBudgetByDTO
type BudgetUsecaseMockCreateBudgetByDTOParamPtrs struct {
	ctx *context.Context
	in  *mm_usecase.CreateBudgetDataInput
}

// BudgetUsecaseMockCreateBudgetByDTOResults contains results of the BudgetUsecase.CreateBudgetByDTO
type BudgetUsecaseMockCreateBudgetByDTOResults struct {
	resBudgetDTO *mm_usecase.BudgetDTO
	err          error
}

// BudgetUsecaseMockCreateBudgetByDTOOrigins contains origins of expectations of the BudgetUsecase.CreateBudgetByDTO
type BudgetUsecaseMockCreateBudgetByDTOExpectationOrigins struct {
	origin    string
	originCtx string
	originIn  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) Optional() *mBudgetUsecaseMockCreateBudgetByDTO {
	mmCreateBudgetByDTO.optional = true
	return mmCreateBudgetByDTO
}

// Expect sets up expected params for BudgetUsecase.CreateBudgetByDTO
func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) Expect(ctx context.Context, in mm_usecase.CreateBudgetDataInput) *mBudgetUsecaseMockCreateBudgetByDTO {
	if mmCreateBudgetByDTO.mock.funcCreateBudgetByDTO != nil {
		mmCreateBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.CreateBudgetByDTO mock is already set by Set")
	}

	if mmCreateBudgetByDTO.defaultExpectation == nil {
		mmCreateBudgetByDTO.defaultExpectation = &BudgetUsecaseMockCreateBudgetByDTOExpectation{}
	}

	if mmCreateBudgetByDTO.defaultExpectation.paramPtrs != nil {
		mmCreateBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.CreateBudgetByDTO mock is already set by ExpectParams functions")
	}

	mmCreateBudgetByDTO.defaultExpectation.params = &BudgetUsecaseMockCreateBudgetByDTOParams{ctx, in}
	mmCreateBudgetByDTO.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateBudgetByDTO.expectations {
		if minimock.Equal(e.params, mmCreateBudgetByDTO.defaultExpectation.params) {
			mmCreateBudgetByDTO.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateBudgetByDTO.defaultExpectation.params)
		}
	}

	return mmCreateBudgetByDTO
}

// ExpectCtxParam1 sets up expected param ctx for BudgetUsecase.CreateBudgetByDTO
func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) ExpectCtxParam1(ctx context.Context) *mBudgetUsecaseMockCreateBudgetByDTO {
	if mmCreateBudgetByDTO.mock.funcCreateBudgetByDTO != nil {
		mmCreateBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.CreateBudgetByDTO mock is already set by Set")
	}

	if mmCreateBudgetByDTO.defaultExpectation == nil {
		mmCreateBudgetByDTO.defaultExpectation = &BudgetUsecaseMockCreateBudgetByDTOExpectation{}
	}

	if mmCreateBudgetByDTO.defaultExpectation.params != nil {
		mmCreateBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.CreateBudgetByDTO mock is already set by Expect")
	}

	if mmCreateBudgetByDTO.defaultExpectation.paramPtrs == nil {
		mmCreateBudgetByDTO.defaultExpectation.paramPtrs = &BudgetUsecaseMockCreateBudgetByDTOParamPtrs{}
	}
	mmCreateBudgetByDTO.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateBudgetByDTO.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateBudgetByDTO
}

// ExpectInParam2 sets up expected param in for BudgetUsecase.CreateBudgetByDTO
func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) ExpectInParam2(in mm_usecase.CreateBudgetDataInput) *mBudgetUsecaseMockCreateBudgetByDTO {
	if mmCreateBudgetByDTO.mock.funcCreateBudgetByDTO != nil {
		mmCreateBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.CreateBudgetByDTO mock is already set by Set")
	}

	if mmCreateBudgetByDTO.defaultExpectation == nil {
		mmCreateBudgetByDTO.defaultExpectation = &BudgetUsecaseMockCreateBudgetByDTOExpectation{}
	}

	if mmCreateBudgetByDTO.defaultExpectation.params != nil {
		mmCreateBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.CreateBudgetByDTO mock is already set by Expect")
	}

	if mmCreateBudgetByDTO.defaultExpectation.paramPtrs == nil {
		mmCreateBudgetByDTO.defaultExpectation.paramPtrs = &BudgetUsecaseMockCreateBudgetByDTOParamPtrs{}
	}
	mmCreateBudgetByDTO.defaultExpectation.paramPtrs.in = &in
	mmCreateBudgetByDTO.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmCreateBudgetByDTO
}

// Inspect accepts an inspector function that has same arguments as the BudgetUsecase.CreateBudgetByDTO
func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) Inspect(f func(ctx context.Context, in mm_usecase.CreateBudgetDataInput)) *mBudgetUsecaseMockCreateBudgetByDTO {
	if mmCreateBudgetByDTO.mock.inspectFuncCreateBudgetByDTO != nil {
		mmCreateBudgetByDTO.mock.t.Fatalf("Inspect function is already set for BudgetUsecaseMock.CreateBudgetByDTO")
	}

	mmCreateBudgetByDTO.mock.inspectFuncCreateBudgetByDTO = f

	return mmCreateBudgetByDTO
}

// Return sets up results that will be returned by BudgetUsecase.CreateBudgetByDTO
func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) Return(resBudgetDTO *mm_usecase.BudgetDTO, err error) *BudgetUsecaseMock {
	if mmCreateBudgetByDTO.mock.funcCreateBudgetByDTO != nil {
		mmCreateBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.CreateBudgetByDTO mock is already set by Set")
	}

	if mmCreateBudgetByDTO.defaultExpectation == nil {
		mmCreateBudgetByDTO.defaultExpectation = &BudgetUsecaseMockCreateBudgetByDTOExpectation{mock: mmCreateBudgetByDTO.mock}
	}
	mmCreateBudgetByDTO.defaultExpectation.results = &BudgetUsecaseMockCreateBudgetByDTOResults{resBudgetDTO, err}
	mmCreateBudgetByDTO.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateBudgetByDTO.mock
}

// Set uses given function f to mock the BudgetUsecase.CreateBudgetByDTO method
func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) Set(f func(ctx context.Context, in mm_usecase.CreateBudgetDataInput) (resBudgetDTO *mm_usecase.BudgetDTO, err error)) *BudgetUsecaseMock {
	if mmCreateBudgetByDTO.defaultExpectation != nil {
		mmCreateBudgetByDTO.mock.t.Fatalf("Default expectation is already set for the BudgetUsecase.CreateBudgetByDTO method")
	}

	if len(mmCreateBudgetByDTO.expectations) > 0 {
		mmCreateBudgetByDTO.mock.t.Fatalf("Some expectations are already set for the BudgetUsecase.CreateBudgetByDTO method")
	}

	mmCreateBudgetByDTO.mock.funcCreateBudgetByDTO = f
	mmCreateBudgetByDTO.mock.funcCreateBudgetByDTOOrigin = minimock.CallerInfo(1)
	return mmCreateBudgetByDTO.mock
}

// When sets expectation for the BudgetUsecase.CreateBudgetByDTO which will trigger the result defined by the following
// Then helper
func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) When(ctx context.Context, in mm_usecase.CreateBudgetDataInput) *BudgetUsecaseMockCreateBudgetByDTOExpectation {
	if mmCreateBudgetByDTO.mock.funcCreateBudgetByDTO != nil {
		mmCreateBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.CreateBudgetByDTO mock is already set by Set")
	}

	expectation := &BudgetUsecaseMockCreateBudgetByDTOExpectation{
		mock:               mmCreateBudgetByDTO.mock,
		params:             &BudgetUsecaseMockCreateBudgetByDTOParams{ctx, in},
		expectationOrigins: BudgetUsecaseMockCreateBudgetByDTOExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateBudgetByDTO.expectations = append(mmCreateBudgetByDTO.expectations, expectation)
	return expectation
}

// Then sets up BudgetUsecase.CreateBudgetByDTO return parameters for the expectation previously defined by the When method
func (e *BudgetUsecaseMockCreateBudgetByDTOExpectation) Then(resBudgetDTO *mm_usecase.BudgetDTO, err error) *BudgetUsecaseMock {
	e.results = &BudgetUsecaseMockCreateBudgetByDTOResults{resBudgetDTO, err}
	return e.mock
}

// Times sets number of times BudgetUsecase.CreateBudgetByDTO should be invoked
func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) Times(n uint64) *mBudgetUsecaseMockCreateBudgetByDTO {
	if n == 0 {
		mmCreateBudgetByDTO.mock.t.Fatalf("Times of BudgetUsecaseMock.CreateBudgetByDTO mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateBudgetByDTO.expectedInvocations, n)
	mmCreateBudgetByDTO.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateBudgetByDTO
}

func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) invocationsDone() bool {
	if len(mmCreateBudgetByDTO.expectations) == 0 && mmCreateBudgetByDTO.defaultExpectation == nil && mmCreateBudgetByDTO.mock.funcCreateBudgetByDTO == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateBudgetByDTO.mock.afterCreateBudgetByDTOCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateBudgetByDTO.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateBudgetByDTO implements mm_usecase.BudgetUsecase
func (mmCreateBudgetByDTO *BudgetUsecaseMock) CreateBudgetByDTO(ctx context.Context, in mm_usecase.CreateBudgetDataInput) (resBudgetDTO *mm_usecase.BudgetDTO, err error) {
	mm_atomic.AddUint64(&mmCreateBudgetByDTO.beforeCreateBudgetByDTOCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateBudgetByDTO.afterCreateBudgetByDTOCounter, 1)

	mmCreateBudgetByDTO.t.Helper()

	if mmCreateBudgetByDTO.inspectFuncCreateBudgetByDTO != nil {
		mmCreateBudgetByDTO.inspectFuncCreateBudgetByDTO(ctx, in)
	}

	mm_params := BudgetUsecaseMockCreateBudgetByDTOParams{ctx, in}

	// Record call args
	mmCreateBudgetByDTO.CreateBudgetByDTOMock.mutex.Lock()
	mmCreateBudgetByDTO.CreateBudgetByDTOMock.callArgs = append(mmCreateBudgetByDTO.CreateBudgetByDTOMock.callArgs, &mm_params)
	mmCreateBudgetByDTO.CreateBudgetByDTOMock.mutex.Unlock()

	for _, e := range mmCreateBudgetByDTO.CreateBudgetByDTOMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resBudgetDTO, e.results.err
		}
	}

	if mmCreateBudgetByDTO.CreateBudgetByDTOMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateBudgetByDTO.CreateBudgetByDTOMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateBudgetByDTO.CreateBudgetByDTOMock.defaultExpectation.params
		mm_want_ptrs := mmCreateBudgetByDTO.CreateBudgetByDTOMock.defaultExpectation.paramPtrs

		mm_got := BudgetUsecaseMockCreateBudgetByDTOParams{ctx, in}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateBudgetByDTO.t.Errorf("BudgetUsecaseMock.CreateBudgetByDTO got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateBudgetByDTO.CreateBudgetByDTOMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmCreateBudgetByDTO.t.Errorf("BudgetUsecaseMock.CreateBudgetByDTO got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateBudgetByDTO.CreateBudgetByDTOMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateBudgetByDTO.t.Errorf("BudgetUsecaseMock.CreateBudgetByDTO got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateBudgetByDTO.CreateBudgetByDTOMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateBudgetByDTO.CreateBudgetByDTOMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateBudgetByDTO.t.Fatal("No results are set for the BudgetUsecaseMock.CreateBudgetByDTO")
		}
		return (*mm_results).resBudgetDTO, (*mm_results).err
	}
	if mmCreateBudgetByDTO.funcCreateBudgetByDTO != nil {
		return mmCreateBudgetByDTO.funcCreateBudgetByDTO(ctx, in)
	}
	mmCreateBudgetByDTO.t.Fatalf("Unexpected call to BudgetUsecaseMock.CreateBudgetByDTO. %v %v", ctx, in)
	return
}

// CreateBudgetByDTOAfterCounter returns a count of finished BudgetUsecaseMock.CreateBudgetByDTO invocations
func (mmCreateBudgetByDTO *BudgetUsecaseMock) CreateBudgetByDTOAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateBudgetByDTO.afterCreateBudgetByDTOCounter)
}

// CreateBudgetByDTOBeforeCounter returns a count of BudgetUsecaseMock.CreateBudgetByDTO invocations
func (mmCreateBudgetByDTO *BudgetUsecaseMock) CreateBudgetByDTOBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateBudgetByDTO.beforeCreateBudgetByDTOCounter)
}

// Calls returns a list of arguments used in each call to BudgetUsecaseMock.CreateBudgetByDTO.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) Calls() []*BudgetUsecaseMockCreateBudgetByDTOParams {
	mmCreateBudgetByDTO.mutex.RLock()

	argCopy := make([]*BudgetUsecaseMockCreateBudgetByDTOParams, len(mmCreateBudgetByDTO.callArgs))
	copy(argCopy, mmCreateBudgetByDTO.callArgs)

	mmCreateBudgetByDTO.mutex.RUnlock()

	return argCopy
}

// MinimockCreateBudgetByDTODone returns true if the count of the CreateBudgetByDTO invocations corresponds
// the number of defined expectations
func (m *BudgetUsecaseMock) MinimockCreateBudgetByDTODone() bool {
	if m.CreateBudgetByDTOMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateBudgetByDTOMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateBudgetByDTOMock.invocationsDone()
}

// MinimockCreateBudgetByDTOInspect logs each unmet expectation
func (m *BudgetUsecaseMock) MinimockCreateBudgetByDTOInspect() {
	for _, e := range m.CreateBudgetByDTOMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BudgetUsecaseMock.CreateBudgetByDTO at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateBudgetByDTOCounter := mm_atomic.LoadUint64(&m.afterCreateBudgetByDTOCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateBudgetByDTOMock.defaultExpectation != nil && afterCreateBudgetByDTOCounter < 1 {
		if m.CreateBudgetByDTOMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BudgetUsecaseMock.CreateBudgetByDTO at\n%s", m.CreateBudgetByDTOMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BudgetUsecaseMock.CreateBudgetByDTO at\n%s with params: %#v", m.CreateBudgetByDTOMock.defaultExpectation.expectationOrigins.origin, *m.CreateBudgetByDTOMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateBudgetByDTO != nil && afterCreateBudgetByDTOCounter < 1 {
		m.t.Errorf("Expected call to BudgetUsecaseMock.CreateBudgetByDTO at\n%s", m.funcCreateBudgetByDTOOrigin)
	}

	if !m.CreateBudgetByDTOMock.invocationsDone() && afterCreateBudgetByDTOCounter > 0 {
		m.t.Errorf("Expected %d calls to BudgetUsecaseMock.CreateBudgetByDTO at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateBudgetByDTOMock.expectedInvocations), m.CreateBudgetByDTOMock.expectedInvocationsOrigin, afterCreateBudgetByDTOCounter)
	}
}

type mBudgetUsecaseMockDeleteBudgetByID struct {
	optional           bool
	mock               *BudgetUsecaseMock
	defaultExpectation *BudgetUsecaseMockDeleteBudgetByIDExpectation
	expectations       []*BudgetUsecaseMockDeleteBudgetByIDExpectation

	callArgs []*BudgetUsecaseMockDeleteBudgetByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BudgetUsecaseMockDeleteBudgetByIDExpectation specifies expectation struct of the BudgetUsecase.DeleteBudgetByID
type BudgetUsecaseMockDeleteBudgetByIDExpectation struct {
	mock               *BudgetUsecaseMock
	params             *BudgetUsecaseMockDeleteBudgetByIDParams
	paramPtrs          *BudgetUsecaseMockDeleteBudgetByIDParamPtrs
	expectationOrigins BudgetUsecaseMockDeleteBudgetByIDExpectationOrigins
	results            *BudgetUsecaseMockDeleteBudgetByIDResults
	returnOrigin       string
	Counter            uint64
}

// BudgetUsecaseMockDeleteBudgetByIDParams contains parameters of the BudgetUsecase.DeleteBudgetByID
type BudgetUsecaseMockDeleteBudgetByIDParams struct {
	ctx context.Context
	id  uuid.UUID
}

// BudgetUsecaseMockDeleteBudgetByIDParamPtrs contains pointers to parameters of the BudgetUsecase.DeleteBudgetByID
type BudgetUsecaseMockDeleteBudgetByIDParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// BudgetUsecaseMockDeleteBudgetByIDResults contains results of the BudgetUsecase.DeleteBudgetByID
type BudgetUsecaseMockDeleteBudgetByIDResults struct {
	err error
}

// BudgetUsecaseMockDeleteBudgetByIDOrigins contains origins of expectations of the BudgetUsecase.DeleteBudgetByID
type BudgetUsecaseMockDeleteBudgetByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) Optional() *mBudgetUsecaseMockDeleteBudgetByID {
	mmDeleteBudgetByID.optional = true
	return mmDeleteBudgetByID
}

// Expect sets up expected params for BudgetUsecase.DeleteBudgetByID
func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) Expect(ctx context.Context, id uuid.UUID) *mBudgetUsecaseMockDeleteBudgetByID {
	if mmDeleteBudgetByID.mock.funcDeleteBudgetByID != nil {
		mmDeleteBudgetByID.mock.t.Fatalf("BudgetUsecaseMock.DeleteBudgetByID mock is already set by Set")
	}

	if mmDeleteBudgetByID.defaultExpectation == nil {
		mmDeleteBudgetByID.defaultExpectation = &BudgetUsecaseMockDeleteBudgetByIDExpectation{}
	}

	if mmDeleteBudgetByID.defaultExpectation.paramPtrs != nil {
		mmDeleteBudgetByID.mock.t.Fatalf("BudgetUsecaseMock.DeleteBudgetByID mock is already set by ExpectParams functions")
	}

	mmDeleteBudgetByID.defaultExpectation.params = &BudgetUsecaseMockDeleteBudgetByIDParams{ctx, id}
	mmDeleteBudgetByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteBudgetByID.expectations {
		if minimock.Equal(e.params, mmDeleteBudgetByID.defaultExpectation.params) {
			mmDeleteBudgetByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteBudgetByID.defaultExpectation.params)
		}
	}

	return mmDeleteBudgetByID
}

// ExpectCtxParam1 sets up expected param ctx for BudgetUsecase.DeleteBudgetByID
func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) ExpectCtxParam1(ctx context.Context) *mBudgetUsecaseMockDeleteBudgetByID {
	if mmDeleteBudgetByID.mock.funcDeleteBudgetByID != nil {
		mmDeleteBudgetByID.mock.t.Fatalf("BudgetUsecaseMock.DeleteBudgetByID mock is already set by Set")
	}

	if mmDeleteBudgetByID.defaultExpectation == nil {
		mmDeleteBudgetByID.defaultExpectation = &BudgetUsecaseMockDeleteBudgetByIDExpectation{}
	}

	if mmDeleteBudgetByID.defaultExpectation.params != nil {
		mmDeleteBudgetByID.mock.t.Fatalf("BudgetUsecaseMock.DeleteBudgetByID mock is already set by Expect")
	}

	if mmDeleteBudgetByID.defaultExpectation.paramPtrs == nil {
		mmDeleteBudgetByID.defaultExpectation.paramPtrs = &BudgetUsecaseMockDeleteBudgetByIDParamPtrs{}
	}
	mmDeleteBudgetByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteBudgetByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteBudgetByID
}

// ExpectIdParam2 sets up expected param id for BudgetUsecase.DeleteBudgetByID
func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) ExpectIdParam2(id uuid.UUID) *mBudgetUsecaseMockDeleteBudgetByID {
	if mmDeleteBudgetByID.mock.funcDeleteBudgetByID != nil {
		mmDeleteBudgetByID.mock.t.Fatalf("BudgetUsecaseMock.DeleteBudgetByID mock is already set by Set")
	}

	if mmDeleteBudgetByID.defaultExpectation == nil {
		mmDeleteBudgetByID.defaultExpectation = &BudgetUsecaseMockDeleteBudgetByIDExpectation{}
	}

	if mmDeleteBudgetByID.defaultExpectation.params != nil {
		mmDeleteBudgetByID.mock.t.Fatalf("BudgetUsecaseMock.DeleteBudgetByID mock is already set by Expect")
	}

	if mmDeleteBudgetByID.defaultExpectation.paramPtrs == nil {
		mmDeleteBudgetByID.defaultExpectation.paramPtrs = &BudgetUsecaseMockDeleteBudgetByIDParamPtrs{}
	}
	mmDeleteBudgetByID.defaultExpectation.paramPtrs.id = &id
	mmDeleteBudgetByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteBudgetByID
}

// Inspect accepts an inspector function that has same arguments as the BudgetUsecase.DeleteBudgetByID
func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) Inspect(f func(ctx context.Context, id uuid.UUID)) *mBudgetUsecaseMockDeleteBudgetByID {
	if mmDeleteBudgetByID.mock.inspectFuncDeleteBudgetByID != nil {
		mmDeleteBudgetByID.mock.t.Fatalf("Inspect function is already set for BudgetUsecaseMock.DeleteBudgetByID")
	}

	mmDeleteBudgetByID.mock.inspectFuncDeleteBudgetByID = f

	return mmDeleteBudgetByID
}

// Return sets up results that will be returned by BudgetUsecase.DeleteBudgetByID
func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) Return(err error) *BudgetUsecaseMock {
	if mmDeleteBudgetByID.mock.funcDeleteBudgetByID != nil {
		mmDeleteBudgetByID.mock.t.Fatalf("BudgetUsecaseMock.DeleteBudgetByID mock is already set by Set")
	}

	if mmDeleteBudgetByID.defaultExpectation == nil {
		mmDeleteBudgetByID.defaultExpectation = &BudgetUsecaseMockDeleteBudgetByIDExpectation{mock: mmDeleteBudgetByID.mock}
	}
	mmDeleteBudgetByID.defaultExpectation.results = &BudgetUsecaseMockDeleteBudgetByIDResults{err}
	mmDeleteBudgetByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteBudgetByID.mock
}

// Set uses given function f to mock the BudgetUsecase.DeleteBudgetByID method
func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *BudgetUsecaseMock {
	if mmDeleteBudgetByID.defaultExpectation != nil {
		mmDeleteBudgetByID.mock.t.Fatalf("Default expectation is already set for the BudgetUsecase.DeleteBudgetByID method")
	}

	if len(mmDeleteBudgetByID.expectations) > 0 {
		mmDeleteBudgetByID.mock.t.Fatalf("Some expectations are already set for the BudgetUsecase.DeleteBudgetByID method")
	}

	mmDeleteBudgetByID.mock.funcDeleteBudgetByID = f
	mmDeleteBudgetByID.mock.funcDeleteBudgetByIDOrigin = minimock.CallerInfo(1)
	return mmDeleteBudgetByID.mock
}

// When sets expectation for the BudgetUsecase.DeleteBudgetByID which will trigger the result defined by the following
// Then helper
func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) When(ctx context.Context, id uuid.UUID) *BudgetUsecaseMockDeleteBudgetByIDExpectation {
	if mmDeleteBudgetByID.mock.funcDeleteBudgetByID != nil {
		mmDeleteBudgetByID.mock.t.Fatalf("BudgetUsecaseMock.DeleteBudgetByID mock is already set by Set")
	}

	expectation := &BudgetUsecaseMockDeleteBudgetByIDExpectation{
		mock:               mmDeleteBudgetByID.mock,
		params:             &BudgetUsecaseMockDeleteBudgetByIDParams{ctx, id},
		expectationOrigins: BudgetUsecaseMockDeleteBudgetByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteBudgetByID.expectations = append(mmDeleteBudgetByID.expectations, expectation)
	return expectation
}

// Then sets up BudgetUsecase.DeleteBudgetByID return parameters for the expectation previously defined by the When method
func (e *BudgetUsecaseMockDeleteBudgetByIDExpectation) Then(err error) *BudgetUsecaseMock {
	e.results = &BudgetUsecaseMockDeleteBudgetByIDResults{err}
	return e.mock
}

// Times sets number of times BudgetUsecase.DeleteBudgetByID should be invoked
func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) Times(n uint64) *mBudgetUsecaseMockDeleteBudgetByID {
	if n == 0 {
		mmDeleteBudgetByID.mock.t.Fatalf("Times of BudgetUsecaseMock.DeleteBudgetByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteBudgetByID.expectedInvocations, n)
	mmDeleteBudgetByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteBudgetByID
}

func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) invocationsDone() bool {
	if len(mmDeleteBudgetByID.expectations) == 0 && mmDeleteBudgetByID.defaultExpectation == nil && mmDeleteBudgetByID.mock.funcDeleteBudgetByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteBudgetByID.mock.afterDeleteBudgetByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteBudgetByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteBudgetByID implements mm_usecase.BudgetUsecase
func (mmDeleteBudgetByID *BudgetUsecaseMock) DeleteBudgetByID(ctx context.Context, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteBudgetByID.beforeDeleteBudgetByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteBudgetByID.afterDeleteBudgetByIDCounter, 1)

	mmDeleteBudgetByID.t.Helper()

	if mmDeleteBudgetByID.inspectFuncDeleteBudgetByID != nil {
		mmDeleteBudgetByID.inspectFuncDeleteBudgetByID(ctx, id)
	}

	mm_params := BudgetUsecaseMockDeleteBudgetByIDParams{ctx, id}

	// Record call args
	mmDeleteBudgetByID.DeleteBudgetByIDMock.mutex.Lock()
	mmDeleteBudgetByID.DeleteBudgetByIDMock.callArgs = append(mmDeleteBudgetByID.DeleteBudgetByIDMock.callArgs, &mm_params)
	mmDeleteBudgetByID.DeleteBudgetByIDMock.mutex.Unlock()

	for _, e := range mmDeleteBudgetByID.DeleteBudgetByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteBudgetByID.DeleteBudgetByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteBudgetByID.DeleteBudgetByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteBudgetByID.DeleteBudgetByIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteBudgetByID.DeleteBudgetByIDMock.defaultExpectation.paramPtrs

		mm_got := BudgetUsecaseMockDeleteBudgetByIDParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteBudgetByID.t.Errorf("BudgetUsecaseMock.DeleteBudgetByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteBudgetByID.DeleteBudgetByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteBudgetByID.t.Errorf("BudgetUsecaseMock.DeleteBudgetByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteBudgetByID.DeleteBudgetByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteBudgetByID.t.Errorf("BudgetUsecaseMock.DeleteBudgetByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteBudgetByID.DeleteBudgetByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteBudgetByID.DeleteBudgetByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteBudgetByID.t.Fatal("No results are set for the BudgetUsecaseMock.DeleteBudgetByID")
		}
		return (*mm_results).err
	}
	if mmDeleteBudgetByID.funcDeleteBudgetByID != nil {
		return mmDeleteBudgetByID.funcDeleteBudgetByID(ctx, id)
	}
	mmDeleteBudgetByID.t.Fatalf("Unexpected call to BudgetUsecaseMock.DeleteBudgetByID. %v %v", ctx, id)
	return
}

// DeleteBudgetByIDAfterCounter returns a count of finished BudgetUsecaseMock.DeleteBudgetByID invocations
func (mmDeleteBudgetByID *BudgetUsecaseMock) DeleteBudgetByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteBudgetByID.afterDeleteBudgetByIDCounter)
}

// DeleteBudgetByIDBeforeCounter returns a count of BudgetUsecaseMock.DeleteBudgetByID invocations
func (mmDeleteBudgetByID *BudgetUsecaseMock) DeleteBudgetByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteBudgetByID.beforeDeleteBudgetByIDCounter)
}

// Calls returns a list of arguments used in each call to BudgetUsecaseMock.DeleteBudgetByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) Calls() []*BudgetUsecaseMockDeleteBudgetByIDParams {
	mmDeleteBudgetByID.mutex.RLock()

	argCopy := make([]*BudgetUsecaseMockDeleteBudgetByIDParams, len(mmDeleteBudgetByID.callArgs))
	copy(argCopy, mmDeleteBudgetByID.callArgs)

	mmDeleteBudgetByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteBudgetByIDDone returns true if the count of the DeleteBudgetByID invocations corresponds
// the number of defined expectations
func (m *BudgetUsecaseMock) MinimockDeleteBudgetByIDDone() bool {
	if m.DeleteBudgetByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteBudgetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteBudgetByIDMock.invocationsDone()
}

// MinimockDeleteBudgetByIDInspect logs each unmet expectation
func (m *BudgetUsecaseMock) MinimockDeleteBudgetByIDInspect() {
	for _, e := range m.DeleteBudgetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BudgetUsecaseMock.DeleteBudgetByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteBudgetByIDCounter := mm_atomic.LoadUint64(&m.afterDeleteBudgetByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteBudgetByIDMock.defaultExpectation != nil && afterDeleteBudgetByIDCounter < 1 {
		if m.DeleteBudgetByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BudgetUsecaseMock.DeleteBudgetByID at\n%s", m.DeleteBudgetByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BudgetUsecaseMock.DeleteBudgetByID at\n%s with params: %#v", m.DeleteBudgetByIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteBudgetByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteBudgetByID != nil && afterDeleteBudgetByIDCounter < 1 {
		m.t.Errorf("Expected call to BudgetUsecaseMock.DeleteBudgetByID at\n%s", m.funcDeleteBudgetByIDOrigin)
	}

	if !m.DeleteBudgetByIDMock.invocationsDone() && afterDeleteBudgetByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to BudgetUsecaseMock.DeleteBudgetByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteBudgetByIDMock.expectedInvocations), m.DeleteBudgetByIDMock.expectedInvocationsOrigin, afterDeleteBudgetByIDCounter)
	}
}

type mBudgetUsecaseMockFindList struct {
	optional           bool
	mock               *BudgetUsecaseMock
	defaultExpectation *BudgetUsecaseMockFindListExpectation
	expectations       []*BudgetUsecaseMockFindListExpectation

	callArgs []*BudgetUsecaseMockFindListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BudgetUsecaseMockFindListExpectation specifies expectation struct of the BudgetUsecase.FindList
type BudgetUsecaseMockFindListExpectation struct {
	mock               *BudgetUsecaseMock
	params             *BudgetUsecaseMockFindListParams
	paramPtrs          *BudgetUsecaseMockFindListParamPtrs
	expectationOrigins BudgetUsecaseMockFindListExpectationOrigins
	results            *BudgetUsecaseMockFindListResults
	returnOrigin       string
	Counter            uint64
}

// BudgetUsecaseMockFindListParams contains parameters of the BudgetUsecase.FindList
type BudgetUsecaseMockFindListParams struct {
	ctx         context.Context
	listOptions *mm_usecase.BudgetListOptions
	queryParams *uctypes.QueryGetListParams
}

// BudgetUsecaseMockFindListParamPtrs contains pointers to parameters of the BudgetUsecase.FindList
type BudgetUsecaseMockFindListParamPtrs struct {
	ctx         *context.Context
	listOptions **mm_usecase.BudgetListOptions
	queryParams **uctypes.QueryGetListParams
}

// BudgetUsecaseMockFindListResults contains results of the BudgetUsecase.FindList
type BudgetUsecaseMockFindListResults struct {
	resItems []*mm_usecase.BudgetDTO
	cacheHit bool
	err      error
}

// BudgetUsecaseMockFindListOrigins contains origins of expectations of the BudgetUsecase.FindList
type BudgetUsecaseMockFindListExpectationOrigins struct {
	origin            string
	originCtx         string
	originListOptions string
	originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindList *mBudgetUsecaseMockFindList) Optional() *mBudgetUsecaseMockFindList {
	mmFindList.optional = true
	return mmFindList
}

// Expect sets up expected params for BudgetUsecase.FindList
func (mmFindList *mBudgetUsecaseMockFindList) Expect(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) *mBudgetUsecaseMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("BudgetUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &BudgetUsecaseMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.paramPtrs != nil {
		mmFindList.mock.t.Fatalf("BudgetUsecaseMock.FindList mock is already set by ExpectParams functions")
	}

	mmFindList.defaultExpectation.params = &BudgetUsecaseMockFindListParams{ctx, listOptions, queryParams}
	mmFindList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindList.expectations {
		if minimock.Equal(e.params, mmFindList.defaultExpectation.params) {
			mmFindList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindList.defaultExpectation.params)
		}
	}

	return mmFindList
}

// ExpectCtxParam1 sets up expected param ctx for BudgetUsecase.FindList
func (mmFindList *mBudgetUsecaseMockFindList) ExpectCtxParam1(ctx context.Context) *mBudgetUsecaseMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("BudgetUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &BudgetUsecaseMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.params != nil {
		mmFindList.mock.t.Fatalf("BudgetUsecaseMock.FindList mock is already set by Expect")
	}

	if mmFindList.defaultExpectation.paramPtrs == nil {
		mmFindList.defaultExpectation.paramPtrs = &BudgetUsecaseMockFindListParamPtrs{}
	}
	mmFindList.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindList
}

// ExpectListOptionsParam2 sets up expected param listOptions for BudgetUsecase.FindList
func (mmFindList *mBudgetUsecaseMockFindList) ExpectListOptionsParam2(listOptions *mm_usecase.BudgetListOptions) *mBudgetUsecaseMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("BudgetUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &BudgetUsecaseMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.params != nil {
		mmFindList.mock.t.Fatalf("BudgetUsecaseMock.FindList mock is already set by Expect")
	}

	if mmFindList.defaultExpectation.paramPtrs == nil {
		mmFindList.defaultExpectation.paramPtrs = &BudgetUsecaseMockFindListParamPtrs{}
	}
	mmFindList.defaultExpectation.paramPtrs.listOptions = &listOptions
	mmFindList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

	return mmFindList
}

// ExpectQueryParamsParam3 sets up expected param queryParams for BudgetUsecase.FindList
func (mmFindList *mBudgetUsecaseMockFindList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mBudgetUsecaseMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("BudgetUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &BudgetUsecaseMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.params != nil {
		mmFindList.mock.t.Fatalf("BudgetUsecaseMock.FindList mock is already set by Expect")
	}

	if mmFindList.defaultExpectation.paramPtrs == nil {
		mmFindList.defaultExpectation.paramPtrs = &BudgetUsecaseMockFindListParamPtrs{}
	}
	mmFindList.defaultExpectation.paramPtrs.queryParams = &queryParams
	mmFindList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

	return mmFindList
}

// Inspect accepts an inspector function that has same arguments as the BudgetUsecase.FindList
func (mmFindList *mBudgetUsecaseMockFindList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams)) *mBudgetUsecaseMockFindList {
	if mmFindList.mock.inspectFuncFindList != nil {
		mmFindList.mock.t.Fatalf("Inspect function is already set for BudgetUsecaseMock.FindList")
	}

	mmFindList.mock.inspectFuncFindList = f

	return mmFindList
}

// Return sets up results that will be returned by BudgetUsecase.FindList
func (mmFindList *mBudgetUsecaseMockFindList) Return(resItems []*mm_usecase.BudgetDTO, cacheHit bool, err error) *BudgetUsecaseMock {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("BudgetUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &BudgetUsecaseMockFindListExpectation{mock: mmFindList.mock}
	}
	mmFindList.defaultExpectation.results = &BudgetUsecaseMockFindListResults{resItems, cacheHit, err}
	mmFindList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindList.mock
}

// Set uses given function f to mock the BudgetUsecase.FindList method
func (mmFindList *mBudgetUsecaseMockFindList) Set(f func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.BudgetDTO, cacheHit bool, err error)) *BudgetUsecaseMock {
	if mmFindList.defaultExpectation != nil {
		mmFindList.mock.t.Fatalf("Default expectation is already set for the BudgetUsecase.FindList method")
	}

	if len(mmFindList.expectations) > 0 {
		mmFindList.mock.t.Fatalf("Some expectations are already set for the BudgetUsecase.FindList method")
	}

	mmFindList.mock.funcFindList = f
	mmFindList.mock.funcFindListOrigin = minimock.CallerInfo(1)
	return mmFindList.mock
}

// When sets expectation for the BudgetUsecase.FindList which will trigger the result defined by the following
// Then helper
func (mmFindList *mBudgetUsecaseMockFindList) When(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) *BudgetUsecaseMockFindListExpectation {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("BudgetUsecaseMock.FindList mock is already set by Set")
	}

	expectation := &BudgetUsecaseMockFindListExpectation{
		mock:               mmFindList.mock,
		params:             &BudgetUsecaseMockFindListParams{ctx, listOptions, queryParams},
		expectationOrigins: BudgetUsecaseMockFindListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindList.expectations = append(mmFindList.expectations, expectation)
	return expectation
}

// Then sets up BudgetUsecase.FindList return parameters for the expectation previously defined by the When method
func (e *BudgetUsecaseMockFindListExpectation) Then(resItems []*mm_usecase.BudgetDTO, cacheHit bool, err error) *BudgetUsecaseMock {
	e.results = &BudgetUsecaseMockFindListResults{resItems, cacheHit, err}
	return e.mock
}

// Times sets number of times BudgetUsecase.FindList should be invoked
func (mmFindList *mBudgetUsecaseMockFindList) Times(n uint64) *mBudgetUsecaseMockFindList {
	if n == 0 {
		mmFindList.mock.t.Fatalf("Times of BudgetUsecaseMock.FindList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindList.expectedInvocations, n)
	mmFindList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindList
}

func (mmFindList *mBudgetUsecaseMockFindList) invocationsDone() bool {
	if len(mmFindList.expectations) == 0 && mmFindList.defaultExpectation == nil && mmFindList.mock.funcFindList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindList.mock.afterFindListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindList implements mm_usecase.BudgetUsecase
func (mmFindList *BudgetUsecaseMock) FindList(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.BudgetDTO, cacheHit bool, err error) {
	mm_atomic.AddUint64(&mmFindList.beforeFindListCounter, 1)
	defer mm_atomic.AddUint64(&mmFindList.afterFindListCounter, 1)

	mmFindList.t.Helper()

	if mmFindList.inspectFuncFindList != nil {
		mmFindList.inspectFuncFindList(ctx, listOptions, queryParams)
	}

	mm_params := BudgetUsecaseMockFindListParams{ctx, listOptions, queryParams}

	// Record call args
	mmFindList.FindListMock.mutex.Lock()
	mmFindList.FindListMock.callArgs = append(mmFindList.FindListMock.callArgs, &mm_params)
	mmFindList.FindListMock.mutex.Unlock()

	for _, e := range mmFindList.FindListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resItems, e.results.cacheHit, e.results.err
		}
	}

	if mmFindList.FindListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindList.FindListMock.defaultExpectation.Counter, 1)
		mm_want := mmFindList.FindListMock.defaultExpectation.params
		mm_want_ptrs := mmFindList.FindListMock.defaultExpectation.paramPtrs

		mm_got := BudgetUsecaseMockFindListParams{ctx, listOptions, queryParams}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindList.t.Errorf("BudgetUsecaseMock.FindList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindList.FindListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.listOptions != nil && !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) {
				mmFindList.t.Errorf("BudgetUsecaseMock.FindList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindList.FindListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
			}

			if mm_want_ptrs.queryParams != nil && !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) {
				mmFindList.t.Errorf("BudgetUsecaseMock.FindList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindList.FindListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindList.t.Errorf("BudgetUsecaseMock.FindList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindList.FindListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindList.FindListMock.defaultExpectation.results
		if mm_results == nil {
			mmFindList.t.Fatal("No results are set for the BudgetUsecaseMock.FindList")
		}
		return (*mm_results).resItems, (*mm_results).cacheHit, (*mm_results).err
	}
	if mmFindList.funcFindList != nil {
		return mmFindList.funcFindList(ctx, listOptions, queryParams)
	}
	mmFindList.t.Fatalf("Unexpected call to BudgetUsecaseMock.FindList. %v %v %v", ctx, listOptions, queryParams)
	return
}

// FindListAfterCounter returns a count of finished BudgetUsecaseMock.FindList invocations
func (mmFindList *BudgetUsecaseMock) FindListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindList.afterFindListCounter)
}

// FindListBeforeCounter returns a count of BudgetUsecaseMock.FindList invocations
func (mmFindList *BudgetUsecaseMock) FindListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindList.beforeFindListCounter)
}

// Calls returns a list of arguments used in each call to BudgetUsecaseMock.FindList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindList *mBudgetUsecaseMockFindList) Calls() []*BudgetUsecaseMockFindListParams {
	mmFindList.mutex.RLock()

	argCopy := make([]*BudgetUsecaseMockFindListParams, len(mmFindList.callArgs))
	copy(argCopy, mmFindList.callArgs)

	mmFindList.mutex.RUnlock()

	return argCopy
}

// MinimockFindListDone returns true if the count of the FindList invocations corresponds
// the number of defined expectations
func (m *BudgetUsecaseMock) MinimockFindListDone() bool {
	if m.FindListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindListMock.invocationsDone()
}

// MinimockFindListInspect logs each unmet expectation
func (m *BudgetUsecaseMock) MinimockFindListInspect() {
	for _, e := range m.FindListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BudgetUsecaseMock.FindList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindListCounter := mm_atomic.LoadUint64(&m.afterFindListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindListMock.defaultExpectation != nil && afterFindListCounter < 1 {
		if m.FindListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BudgetUsecaseMock.FindList at\n%s", m.FindListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BudgetUsecaseMock.FindList at\n%s with params: %#v", m.FindListMock.defaultExpectation.expectationOrigins.origin, *m.FindListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindList != nil && afterFindListCounter < 1 {
		m.t.Errorf("Expected call to BudgetUsecaseMock.FindList at\n%s", m.funcFindListOrigin)
	}

	if !m.FindListMock.invocationsDone() && afterFindListCounter > 0 {
		m.t.Errorf("Expected %d calls to BudgetUsecaseMock.FindList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindListMock.expectedInvocations), m.FindListMock.expectedInvocationsOrigin, afterFindListCounter)
	}
}

type mBudgetUsecaseMockFindOneByID struct {
	optional           bool
	mock               *BudgetUsecaseMock
	defaultExpectation *BudgetUsecaseMockFindOneByIDExpectation
	expectations       []*BudgetUsecaseMockFindOneByIDExpectation

	callArgs []*BudgetUsecaseMockFindOneByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BudgetUsecaseMockFindOneByIDExpectation specifies expectation struct of the BudgetUsecase.FindOneByID
type BudgetUsecaseMockFindOneByIDExpectation struct {
	mock               *BudgetUsecaseMock
	params             *BudgetUsecaseMockFindOneByIDParams
	paramPtrs          *BudgetUsecaseMockFindOneByIDParamPtrs
	expectationOrigins BudgetUsecaseMockFindOneByIDExpectationOrigins
	results            *BudgetUsecaseMockFindOneByIDResults
	returnOrigin       string
	Counter            uint64
}

// BudgetUsecaseMockFindOneByIDParams contains parameters of the BudgetUsecase.FindOneByID
type BudgetUsecaseMockFindOneByIDParams struct {
	ctx         context.Context
	id          uuid.UUID
	queryParams *uctypes.QueryGetOneParams
}

// BudgetUsecaseMockFindOneByIDParamPtrs contains pointers to parameters of the BudgetUsecase.FindOneByID
type BudgetUsecaseMockFindOneByIDParamPtrs struct {
	ctx         *context.Context
	id          *uuid.UUID
	queryParams **uctypes.QueryGetOneParams
}

// BudgetUsecaseMockFindOneByIDResults contains results of the BudgetUsecase.FindOneByID
type BudgetUsecaseMockFindOneByIDResults struct {
	resItem  *mm_usecase.BudgetDTO
	cacheHit bool
	err      error
}

// BudgetUsecaseMockFindOneByIDOrigins contains origins of expectations of the BudgetUsecase.FindOneByID
type BudgetUsecaseMockFindOneByIDExpectationOrigins struct {
	origin            string
	originCtx         string
	originId          string
	originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) Optional() *mBudgetUsecaseMockFindOneByID {
	mmFindOneByID.optional = true
	return mmFindOneByID
}

// Expect sets up expected params for BudgetUsecase.FindOneByID
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) Expect(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *mBudgetUsecaseMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("BudgetUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &BudgetUsecaseMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.paramPtrs != nil {
		mmFindOneByID.mock.t.Fatalf("BudgetUsecaseMock.FindOneByID mock is already set by ExpectParams functions")
	}

	mmFindOneByID.defaultExpectation.params = &BudgetUsecaseMockFindOneByIDParams{ctx, id, queryParams}
	mmFindOneByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindOneByID.expectations {
		if minimock.Equal(e.params, mmFindOneByID.defaultExpectation.params) {
			mmFindOneByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindOneByID.defaultExpectation.params)
		}
	}

	return mmFindOneByID
}

// ExpectCtxParam1 sets up expected param ctx for BudgetUsecase.FindOneByID
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) ExpectCtxParam1(ctx context.Context) *mBudgetUsecaseMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("BudgetUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &BudgetUsecaseMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.params != nil {
		mmFindOneByID.mock.t.Fatalf("BudgetUsecaseMock.FindOneByID mock is already set by Expect")
	}

	if mmFindOneByID.defaultExpectation.paramPtrs == nil {
		mmFindOneByID.defaultExpectation.paramPtrs = &BudgetUsecaseMockFindOneByIDParamPtrs{}
	}
	mmFindOneByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindOneByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindOneByID
}

// ExpectIdParam2 sets up expected param id for BudgetUsecase.FindOneByID
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) ExpectIdParam2(id uuid.UUID) *mBudgetUsecaseMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("BudgetUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &BudgetUsecaseMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.params != nil {
		mmFindOneByID.mock.t.Fatalf("BudgetUsecaseMock.FindOneByID mock is already set by Expect")
	}

	if mmFindOneByID.defaultExpectation.paramPtrs == nil {
		mmFindOneByID.defaultExpectation.paramPtrs = &BudgetUsecaseMockFindOneByIDParamPtrs{}
	}
	mmFindOneByID.defaultExpectation.paramPtrs.id = &id
	mmFindOneByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmFindOneByID
}

// ExpectQueryParamsParam3 sets up expected param queryParams for BudgetUsecase.FindOneByID
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetOneParams) *mBudgetUsecaseMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("BudgetUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &BudgetUsecaseMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.params != nil {
		mmFindOneByID.mock.t.Fatalf("BudgetUsecaseMock.FindOneByID mock is already set by Expect")
	}

	if mmFindOneByID.defaultExpectation.paramPtrs == nil {
		mmFindOneByID.defaultExpectation.paramPtrs = &BudgetUsecaseMockFindOneByIDParamPtrs{}
	}
	mmFindOneByID.defaultExpectation.paramPtrs.queryParams = &queryParams
	mmFindOneByID.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

	return mmFindOneByID
}

// Inspect accepts an inspector function that has same arguments as the BudgetUsecase.FindOneByID
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) Inspect(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)) *mBudgetUsecaseMockFindOneByID {
	if mmFindOneByID.mock.inspectFuncFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("Inspect function is already set for BudgetUsecaseMock.FindOneByID")
	}

	mmFindOneByID.mock.inspectFuncFindOneByID = f

	return mmFindOneByID
}

// Return sets up results that will be returned by BudgetUsecase.FindOneByID
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) Return(resItem *mm_usecase.BudgetDTO, cacheHit bool, err error) *BudgetUsecaseMock {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("BudgetUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &BudgetUsecaseMockFindOneByIDExpectation{mock: mmFindOneByID.mock}
	}
	mmFindOneByID.defaultExpectation.results = &BudgetUsecaseMockFindOneByIDResults{resItem, cacheHit, err}
	mmFindOneByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindOneByID.mock
}

// Set uses given function f to mock the BudgetUsecase.FindOneByID method
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) Set(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (resItem *mm_usecase.BudgetDTO, cacheHit bool, err error)) *BudgetUsecaseMock {
	if mmFindOneByID.defaultExpectation != nil {
		mmFindOneByID.mock.t.Fatalf("Default expectation is already set for the BudgetUsecase.FindOneByID method")
	}

	if len(mmFindOneByID.expectations) > 0 {
		mmFindOneByID.mock.t.Fatalf("Some expectations are already set for the BudgetUsecase.FindOneByID method")
	}

	mmFindOneByID.mock.funcFindOneByID = f
	mmFindOneByID.mock.funcFindOneByIDOrigin = minimock.CallerInfo(1)
	return mmFindOneByID.mock
}

// When sets expectation for the BudgetUsecase.FindOneByID which will trigger the result defined by the following
// Then helper
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) When(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *BudgetUsecaseMockFindOneByIDExpectation {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("BudgetUsecaseMock.FindOneByID mock is already set by Set")
	}

	expectation := &BudgetUsecaseMockFindOneByIDExpectation{
		mock:               mmFindOneByID.mock,
		params:             &BudgetUsecaseMockFindOneByIDParams{ctx, id, queryParams},
		expectationOrigins: BudgetUsecaseMockFindOneByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindOneByID.expectations = append(mmFindOneByID.expectations, expectation)
	return expectation
}

// Then sets up BudgetUsecase.FindOneByID return parameters for the expectation previously defined by the When method
func (e *BudgetUsecaseMockFindOneByIDExpectation) Then(resItem *mm_usecase.BudgetDTO, cacheHit bool, err error) *BudgetUsecaseMock {
	e.results = &BudgetUsecaseMockFindOneByIDResults{resItem, cacheHit, err}
	return e.mock
}

// Times sets number of times BudgetUsecase.FindOneByID should be invoked
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) Times(n uint64) *mBudgetUsecaseMockFindOneByID {
	if n == 0 {
		mmFindOneByID.mock.t.Fatalf("Times of BudgetUsecaseMock.FindOneByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindOneByID.expectedInvocations, n)
	mmFindOneByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindOneByID
}

func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) invocationsDone() bool {
	if len(mmFindOneByID.expectations) == 0 && mmFindOneByID.defaultExpectation == nil && mmFindOneByID.mock.funcFindOneByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindOneByID.mock.afterFindOneByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindOneByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindOneByID implements mm_usecase.BudgetUsecase
func (mmFindOneByID *BudgetUsecaseMock) FindOneByID(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (resItem *mm_usecase.BudgetDTO, cacheHit bool, err error) {
	mm_atomic.AddUint64(&mmFindOneByID.beforeFindOneByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmFindOneByID.afterFindOneByIDCounter, 1)

	mmFindOneByID.t.Helper()

	if mmFindOneByID.inspectFuncFindOneByID != nil {
		mmFindOneByID.inspectFuncFindOneByID(ctx, id, queryParams)
	}

	mm_params := BudgetUsecaseMockFindOneByIDParams{ctx, id, queryParams}

	// Record call args
	mmFindOneByID.FindOneByIDMock.mutex.Lock()
	mmFindOneByID.FindOneByIDMock.callArgs = append(mmFindOneByID.FindOneByIDMock.callArgs, &mm_params)
	mmFindOneByID.FindOneByIDMock.mutex.Unlock()

	for _, e := range mmFindOneByID.FindOneByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resItem, e.results.cacheHit, e.results.err
		}
	}

	if mmFindOneByID.FindOneByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindOneByID.FindOneByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmFindOneByID.FindOneByIDMock.defaultExpectation.params
		mm_want_ptrs := mmFindOneByID.FindOneByIDMock.defaultExpectation.paramPtrs

		mm_got := BudgetUsecaseMockFindOneByIDParams{ctx, id, queryParams}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindOneByID.t.Errorf("BudgetUsecaseMock.FindOneByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmFindOneByID.t.Errorf("BudgetUsecaseMock.FindOneByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.queryParams != nil && !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) {
				mmFindOneByID.t.Errorf("BudgetUsecaseMock.FindOneByID got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindOneByID.t.Errorf("BudgetUsecaseMock.FindOneByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindOneByID.FindOneByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmFindOneByID.t.Fatal("No results are set for the BudgetUsecaseMock.FindOneByID")
		}
		return (*mm_results).resItem, (*mm_results).cacheHit, (*mm_results).err
	}
	if mmFindOneByID.funcFindOneByID != nil {
		return mmFindOneByID.funcFindOneByID(ctx, id, queryParams)
	}
	mmFindOneByID.t.Fatalf("Unexpected call to BudgetUsecaseMock.FindOneByID. %v %v %v", ctx, id, queryParams)
	return
}

// FindOneByIDAfterCounter returns a count of finished BudgetUsecaseMock.FindOneByID invocations
func (mmFindOneByID *BudgetUsecaseMock) FindOneByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindOneByID.afterFindOneByIDCounter)
}

// FindOneByIDBeforeCounter returns a count of BudgetUsecaseMock.FindOneByID invocations
func (mmFindOneByID *BudgetUsecaseMock) FindOneByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindOneByID.beforeFindOneByIDCounter)
}

// Calls returns a list of arguments used in each call to BudgetUsecaseMock.FindOneByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) Calls() []*BudgetUsecaseMockFindOneByIDParams {
	mmFindOneByID.mutex.RLock()

	argCopy := make([]*BudgetUsecaseMockFindOneByIDParams, len(mmFindOneByID.callArgs))
	copy(argCopy, mmFindOneByID.callArgs)

	mmFindOneByID.mutex.RUnlock()

	return argCopy
}

// MinimockFindOneByIDDone returns true if the count of the FindOneByID invocations corresponds
// the number of defined expectations
func (m *BudgetUsecaseMock) MinimockFindOneByIDDone() bool {
	if m.FindOneByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindOneByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindOneByIDMock.invocationsDone()
}

// MinimockFindOneByIDInspect logs each unmet expectation
func (m *BudgetUsecaseMock) MinimockFindOneByIDInspect() {
	for _, e := range m.FindOneByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BudgetUsecaseMock.FindOneByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindOneByIDCounter := mm_atomic.LoadUint64(&m.afterFindOneByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindOneByIDMock.defaultExpectation != nil && afterFindOneByIDCounter < 1 {
		if m.FindOneByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BudgetUsecaseMock.FindOneByID at\n%s", m.FindOneByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BudgetUsecaseMock.FindOneByID at\n%s with params: %#v", m.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *m.FindOneByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindOneByID != nil && afterFindOneByIDCounter < 1 {
		m.t.Errorf("Expected call to BudgetUsecaseMock.FindOneByID at\n%s", m.funcFindOneByIDOrigin)
	}

	if !m.FindOneByIDMock.invocationsDone() && afterFindOneByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to BudgetUsecaseMock.FindOneByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindOneByIDMock.expectedInvocations), m.FindOneByIDMock.expectedInvocationsOrigin, afterFindOneByIDCounter)
	}
}

type mBudgetUsecaseMockFindPagedList struct {
	optional           bool
	mock               *BudgetUsecaseMock
	defaultExpectation *BudgetUsecaseMockFindPagedListExpectation
	expectations       []*BudgetUsecaseMockFindPagedListExpectation

	callArgs []*BudgetUsecaseMockFindPagedListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BudgetUsecaseMockFindPagedListExpectation specifies expectation struct of the BudgetUsecase.FindPagedList
type BudgetUsecaseMockFindPagedListExpectation struct {
	mock               *BudgetUsecaseMock
	params             *BudgetUsecaseMockFindPagedListParams
	paramPtrs          *BudgetUsecaseMockFindPagedListParamPtrs
	expectationOrigins BudgetUsecaseMockFindPagedListExpectationOrigins
	results            *BudgetUsecaseMockFindPagedListResults
	returnOrigin       string
	Counter            uint64
}

// BudgetUsecaseMockFindPagedListParams contains parameters of the BudgetUsecase.FindPagedList
type BudgetUsecaseMockFindPagedListParams struct {
	ctx         context.Context
	listOptions *mm_usecase.BudgetListOptions
	queryParams *uctypes.QueryGetListParams
}

// BudgetUsecaseMockFindPagedListParamPtrs contains pointers to parameters of the BudgetUsecase.FindPagedList
type BudgetUsecaseMockFindPagedListParamPtrs struct {
	ctx         *context.Context
	listOptions **mm_usecase.BudgetListOptions
	queryParams **uctypes.QueryGetListParams
}

// BudgetUsecaseMockFindPagedListResults contains results of the BudgetUsecase.FindPagedList
type BudgetUsecaseMockFindPagedListResults struct {
	resItems []*mm_usecase.BudgetDTO
	total    uint64
	cacheHit bool
	err      error
}

// BudgetUsecaseMockFindPagedListOrigins contains origins of expectations of the BudgetUsecase.FindPagedList
type BudgetUsecaseMockFindPagedListExpectationOrigins struct {
	origin            string
	originCtx         string
	originListOptions string
	originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) Optional() *mBudgetUsecaseMockFindPagedList {
	mmFindPagedList.optional = true
	return mmFindPagedList
}

// Expect sets up expected params for BudgetUsecase.FindPagedList
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) Expect(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) *mBudgetUsecaseMockFindPagedList {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("BudgetUsecaseMock.FindPagedList mock is already set by Set")
	}

	if mmFindPagedList.defaultExpectation == nil {
		mmFindPagedList.defaultExpectation = &BudgetUsecaseMockFindPagedListExpectation{}
	}

	if mmFindPagedList.defaultExpectation.paramPtrs != nil {
		mmFindPagedList.mock.t.Fatalf("BudgetUsecaseMock.FindPagedList mock is already set by ExpectParams functions")
	}

	mmFindPagedList.defaultExpectation.params = &BudgetUsecaseMockFindPagedListParams{ctx, listOptions, queryParams}
	mmFindPagedList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindPagedList.expectations {
		if minimock.Equal(e.params, mmFindPagedList.defaultExpectation.params) {
			mmFindPagedList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindPagedList.defaultExpectation.params)
		}
	}

	return mmFindPagedList
}

// ExpectCtxParam1 sets up expected param ctx for BudgetUsecase.FindPagedList
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) ExpectCtxParam1(ctx context.Context) *mBudgetUsecaseMockFindPagedList {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("BudgetUsecaseMock.FindPagedList mock is already set by Set")
	}

	if mmFindPagedList.defaultExpectation == nil {
		mmFindPagedList.defaultExpectation = &BudgetUsecaseMockFindPagedListExpectation{}
	}

	if mmFindPagedList.defaultExpectation.params != nil {
		mmFindPagedList.mock.t.Fatalf("BudgetUsecaseMock.FindPagedList mock is already set by Expect")
	}

	if mmFindPagedList.defaultExpectation.paramPtrs == nil {
		mmFindPagedList.defaultExpectation.paramPtrs = &BudgetUsecaseMockFindPagedListParamPtrs{}
	}
	mmFindPagedList.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindPagedList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindPagedList
}

// ExpectListOptionsParam2 sets up expected param listOptions for BudgetUsecase.FindPagedList
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) ExpectListOptionsParam2(listOptions *mm_usecase.BudgetListOptions) *mBudgetUsecaseMockFindPagedList {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("BudgetUsecaseMock.FindPagedList mock is already set by Set")
	}

	if mmFindPagedList.defaultExpectation == nil {
		mmFindPagedList.defaultExpectation = &BudgetUsecaseMockFindPagedListExpectation{}
	}

	if mmFindPagedList.defaultExpectation.params != nil {
		mmFindPagedList.mock.t.Fatalf("BudgetUsecaseMock.FindPagedList mock is already set by Expect")
	}

	if mmFindPagedList.defaultExpectation.paramPtrs == nil {
		mmFindPagedList.defaultExpectation.paramPtrs = &BudgetUsecaseMockFindPagedListParamPtrs{}
	}
	mmFindPagedList.defaultExpectation.paramPtrs.listOptions = &listOptions
	mmFindPagedList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

	return mmFindPagedList
}

// ExpectQueryParamsParam3 sets up expected param queryParams for BudgetUsecase.FindPagedList
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mBudgetUsecaseMockFindPagedList {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("BudgetUsecaseMock.FindPagedList mock is already set by Set")
	}

	if mmFindPagedList.defaultExpectation == nil {
		mmFindPagedList.defaultExpectation = &BudgetUsecaseMockFindPagedListExpectation{}
	}

	if mmFindPagedList.defaultExpectation.params != nil {
		mmFindPagedList.mock.t.Fatalf("BudgetUsecaseMock.FindPagedList mock is already set by Expect")
	}

	if mmFindPagedList.defaultExpectation.paramPtrs == nil {
		mmFindPagedList.defaultExpectation.paramPtrs = &BudgetUsecaseMockFindPagedListParamPtrs{}
	}
	mmFindPagedList.defaultExpectation.paramPtrs.queryParams = &queryParams
	mmFindPagedList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

	return mmFindPagedList
}

// Inspect accepts an inspector function that has same arguments as the BudgetUsecase.FindPagedList
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams)) *mBudgetUsecaseMockFindPagedList {
	if mmFindPagedList.mock.inspectFuncFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("Inspect function is already set for BudgetUsecaseMock.FindPagedList")
	}

	mmFindPagedList.mock.inspectFuncFindPagedList = f

	return mmFindPagedList
}

// Return sets up results that will be returned by BudgetUsecase.FindPagedList
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) Return(resItems []*mm_usecase.BudgetDTO, total uint64, cacheHit bool, err error) *BudgetUsecaseMock {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("BudgetUsecaseMock.FindPagedList mock is already set by Set")
	}

	if mmFindPagedList.defaultExpectation == nil {
		mmFindPagedList.defaultExpectation = &BudgetUsecaseMockFindPagedListExpectation{mock: mmFindPagedList.mock}
	}
	mmFindPagedList.defaultExpectation.results = &BudgetUsecaseMockFindPagedListResults{resItems, total, cacheHit, err}
	mmFindPagedList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindPagedList.mock
}

// Set uses given function f to mock the BudgetUsecase.FindPagedList method
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) Set(f func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.BudgetDTO, total uint64, cacheHit bool, err error)) *BudgetUsecaseMock {
	if mmFindPagedList.defaultExpectation != nil {
		mmFindPagedList.mock.t.Fatalf("Default expectation is already set for the BudgetUsecase.FindPagedList method")
	}

	if len(mmFindPagedList.expectations) > 0 {
		mmFindPagedList.mock.t.Fatalf("Some expectations are already set for the BudgetUsecase.FindPagedList method")
	}

	mmFindPagedList.mock.funcFindPagedList = f
	mmFindPagedList.mock.funcFindPagedListOrigin = minimock.CallerInfo(1)
	return mmFindPagedList.mock
}

// When sets expectation for the BudgetUsecase.FindPagedList which will trigger the result defined by the following
// Then helper
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) When(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) *BudgetUsecaseMockFindPagedListExpectation {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("BudgetUsecaseMock.FindPagedList mock is already set by Set")
	}

	expectation := &BudgetUsecaseMockFindPagedListExpectation{
		mock:               mmFindPagedList.mock,
		params:             &BudgetUsecaseMockFindPagedListParams{ctx, listOptions, queryParams},
		expectationOrigins: BudgetUsecaseMockFindPagedListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindPagedList.expectations = append(mmFindPagedList.expectations, expectation)
	return expectation
}

// Then sets up BudgetUsecase.FindPagedList return parameters for the expectation previously defined by the When method
func (e *BudgetUsecaseMockFindPagedListExpectation) Then(resItems []*mm_usecase.BudgetDTO, total uint64, cacheHit bool, err error) *BudgetUsecaseMock {
	e.results = &BudgetUsecaseMockFindPagedListResults{resItems, total, cacheHit, err}
	return e.mock
}

// Times sets number of times BudgetUsecase.FindPagedList should be invoked
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) Times(n uint64) *mBudgetUsecaseMockFindPagedList {
	if n == 0 {
		mmFindPagedList.mock.t.Fatalf("Times of BudgetUsecaseMock.FindPagedList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindPagedList.expectedInvocations, n)
	mmFindPagedList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindPagedList
}

func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) invocationsDone() bool {
	if len(mmFindPagedList.expectations) == 0 && mmFindPagedList.defaultExpectation == nil && mmFindPagedList.mock.funcFindPagedList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindPagedList.mock.afterFindPagedListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindPagedList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindPagedList implements mm_usecase.BudgetUsecase
func (mmFindPagedList *BudgetUsecaseMock) FindPagedList(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.BudgetDTO, total uint64, cacheHit bool, err error) {
	mm_atomic.AddUint64(&mmFindPagedList.beforeFindPagedListCounter, 1)
	defer mm_atomic.AddUint64(&mmFindPagedList.afterFindPagedListCounter, 1)

	mmFindPagedList.t.Helper()

	if mmFindPagedList.inspectFuncFindPagedList != nil {
		mmFindPagedList.inspectFuncFindPagedList(ctx, listOptions, queryParams)
	}

	mm_params := BudgetUsecaseMockFindPagedListParams{ctx, listOptions, queryParams}

	// Record call args
	mmFindPagedList.FindPagedListMock.mutex.Lock()
	mmFindPagedList.FindPagedListMock.callArgs = append(mmFindPagedList.FindPagedListMock.callArgs, &mm_params)
	mmFindPagedList.FindPagedListMock.mutex.Unlock()

	for _, e := range mmFindPagedList.FindPagedListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resItems, e.results.total, e.results.cacheHit, e.results.err
		}
	}

	if mmFindPagedList.FindPagedListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindPagedList.FindPagedListMock.defaultExpectation.Counter, 1)
		mm_want := mmFindPagedList.FindPagedListMock.defaultExpectation.params
		mm_want_ptrs := mmFindPagedList.FindPagedListMock.defaultExpectation.paramPtrs

		mm_got := BudgetUsecaseMockFindPagedListParams{ctx, listOptions, queryParams}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindPagedList.t.Errorf("BudgetUsecaseMock.FindPagedList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.listOptions != nil && !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) {
				mmFindPagedList.t.Errorf("BudgetUsecaseMock.FindPagedList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
			}

			if mm_want_ptrs.queryParams != nil && !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) {
				mmFindPagedList.t.Errorf("BudgetUsecaseMock.FindPagedList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindPagedList.t.Errorf("BudgetUsecaseMock.FindPagedList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindPagedList.FindPagedListMock.defaultExpectation.results
		if mm_results == nil {
			mmFindPagedList.t.Fatal("No results are set for the BudgetUsecaseMock.FindPagedList")
		}
		return (*mm_results).resItems, (*mm_results).total, (*mm_results).cacheHit, (*mm_results).err
	}
	if mmFindPagedList.funcFindPagedList != nil {
		return mmFindPagedList.funcFindPagedList(ctx, listOptions, queryParams)
	}
	mmFindPagedList.t.Fatalf("Unexpected call to BudgetUsecaseMock.FindPagedList. %v %v %v", ctx, listOptions, queryParams)
	return
}

// FindPagedListAfterCounter returns a count of finished BudgetUsecaseMock.FindPagedList invocations
func (mmFindPagedList *BudgetUsecaseMock) FindPagedListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindPagedList.afterFindPagedListCounter)
}

// FindPagedListBeforeCounter returns a count of BudgetUsecaseMock.FindPagedList invocations
func (mmFindPagedList *BudgetUsecaseMock) FindPagedListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindPagedList.beforeFindPagedListCounter)
}

// Calls returns a list of arguments used in each call to BudgetUsecaseMock.FindPagedList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) Calls() []*BudgetUsecaseMockFindPagedListParams {
	mmFindPagedList.mutex.RLock()

	argCopy := make([]*BudgetUsecaseMockFindPagedListParams, len(mmFindPagedList.callArgs))
	copy(argCopy, mmFindPagedList.callArgs)

	mmFindPagedList.mutex.RUnlock()

	return argCopy
}

// MinimockFindPagedListDone returns true if the count of the FindPagedList invocations corresponds
// the number of defined expectations
func (m *BudgetUsecaseMock) MinimockFindPagedListDone() bool {
	if m.FindPagedListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindPagedListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindPagedListMock.invocationsDone()
}

// MinimockFindPagedListInspect logs each unmet expectation
func (m *BudgetUsecaseMock) MinimockFindPagedListInspect() {
	for _, e := range m.FindPagedListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BudgetUsecaseMock.FindPagedList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindPagedListCounter := mm_atomic.LoadUint64(&m.afterFindPagedListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindPagedListMock.defaultExpectation != nil && afterFindPagedListCounter < 1 {
		if m.FindPagedListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BudgetUsecaseMock.FindPagedList at\n%s", m.FindPagedListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BudgetUsecaseMock.FindPagedList at\n%s with params: %#v", m.FindPagedListMock.defaultExpectation.expectationOrigins.origin, *m.FindPagedListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindPagedList != nil && afterFindPagedListCounter < 1 {
		m.t.Errorf("Expected call to BudgetUsecaseMock.FindPagedList at\n%s", m.funcFindPagedListOrigin)
	}

	if !m.FindPagedListMock.invocationsDone() && afterFindPagedListCounter > 0 {
		m.t.Errorf("Expected %d calls to BudgetUsecaseMock.FindPagedList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindPagedListMock.expectedInvocations), m.FindPagedListMock.expectedInvocationsOrigin, afterFindPagedListCounter)
	}
}

type mBudgetUsecaseMockPatchBudgetByDTO struct {
	optional           bool
	mock               *BudgetUsecaseMock
	defaultExpectation *BudgetUsecaseMockPatchBudgetByDTOExpectation
	expectations       []*BudgetUsecaseMockPatchBudgetByDTOExpectation

	callArgs []*BudgetUsecaseMockPatchBudgetByDTOParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BudgetUsecaseMockPatchBudgetByDTOExpectation specifies expectation struct of the BudgetUsecase.PatchBudgetByDTO
type BudgetUsecaseMockPatchBudgetByDTOExpectation struct {
	mock               *BudgetUsecaseMock
	params             *BudgetUsecaseMockPatchBudgetByDTOParams
	paramPtrs          *BudgetUsecaseMockPatchBudgetByDTOParamPtrs
	expectationOrigins BudgetUsecaseMockPatchBudgetByDTOExpectationOrigins
	results            *BudgetUsecaseMockPatchBudgetByDTOResults
	returnOrigin       string
	Counter            uint64
}

// BudgetUsecaseMockPatchBudgetByDTOParams contains parameters of the BudgetUsecase.PatchBudgetByDTO
type BudgetUsecaseMockPatchBudgetByDTOParams struct {
	ctx              context.Context
	id               uuid.UUID
	in               mm_usecase.PatchBudgetDataInput
	skipVersionCheck bool
}

// BudgetUsecaseMockPatchBudgetByDTOParamPtrs contains pointers to parameters of the BudgetUsecase.PatchBudgetByDTO
type BudgetUsecaseMockPatchBudgetByDTOParamPtrs struct {
	ctx              *context.Context
	id               *uuid.UUID
	in               *mm_usecase.PatchBudgetDataInput
	skipVersionCheck *bool
}

// BudgetUsecaseMockPatchBudgetByDTOResults contains results of the BudgetUsecase.PatchBudgetByDTO
type BudgetUsecaseMockPatchBudgetByDTOResults struct {
	err error
}

// BudgetUsecaseMockPatchBudgetByDTOOrigins contains origins of expectations of the BudgetUsecase.PatchBudgetByDTO
type BudgetUsecaseMockPatchBudgetByDTOExpectationOrigins struct {
	origin                 string
	originCtx              string
	originId               string
	originIn               string
	originSkipVersionCheck string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) Optional() *mBudgetUsecaseMockPatchBudgetByDTO {
	mmPatchBudgetByDTO.optional = true
	return mmPatchBudgetByDTO
}

// Expect sets up expected params for BudgetUsecase.PatchBudgetByDTO
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) Expect(ctx context.Context, id uuid.UUID, in mm_usecase.PatchBudgetDataInput, skipVersionCheck bool) *mBudgetUsecaseMockPatchBudgetByDTO {
	if mmPatchBudgetByDTO.mock.funcPatchBudgetByDTO != nil {
		mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Set")
	}

	if mmPatchBudgetByDTO.defaultExpectation == nil {
		mmPatchBudgetByDTO.defaultExpectation = &BudgetUsecaseMockPatchBudgetByDTOExpectation{}
	}

	if mmPatchBudgetByDTO.defaultExpectation.paramPtrs != nil {
		mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by ExpectParams functions")
	}

	mmPatchBudgetByDTO.defaultExpectation.params = &BudgetUsecaseMockPatchBudgetByDTOParams{ctx, id, in, skipVersionCheck}
	mmPatchBudgetByDTO.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPatchBudgetByDTO.expectations {
		if minimock.Equal(e.params, mmPatchBudgetByDTO.defaultExpectation.params) {
			mmPatchBudgetByDTO.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPatchBudgetByDTO.defaultExpectation.params)
		}
	}

	return mmPatchBudgetByDTO
}

// ExpectCtxParam1 sets up expected param ctx for BudgetUsecase.PatchBudgetByDTO
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) ExpectCtxParam1(ctx context.Context) *mBudgetUsecaseMockPatchBudgetByDTO {
	if mmPatchBudgetByDTO.mock.funcPatchBudgetByDTO != nil {
		mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Set")
	}

	if mmPatchBudgetByDTO.defaultExpectation == nil {
		mmPatchBudgetByDTO.defaultExpectation = &BudgetUsecaseMockPatchBudgetByDTOExpectation{}
	}

	if mmPatchBudgetByDTO.defaultExpectation.params != nil {
		mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Expect")
	}

	if mmPatchBudgetByDTO.defaultExpectation.paramPtrs == nil {
		mmPatchBudgetByDTO.defaultExpectation.paramPtrs = &BudgetUsecaseMockPatchBudgetByDTOParamPtrs{}
	}
	mmPatchBudgetByDTO.defaultExpectation.paramPtrs.ctx = &ctx
	mmPatchBudgetByDTO.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPatchBudgetByDTO
}

// ExpectIdParam2 sets up expected param id for BudgetUsecase.PatchBudgetByDTO
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) ExpectIdParam2(id uuid.UUID) *mBudgetUsecaseMockPatchBudgetByDTO {
	if mmPatchBudgetByDTO.mock.funcPatchBudgetByDTO != nil {
		mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Set")
	}

	if mmPatchBudgetByDTO.defaultExpectation == nil {
		mmPatchBudgetByDTO.defaultExpectation = &BudgetUsecaseMockPatchBudgetByDTOExpectation{}
	}

	if mmPatchBudgetByDTO.defaultExpectation.params != nil {
		mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Expect")
	}

	if mmPatchBudgetByDTO.defaultExpectation.paramPtrs == nil {
		mmPatchBudgetByDTO.defaultExpectation.paramPtrs = &BudgetUsecaseMockPatchBudgetByDTOParamPtrs{}
	}
	mmPatchBudgetByDTO.defaultExpectation.paramPtrs.id = &id
	mmPatchBudgetByDTO.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmPatchBudgetByDTO
}

// ExpectInParam3 sets up expected param in for BudgetUsecase.PatchBudgetByDTO
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) ExpectInParam3(in mm_usecase.PatchBudgetDataInput) *mBudgetUsecaseMockPatchBudgetByDTO {
	if mmPatchBudgetByDTO.mock.funcPatchBudgetByDTO != nil {
		mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Set")
	}

	if mmPatchBudgetByDTO.defaultExpectation == nil {
		mmPatchBudgetByDTO.defaultExpectation = &BudgetUsecaseMockPatchBudgetByDTOExpectation{}
	}

	if mmPatchBudgetByDTO.defaultExpectation.params != nil {
		mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Expect")
	}

	if mmPatchBudgetByDTO.defaultExpectation.paramPtrs == nil {
		mmPatchBudgetByDTO.defaultExpectation.paramPtrs = &BudgetUsecaseMockPatchBudgetByDTOParamPtrs{}
	}
	mmPatchBudgetByDTO.defaultExpectation.paramPtrs.in = &in
	mmPatchBudgetByDTO.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmPatchBudgetByDTO
}

// ExpectSkipVersionCheckParam4 sets up expected param skipVersionCheck for BudgetUsecase.PatchBudgetByDTO
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) ExpectSkipVersionCheckParam4(skipVersionCheck bool) *mBudgetUsecaseMockPatchBudgetByDTO {
	if mmPatchBudgetByDTO.mock.funcPatchBudgetByDTO != nil {
		mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Set")
	}

	if mmPatchBudgetByDTO.defaultExpectation == nil {
		mmPatchBudgetByDTO.defaultExpectation = &BudgetUsecaseMockPatchBudgetByDTOExpectation{}
	}

	if mmPatchBudgetByDTO.defaultExpectation.params != nil {
		mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Expect")
	}

	if mmPatchBudgetByDTO.defaultExpectation.paramPtrs == nil {
		mmPatchBudgetByDTO.defaultExpectation.paramPtrs = &BudgetUsecaseMockPatchBudgetByDTOParamPtrs{}
	}
	mmPatchBudgetByDTO.defaultExpectation.paramPtrs.skipVersionCheck = &skipVersionCheck
	mmPatchBudgetByDTO.defaultExpectation.expectationOrigins.originSkipVersionCheck = minimock.CallerInfo(1)

	return mmPatchBudgetByDTO
}

// Inspect accepts an inspector function that has same arguments as the BudgetUsecase.PatchBudgetByDTO
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) Inspect(f func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchBudgetDataInput, skipVersionCheck bool)) *mBudgetUsecaseMockPatchBudgetByDTO {
	if mmPatchBudgetByDTO.mock.inspectFuncPatchBudgetByDTO != nil {
		mmPatchBudgetByDTO.mock.t.Fatalf("Inspect function is already set for BudgetUsecaseMock.PatchBudgetByDTO")
	}

	mmPatchBudgetByDTO.mock.inspectFuncPatchBudgetByDTO = f

	return mmPatchBudgetByDTO
}

// Return sets up results that will be returned by BudgetUsecase.PatchBudgetByDTO
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) Return(err error) *BudgetUsecaseMock {
	if mmPatchBudgetByDTO.mock.funcPatchBudgetByDTO != nil {
		mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Set")
	}

	if mmPatchBudgetByDTO.defaultExpectation == nil {
		mmPatchBudgetByDTO.defaultExpectation = &BudgetUsecaseMockPatchBudgetByDTOExpectation{mock: mmPatchBudgetByDTO.mock}
	}
	mmPatchBudgetByDTO.defaultExpectation.results = &BudgetUsecaseMockPatchBudgetByDTOResults{err}
	mmPatchBudgetByDTO.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPatchBudgetByDTO.mock
}

// Set uses given function f to mock the BudgetUsecase.PatchBudgetByDTO method
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) Set(f func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchBudgetDataInput, skipVersionCheck bool) (err error)) *BudgetUsecaseMock {
	if mmPatchBudgetByDTO.defaultExpectation != nil {
		mmPatchBudgetByDTO.mock.t.Fatalf("Default expectation is already set for the BudgetUsecase.PatchBudgetByDTO method")
	}

	if len(mmPatchBudgetByDTO.expectations) > 0 {
		mmPatchBudgetByDTO.mock.t.Fatalf("Some expectations are already set for the BudgetUsecase.PatchBudgetByDTO method")
	}

	mmPatchBudgetByDTO.mock.funcPatchBudgetByDTO = f
	mmPatchBudgetByDTO.mock.funcPatchBudgetByDTOOrigin = minimock.CallerInfo(1)
	return mmPatchBudgetByDTO.mock
}

// When sets expectation for the BudgetUsecase.PatchBudgetByDTO which will trigger the result defined by the following
// Then helper
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) When(ctx context.Context, id uuid.UUID, in mm_usecase.PatchBudgetDataInput, skipVersionCheck bool) *BudgetUsecaseMockPatchBudgetByDTOExpectation {
	if mmPatchBudgetByDTO.mock.funcPatchBudgetByDTO != nil {
		mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Set")
	}

	expectation := &BudgetUsecaseMockPatchBudgetByDTOExpectation{
		mock:               mmPatchBudgetByDTO.mock,
		params:             &BudgetUsecaseMockPatchBudgetByDTOParams{ctx, id, in, skipVersionCheck},
		expectationOrigins: BudgetUsecaseMockPatchBudgetByDTOExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPatchBudgetByDTO.expectations = append(mmPatchBudgetByDTO.expectations, expectation)
	return expectation
}

// Then sets up BudgetUsecase.PatchBudgetByDTO return parameters for the expectation previously defined by the When method
func (e *BudgetUsecaseMockPatchBudgetByDTOExpectation) Then(err error) *BudgetUsecaseMock {
	e.results = &BudgetUsecaseMockPatchBudgetByDTOResults{err}
	return e.mock
}

// Times sets number of times BudgetUsecase.PatchBudgetByDTO should be invoked
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) Times(n uint64) *mBudgetUsecaseMockPatchBudgetByDTO {
	if n == 0 {
		mmPatchBudgetByDTO.mock.t.Fatalf("Times of BudgetUsecaseMock.PatchBudgetByDTO mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPatchBudgetByDTO.expectedInvocations, n)
	mmPatchBudgetByDTO.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPatchBudgetByDTO
}

func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) invocationsDone() bool {
	if len(mmPatchBudgetByDTO.expectations) == 0 && mmPatchBudgetByDTO.defaultExpectation == nil && mmPatchBudgetByDTO.mock.funcPatchBudgetByDTO == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPatchBudgetByDTO.mock.afterPatchBudgetByDTOCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPatchBudgetByDTO.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PatchBudgetByDTO implements mm_usecase.BudgetUsecase
func (mmPatchBudgetByDTO *BudgetUsecaseMock) PatchBudgetByDTO(ctx context.Context, id uuid.UUID, in mm_usecase.PatchBudgetDataInput, skipVersionCheck bool) (err error) {
	mm_atomic.AddUint64(&mmPatchBudgetByDTO.beforePatchBudgetByDTOCounter, 1)
	defer mm_atomic.AddUint64(&mmPatchBudgetByDTO.afterPatchBudgetByDTOCounter, 1)

	mmPatchBudgetByDTO.t.Helper()

	if mmPatchBudgetByDTO.inspectFuncPatchBudgetByDTO != nil {
		mmPatchBudgetByDTO.inspectFuncPatchBudgetByDTO(ctx, id, in, skipVersionCheck)
	}

	mm_params := BudgetUsecaseMockPatchBudgetByDTOParams{ctx, id, in, skipVersionCheck}

	// Record call args
	mmPatchBudgetByDTO.PatchBudgetByDTOMock.mutex.Lock()
	mmPatchBudgetByDTO.PatchBudgetByDTOMock.callArgs = append(mmPatchBudgetByDTO.PatchBudgetByDTOMock.callArgs, &mm_params)
	mmPatchBudgetByDTO.PatchBudgetByDTOMock.mutex.Unlock()

	for _, e := range mmPatchBudgetByDTO.PatchBudgetByDTOMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPatchBudgetByDTO.PatchBudgetByDTOMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPatchBudgetByDTO.PatchBudgetByDTOMock.defaultExpectation.Counter, 1)
		mm_want := mmPatchBudgetByDTO.PatchBudgetByDTOMock.defaultExpectation.params
		mm_want_ptrs := mmPatchBudgetByDTO.PatchBudgetByDTOMock.defaultExpectation.paramPtrs

		mm_got := BudgetUsecaseMockPatchBudgetByDTOParams{ctx, id, in, skipVersionCheck}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPatchBudgetByDTO.t.Errorf("BudgetUsecaseMock.PatchBudgetByDTO got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatchBudgetByDTO.PatchBudgetByDTOMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmPatchBudgetByDTO.t.Errorf("BudgetUsecaseMock.PatchBudgetByDTO got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatchBudgetByDTO.PatchBudgetByDTOMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmPatchBudgetByDTO.t.Errorf("BudgetUsecaseMock.PatchBudgetByDTO got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatchBudgetByDTO.PatchBudgetByDTOMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.skipVersionCheck != nil && !minimock.Equal(*mm_want_ptrs.skipVersionCheck, mm_got.skipVersionCheck) {
				mmPatchBudgetByDTO.t.Errorf("BudgetUsecaseMock.PatchBudgetByDTO got unexpected parameter skipVersionCheck, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatchBudgetByDTO.PatchBudgetByDTOMock.defaultExpectation.expectationOrigins.originSkipVersionCheck, *mm_want_ptrs.skipVersionCheck, mm_got.skipVersionCheck, minimock.Diff(*mm_want_ptrs.skipVersionCheck, mm_got.skipVersionCheck))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPatchBudgetByDTO.t.Errorf("BudgetUsecaseMock.PatchBudgetByDTO got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPatchBudgetByDTO.PatchBudgetByDTOMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPatchBudgetByDTO.PatchBudgetByDTOMock.defaultExpectation.results
		if mm_results == nil {
			mmPatchBudgetByDTO.t.Fatal("No results are set for the BudgetUsecaseMock.PatchBudgetByDTO")
		}
		return (*mm_results).err
	}
	if mmPatchBudgetByDTO.funcPatchBudgetByDTO != nil {
		return mmPatchBudgetByDTO.funcPatchBudgetByDTO(ctx, id, in, skipVersionCheck)
	}
	mmPatchBudgetByDTO.t.Fatalf("Unexpected call to BudgetUsecaseMock.PatchBudgetByDTO. %v %v %v %v", ctx, id, in, skipVersionCheck)
	return
}

// PatchBudgetByDTOAfterCounter returns a count of finished BudgetUsecaseMock.PatchBudgetByDTO invocations
func (mmPatchBudgetByDTO *BudgetUsecaseMock) PatchBudgetByDTOAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPatchBudgetByDTO.afterPatchBudgetByDTOCounter)
}

// PatchBudgetByDTOBeforeCounter returns a count of BudgetUsecaseMock.PatchBudgetByDTO invocations
func (mmPatchBudgetByDTO *BudgetUsecaseMock) PatchBudgetByDTOBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPatchBudgetByDTO.beforePatchBudgetByDTOCounter)
}

// Calls returns a list of arguments used in each call to BudgetUsecaseMock.PatchBudgetByDTO.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) Calls() []*BudgetUsecaseMockPatchBudgetByDTOParams {
	mmPatchBudgetByDTO.mutex.RLock()

	argCopy := make([]*BudgetUsecaseMockPatchBudgetByDTOParams, len(mmPatchBudgetByDTO.callArgs))
	copy(argCopy, mmPatchBudgetByDTO.callArgs)

	mmPatchBudgetByDTO.mutex.RUnlock()

	return argCopy
}

// MinimockPatchBudgetByDTODone returns true if the count of the PatchBudgetByDTO invocations corresponds
// the number of defined expectations
func (m *BudgetUsecaseMock) MinimockPatchBudgetByDTODone() bool {
	if m.PatchBudgetByDTOMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PatchBudgetByDTOMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PatchBudgetByDTOMock.invocationsDone()
}

// MinimockPatchBudgetByDTOInspect logs each unmet expectation
func (m *BudgetUsecaseMock) MinimockPatchBudgetByDTOInspect() {
	for _, e := range m.PatchBudgetByDTOMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BudgetUsecaseMock.PatchBudgetByDTO at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPatchBudgetByDTOCounter := mm_atomic.LoadUint64(&m.afterPatchBudgetByDTOCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PatchBudgetByDTOMock.defaultExpectation != nil && afterPatchBudgetByDTOCounter < 1 {
		if m.PatchBudgetByDTOMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BudgetUsecaseMock.PatchBudgetByDTO at\n%s", m.PatchBudgetByDTOMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BudgetUsecaseMock.PatchBudgetByDTO at\n%s with params: %#v", m.PatchBudgetByDTOMock.defaultExpectation.expectationOrigins.origin, *m.PatchBudgetByDTOMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPatchBudgetByDTO != nil && afterPatchBudgetByDTOCounter < 1 {
		m.t.Errorf("Expected call to BudgetUsecaseMock.PatchBudgetByDTO at\n%s", m.funcPatchBudgetByDTOOrigin)
	}

	if !m.PatchBudgetByDTOMock.invocationsDone() && afterPatchBudgetByDTOCounter > 0 {
		m.t.Errorf("Expected %d calls to BudgetUsecaseMock.PatchBudgetByDTO at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PatchBudgetByDTOMock.expectedInvocations), m.PatchBudgetByDTOMock.expectedInvocationsOrigin, afterPatchBudgetByDTOCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *BudgetUsecaseMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateBudgetByDTOInspect()

			m.MinimockDeleteBudgetByIDInspect()

			m.MinimockFindListInspect()

			m.MinimockFindOneByIDInspect()

			m.MinimockFindPagedListInspect()

			m.MinimockPatchBudgetByDTOInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *BudgetUsecaseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *BudgetUsecaseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateBudgetByDTODone() &&
		m.MinimockDeleteBudgetByIDDone() &&
		m.MinimockFindListDone() &&
		m.MinimockFindOneByIDDone() &&
		m.MinimockFindPagedListDone() &&
		m.MinimockPatchBudgetByDTODone()
}
