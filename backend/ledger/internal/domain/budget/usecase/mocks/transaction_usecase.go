// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase.TransactionUsecase -o transaction_usecase.go -n TransactionUsecaseMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
	"github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
	"github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
	mm_usecase "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
)

// TransactionUsecaseMock implements mm_usecase.TransactionUsecase
type TransactionUsecaseMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCountReportItems          func(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter) (items []*entity.ReportItem, cacheHit bool, err error)
	funcCountReportItemsOrigin    string
	inspectFuncCountReportItems   func(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter)
	afterCountReportItemsCounter  uint64
	beforeCountReportItemsCounter uint64
	CountReportItemsMock          mTransactionUsecaseMockCountReportItems

	funcCreateTransactionByDTO          func(ctx context.Context, in mm_usecase.CreateTransactionDataInput, skipCacheClear bool) (resTransactionDTO *mm_usecase.TransactionDTO, err error)
	funcCreateTransactionByDTOOrigin    string
	inspectFuncCreateTransactionByDTO   func(ctx context.Context, in mm_usecase.CreateTransactionDataInput, skipCacheClear bool)
	afterCreateTransactionByDTOCounter  uint64
	beforeCreateTransactionByDTOCounter uint64
	CreateTransactionByDTOMock          mTransactionUsecaseMockCreateTransactionByDTO

	funcDeleteTransactionByID          func(ctx context.Context, id uuid.UUID) (err error)
	funcDeleteTransactionByIDOrigin    string
	inspectFuncDeleteTransactionByID   func(ctx context.Context, id uuid.UUID)
	afterDeleteTransactionByIDCounter  uint64
	beforeDeleteTransactionByIDCounter uint64
	DeleteTransactionByIDMock          mTransactionUsecaseMockDeleteTransactionByID

	funcFindList          func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.TransactionDTO, err error)
	funcFindListOrigin    string
	inspectFuncFindList   func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)
	afterFindListCounter  uint64
	beforeFindListCounter uint64
	FindListMock          mTransactionUsecaseMockFindList

	funcFindListInMap          func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (resItems map[uuid.UUID]*mm_usecase.TransactionDTO, err error)
	funcFindListInMapOrigin    string
	inspectFuncFindListInMap   func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)
	afterFindListInMapCounter  uint64
	beforeFindListInMapCounter uint64
	FindListInMapMock          mTransactionUsecaseMockFindListInMap

	funcFindOneByID          func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (resItem *mm_usecase.TransactionDTO, err error)
	funcFindOneByIDOrigin    string
	inspectFuncFindOneByID   func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)
	afterFindOneByIDCounter  uint64
	beforeFindOneByIDCounter uint64
	FindOneByIDMock          mTransactionUsecaseMockFindOneByID

	funcFindPagedList          func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.TransactionDTO, total uint64, err error)
	funcFindPagedListOrigin    string
	inspectFuncFindPagedList   func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)
	afterFindPagedListCounter  uint64
	beforeFindPagedListCounter uint64
	FindPagedListMock          mTransactionUsecaseMockFindPagedList

	funcFindPagedListAsCSV          func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (res []byte, total uint64, err error)
	funcFindPagedListAsCSVOrigin    string
	inspectFuncFindPagedListAsCSV   func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)
	afterFindPagedListAsCSVCounter  uint64
	beforeFindPagedListAsCSVCounter uint64
	FindPagedListAsCSVMock          mTransactionUsecaseMockFindPagedListAsCSV

	funcImportTransactionsFromCSV          func(ctx context.Context, data []byte, accountID uuid.UUID) (err error)
	funcImportTransactionsFromCSVOrigin    string
	inspectFuncImportTransactionsFromCSV   func(ctx context.Context, data []byte, accountID uuid.UUID)
	afterImportTransactionsFromCSVCounter  uint64
	beforeImportTransactionsFromCSVCounter uint64
	ImportTransactionsFromCSVMock          mTransactionUsecaseMockImportTransactionsFromCSV

	funcPatchTransactionByDTO          func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchTransactionDataInput, skipVersionCheck bool) (err error)
	funcPatchTransactionByDTOOrigin    string
	inspectFuncPatchTransactionByDTO   func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchTransactionDataInput, skipVersionCheck bool)
	afterPatchTransactionByDTOCounter  uint64
	beforePatchTransactionByDTOCounter uint64
	PatchTransactionByDTOMock          mTransactionUsecaseMockPatchTransactionByDTO
}

// NewTransactionUsecaseMock returns a mock for mm_usecase.TransactionUsecase
func NewTransactionUsecaseMock(t minimock.Tester) *TransactionUsecaseMock {
	m := &TransactionUsecaseMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CountReportItemsMock = mTransactionUsecaseMockCountReportItems{mock: m}
	m.CountReportItemsMock.callArgs = []*TransactionUsecaseMockCountReportItemsParams{}

	m.CreateTransactionByDTOMock = mTransactionUsecaseMockCreateTransactionByDTO{mock: m}
	m.CreateTransactionByDTOMock.callArgs = []*TransactionUsecaseMockCreateTransactionByDTOParams{}

	m.DeleteTransactionByIDMock = mTransactionUsecaseMockDeleteTransactionByID{mock: m}
	m.DeleteTransactionByIDMock.callArgs = []*TransactionUsecaseMockDeleteTransactionByIDParams{}

	m.FindListMock = mTransactionUsecaseMockFindList{mock: m}
	m.FindListMock.callArgs = []*TransactionUsecaseMockFindListParams{}

	m.FindListInMapMock = mTransactionUsecaseMockFindListInMap{mock: m}
	m.FindListInMapMock.callArgs = []*TransactionUsecaseMockFindListInMapParams{}

	m.FindOneByIDMock = mTransactionUsecaseMockFindOneByID{mock: m}
	m.FindOneByIDMock.callArgs = []*TransactionUsecaseMockFindOneByIDParams{}

	m.FindPagedListMock = mTransactionUsecaseMockFindPagedList{mock: m}
	m.FindPagedListMock.callArgs = []*TransactionUsecaseMockFindPagedListParams{}

	m.FindPagedListAsCSVMock = mTransactionUsecaseMockFindPagedListAsCSV{mock: m}
	m.FindPagedListAsCSVMock.callArgs = []*TransactionUsecaseMockFindPagedListAsCSVParams{}

	m.ImportTransactionsFromCSVMock = mTransactionUsecaseMockImportTransactionsFromCSV{mock: m}
	m.ImportTransactionsFromCSVMock.callArgs = []*TransactionUsecaseMockImportTransactionsFromCSVParams{}

	m.PatchTransactionByDTOMock = mTransactionUsecaseMockPatchTransactionByDTO{mock: m}
	m.PatchTransactionByDTOMock.callArgs = []*TransactionUsecaseMockPatchTransactionByDTOParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTransactionUsecaseMockCountReportItems struct {
	optional           bool
	mock               *TransactionUsecaseMock
	defaultExpectation *TransactionUsecaseMockCountReportItemsExpectation
	expectations       []*TransactionUsecaseMockCountReportItemsExpectation

	callArgs []*TransactionUsecaseMockCountReportItemsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionUsecaseMockCountReportItemsExpectation specifies expectation struct of the TransactionUsecase.CountReportItems
type TransactionUsecaseMockCountReportItemsExpectation struct {
	mock               *TransactionUsecaseMock
	params             *TransactionUsecaseMockCountReportItemsParams
	paramPtrs          *TransactionUsecaseMockCountReportItemsParamPtrs
	expectationOrigins TransactionUsecaseMockCountReportItemsExpectationOrigins
	results            *TransactionUsecaseMockCountReportItemsResults
	returnOrigin       string
	Counter            uint64
}

// TransactionUsecaseMockCountReportItemsParams contains parameters of the TransactionUsecase.CountReportItems
type TransactionUsecaseMockCountReportItemsParams struct {
	ctx         context.Context
	queryFilter mm_usecase.CountReportItemsQueryFilter
}

// TransactionUsecaseMockCountReportItemsParamPtrs contains pointers to parameters of the TransactionUsecase.CountReportItems
type TransactionUsecaseMockCountReportItemsParamPtrs struct {
	ctx         *context.Context
	queryFilter *mm_usecase.CountReportItemsQueryFilter
}

// TransactionUsecaseMockCountReportItemsResults contains results of the TransactionUsecase.CountReportItems
type TransactionUsecaseMockCountReportItemsResults struct {
	items    []*entity.ReportItem
	cacheHit bool
	err      error
}

// TransactionUsecaseMockCountReportItemsOrigins contains origins of expectations of the TransactionUsecase.CountReportItems
type TransactionUsecaseMockCountReportItemsExpectationOrigins struct {
	origin            string
	originCtx         string
	originQueryFilter string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) Optional() *mTransactionUsecaseMockCountReportItems {
	mmCountReportItems.optional = true
	return mmCountReportItems
}

// Expect sets up expected params for TransactionUsecase.CountReportItems
func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) Expect(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter) *mTransactionUsecaseMockCountReportItems {
	if mmCountReportItems.mock.funcCountReportItems != nil {
		mmCountReportItems.mock.t.Fatalf("TransactionUsecaseMock.CountReportItems mock is already set by Set")
	}

	if mmCountReportItems.defaultExpectation == nil {
		mmCountReportItems.defaultExpectation = &TransactionUsecaseMockCountReportItemsExpectation{}
	}

	if mmCountReportItems.defaultExpectation.paramPtrs != nil {
		mmCountReportItems.mock.t.Fatalf("TransactionUsecaseMock.CountReportItems mock is already set by ExpectParams functions")
	}

	mmCountReportItems.defaultExpectation.params = &TransactionUsecaseMockCountReportItemsParams{ctx, queryFilter}
	mmCountReportItems.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCountReportItems.expectations {
		if minimock.Equal(e.params, mmCountReportItems.defaultExpectation.params) {
			mmCountReportItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCountReportItems.defaultExpectation.params)
		}
	}

	return mmCountReportItems
}

// ExpectCtxParam1 sets up expected param ctx for TransactionUsecase.CountReportItems
func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) ExpectCtxParam1(ctx context.Context) *mTransactionUsecaseMockCountReportItems {
	if mmCountReportItems.mock.funcCountReportItems != nil {
		mmCountReportItems.mock.t.Fatalf("TransactionUsecaseMock.CountReportItems mock is already set by Set")
	}

	if mmCountReportItems.defaultExpectation == nil {
		mmCountReportItems.defaultExpectation = &TransactionUsecaseMockCountReportItemsExpectation{}
	}

	if mmCountReportItems.defaultExpectation.params != nil {
		mmCountReportItems.mock.t.Fatalf("TransactionUsecaseMock.CountReportItems mock is already set by Expect")
	}

	if mmCountReportItems.defaultExpectation.paramPtrs == nil {
		mmCountReportItems.defaultExpectation.paramPtrs = &TransactionUsecaseMockCountReportItemsParamPtrs{}
	}
	mmCountReportItems.defaultExpectation.paramPtrs.ctx = &ctx
	mmCountReportItems.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCountReportItems
}

// ExpectQueryFilterParam2 sets up expected param queryFilter for TransactionUsecase.CountReportItems
func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) ExpectQueryFilterParam2(queryFilter mm_usecase.CountReportItemsQueryFilter) *mTransactionUsecaseMockCountReportItems {
	if mmCountReportItems.mock.funcCountReportItems != nil {
		mmCountReportItems.mock.t.Fatalf("TransactionUsecaseMock.CountReportItems mock is already set by Set")
	}

	if mmCountReportItems.defaultExpectation == nil {
		mmCountReportItems.defaultExpectation = &TransactionUsecaseMockCountReportItemsExpectation{}
	}

	if mmCountReportItems.defaultExpectation.params != nil {
		mmCountReportItems.mock.t.Fatalf("TransactionUsecaseMock.CountReportItems mock is already set by Expect")
	}

	if mmCountReportItems.defaultExpectation.paramPtrs == nil {
		mmCountReportItems.defaultExpectation.paramPtrs = &TransactionUsecaseMockCountReportItemsParamPtrs{}
	}
	mmCountReportItems.defaultExpectation.paramPtrs.queryFilter = &queryFilter
	mmCountReportItems.defaultExpectation.expectationOrigins.originQueryFilter = minimock.CallerInfo(1)

	return mmCountReportItems
}

// Inspect accepts an inspector function that has same arguments as the TransactionUsecase.CountReportItems
func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) Inspect(f func(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter)) *mTransactionUsecaseMockCountReportItems {
	if mmCountReportItems.mock.inspectFuncCountReportItems != nil {
		mmCountReportItems.mock.t.Fatalf("Inspect function is already set for TransactionUsecaseMock.CountReportItems")
	}

	mmCountReportItems.mock.inspectFuncCountReportItems = f

	return mmCountReportItems
}

// Return sets up results that will be returned by TransactionUsecase.CountReportItems
func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) Return(items []*entity.ReportItem, cacheHit bool, err error) *TransactionUsecaseMock {
	if mmCountReportItems.mock.funcCountReportItems != nil {
		mmCountReportItems.mock.t.Fatalf("TransactionUsecaseMock.CountReportItems mock is already set by Set")
	}

	if mmCountReportItems.defaultExpectation == nil {
		mmCountReportItems.defaultExpectation = &TransactionUsecaseMockCountReportItemsExpectation{mock: mmCountReportItems.mock}
	}
	mmCountReportItems.defaultExpectation.results = &TransactionUsecaseMockCountReportItemsResults{items, cacheHit, err}
	mmCountReportItems.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCountReportItems.mock
}

// Set uses given function f to mock the TransactionUsecase.CountReportItems method
func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) Set(f func(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter) (items []*entity.ReportItem, cacheHit bool, err error)) *TransactionUsecaseMock {
	if mmCountReportItems.defaultExpectation != nil {
		mmCountReportItems.mock.t.Fatalf("Default expectation is already set for the TransactionUsecase.CountReportItems method")
	}

	if len(mmCountReportItems.expectations) > 0 {
		mmCountReportItems.mock.t.Fatalf("Some expectations are already set for the TransactionUsecase.CountReportItems method")
	}

	mmCountReportItems.mock.funcCountReportItems = f
	mmCountReportItems.mock.funcCountReportItemsOrigin = minimock.CallerInfo(1)
	return mmCountReportItems.mock
}

// When sets expectation for the TransactionUsecase.CountReportItems which will trigger the result defined by the following
// Then helper
func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) When(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter) *TransactionUsecaseMockCountReportItemsExpectation {
	if mmCountReportItems.mock.funcCountReportItems != nil {
		mmCountReportItems.mock.t.Fatalf("TransactionUsecaseMock.CountReportItems mock is already set by Set")
	}

	expectation := &TransactionUsecaseMockCountReportItemsExpectation{
		mock:               mmCountReportItems.mock,
		params:             &TransactionUsecaseMockCountReportItemsParams{ctx, queryFilter},
		expectationOrigins: TransactionUsecaseMockCountReportItemsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCountReportItems.expectations = append(mmCountReportItems.expectations, expectation)
	return expectation
}

// Then sets up TransactionUsecase.CountReportItems return parameters for the expectation previously defined by the When method
func (e *TransactionUsecaseMockCountReportItemsExpectation) Then(items []*entity.ReportItem, cacheHit bool, err error) *TransactionUsecaseMock {
	e.results = &TransactionUsecaseMockCountReportItemsResults{items, cacheHit, err}
	return e.mock
}

// Times sets number of times TransactionUsecase.CountReportItems should be invoked
func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) Times(n uint64) *mTransactionUsecaseMockCountReportItems {
	if n == 0 {
		mmCountReportItems.mock.t.Fatalf("Times of TransactionUsecaseMock.CountReportItems mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCountReportItems.expectedInvocations, n)
	mmCountReportItems.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCountReportItems
}

func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) invocationsDone() bool {
	if len(mmCountReportItems.expectations) == 0 && mmCountReportItems.defaultExpectation == nil && mmCountReportItems.mock.funcCountReportItems == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCountReportItems.mock.afterCountReportItemsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCountReportItems.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CountReportItems implements mm_usecase.TransactionUsecase
func (mmCountReportItems *TransactionUsecaseMock) CountReportItems(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter) (items []*entity.ReportItem, cacheHit bool, err error) {
	mm_atomic.AddUint64(&mmCountReportItems.beforeCountReportItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmCountReportItems.afterCountReportItemsCounter, 1)

	mmCountReportItems.t.Helper()

	if mmCountReportItems.inspectFuncCountReportItems != nil {
		mmCountReportItems.inspectFuncCountReportItems(ctx, queryFilter)
	}

	mm_params := TransactionUsecaseMockCountReportItemsParams{ctx, queryFilter}

	// Record call args
	mmCountReportItems.CountReportItemsMock.mutex.Lock()
	mmCountReportItems.CountReportItemsMock.callArgs = append(mmCountReportItems.CountReportItemsMock.callArgs, &mm_params)
	mmCountReportItems.CountReportItemsMock.mutex.Unlock()

	for _, e := range mmCountReportItems.CountReportItemsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.items, e.results.cacheHit, e.results.err
		}
	}

	if mmCountReportItems.CountReportItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCountReportItems.CountReportItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmCountReportItems.CountReportItemsMock.defaultExpectation.params
		mm_want_ptrs := mmCountReportItems.CountReportItemsMock.defaultExpectation.paramPtrs

		mm_got := TransactionUsecaseMockCountReportItemsParams{ctx, queryFilter}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCountReportItems.t.Errorf("TransactionUsecaseMock.CountReportItems got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCountReportItems.CountReportItemsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.queryFilter != nil && !minimock.Equal(*mm_want_ptrs.queryFilter, mm_got.queryFilter) {
				mmCountReportItems.t.Errorf("TransactionUsecaseMock.CountReportItems got unexpected parameter queryFilter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCountReportItems.CountReportItemsMock.defaultExpectation.expectationOrigins.originQueryFilter, *mm_want_ptrs.queryFilter, mm_got.queryFilter, minimock.Diff(*mm_want_ptrs.queryFilter, mm_got.queryFilter))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCountReportItems.t.Errorf("TransactionUsecaseMock.CountReportItems got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCountReportItems.CountReportItemsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCountReportItems.CountReportItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmCountReportItems.t.Fatal("No results are set for the TransactionUsecaseMock.CountReportItems")
		}
		return (*mm_results).items, (*mm_results).cacheHit, (*mm_results).err
	}
	if mmCountReportItems.funcCountReportItems != nil {
		return mmCountReportItems.funcCountReportItems(ctx, queryFilter)
	}
	mmCountReportItems.t.Fatalf("Unexpected call to TransactionUsecaseMock.CountReportItems. %v %v", ctx, queryFilter)
	return
}

// CountReportItemsAfterCounter returns a count of finished TransactionUsecaseMock.CountReportItems invocations
func (mmCountReportItems *TransactionUsecaseMock) CountReportItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCountReportItems.afterCountReportItemsCounter)
}

// CountReportItemsBeforeCounter returns a count of TransactionUsecaseMock.CountReportItems invocations
func (mmCountReportItems *TransactionUsecaseMock) CountReportItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCountReportItems.beforeCountReportItemsCounter)
}

// Calls returns a list of arguments used in each call to TransactionUsecaseMock.CountReportItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) Calls() []*TransactionUsecaseMockCountReportItemsParams {
	mmCountReportItems.mutex.RLock()

	argCopy := make([]*TransactionUsecaseMockCountReportItemsParams, len(mmCountReportItems.callArgs))
	copy(argCopy, mmCountReportItems.callArgs)

	mmCountReportItems.mutex.RUnlock()

	return argCopy
}

// MinimockCountReportItemsDone returns true if the count of the CountReportItems invocations corresponds
// the number of defined expectations
func (m *TransactionUsecaseMock) MinimockCountReportItemsDone() bool {
	if m.CountReportItemsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CountReportItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CountReportItemsMock.invocationsDone()
}

// MinimockCountReportItemsInspect logs each unmet expectation
func (m *TransactionUsecaseMock) MinimockCountReportItemsInspect() {
	for _, e := range m.CountReportItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionUsecaseMock.CountReportItems at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCountReportItemsCounter := mm_atomic.LoadUint64(&m.afterCountReportItemsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CountReportItemsMock.defaultExpectation != nil && afterCountReportItemsCounter < 1 {
		if m.CountReportItemsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionUsecaseMock.CountReportItems at\n%s", m.CountReportItemsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionUsecaseMock.CountReportItems at\n%s with params: %#v", m.CountReportItemsMock.defaultExpectation.expectationOrigins.origin, *m.CountReportItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCountReportItems != nil && afterCountReportItemsCounter < 1 {
		m.t.Errorf("Expected call to TransactionUsecaseMock.CountReportItems at\n%s", m.funcCountReportItemsOrigin)
	}

	if !m.CountReportItemsMock.invocationsDone() && afterCountReportItemsCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionUsecaseMock.CountReportItems at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CountReportItemsMock.expectedInvocations), m.CountReportItemsMock.expectedInvocationsOrigin, afterCountReportItemsCounter)
	}
}

type mTransactionUsecaseMockCreateTransactionByDTO struct {
	optional           bool
	mock               *TransactionUsecaseMock
	defaultExpectation *TransactionUsecaseMockCreateTransactionByDTOExpectation
	expectations       []*TransactionUsecaseMockCreateTransactionByDTOExpectation

	callArgs []*TransactionUsecaseMockCreateTransactionByDTOParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionUsecaseMockCreateTransactionByDTOExpectation specifies expectation struct of the TransactionUsecase.CreateTransactionByDTO
type TransactionUsecaseMockCreateTransactionByDTOExpectation struct {
	mock               *TransactionUsecaseMock
	params             *TransactionUsecaseMockCreateTransactionByDTOParams
	paramPtrs          *TransactionUsecaseMockCreateTransactionByDTOParamPtrs
	expectationOrigins TransactionUsecaseMockCreateTransactionByDTOExpectationOrigins
	results            *TransactionUsecaseMockCreateTransactionByDTOResults
	returnOrigin       string
	Counter            uint64
}

// TransactionUsecaseMockCreateTransactionByDTOParams contains parameters of the TransactionUsecase.CreateTransactionByDTO
type TransactionUsecaseMockCreateTransactionByDTOParams struct {
	ctx            context.Context
	in             mm_usecase.CreateTransactionDataInput
	skipCacheClear bool
}

// TransactionUsecaseMockCreateTransactionByDTOParamPtrs contains pointers to parameters of the TransactionUsecase.CreateTransactionByDTO
type TransactionUsecaseMockCreateTransactionByDTOParamPtrs struct {
	ctx            *context.Context
	in             *mm_usecase.CreateTransactionDataInput
	skipCacheClear *bool
}

// TransactionUsecaseMockCreateTransactionByDTOResults contains results of the TransactionUsecase.CreateTransactionByDTO
type TransactionUsecaseMockCreateTransactionByDTOResults struct {
	resTransactionDTO *mm_usecase.TransactionDTO
	err               error
}

// TransactionUsecaseMockCreateTransactionByDTOOrigins contains origins of expectations of the TransactionUsecase.CreateTransactionByDTO
type TransactionUsecaseMockCreateTransactionByDTOExpectationOrigins struct {
	origin               string
	originCtx            string
	originIn             string
	originSkipCacheClear string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) Optional() *mTransactionUsecaseMockCreateTransactionByDTO {
	mmCreateTransactionByDTO.optional = true
	return mmCreateTransactionByDTO
}

// Expect sets up expected params for TransactionUsecase.CreateTransactionByDTO
func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) Expect(ctx context.Context, in mm_usecase.CreateTransactionDataInput, skipCacheClear bool) *mTransactionUsecaseMockCreateTransactionByDTO {
	if mmCreateTransactionByDTO.mock.funcCreateTransactionByDTO != nil {
		mmCreateTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.CreateTransactionByDTO mock is already set by Set")
	}

	if mmCreateTransactionByDTO.defaultExpectation == nil {
		mmCreateTransactionByDTO.defaultExpectation = &TransactionUsecaseMockCreateTransactionByDTOExpectation{}
	}

	if mmCreateTransactionByDTO.defaultExpectation.paramPtrs != nil {
		mmCreateTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.CreateTransactionByDTO mock is already set by ExpectParams functions")
	}

	mmCreateTransactionByDTO.defaultExpectation.params = &TransactionUsecaseMockCreateTransactionByDTOParams{ctx, in, skipCacheClear}
	mmCreateTransactionByDTO.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateTransactionByDTO.expectations {
		if minimock.Equal(e.params, mmCreateTransactionByDTO.defaultExpectation.params) {
			mmCreateTransactionByDTO.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateTransactionByDTO.defaultExpectation.params)
		}
	}

	return mmCreateTransactionByDTO
}

// ExpectCtxParam1 sets up expected param ctx for TransactionUsecase.CreateTransactionByDTO
func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) ExpectCtxParam1(ctx context.Context) *mTransactionUsecaseMockCreateTransactionByDTO {
	if mmCreateTransactionByDTO.mock.funcCreateTransactionByDTO != nil {
		mmCreateTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.CreateTransactionByDTO mock is already set by Set")
	}

	if mmCreateTransactionByDTO.defaultExpectation == nil {
		mmCreateTransactionByDTO.defaultExpectation = &TransactionUsecaseMockCreateTransactionByDTOExpectation{}
	}

	if mmCreateTransactionByDTO.defaultExpectation.params != nil {
		mmCreateTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.CreateTransactionByDTO mock is already set by Expect")
	}

	if mmCreateTransactionByDTO.defaultExpectation.paramPtrs == nil {
		mmCreateTransactionByDTO.defaultExpectation.paramPtrs = &TransactionUsecaseMockCreateTransactionByDTOParamPtrs{}
	}
	mmCreateTransactionByDTO.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateTransactionByDTO.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateTransactionByDTO
}

// ExpectInParam2 sets up expected param in for TransactionUsecase.CreateTransactionByDTO
func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) ExpectInParam2(in mm_usecase.CreateTransactionDataInput) *mTransactionUsecaseMockCreateTransactionByDTO {
	if mmCreateTransactionByDTO.mock.funcCreateTransactionByDTO != nil {
		mmCreateTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.CreateTransactionByDTO mock is already set by Set")
	}

	if mmCreateTransactionByDTO.defaultExpectation == nil {
		mmCreateTransactionByDTO.defaultExpectation = &TransactionUsecaseMockCreateTransactionByDTOExpectation{}
	}

	if mmCreateTransactionByDTO.defaultExpectation.params != nil {
		mmCreateTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.CreateTransactionByDTO mock is already set by Expect")
	}

	if mmCreateTransactionByDTO.defaultExpectation.paramPtrs == nil {
		mmCreateTransactionByDTO.defaultExpectation.paramPtrs = &TransactionUsecaseMockCreateTransactionByDTOParamPtrs{}
	}
	mmCreateTransactionByDTO.defaultExpectation.paramPtrs.in = &in
	mmCreateTransactionByDTO.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmCreateTransactionByDTO
}

// ExpectSkipCacheClearParam3 sets up expected param skipCacheClear for TransactionUsecase.CreateTransactionByDTO
func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) ExpectSkipCacheClearParam3(skipCacheClear bool) *mTransactionUsecaseMockCreateTransactionByDTO {
	if mmCreateTransactionByDTO.mock.funcCreateTransactionByDTO != nil {
		mmCreateTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.CreateTransactionByDTO mock is already set by Set")
	}

	if mmCreateTransactionByDTO.defaultExpectation == nil {
		mmCreateTransactionByDTO.defaultExpectation = &TransactionUsecaseMockCreateTransactionByDTOExpectation{}
	}

	if mmCreateTransactionByDTO.defaultExpectation.params != nil {
		mmCreateTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.CreateTransactionByDTO mock is already set by Expect")
	}

	if mmCreateTransactionByDTO.defaultExpectation.paramPtrs == nil {
		mmCreateTransactionByDTO.defaultExpectation.paramPtrs = &TransactionUsecaseMockCreateTransactionByDTOParamPtrs{}
	}
	mmCreateTransactionByDTO.defaultExpectation.paramPtrs.skipCacheClear = &skipCacheClear
	mmCreateTransactionByDTO.defaultExpectation.expectationOrigins.originSkipCacheClear = minimock.CallerInfo(1)

	return mmCreateTransactionByDTO
}

// Inspect accepts an inspector function that has same arguments as the TransactionUsecase.CreateTransactionByDTO
func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) Inspect(f func(ctx context.Context, in mm_usecase.CreateTransactionDataInput, skipCacheClear bool)) *mTransactionUsecaseMockCreateTransactionByDTO {
	if mmCreateTransactionByDTO.mock.inspectFuncCreateTransactionByDTO != nil {
		mmCreateTransactionByDTO.mock.t.Fatalf("Inspect function is already set for TransactionUsecaseMock.CreateTransactionByDTO")
	}

	mmCreateTransactionByDTO.mock.inspectFuncCreateTransactionByDTO = f

	return mmCreateTransactionByDTO
}

// Return sets up results that will be returned by TransactionUsecase.CreateTransactionByDTO
func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) Return(resTransactionDTO *mm_usecase.TransactionDTO, err error) *TransactionUsecaseMock {
	if mmCreateTransactionByDTO.mock.funcCreateTransactionByDTO != nil {
		mmCreateTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.CreateTransactionByDTO mock is already set by Set")
	}

	if mmCreateTransactionByDTO.defaultExpectation == nil {
		mmCreateTransactionByDTO.defaultExpectation = &TransactionUsecaseMockCreateTransactionByDTOExpectation{mock: mmCreateTransactionByDTO.mock}
	}
	mmCreateTransactionByDTO.defaultExpectation.results = &TransactionUsecaseMockCreateTransactionByDTOResults{resTransactionDTO, err}
	mmCreateTransactionByDTO.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateTransactionByDTO.mock
}

// Set uses given function f to mock the TransactionUsecase.CreateTransactionByDTO method
func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) Set(f func(ctx context.Context, in mm_usecase.CreateTransactionDataInput, skipCacheClear bool) (resTransactionDTO *mm_usecase.TransactionDTO, err error)) *TransactionUsecaseMock {
	if mmCreateTransactionByDTO.defaultExpectation != nil {
		mmCreateTransactionByDTO.mock.t.Fatalf("Default expectation is already set for the TransactionUsecase.CreateTransactionByDTO method")
	}

	if len(mmCreateTransactionByDTO.expectations) > 0 {
		mmCreateTransactionByDTO.mock.t.Fatalf("Some expectations are already set for the TransactionUsecase.CreateTransactionByDTO method")
	}

	mmCreateTransactionByDTO.mock.funcCreateTransactionByDTO = f
	mmCreateTransactionByDTO.mock.funcCreateTransactionByDTOOrigin = minimock.CallerInfo(1)
	return mmCreateTransactionByDTO.mock
}

// When sets expectation for the TransactionUsecase.CreateTransactionByDTO which will trigger the result defined by the following
// Then helper
func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) When(ctx context.Context, in mm_usecase.CreateTransactionDataInput, skipCacheClear bool) *TransactionUsecaseMockCreateTransactionByDTOExpectation {
	if mmCreateTransactionByDTO.mock.funcCreateTransactionByDTO != nil {
		mmCreateTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.CreateTransactionByDTO mock is already set by Set")
	}

	expectation := &TransactionUsecaseMockCreateTransactionByDTOExpectation{
		mock:               mmCreateTransactionByDTO.mock,
		params:             &TransactionUsecaseMockCreateTransactionByDTOParams{ctx, in, skipCacheClear},
		expectationOrigins: TransactionUsecaseMockCreateTransactionByDTOExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateTransactionByDTO.expectations = append(mmCreateTransactionByDTO.expectations, expectation)
	return expectation
}

// Then sets up TransactionUsecase.CreateTransactionByDTO return parameters for the expectation previously defined by the When method
func (e *TransactionUsecaseMockCreateTransactionByDTOExpectation) Then(resTransactionDTO *mm_usecase.TransactionDTO, err error) *TransactionUsecaseMock {
	e.results = &TransactionUsecaseMockCreateTransactionByDTOResults{resTransactionDTO, err}
	return e.mock
}

// Times sets number of times TransactionUsecase.CreateTransactionByDTO should be invoked
func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) Times(n uint64) *mTransactionUsecaseMockCreateTransactionByDTO {
	if n == 0 {
		mmCreateTransactionByDTO.mock.t.Fatalf("Times of TransactionUsecaseMock.CreateTransactionByDTO mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateTransactionByDTO.expectedInvocations, n)
	mmCreateTransactionByDTO.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateTransactionByDTO
}

func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) invocationsDone() bool {
	if len(mmCreateTransactionByDTO.expectations) == 0 && mmCreateTransactionByDTO.defaultExpectation == nil && mmCreateTransactionByDTO.mock.funcCreateTransactionByDTO == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateTransactionByDTO.mock.afterCreateTransactionByDTOCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateTransactionByDTO.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateTransactionByDTO implements mm_usecase.TransactionUsecase
func (mmCreateTransactionByDTO *TransactionUsecaseMock) CreateTransactionByDTO(ctx context.Context, in mm_usecase.CreateTransactionDataInput, skipCacheClear bool) (resTransactionDTO *mm_usecase.TransactionDTO, err error) {
	mm_atomic.AddUint64(&mmCreateTransactionByDTO.beforeCreateTransactionByDTOCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateTransactionByDTO.afterCreateTransactionByDTOCounter, 1)

	mmCreateTransactionByDTO.t.Helper()

	if mmCreateTransactionByDTO.inspectFuncCreateTransactionByDTO != nil {
		mmCreateTransactionByDTO.inspectFuncCreateTransactionByDTO(ctx, in, skipCacheClear)
	}

	mm_params := TransactionUsecaseMockCreateTransactionByDTOParams{ctx, in, skipCacheClear}

	// Record call args
	mmCreateTransactionByDTO.CreateTransactionByDTOMock.mutex.Lock()
	mmCreateTransactionByDTO.CreateTransactionByDTOMock.callArgs = append(mmCreateTransactionByDTO.CreateTransactionByDTOMock.callArgs, &mm_params)
	mmCreateTransactionByDTO.CreateTransactionByDTOMock.mutex.Unlock()

	for _, e := range mmCreateTransactionByDTO.CreateTransactionByDTOMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resTransactionDTO, e.results.err
		}
	}

	if mmCreateTransactionByDTO.CreateTransactionByDTOMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateTransactionByDTO.CreateTransactionByDTOMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateTransactionByDTO.CreateTransactionByDTOMock.defaultExpectation.params
		mm_want_ptrs := mmCreateTransactionByDTO.CreateTransactionByDTOMock.defaultExpectation.paramPtrs

		mm_got := TransactionUsecaseMockCreateTransactionByDTOParams{ctx, in, skipCacheClear}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateTransactionByDTO.t.Errorf("TransactionUsecaseMock.CreateTransactionByDTO got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTransactionByDTO.CreateTransactionByDTOMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmCreateTransactionByDTO.t.Errorf("TransactionUsecaseMock.CreateTransactionByDTO got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTransactionByDTO.CreateTransactionByDTOMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.skipCacheClear != nil && !minimock.Equal(*mm_want_ptrs.skipCacheClear, mm_got.skipCacheClear) {
				mmCreateTransactionByDTO.t.Errorf("TransactionUsecaseMock.CreateTransactionByDTO got unexpected parameter skipCacheClear, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTransactionByDTO.CreateTransactionByDTOMock.defaultExpectation.expectationOrigins.originSkipCacheClear, *mm_want_ptrs.skipCacheClear, mm_got.skipCacheClear, minimock.Diff(*mm_want_ptrs.skipCacheClear, mm_got.skipCacheClear))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateTransactionByDTO.t.Errorf("TransactionUsecaseMock.CreateTransactionByDTO got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateTransactionByDTO.CreateTransactionByDTOMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateTransactionByDTO.CreateTransactionByDTOMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateTransactionByDTO.t.Fatal("No results are set for the TransactionUsecaseMock.CreateTransactionByDTO")
		}
		return (*mm_results).resTransactionDTO, (*mm_results).err
	}
	if mmCreateTransactionByDTO.funcCreateTransactionByDTO != nil {
		return mmCreateTransactionByDTO.funcCreateTransactionByDTO(ctx, in, skipCacheClear)
	}
	mmCreateTransactionByDTO.t.Fatalf("Unexpected call to TransactionUsecaseMock.CreateTransactionByDTO. %v %v %v", ctx, in, skipCacheClear)
	return
}

// CreateTransactionByDTOAfterCounter returns a count of finished TransactionUsecaseMock.CreateTransactionByDTO invocations
func (mmCreateTransactionByDTO *TransactionUsecaseMock) CreateTransactionByDTOAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTransactionByDTO.afterCreateTransactionByDTOCounter)
}

// CreateTransactionByDTOBeforeCounter returns a count of TransactionUsecaseMock.CreateTransactionByDTO invocations
func (mmCreateTransactionByDTO *TransactionUsecaseMock) CreateTransactionByDTOBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTransactionByDTO.beforeCreateTransactionByDTOCounter)
}

// Calls returns a list of arguments used in each call to TransactionUsecaseMock.CreateTransactionByDTO.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) Calls() []*TransactionUsecaseMockCreateTransactionByDTOParams {
	mmCreateTransactionByDTO.mutex.RLock()

	argCopy := make([]*TransactionUsecaseMockCreateTransactionByDTOParams, len(mmCreateTransactionByDTO.callArgs))
	copy(argCopy, mmCreateTransactionByDTO.callArgs)

	mmCreateTransactionByDTO.mutex.RUnlock()

	return argCopy
}

// MinimockCreateTransactionByDTODone returns true if the count of the CreateTransactionByDTO invocations corresponds
// the number of defined expectations
func (m *TransactionUsecaseMock) MinimockCreateTransactionByDTODone() bool {
	if m.CreateTransactionByDTOMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateTransactionByDTOMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateTransactionByDTOMock.invocationsDone()
}

// MinimockCreateTransactionByDTOInspect logs each unmet expectation
func (m *TransactionUsecaseMock) MinimockCreateTransactionByDTOInspect() {
	for _, e := range m.CreateTransactionByDTOMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionUsecaseMock.CreateTransactionByDTO at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateTransactionByDTOCounter := mm_atomic.LoadUint64(&m.afterCreateTransactionByDTOCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTransactionByDTOMock.defaultExpectation != nil && afterCreateTransactionByDTOCounter < 1 {
		if m.CreateTransactionByDTOMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionUsecaseMock.CreateTransactionByDTO at\n%s", m.CreateTransactionByDTOMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionUsecaseMock.CreateTransactionByDTO at\n%s with params: %#v", m.CreateTransactionByDTOMock.defaultExpectation.expectationOrigins.origin, *m.CreateTransactionByDTOMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTransactionByDTO != nil && afterCreateTransactionByDTOCounter < 1 {
		m.t.Errorf("Expected call to TransactionUsecaseMock.CreateTransactionByDTO at\n%s", m.funcCreateTransactionByDTOOrigin)
	}

	if !m.CreateTransactionByDTOMock.invocationsDone() && afterCreateTransactionByDTOCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionUsecaseMock.CreateTransactionByDTO at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateTransactionByDTOMock.expectedInvocations), m.CreateTransactionByDTOMock.expectedInvocationsOrigin, afterCreateTransactionByDTOCounter)
	}
}

type mTransactionUsecaseMockDeleteTransactionByID struct {
	optional           bool
	mock               *TransactionUsecaseMock
	defaultExpectation *TransactionUsecaseMockDeleteTransactionByIDExpectation
	expectations       []*TransactionUsecaseMockDeleteTransactionByIDExpectation

	callArgs []*TransactionUsecaseMockDeleteTransactionByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionUsecaseMockDeleteTransactionByIDExpectation specifies expectation struct of the TransactionUsecase.DeleteTransactionByID
type TransactionUsecaseMockDeleteTransactionByIDExpectation struct {
	mock               *TransactionUsecaseMock
	params             *TransactionUsecaseMockDeleteTransactionByIDParams
	paramPtrs          *TransactionUsecaseMockDeleteTransactionByIDParamPtrs
	expectationOrigins TransactionUsecaseMockDeleteTransactionByIDExpectationOrigins
	results            *TransactionUsecaseMockDeleteTransactionByIDResults
	returnOrigin       string
	Counter            uint64
}

// TransactionUsecaseMockDeleteTransactionByIDParams contains parameters of the TransactionUsecase.DeleteTransactionByID
type TransactionUsecaseMockDeleteTransactionByIDParams struct {
	ctx context.Context
	id  uuid.UUID
}

// TransactionUsecaseMockDeleteTransactionByIDParamPtrs contains pointers to parameters of the TransactionUsecase.DeleteTransactionByID
type TransactionUsecaseMockDeleteTransactionByIDParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// TransactionUsecaseMockDeleteTransactionByIDResults contains results of the TransactionUsecase.DeleteTransactionByID
type TransactionUsecaseMockDeleteTransactionByIDResults struct {
	err error
}

// TransactionUsecaseMockDeleteTransactionByIDOrigins contains origins of expectations of the TransactionUsecase.DeleteTransactionByID
type TransactionUsecaseMockDeleteTransactionByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) Optional() *mTransactionUsecaseMockDeleteTransactionByID {
	mmDeleteTransactionByID.optional = true
	return mmDeleteTransactionByID
}

// Expect sets up expected params for TransactionUsecase.DeleteTransactionByID
func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) Expect(ctx context.Context, id uuid.UUID) *mTransactionUsecaseMockDeleteTransactionByID {
	if mmDeleteTransactionByID.mock.funcDeleteTransactionByID != nil {
		mmDeleteTransactionByID.mock.t.Fatalf("TransactionUsecaseMock.DeleteTransactionByID mock is already set by Set")
	}

	if mmDeleteTransactionByID.defaultExpectation == nil {
		mmDeleteTransactionByID.defaultExpectation = &TransactionUsecaseMockDeleteTransactionByIDExpectation{}
	}

	if mmDeleteTransactionByID.defaultExpectation.paramPtrs != nil {
		mmDeleteTransactionByID.mock.t.Fatalf("TransactionUsecaseMock.DeleteTransactionByID mock is already set by ExpectParams functions")
	}

	mmDeleteTransactionByID.defaultExpectation.params = &TransactionUsecaseMockDeleteTransactionByIDParams{ctx, id}
	mmDeleteTransactionByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteTransactionByID.expectations {
		if minimock.Equal(e.params, mmDeleteTransactionByID.defaultExpectation.params) {
			mmDeleteTransactionByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteTransactionByID.defaultExpectation.params)
		}
	}

	return mmDeleteTransactionByID
}

// ExpectCtxParam1 sets up expected param ctx for TransactionUsecase.DeleteTransactionByID
func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) ExpectCtxParam1(ctx context.Context) *mTransactionUsecaseMockDeleteTransactionByID {
	if mmDeleteTransactionByID.mock.funcDeleteTransactionByID != nil {
		mmDeleteTransactionByID.mock.t.Fatalf("TransactionUsecaseMock.DeleteTransactionByID mock is already set by Set")
	}

	if mmDeleteTransactionByID.defaultExpectation == nil {
		mmDeleteTransactionByID.defaultExpectation = &TransactionUsecaseMockDeleteTransactionByIDExpectation{}
	}

	if mmDeleteTransactionByID.defaultExpectation.params != nil {
		mmDeleteTransactionByID.mock.t.Fatalf("TransactionUsecaseMock.DeleteTransactionByID mock is already set by Expect")
	}

	if mmDeleteTransactionByID.defaultExpectation.paramPtrs == nil {
		mmDeleteTransactionByID.defaultExpectation.paramPtrs = &TransactionUsecaseMockDeleteTransactionByIDParamPtrs{}
	}
	mmDeleteTransactionByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteTransactionByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteTransactionByID
}

// ExpectIdParam2 sets up expected param id for TransactionUsecase.DeleteTransactionByID
func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) ExpectIdParam2(id uuid.UUID) *mTransactionUsecaseMockDeleteTransactionByID {
	if mmDeleteTransactionByID.mock.funcDeleteTransactionByID != nil {
		mmDeleteTransactionByID.mock.t.Fatalf("TransactionUsecaseMock.DeleteTransactionByID mock is already set by Set")
	}

	if mmDeleteTransactionByID.defaultExpectation == nil {
		mmDeleteTransactionByID.defaultExpectation = &TransactionUsecaseMockDeleteTransactionByIDExpectation{}
	}

	if mmDeleteTransactionByID.defaultExpectation.params != nil {
		mmDeleteTransactionByID.mock.t.Fatalf("TransactionUsecaseMock.DeleteTransactionByID mock is already set by Expect")
	}

	if mmDeleteTransactionByID.defaultExpectation.paramPtrs == nil {
		mmDeleteTransactionByID.defaultExpectation.paramPtrs = &TransactionUsecaseMockDeleteTransactionByIDParamPtrs{}
	}
	mmDeleteTransactionByID.defaultExpectation.paramPtrs.id = &id
	mmDeleteTransactionByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteTransactionByID
}

// Inspect accepts an inspector function that has same arguments as the TransactionUsecase.DeleteTransactionByID
func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) Inspect(f func(ctx context.Context, id uuid.UUID)) *mTransactionUsecaseMockDeleteTransactionByID {
	if mmDeleteTransactionByID.mock.inspectFuncDeleteTransactionByID != nil {
		mmDeleteTransactionByID.mock.t.Fatalf("Inspect function is already set for TransactionUsecaseMock.DeleteTransactionByID")
	}

	mmDeleteTransactionByID.mock.inspectFuncDeleteTransactionByID = f

	return mmDeleteTransactionByID
}

// Return sets up results that will be returned by TransactionUsecase.DeleteTransactionByID
func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) Return(err error) *TransactionUsecaseMock {
	if mmDeleteTransactionByID.mock.funcDeleteTransactionByID != nil {
		mmDeleteTransactionByID.mock.t.Fatalf("TransactionUsecaseMock.DeleteTransactionByID mock is already set by Set")
	}

	if mmDeleteTransactionByID.defaultExpectation == nil {
		mmDeleteTransactionByID.defaultExpectation = &TransactionUsecaseMockDeleteTransactionByIDExpectation{mock: mmDeleteTransactionByID.mock}
	}
	mmDeleteTransactionByID.defaultExpectation.results = &TransactionUsecaseMockDeleteTransactionByIDResults{err}
	mmDeleteTransactionByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteTransactionByID.mock
}

// Set uses given function f to mock the TransactionUsecase.DeleteTransactionByID method
func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *TransactionUsecaseMock {
	if mmDeleteTransactionByID.defaultExpectation != nil {
		mmDeleteTransactionByID.mock.t.Fatalf("Default expectation is already set for the TransactionUsecase.DeleteTransactionByID method")
	}

	if len(mmDeleteTransactionByID.expectations) > 0 {
		mmDeleteTransactionByID.mock.t.Fatalf("Some expectations are already set for the TransactionUsecase.DeleteTransactionByID method")
	}

	mmDeleteTransactionByID.mock.funcDeleteTransactionByID = f
	mmDeleteTransactionByID.mock.funcDeleteTransactionByIDOrigin = minimock.CallerInfo(1)
	return mmDeleteTransactionByID.mock
}

// When sets expectation for the TransactionUsecase.DeleteTransactionByID which will trigger the result defined by the following
// Then helper
func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) When(ctx context.Context, id uuid.UUID) *TransactionUsecaseMockDeleteTransactionByIDExpectation {
	if mmDeleteTransactionByID.mock.funcDeleteTransactionByID != nil {
		mmDeleteTransactionByID.mock.t.Fatalf("TransactionUsecaseMock.DeleteTransactionByID mock is already set by Set")
	}

	expectation := &TransactionUsecaseMockDeleteTransactionByIDExpectation{
		mock:               mmDeleteTransactionByID.mock,
		params:             &TransactionUsecaseMockDeleteTransactionByIDParams{ctx, id},
		expectationOrigins: TransactionUsecaseMockDeleteTransactionByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteTransactionByID.expectations = append(mmDeleteTransactionByID.expectations, expectation)
	return expectation
}

// Then sets up TransactionUsecase.DeleteTransactionByID return parameters for the expectation previously defined by the When method
func (e *TransactionUsecaseMockDeleteTransactionByIDExpectation) Then(err error) *TransactionUsecaseMock {
	e.results = &TransactionUsecaseMockDeleteTransactionByIDResults{err}
	return e.mock
}

// Times sets number of times TransactionUsecase.DeleteTransactionByID should be invoked
func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) Times(n uint64) *mTransactionUsecaseMockDeleteTransactionByID {
	if n == 0 {
		mmDeleteTransactionByID.mock.t.Fatalf("Times of TransactionUsecaseMock.DeleteTransactionByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteTransactionByID.expectedInvocations, n)
	mmDeleteTransactionByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteTransactionByID
}

func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) invocationsDone() bool {
	if len(mmDeleteTransactionByID.expectations) == 0 && mmDeleteTransactionByID.defaultExpectation == nil && mmDeleteTransactionByID.mock.funcDeleteTransactionByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteTransactionByID.mock.afterDeleteTransactionByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteTransactionByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteTransactionByID implements mm_usecase.TransactionUsecase
func (mmDeleteTransactionByID *TransactionUsecaseMock) DeleteTransactionByID(ctx context.Context, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteTransactionByID.beforeDeleteTransactionByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteTransactionByID.afterDeleteTransactionByIDCounter, 1)

	mmDeleteTransactionByID.t.Helper()

	if mmDeleteTransactionByID.inspectFuncDeleteTransactionByID != nil {
		mmDeleteTransactionByID.inspectFuncDeleteTransactionByID(ctx, id)
	}

	mm_params := TransactionUsecaseMockDeleteTransactionByIDParams{ctx, id}

	// Record call args
	mmDeleteTransactionByID.DeleteTransactionByIDMock.mutex.Lock()
	mmDeleteTransactionByID.DeleteTransactionByIDMock.callArgs = append(mmDeleteTransactionByID.DeleteTransactionByIDMock.callArgs, &mm_params)
	mmDeleteTransactionByID.DeleteTransactionByIDMock.mutex.Unlock()

	for _, e := range mmDeleteTransactionByID.DeleteTransactionByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteTransactionByID.DeleteTransactionByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteTransactionByID.DeleteTransactionByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteTransactionByID.DeleteTransactionByIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteTransactionByID.DeleteTransactionByIDMock.defaultExpectation.paramPtrs

		mm_got := TransactionUsecaseMockDeleteTransactionByIDParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteTransactionByID.t.Errorf("TransactionUsecaseMock.DeleteTransactionByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteTransactionByID.DeleteTransactionByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteTransactionByID.t.Errorf("TransactionUsecaseMock.DeleteTransactionByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteTransactionByID.DeleteTransactionByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteTransactionByID.t.Errorf("TransactionUsecaseMock.DeleteTransactionByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteTransactionByID.DeleteTransactionByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteTransactionByID.DeleteTransactionByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteTransactionByID.t.Fatal("No results are set for the TransactionUsecaseMock.DeleteTransactionByID")
		}
		return (*mm_results).err
	}
	if mmDeleteTransactionByID.funcDeleteTransactionByID != nil {
		return mmDeleteTransactionByID.funcDeleteTransactionByID(ctx, id)
	}
	mmDeleteTransactionByID.t.Fatalf("Unexpected call to TransactionUsecaseMock.DeleteTransactionByID. %v %v", ctx, id)
	return
}

// DeleteTransactionByIDAfterCounter returns a count of finished TransactionUsecaseMock.DeleteTransactionByID invocations
func (mmDeleteTransactionByID *TransactionUsecaseMock) DeleteTransactionByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteTransactionByID.afterDeleteTransactionByIDCounter)
}

// DeleteTransactionByIDBeforeCounter returns a count of TransactionUsecaseMock.DeleteTransactionByID invocations
func (mmDeleteTransactionByID *TransactionUsecaseMock) DeleteTransactionByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteTransactionByID.beforeDeleteTransactionByIDCounter)
}

// Calls returns a list of arguments used in each call to TransactionUsecaseMock.DeleteTransactionByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) Calls() []*TransactionUsecaseMockDeleteTransactionByIDParams {
	mmDeleteTransactionByID.mutex.RLock()

	argCopy := make([]*TransactionUsecaseMockDeleteTransactionByIDParams, len(mmDeleteTransactionByID.callArgs))
	copy(argCopy, mmDeleteTransactionByID.callArgs)

	mmDeleteTransactionByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteTransactionByIDDone returns true if the count of the DeleteTransactionByID invocations corresponds
// the number of defined expectations
func (m *TransactionUsecaseMock) MinimockDeleteTransactionByIDDone() bool {
	if m.DeleteTransactionByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteTransactionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteTransactionByIDMock.invocationsDone()
}

// MinimockDeleteTransactionByIDInspect logs each unmet expectation
func (m *TransactionUsecaseMock) MinimockDeleteTransactionByIDInspect() {
	for _, e := range m.DeleteTransactionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionUsecaseMock.DeleteTransactionByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteTransactionByIDCounter := mm_atomic.LoadUint64(&m.afterDeleteTransactionByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteTransactionByIDMock.defaultExpectation != nil && afterDeleteTransactionByIDCounter < 1 {
		if m.DeleteTransactionByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionUsecaseMock.DeleteTransactionByID at\n%s", m.DeleteTransactionByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionUsecaseMock.DeleteTransactionByID at\n%s with params: %#v", m.DeleteTransactionByIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteTransactionByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteTransactionByID != nil && afterDeleteTransactionByIDCounter < 1 {
		m.t.Errorf("Expected call to TransactionUsecaseMock.DeleteTransactionByID at\n%s", m.funcDeleteTransactionByIDOrigin)
	}

	if !m.DeleteTransactionByIDMock.invocationsDone() && afterDeleteTransactionByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionUsecaseMock.DeleteTransactionByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteTransactionByIDMock.expectedInvocations), m.DeleteTransactionByIDMock.expectedInvocationsOrigin, afterDeleteTransactionByIDCounter)
	}
}

type mTransactionUsecaseMockFindList struct {
	optional           bool
	mock               *TransactionUsecaseMock
	defaultExpectation *TransactionUsecaseMockFindListExpectation
	expectations       []*TransactionUsecaseMockFindListExpectation

	callArgs []*TransactionUsecaseMockFindListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionUsecaseMockFindListExpectation specifies expectation struct of the TransactionUsecase.FindList
type TransactionUsecaseMockFindListExpectation struct {
	mock               *TransactionUsecaseMock
	params             *TransactionUsecaseMockFindListParams
	paramPtrs          *TransactionUsecaseMockFindListParamPtrs
	expectationOrigins TransactionUsecaseMockFindListExpectationOrigins
	results            *TransactionUsecaseMockFindListResults
	returnOrigin       string
	Counter            uint64
}

// TransactionUsecaseMockFindListParams contains parameters of the TransactionUsecase.FindList
type TransactionUsecaseMockFindListParams struct {
	ctx         context.Context
	listOptions *mm_usecase.TransactionListOptions
	queryParams *uctypes.QueryGetListParams
}

// TransactionUsecaseMockFindListParamPtrs contains pointers to parameters of the TransactionUsecase.FindList
type TransactionUsecaseMockFindListParamPtrs struct {
	ctx         *context.Context
	listOptions **mm_usecase.TransactionListOptions
	queryParams **uctypes.QueryGetListParams
}

// TransactionUsecaseMockFindListResults contains results of the TransactionUsecase.FindList
type TransactionUsecaseMockFindListResults struct {
	resItems []*mm_usecase.TransactionDTO
	err      error
}

// TransactionUsecaseMockFindListOrigins contains origins of expectations of the TransactionUsecase.FindList
type TransactionUsecaseMockFindListExpectationOrigins struct {
	origin            string
	originCtx         string
	originListOptions string
	originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindList *mTransactionUsecaseMockFindList) Optional() *mTransactionUsecaseMockFindList {
	mmFindList.optional = true
	return mmFindList
}

// Expect sets up expected params for TransactionUsecase.FindList
func (mmFindList *mTransactionUsecaseMockFindList) Expect(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *mTransactionUsecaseMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("TransactionUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &TransactionUsecaseMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.paramPtrs != nil {
		mmFindList.mock.t.Fatalf("TransactionUsecaseMock.FindList mock is already set by ExpectParams functions")
	}

	mmFindList.defaultExpectation.params = &TransactionUsecaseMockFindListParams{ctx, listOptions, queryParams}
	mmFindList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindList.expectations {
		if minimock.Equal(e.params, mmFindList.defaultExpectation.params) {
			mmFindList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindList.defaultExpectation.params)
		}
	}

	return mmFindList
}

// ExpectCtxParam1 sets up expected param ctx for TransactionUsecase.FindList
func (mmFindList *mTransactionUsecaseMockFindList) ExpectCtxParam1(ctx context.Context) *mTransactionUsecaseMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("TransactionUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &TransactionUsecaseMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.params != nil {
		mmFindList.mock.t.Fatalf("TransactionUsecaseMock.FindList mock is already set by Expect")
	}

	if mmFindList.defaultExpectation.paramPtrs == nil {
		mmFindList.defaultExpectation.paramPtrs = &TransactionUsecaseMockFindListParamPtrs{}
	}
	mmFindList.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindList
}

// ExpectListOptionsParam2 sets up expected param listOptions for TransactionUsecase.FindList
func (mmFindList *mTransactionUsecaseMockFindList) ExpectListOptionsParam2(listOptions *mm_usecase.TransactionListOptions) *mTransactionUsecaseMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("TransactionUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &TransactionUsecaseMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.params != nil {
		mmFindList.mock.t.Fatalf("TransactionUsecaseMock.FindList mock is already set by Expect")
	}

	if mmFindList.defaultExpectation.paramPtrs == nil {
		mmFindList.defaultExpectation.paramPtrs = &TransactionUsecaseMockFindListParamPtrs{}
	}
	mmFindList.defaultExpectation.paramPtrs.listOptions = &listOptions
	mmFindList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

	return mmFindList
}

// ExpectQueryParamsParam3 sets up expected param queryParams for TransactionUsecase.FindList
func (mmFindList *mTransactionUsecaseMockFindList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mTransactionUsecaseMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("TransactionUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &TransactionUsecaseMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.params != nil {
		mmFindList.mock.t.Fatalf("TransactionUsecaseMock.FindList mock is already set by Expect")
	}

	if mmFindList.defaultExpectation.paramPtrs == nil {
		mmFindList.defaultExpectation.paramPtrs = &TransactionUsecaseMockFindListParamPtrs{}
	}
	mmFindList.defaultExpectation.paramPtrs.queryParams = &queryParams
	mmFindList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

	return mmFindList
}

// Inspect accepts an inspector function that has same arguments as the TransactionUsecase.FindList
func (mmFindList *mTransactionUsecaseMockFindList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)) *mTransactionUsecaseMockFindList {
	if mmFindList.mock.inspectFuncFindList != nil {
		mmFindList.mock.t.Fatalf("Inspect function is already set for TransactionUsecaseMock.FindList")
	}

	mmFindList.mock.inspectFuncFindList = f

	return mmFindList
}

// Return sets up results that will be returned by TransactionUsecase.FindList
func (mmFindList *mTransactionUsecaseMockFindList) Return(resItems []*mm_usecase.TransactionDTO, err error) *TransactionUsecaseMock {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("TransactionUsecaseMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &TransactionUsecaseMockFindListExpectation{mock: mmFindList.mock}
	}
	mmFindList.defaultExpectation.results = &TransactionUsecaseMockFindListResults{resItems, err}
	mmFindList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindList.mock
}

// Set uses given function f to mock the TransactionUsecase.FindList method
func (mmFindList *mTransactionUsecaseMockFindList) Set(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.TransactionDTO, err error)) *TransactionUsecaseMock {
	if mmFindList.defaultExpectation != nil {
		mmFindList.mock.t.Fatalf("Default expectation is already set for the TransactionUsecase.FindList method")
	}

	if len(mmFindList.expectations) > 0 {
		mmFindList.mock.t.Fatalf("Some expectations are already set for the TransactionUsecase.FindList method")
	}

	mmFindList.mock.funcFindList = f
	mmFindList.mock.funcFindListOrigin = minimock.CallerInfo(1)
	return mmFindList.mock
}

// When sets expectation for the TransactionUsecase.FindList which will trigger the result defined by the following
// Then helper
func (mmFindList *mTransactionUsecaseMockFindList) When(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *TransactionUsecaseMockFindListExpectation {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("TransactionUsecaseMock.FindList mock is already set by Set")
	}

	expectation := &TransactionUsecaseMockFindListExpectation{
		mock:               mmFindList.mock,
		params:             &TransactionUsecaseMockFindListParams{ctx, listOptions, queryParams},
		expectationOrigins: TransactionUsecaseMockFindListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindList.expectations = append(mmFindList.expectations, expectation)
	return expectation
}

// Then sets up TransactionUsecase.FindList return parameters for the expectation previously defined by the When method
func (e *TransactionUsecaseMockFindListExpectation) Then(resItems []*mm_usecase.TransactionDTO, err error) *TransactionUsecaseMock {
	e.results = &TransactionUsecaseMockFindListResults{resItems, err}
	return e.mock
}

// Times sets number of times TransactionUsecase.FindList should be invoked
func (mmFindList *mTransactionUsecaseMockFindList) Times(n uint64) *mTransactionUsecaseMockFindList {
	if n == 0 {
		mmFindList.mock.t.Fatalf("Times of TransactionUsecaseMock.FindList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindList.expectedInvocations, n)
	mmFindList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindList
}

func (mmFindList *mTransactionUsecaseMockFindList) invocationsDone() bool {
	if len(mmFindList.expectations) == 0 && mmFindList.defaultExpectation == nil && mmFindList.mock.funcFindList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindList.mock.afterFindListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindList implements mm_usecase.TransactionUsecase
func (mmFindList *TransactionUsecaseMock) FindList(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.TransactionDTO, err error) {
	mm_atomic.AddUint64(&mmFindList.beforeFindListCounter, 1)
	defer mm_atomic.AddUint64(&mmFindList.afterFindListCounter, 1)

	mmFindList.t.Helper()

	if mmFindList.inspectFuncFindList != nil {
		mmFindList.inspectFuncFindList(ctx, listOptions, queryParams)
	}

	mm_params := TransactionUsecaseMockFindListParams{ctx, listOptions, queryParams}

	// Record call args
	mmFindList.FindListMock.mutex.Lock()
	mmFindList.FindListMock.callArgs = append(mmFindList.FindListMock.callArgs, &mm_params)
	mmFindList.FindListMock.mutex.Unlock()

	for _, e := range mmFindList.FindListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resItems, e.results.err
		}
	}

	if mmFindList.FindListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindList.FindListMock.defaultExpectation.Counter, 1)
		mm_want := mmFindList.FindListMock.defaultExpectation.params
		mm_want_ptrs := mmFindList.FindListMock.defaultExpectation.paramPtrs

		mm_got := TransactionUsecaseMockFindListParams{ctx, listOptions, queryParams}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindList.t.Errorf("TransactionUsecaseMock.FindList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindList.FindListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.listOptions != nil && !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) {
				mmFindList.t.Errorf("TransactionUsecaseMock.FindList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindList.FindListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
			}

			if mm_want_ptrs.queryParams != nil && !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) {
				mmFindList.t.Errorf("TransactionUsecaseMock.FindList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindList.FindListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindList.t.Errorf("TransactionUsecaseMock.FindList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindList.FindListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindList.FindListMock.defaultExpectation.results
		if mm_results == nil {
			mmFindList.t.Fatal("No results are set for the TransactionUsecaseMock.FindList")
		}
		return (*mm_results).resItems, (*mm_results).err
	}
	if mmFindList.funcFindList != nil {
		return mmFindList.funcFindList(ctx, listOptions, queryParams)
	}
	mmFindList.t.Fatalf("Unexpected call to TransactionUsecaseMock.FindList. %v %v %v", ctx, listOptions, queryParams)
	return
}

// FindListAfterCounter returns a count of finished TransactionUsecaseMock.FindList invocations
func (mmFindList *TransactionUsecaseMock) FindListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindList.afterFindListCounter)
}

// FindListBeforeCounter returns a count of TransactionUsecaseMock.FindList invocations
func (mmFindList *TransactionUsecaseMock) FindListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindList.beforeFindListCounter)
}

// Calls returns a list of arguments used in each call to TransactionUsecaseMock.FindList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindList *mTransactionUsecaseMockFindList) Calls() []*TransactionUsecaseMockFindListParams {
	mmFindList.mutex.RLock()

	argCopy := make([]*TransactionUsecaseMockFindListParams, len(mmFindList.callArgs))
	copy(argCopy, mmFindList.callArgs)

	mmFindList.mutex.RUnlock()

	return argCopy
}

// MinimockFindListDone returns true if the count of the FindList invocations corresponds
// the number of defined expectations
func (m *TransactionUsecaseMock) MinimockFindListDone() bool {
	if m.FindListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindListMock.invocationsDone()
}

// MinimockFindListInspect logs each unmet expectation
func (m *TransactionUsecaseMock) MinimockFindListInspect() {
	for _, e := range m.FindListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionUsecaseMock.FindList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindListCounter := mm_atomic.LoadUint64(&m.afterFindListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindListMock.defaultExpectation != nil && afterFindListCounter < 1 {
		if m.FindListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionUsecaseMock.FindList at\n%s", m.FindListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionUsecaseMock.FindList at\n%s with params: %#v", m.FindListMock.defaultExpectation.expectationOrigins.origin, *m.FindListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindList != nil && afterFindListCounter < 1 {
		m.t.Errorf("Expected call to TransactionUsecaseMock.FindList at\n%s", m.funcFindListOrigin)
	}

	if !m.FindListMock.invocationsDone() && afterFindListCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionUsecaseMock.FindList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindListMock.expectedInvocations), m.FindListMock.expectedInvocationsOrigin, afterFindListCounter)
	}
}

type mTransactionUsecaseMockFindListInMap struct {
	optional           bool
	mock               *TransactionUsecaseMock
	defaultExpectation *TransactionUsecaseMockFindListInMapExpectation
	expectations       []*TransactionUsecaseMockFindListInMapExpectation

	callArgs []*TransactionUsecaseMockFindListInMapParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionUsecaseMockFindListInMapExpectation specifies expectation struct of the TransactionUsecase.FindListInMap
type TransactionUsecaseMockFindListInMapExpectation struct {
	mock               *TransactionUsecaseMock
	params             *TransactionUsecaseMockFindListInMapParams
	paramPtrs          *TransactionUsecaseMockFindListInMapParamPtrs
	expectationOrigins TransactionUsecaseMockFindListInMapExpectationOrigins
	results            *TransactionUsecaseMockFindListInMapResults
	returnOrigin       string
	Counter            uint64
}

// TransactionUsecaseMockFindListInMapParams contains parameters of the TransactionUsecase.FindListInMap
type TransactionUsecaseMockFindListInMapParams struct {
	ctx         context.Context
	listOptions *mm_usecase.TransactionListOptions
	queryParams *uctypes.QueryGetListParams
}

// TransactionUsecaseMockFindListInMapParamPtrs contains pointers to parameters of the TransactionUsecase.FindListInMap
type TransactionUsecaseMockFindListInMapParamPtrs struct {
	ctx         *context.Context
	listOptions **mm_usecase.TransactionListOptions
	queryParams **uctypes.QueryGetListParams
}

// TransactionUsecaseMockFindListInMapResults contains results of the TransactionUsecase.FindListInMap
type TransactionUsecaseMockFindListInMapResults struct {
	resItems map[uuid.UUID]*mm_usecase.TransactionDTO
	err      error
}

// TransactionUsecaseMockFindListInMapOrigins contains origins of expectations of the TransactionUsecase.FindListInMap
type TransactionUsecaseMockFindListInMapExpectationOrigins struct {
	origin            string
	originCtx         string
	originListOptions string
	originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) Optional() *mTransactionUsecaseMockFindListInMap {
	mmFindListInMap.optional = true
	return mmFindListInMap
}

// Expect sets up expected params for TransactionUsecase.FindListInMap
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) Expect(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *mTransactionUsecaseMockFindListInMap {
	if mmFindListInMap.mock.funcFindListInMap != nil {
		mmFindListInMap.mock.t.Fatalf("TransactionUsecaseMock.FindListInMap mock is already set by Set")
	}

	if mmFindListInMap.defaultExpectation == nil {
		mmFindListInMap.defaultExpectation = &TransactionUsecaseMockFindListInMapExpectation{}
	}

	if mmFindListInMap.defaultExpectation.paramPtrs != nil {
		mmFindListInMap.mock.t.Fatalf("TransactionUsecaseMock.FindListInMap mock is already set by ExpectParams functions")
	}

	mmFindListInMap.defaultExpectation.params = &TransactionUsecaseMockFindListInMapParams{ctx, listOptions, queryParams}
	mmFindListInMap.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindListInMap.expectations {
		if minimock.Equal(e.params, mmFindListInMap.defaultExpectation.params) {
			mmFindListInMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindListInMap.defaultExpectation.params)
		}
	}

	return mmFindListInMap
}

// ExpectCtxParam1 sets up expected param ctx for TransactionUsecase.FindListInMap
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) ExpectCtxParam1(ctx context.Context) *mTransactionUsecaseMockFindListInMap {
	if mmFindListInMap.mock.funcFindListInMap != nil {
		mmFindListInMap.mock.t.Fatalf("TransactionUsecaseMock.FindListInMap mock is already set by Set")
	}

	if mmFindListInMap.defaultExpectation == nil {
		mmFindListInMap.defaultExpectation = &TransactionUsecaseMockFindListInMapExpectation{}
	}

	if mmFindListInMap.defaultExpectation.params != nil {
		mmFindListInMap.mock.t.Fatalf("TransactionUsecaseMock.FindListInMap mock is already set by Expect")
	}

	if mmFindListInMap.defaultExpectation.paramPtrs == nil {
		mmFindListInMap.defaultExpectation.paramPtrs = &TransactionUsecaseMockFindListInMapParamPtrs{}
	}
	mmFindListInMap.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindListInMap.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindListInMap
}

// ExpectListOptionsParam2 sets up expected param listOptions for TransactionUsecase.FindListInMap
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) ExpectListOptionsParam2(listOptions *mm_usecase.TransactionListOptions) *mTransactionUsecaseMockFindListInMap {
	if mmFindListInMap.mock.funcFindListInMap != nil {
		mmFindListInMap.mock.t.Fatalf("TransactionUsecaseMock.FindListInMap mock is already set by Set")
	}

	if mmFindListInMap.defaultExpectation == nil {
		mmFindListInMap.defaultExpectation = &TransactionUsecaseMockFindListInMapExpectation{}
	}

	if mmFindListInMap.defaultExpectation.params != nil {
		mmFindListInMap.mock.t.Fatalf("TransactionUsecaseMock.FindListInMap mock is already set by Expect")
	}

	if mmFindListInMap.defaultExpectation.paramPtrs == nil {
		mmFindListInMap.defaultExpectation.paramPtrs = &TransactionUsecaseMockFindListInMapParamPtrs{}
	}
	mmFindListInMap.defaultExpectation.paramPtrs.listOptions = &listOptions
	mmFindListInMap.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

	return mmFindListInMap
}

// ExpectQueryParamsParam3 sets up expected param queryParams for TransactionUsecase.FindListInMap
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mTransactionUsecaseMockFindListInMap {
	if mmFindListInMap.mock.funcFindListInMap != nil {
		mmFindListInMap.mock.t.Fatalf("TransactionUsecaseMock.FindListInMap mock is already set by Set")
	}

	if mmFindListInMap.defaultExpectation == nil {
		mmFindListInMap.defaultExpectation = &TransactionUsecaseMockFindListInMapExpectation{}
	}

	if mmFindListInMap.defaultExpectation.params != nil {
		mmFindListInMap.mock.t.Fatalf("TransactionUsecaseMock.FindListInMap mock is already set by Expect")
	}

	if mmFindListInMap.defaultExpectation.paramPtrs == nil {
		mmFindListInMap.defaultExpectation.paramPtrs = &TransactionUsecaseMockFindListInMapParamPtrs{}
	}
	mmFindListInMap.defaultExpectation.paramPtrs.queryParams = &queryParams
	mmFindListInMap.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

	return mmFindListInMap
}

// Inspect accepts an inspector function that has same arguments as the TransactionUsecase.FindListInMap
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) Inspect(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)) *mTransactionUsecaseMockFindListInMap {
	if mmFindListInMap.mock.inspectFuncFindListInMap != nil {
		mmFindListInMap.mock.t.Fatalf("Inspect function is already set for TransactionUsecaseMock.FindListInMap")
	}

	mmFindListInMap.mock.inspectFuncFindListInMap = f

	return mmFindListInMap
}

// Return sets up results that will be returned by TransactionUsecase.FindListInMap
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) Return(resItems map[uuid.UUID]*mm_usecase.TransactionDTO, err error) *TransactionUsecaseMock {
	if mmFindListInMap.mock.funcFindListInMap != nil {
		mmFindListInMap.mock.t.Fatalf("TransactionUsecaseMock.FindListInMap mock is already set by Set")
	}

	if mmFindListInMap.defaultExpectation == nil {
		mmFindListInMap.defaultExpectation = &TransactionUsecaseMockFindListInMapExpectation{mock: mmFindListInMap.mock}
	}
	mmFindListInMap.defaultExpectation.results = &TransactionUsecaseMockFindListInMapResults{resItems, err}
	mmFindListInMap.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindListInMap.mock
}

// Set uses given function f to mock the TransactionUsecase.FindListInMap method
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) Set(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (resItems map[uuid.UUID]*mm_usecase.TransactionDTO, err error)) *TransactionUsecaseMock {
	if mmFindListInMap.defaultExpectation != nil {
		mmFindListInMap.mock.t.Fatalf("Default expectation is already set for the TransactionUsecase.FindListInMap method")
	}

	if len(mmFindListInMap.expectations) > 0 {
		mmFindListInMap.mock.t.Fatalf("Some expectations are already set for the TransactionUsecase.FindListInMap method")
	}

	mmFindListInMap.mock.funcFindListInMap = f
	mmFindListInMap.mock.funcFindListInMapOrigin = minimock.CallerInfo(1)
	return mmFindListInMap.mock
}

// When sets expectation for the TransactionUsecase.FindListInMap which will trigger the result defined by the following
// Then helper
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) When(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *TransactionUsecaseMockFindListInMapExpectation {
	if mmFindListInMap.mock.funcFindListInMap != nil {
		mmFindListInMap.mock.t.Fatalf("TransactionUsecaseMock.FindListInMap mock is already set by Set")
	}

	expectation := &TransactionUsecaseMockFindListInMapExpectation{
		mock:               mmFindListInMap.mock,
		params:             &TransactionUsecaseMockFindListInMapParams{ctx, listOptions, queryParams},
		expectationOrigins: TransactionUsecaseMockFindListInMapExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindListInMap.expectations = append(mmFindListInMap.expectations, expectation)
	return expectation
}

// Then sets up TransactionUsecase.FindListInMap return parameters for the expectation previously defined by the When method
func (e *TransactionUsecaseMockFindListInMapExpectation) Then(resItems map[uuid.UUID]*mm_usecase.TransactionDTO, err error) *TransactionUsecaseMock {
	e.results = &TransactionUsecaseMockFindListInMapResults{resItems, err}
	return e.mock
}

// Times sets number of times TransactionUsecase.FindListInMap should be invoked
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) Times(n uint64) *mTransactionUsecaseMockFindListInMap {
	if n == 0 {
		mmFindListInMap.mock.t.Fatalf("Times of TransactionUsecaseMock.FindListInMap mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindListInMap.expectedInvocations, n)
	mmFindListInMap.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindListInMap
}

func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) invocationsDone() bool {
	if len(mmFindListInMap.expectations) == 0 && mmFindListInMap.defaultExpectation == nil && mmFindListInMap.mock.funcFindListInMap == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindListInMap.mock.afterFindListInMapCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindListInMap.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindListInMap implements mm_usecase.TransactionUsecase
func (mmFindListInMap *TransactionUsecaseMock) FindListInMap(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (resItems map[uuid.UUID]*mm_usecase.TransactionDTO, err error) {
	mm_atomic.AddUint64(&mmFindListInMap.beforeFindListInMapCounter, 1)
	defer mm_atomic.AddUint64(&mmFindListInMap.afterFindListInMapCounter, 1)

	mmFindListInMap.t.Helper()

	if mmFindListInMap.inspectFuncFindListInMap != nil {
		mmFindListInMap.inspectFuncFindListInMap(ctx, listOptions, queryParams)
	}

	mm_params := TransactionUsecaseMockFindListInMapParams{ctx, listOptions, queryParams}

	// Record call args
	mmFindListInMap.FindListInMapMock.mutex.Lock()
	mmFindListInMap.FindListInMapMock.callArgs = append(mmFindListInMap.FindListInMapMock.callArgs, &mm_params)
	mmFindListInMap.FindListInMapMock.mutex.Unlock()

	for _, e := range mmFindListInMap.FindListInMapMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resItems, e.results.err
		}
	}

	if mmFindListInMap.FindListInMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindListInMap.FindListInMapMock.defaultExpectation.Counter, 1)
		mm_want := mmFindListInMap.FindListInMapMock.defaultExpectation.params
		mm_want_ptrs := mmFindListInMap.FindListInMapMock.defaultExpectation.paramPtrs

		mm_got := TransactionUsecaseMockFindListInMapParams{ctx, listOptions, queryParams}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindListInMap.t.Errorf("TransactionUsecaseMock.FindListInMap got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindListInMap.FindListInMapMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.listOptions != nil && !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) {
				mmFindListInMap.t.Errorf("TransactionUsecaseMock.FindListInMap got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindListInMap.FindListInMapMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
			}

			if mm_want_ptrs.queryParams != nil && !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) {
				mmFindListInMap.t.Errorf("TransactionUsecaseMock.FindListInMap got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindListInMap.FindListInMapMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindListInMap.t.Errorf("TransactionUsecaseMock.FindListInMap got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindListInMap.FindListInMapMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindListInMap.FindListInMapMock.defaultExpectation.results
		if mm_results == nil {
			mmFindListInMap.t.Fatal("No results are set for the TransactionUsecaseMock.FindListInMap")
		}
		return (*mm_results).resItems, (*mm_results).err
	}
	if mmFindListInMap.funcFindListInMap != nil {
		return mmFindListInMap.funcFindListInMap(ctx, listOptions, queryParams)
	}
	mmFindListInMap.t.Fatalf("Unexpected call to TransactionUsecaseMock.FindListInMap. %v %v %v", ctx, listOptions, queryParams)
	return
}

// FindListInMapAfterCounter returns a count of finished TransactionUsecaseMock.FindListInMap invocations
func (mmFindListInMap *TransactionUsecaseMock) FindListInMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindListInMap.afterFindListInMapCounter)
}

// FindListInMapBeforeCounter returns a count of TransactionUsecaseMock.FindListInMap invocations
func (mmFindListInMap *TransactionUsecaseMock) FindListInMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindListInMap.beforeFindListInMapCounter)
}

// Calls returns a list of arguments used in each call to TransactionUsecaseMock.FindListInMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) Calls() []*TransactionUsecaseMockFindListInMapParams {
	mmFindListInMap.mutex.RLock()

	argCopy := make([]*TransactionUsecaseMockFindListInMapParams, len(mmFindListInMap.callArgs))
	copy(argCopy, mmFindListInMap.callArgs)

	mmFindListInMap.mutex.RUnlock()

	return argCopy
}

// MinimockFindListInMapDone returns true if the count of the FindListInMap invocations corresponds
// the number of defined expectations
func (m *TransactionUsecaseMock) MinimockFindListInMapDone() bool {
	if m.FindListInMapMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindListInMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindListInMapMock.invocationsDone()
}

// MinimockFindListInMapInspect logs each unmet expectation
func (m *TransactionUsecaseMock) MinimockFindListInMapInspect() {
	for _, e := range m.FindListInMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionUsecaseMock.FindListInMap at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindListInMapCounter := mm_atomic.LoadUint64(&m.afterFindListInMapCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindListInMapMock.defaultExpectation != nil && afterFindListInMapCounter < 1 {
		if m.FindListInMapMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionUsecaseMock.FindListInMap at\n%s", m.FindListInMapMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionUsecaseMock.FindListInMap at\n%s with params: %#v", m.FindListInMapMock.defaultExpectation.expectationOrigins.origin, *m.FindListInMapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindListInMap != nil && afterFindListInMapCounter < 1 {
		m.t.Errorf("Expected call to TransactionUsecaseMock.FindListInMap at\n%s", m.funcFindListInMapOrigin)
	}

	if !m.FindListInMapMock.invocationsDone() && afterFindListInMapCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionUsecaseMock.FindListInMap at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindListInMapMock.expectedInvocations), m.FindListInMapMock.expectedInvocationsOrigin, afterFindListInMapCounter)
	}
}

type mTransactionUsecaseMockFindOneByID struct {
	optional           bool
	mock               *TransactionUsecaseMock
	defaultExpectation *TransactionUsecaseMockFindOneByIDExpectation
	expectations       []*TransactionUsecaseMockFindOneByIDExpectation

	callArgs []*TransactionUsecaseMockFindOneByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionUsecaseMockFindOneByIDExpectation specifies expectation struct of the TransactionUsecase.FindOneByID
type TransactionUsecaseMockFindOneByIDExpectation struct {
	mock               *TransactionUsecaseMock
	params             *TransactionUsecaseMockFindOneByIDParams
	paramPtrs          *TransactionUsecaseMockFindOneByIDParamPtrs
	expectationOrigins TransactionUsecaseMockFindOneByIDExpectationOrigins
	results            *TransactionUsecaseMockFindOneByIDResults
	returnOrigin       string
	Counter            uint64
}

// TransactionUsecaseMockFindOneByIDParams contains parameters of the TransactionUsecase.FindOneByID
type TransactionUsecaseMockFindOneByIDParams struct {
	ctx         context.Context
	id          uuid.UUID
	queryParams *uctypes.QueryGetOneParams
}

// TransactionUsecaseMockFindOneByIDParamPtrs contains pointers to parameters of the TransactionUsecase.FindOneByID
type TransactionUsecaseMockFindOneByIDParamPtrs struct {
	ctx         *context.Context
	id          *uuid.UUID
	queryParams **uctypes.QueryGetOneParams
}

// TransactionUsecaseMockFindOneByIDResults contains results of the TransactionUsecase.FindOneByID
type TransactionUsecaseMockFindOneByIDResults struct {
	resItem *mm_usecase.TransactionDTO
	err     error
}

// TransactionUsecaseMockFindOneByIDOrigins contains origins of expectations of the TransactionUsecase.FindOneByID
type TransactionUsecaseMockFindOneByIDExpectationOrigins struct {
	origin            string
	originCtx         string
	originId          string
	originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) Optional() *mTransactionUsecaseMockFindOneByID {
	mmFindOneByID.optional = true
	return mmFindOneByID
}

// Expect sets up expected params for TransactionUsecase.FindOneByID
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) Expect(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *mTransactionUsecaseMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("TransactionUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &TransactionUsecaseMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.paramPtrs != nil {
		mmFindOneByID.mock.t.Fatalf("TransactionUsecaseMock.FindOneByID mock is already set by ExpectParams functions")
	}

	mmFindOneByID.defaultExpectation.params = &TransactionUsecaseMockFindOneByIDParams{ctx, id, queryParams}
	mmFindOneByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindOneByID.expectations {
		if minimock.Equal(e.params, mmFindOneByID.defaultExpectation.params) {
			mmFindOneByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindOneByID.defaultExpectation.params)
		}
	}

	return mmFindOneByID
}

// ExpectCtxParam1 sets up expected param ctx for TransactionUsecase.FindOneByID
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) ExpectCtxParam1(ctx context.Context) *mTransactionUsecaseMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("TransactionUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &TransactionUsecaseMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.params != nil {
		mmFindOneByID.mock.t.Fatalf("TransactionUsecaseMock.FindOneByID mock is already set by Expect")
	}

	if mmFindOneByID.defaultExpectation.paramPtrs == nil {
		mmFindOneByID.defaultExpectation.paramPtrs = &TransactionUsecaseMockFindOneByIDParamPtrs{}
	}
	mmFindOneByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindOneByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindOneByID
}

// ExpectIdParam2 sets up expected param id for TransactionUsecase.FindOneByID
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) ExpectIdParam2(id uuid.UUID) *mTransactionUsecaseMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("TransactionUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &TransactionUsecaseMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.params != nil {
		mmFindOneByID.mock.t.Fatalf("TransactionUsecaseMock.FindOneByID mock is already set by Expect")
	}

	if mmFindOneByID.defaultExpectation.paramPtrs == nil {
		mmFindOneByID.defaultExpectation.paramPtrs = &TransactionUsecaseMockFindOneByIDParamPtrs{}
	}
	mmFindOneByID.defaultExpectation.paramPtrs.id = &id
	mmFindOneByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmFindOneByID
}

// ExpectQueryParamsParam3 sets up expected param queryParams for TransactionUsecase.FindOneByID
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetOneParams) *mTransactionUsecaseMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("TransactionUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &TransactionUsecaseMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.params != nil {
		mmFindOneByID.mock.t.Fatalf("TransactionUsecaseMock.FindOneByID mock is already set by Expect")
	}

	if mmFindOneByID.defaultExpectation.paramPtrs == nil {
		mmFindOneByID.defaultExpectation.paramPtrs = &TransactionUsecaseMockFindOneByIDParamPtrs{}
	}
	mmFindOneByID.defaultExpectation.paramPtrs.queryParams = &queryParams
	mmFindOneByID.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

	return mmFindOneByID
}

// Inspect accepts an inspector function that has same arguments as the TransactionUsecase.FindOneByID
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) Inspect(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)) *mTransactionUsecaseMockFindOneByID {
	if mmFindOneByID.mock.inspectFuncFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("Inspect function is already set for TransactionUsecaseMock.FindOneByID")
	}

	mmFindOneByID.mock.inspectFuncFindOneByID = f

	return mmFindOneByID
}

// Return sets up results that will be returned by TransactionUsecase.FindOneByID
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) Return(resItem *mm_usecase.TransactionDTO, err error) *TransactionUsecaseMock {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("TransactionUsecaseMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &TransactionUsecaseMockFindOneByIDExpectation{mock: mmFindOneByID.mock}
	}
	mmFindOneByID.defaultExpectation.results = &TransactionUsecaseMockFindOneByIDResults{resItem, err}
	mmFindOneByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindOneByID.mock
}

// Set uses given function f to mock the TransactionUsecase.FindOneByID method
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) Set(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (resItem *mm_usecase.TransactionDTO, err error)) *TransactionUsecaseMock {
	if mmFindOneByID.defaultExpectation != nil {
		mmFindOneByID.mock.t.Fatalf("Default expectation is already set for the TransactionUsecase.FindOneByID method")
	}

	if len(mmFindOneByID.expectations) > 0 {
		mmFindOneByID.mock.t.Fatalf("Some expectations are already set for the TransactionUsecase.FindOneByID method")
	}

	mmFindOneByID.mock.funcFindOneByID = f
	mmFindOneByID.mock.funcFindOneByIDOrigin = minimock.CallerInfo(1)
	return mmFindOneByID.mock
}

// When sets expectation for the TransactionUsecase.FindOneByID which will trigger the result defined by the following
// Then helper
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) When(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *TransactionUsecaseMockFindOneByIDExpectation {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("TransactionUsecaseMock.FindOneByID mock is already set by Set")
	}

	expectation := &TransactionUsecaseMockFindOneByIDExpectation{
		mock:               mmFindOneByID.mock,
		params:             &TransactionUsecaseMockFindOneByIDParams{ctx, id, queryParams},
		expectationOrigins: TransactionUsecaseMockFindOneByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindOneByID.expectations = append(mmFindOneByID.expectations, expectation)
	return expectation
}

// Then sets up TransactionUsecase.FindOneByID return parameters for the expectation previously defined by the When method
func (e *TransactionUsecaseMockFindOneByIDExpectation) Then(resItem *mm_usecase.TransactionDTO, err error) *TransactionUsecaseMock {
	e.results = &TransactionUsecaseMockFindOneByIDResults{resItem, err}
	return e.mock
}

// Times sets number of times TransactionUsecase.FindOneByID should be invoked
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) Times(n uint64) *mTransactionUsecaseMockFindOneByID {
	if n == 0 {
		mmFindOneByID.mock.t.Fatalf("Times of TransactionUsecaseMock.FindOneByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindOneByID.expectedInvocations, n)
	mmFindOneByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindOneByID
}

func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) invocationsDone() bool {
	if len(mmFindOneByID.expectations) == 0 && mmFindOneByID.defaultExpectation == nil && mmFindOneByID.mock.funcFindOneByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindOneByID.mock.afterFindOneByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindOneByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindOneByID implements mm_usecase.TransactionUsecase
func (mmFindOneByID *TransactionUsecaseMock) FindOneByID(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (resItem *mm_usecase.TransactionDTO, err error) {
	mm_atomic.AddUint64(&mmFindOneByID.beforeFindOneByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmFindOneByID.afterFindOneByIDCounter, 1)

	mmFindOneByID.t.Helper()

	if mmFindOneByID.inspectFuncFindOneByID != nil {
		mmFindOneByID.inspectFuncFindOneByID(ctx, id, queryParams)
	}

	mm_params := TransactionUsecaseMockFindOneByIDParams{ctx, id, queryParams}

	// Record call args
	mmFindOneByID.FindOneByIDMock.mutex.Lock()
	mmFindOneByID.FindOneByIDMock.callArgs = append(mmFindOneByID.FindOneByIDMock.callArgs, &mm_params)
	mmFindOneByID.FindOneByIDMock.mutex.Unlock()

	for _, e := range mmFindOneByID.FindOneByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resItem, e.results.err
		}
	}

	if mmFindOneByID.FindOneByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindOneByID.FindOneByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmFindOneByID.FindOneByIDMock.defaultExpectation.params
		mm_want_ptrs := mmFindOneByID.FindOneByIDMock.defaultExpectation.paramPtrs

		mm_got := TransactionUsecaseMockFindOneByIDParams{ctx, id, queryParams}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindOneByID.t.Errorf("TransactionUsecaseMock.FindOneByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmFindOneByID.t.Errorf("TransactionUsecaseMock.FindOneByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.queryParams != nil && !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) {
				mmFindOneByID.t.Errorf("TransactionUsecaseMock.FindOneByID got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindOneByID.t.Errorf("TransactionUsecaseMock.FindOneByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindOneByID.FindOneByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmFindOneByID.t.Fatal("No results are set for the TransactionUsecaseMock.FindOneByID")
		}
		return (*mm_results).resItem, (*mm_results).err
	}
	if mmFindOneByID.funcFindOneByID != nil {
		return mmFindOneByID.funcFindOneByID(ctx, id, queryParams)
	}
	mmFindOneByID.t.Fatalf("Unexpected call to TransactionUsecaseMock.FindOneByID. %v %v %v", ctx, id, queryParams)
	return
}

// FindOneByIDAfterCounter returns a count of finished TransactionUsecaseMock.FindOneByID invocations
func (mmFindOneByID *TransactionUsecaseMock) FindOneByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindOneByID.afterFindOneByIDCounter)
}

// FindOneByIDBeforeCounter returns a count of TransactionUsecaseMock.FindOneByID invocations
func (mmFindOneByID *TransactionUsecaseMock) FindOneByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindOneByID.beforeFindOneByIDCounter)
}

// Calls returns a list of arguments used in each call to TransactionUsecaseMock.FindOneByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) Calls() []*TransactionUsecaseMockFindOneByIDParams {
	mmFindOneByID.mutex.RLock()

	argCopy := make([]*TransactionUsecaseMockFindOneByIDParams, len(mmFindOneByID.callArgs))
	copy(argCopy, mmFindOneByID.callArgs)

	mmFindOneByID.mutex.RUnlock()

	return argCopy
}

// MinimockFindOneByIDDone returns true if the count of the FindOneByID invocations corresponds
// the number of defined expectations
func (m *TransactionUsecaseMock) MinimockFindOneByIDDone() bool {
	if m.FindOneByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindOneByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindOneByIDMock.invocationsDone()
}

// MinimockFindOneByIDInspect logs each unmet expectation
func (m *TransactionUsecaseMock) MinimockFindOneByIDInspect() {
	for _, e := range m.FindOneByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionUsecaseMock.FindOneByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindOneByIDCounter := mm_atomic.LoadUint64(&m.afterFindOneByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindOneByIDMock.defaultExpectation != nil && afterFindOneByIDCounter < 1 {
		if m.FindOneByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionUsecaseMock.FindOneByID at\n%s", m.FindOneByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionUsecaseMock.FindOneByID at\n%s with params: %#v", m.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *m.FindOneByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindOneByID != nil && afterFindOneByIDCounter < 1 {
		m.t.Errorf("Expected call to TransactionUsecaseMock.FindOneByID at\n%s", m.funcFindOneByIDOrigin)
	}

	if !m.FindOneByIDMock.invocationsDone() && afterFindOneByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionUsecaseMock.FindOneByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindOneByIDMock.expectedInvocations), m.FindOneByIDMock.expectedInvocationsOrigin, afterFindOneByIDCounter)
	}
}

type mTransactionUsecaseMockFindPagedList struct {
	optional           bool
	mock               *TransactionUsecaseMock
	defaultExpectation *TransactionUsecaseMockFindPagedListExpectation
	expectations       []*TransactionUsecaseMockFindPagedListExpectation

	callArgs []*TransactionUsecaseMockFindPagedListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionUsecaseMockFindPagedListExpectation specifies expectation struct of the TransactionUsecase.FindPagedList
type TransactionUsecaseMockFindPagedListExpectation struct {
	mock               *TransactionUsecaseMock
	params             *TransactionUsecaseMockFindPagedListParams
	paramPtrs          *TransactionUsecaseMockFindPagedListParamPtrs
	expectationOrigins TransactionUsecaseMockFindPagedListExpectationOrigins
	results            *TransactionUsecaseMockFindPagedListResults
	returnOrigin       string
	Counter            uint64
}

// TransactionUsecaseMockFindPagedListParams contains parameters of the TransactionUsecase.FindPagedList
type TransactionUsecaseMockFindPagedListParams struct {
	ctx         context.Context
	listOptions *mm_usecase.TransactionListOptions
	queryParams *uctypes.QueryGetListParams
}

// TransactionUsecaseMockFindPagedListParamPtrs contains pointers to parameters of the TransactionUsecase.FindPagedList
type TransactionUsecaseMockFindPagedListParamPtrs struct {
	ctx         *context.Context
	listOptions **mm_usecase.TransactionListOptions
	queryParams **uctypes.QueryGetListParams
}

// TransactionUsecaseMockFindPagedListResults contains results of the TransactionUsecase.FindPagedList
type TransactionUsecaseMockFindPagedListResults struct {
	resItems []*mm_usecase.TransactionDTO
	total    uint64
	err      error
}

// TransactionUsecaseMockFindPagedListOrigins contains origins of expectations of the TransactionUsecase.FindPagedList
type TransactionUsecaseMockFindPagedListExpectationOrigins struct {
	origin            string
	originCtx         string
	originListOptions string
	originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) Optional() *mTransactionUsecaseMockFindPagedList {
	mmFindPagedList.optional = true
	return mmFindPagedList
}

// Expect sets up expected params for TransactionUsecase.FindPagedList
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) Expect(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *mTransactionUsecaseMockFindPagedList {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("TransactionUsecaseMock.FindPagedList mock is already set by Set")
	}

	if mmFindPagedList.defaultExpectation == nil {
		mmFindPagedList.defaultExpectation = &TransactionUsecaseMockFindPagedListExpectation{}
	}

	if mmFindPagedList.defaultExpectation.paramPtrs != nil {
		mmFindPagedList.mock.t.Fatalf("TransactionUsecaseMock.FindPagedList mock is already set by ExpectParams functions")
	}

	mmFindPagedList.defaultExpectation.params = &TransactionUsecaseMockFindPagedListParams{ctx, listOptions, queryParams}
	mmFindPagedList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindPagedList.expectations {
		if minimock.Equal(e.params, mmFindPagedList.defaultExpectation.params) {
			mmFindPagedList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindPagedList.defaultExpectation.params)
		}
	}

	return mmFindPagedList
}

// ExpectCtxParam1 sets up expected param ctx for TransactionUsecase.FindPagedList
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) ExpectCtxParam1(ctx context.Context) *mTransactionUsecaseMockFindPagedList {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("TransactionUsecaseMock.FindPagedList mock is already set by Set")
	}

	if mmFindPagedList.defaultExpectation == nil {
		mmFindPagedList.defaultExpectation = &TransactionUsecaseMockFindPagedListExpectation{}
	}

	if mmFindPagedList.defaultExpectation.params != nil {
		mmFindPagedList.mock.t.Fatalf("TransactionUsecaseMock.FindPagedList mock is already set by Expect")
	}

	if mmFindPagedList.defaultExpectation.paramPtrs == nil {
		mmFindPagedList.defaultExpectation.paramPtrs = &TransactionUsecaseMockFindPagedListParamPtrs{}
	}
	mmFindPagedList.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindPagedList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindPagedList
}

// ExpectListOptionsParam2 sets up expected param listOptions for TransactionUsecase.FindPagedList
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) ExpectListOptionsParam2(listOptions *mm_usecase.TransactionListOptions) *mTransactionUsecaseMockFindPagedList {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("TransactionUsecaseMock.FindPagedList mock is already set by Set")
	}

	if mmFindPagedList.defaultExpectation == nil {
		mmFindPagedList.defaultExpectation = &TransactionUsecaseMockFindPagedListExpectation{}
	}

	if mmFindPagedList.defaultExpectation.params != nil {
		mmFindPagedList.mock.t.Fatalf("TransactionUsecaseMock.FindPagedList mock is already set by Expect")
	}

	if mmFindPagedList.defaultExpectation.paramPtrs == nil {
		mmFindPagedList.defaultExpectation.paramPtrs = &TransactionUsecaseMockFindPagedListParamPtrs{}
	}
	mmFindPagedList.defaultExpectation.paramPtrs.listOptions = &listOptions
	mmFindPagedList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

	return mmFindPagedList
}

// ExpectQueryParamsParam3 sets up expected param queryParams for TransactionUsecase.FindPagedList
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mTransactionUsecaseMockFindPagedList {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("TransactionUsecaseMock.FindPagedList mock is already set by Set")
	}

	if mmFindPagedList.defaultExpectation == nil {
		mmFindPagedList.defaultExpectation = &TransactionUsecaseMockFindPagedListExpectation{}
	}

	if mmFindPagedList.defaultExpectation.params != nil {
		mmFindPagedList.mock.t.Fatalf("TransactionUsecaseMock.FindPagedList mock is already set by Expect")
	}

	if mmFindPagedList.defaultExpectation.paramPtrs == nil {
		mmFindPagedList.defaultExpectation.paramPtrs = &TransactionUsecaseMockFindPagedListParamPtrs{}
	}
	mmFindPagedList.defaultExpectation.paramPtrs.queryParams = &queryParams
	mmFindPagedList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

	return mmFindPagedList
}

// Inspect accepts an inspector function that has same arguments as the TransactionUsecase.FindPagedList
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)) *mTransactionUsecaseMockFindPagedList {
	if mmFindPagedList.mock.inspectFuncFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("Inspect function is already set for TransactionUsecaseMock.FindPagedList")
	}

	mmFindPagedList.mock.inspectFuncFindPagedList = f

	return mmFindPagedList
}

// Return sets up results that will be returned by TransactionUsecase.FindPagedList
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) Return(resItems []*mm_usecase.TransactionDTO, total uint64, err error) *TransactionUsecaseMock {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("TransactionUsecaseMock.FindPagedList mock is already set by Set")
	}

	if mmFindPagedList.defaultExpectation == nil {
		mmFindPagedList.defaultExpectation = &TransactionUsecaseMockFindPagedListExpectation{mock: mmFindPagedList.mock}
	}
	mmFindPagedList.defaultExpectation.results = &TransactionUsecaseMockFindPagedListResults{resItems, total, err}
	mmFindPagedList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindPagedList.mock
}

// Set uses given function f to mock the TransactionUsecase.FindPagedList method
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) Set(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.TransactionDTO, total uint64, err error)) *TransactionUsecaseMock {
	if mmFindPagedList.defaultExpectation != nil {
		mmFindPagedList.mock.t.Fatalf("Default expectation is already set for the TransactionUsecase.FindPagedList method")
	}

	if len(mmFindPagedList.expectations) > 0 {
		mmFindPagedList.mock.t.Fatalf("Some expectations are already set for the TransactionUsecase.FindPagedList method")
	}

	mmFindPagedList.mock.funcFindPagedList = f
	mmFindPagedList.mock.funcFindPagedListOrigin = minimock.CallerInfo(1)
	return mmFindPagedList.mock
}

// When sets expectation for the TransactionUsecase.FindPagedList which will trigger the result defined by the following
// Then helper
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) When(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *TransactionUsecaseMockFindPagedListExpectation {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("TransactionUsecaseMock.FindPagedList mock is already set by Set")
	}

	expectation := &TransactionUsecaseMockFindPagedListExpectation{
		mock:               mmFindPagedList.mock,
		params:             &TransactionUsecaseMockFindPagedListParams{ctx, listOptions, queryParams},
		expectationOrigins: TransactionUsecaseMockFindPagedListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindPagedList.expectations = append(mmFindPagedList.expectations, expectation)
	return expectation
}

// Then sets up TransactionUsecase.FindPagedList return parameters for the expectation previously defined by the When method
func (e *TransactionUsecaseMockFindPagedListExpectation) Then(resItems []*mm_usecase.TransactionDTO, total uint64, err error) *TransactionUsecaseMock {
	e.results = &TransactionUsecaseMockFindPagedListResults{resItems, total, err}
	return e.mock
}

// Times sets number of times TransactionUsecase.FindPagedList should be invoked
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) Times(n uint64) *mTransactionUsecaseMockFindPagedList {
	if n == 0 {
		mmFindPagedList.mock.t.Fatalf("Times of TransactionUsecaseMock.FindPagedList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindPagedList.expectedInvocations, n)
	mmFindPagedList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindPagedList
}

func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) invocationsDone() bool {
	if len(mmFindPagedList.expectations) == 0 && mmFindPagedList.defaultExpectation == nil && mmFindPagedList.mock.funcFindPagedList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindPagedList.mock.afterFindPagedListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindPagedList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindPagedList implements mm_usecase.TransactionUsecase
func (mmFindPagedList *TransactionUsecaseMock) FindPagedList(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.TransactionDTO, total uint64, err error) {
	mm_atomic.AddUint64(&mmFindPagedList.beforeFindPagedListCounter, 1)
	defer mm_atomic.AddUint64(&mmFindPagedList.afterFindPagedListCounter, 1)

	mmFindPagedList.t.Helper()

	if mmFindPagedList.inspectFuncFindPagedList != nil {
		mmFindPagedList.inspectFuncFindPagedList(ctx, listOptions, queryParams)
	}

	mm_params := TransactionUsecaseMockFindPagedListParams{ctx, listOptions, queryParams}

	// Record call args
	mmFindPagedList.FindPagedListMock.mutex.Lock()
	mmFindPagedList.FindPagedListMock.callArgs = append(mmFindPagedList.FindPagedListMock.callArgs, &mm_params)
	mmFindPagedList.FindPagedListMock.mutex.Unlock()

	for _, e := range mmFindPagedList.FindPagedListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resItems, e.results.total, e.results.err
		}
	}

	if mmFindPagedList.FindPagedListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindPagedList.FindPagedListMock.defaultExpectation.Counter, 1)
		mm_want := mmFindPagedList.FindPagedListMock.defaultExpectation.params
		mm_want_ptrs := mmFindPagedList.FindPagedListMock.defaultExpectation.paramPtrs

		mm_got := TransactionUsecaseMockFindPagedListParams{ctx, listOptions, queryParams}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindPagedList.t.Errorf("TransactionUsecaseMock.FindPagedList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.listOptions != nil && !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) {
				mmFindPagedList.t.Errorf("TransactionUsecaseMock.FindPagedList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
			}

			if mm_want_ptrs.queryParams != nil && !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) {
				mmFindPagedList.t.Errorf("TransactionUsecaseMock.FindPagedList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindPagedList.t.Errorf("TransactionUsecaseMock.FindPagedList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindPagedList.FindPagedListMock.defaultExpectation.results
		if mm_results == nil {
			mmFindPagedList.t.Fatal("No results are set for the TransactionUsecaseMock.FindPagedList")
		}
		return (*mm_results).resItems, (*mm_results).total, (*mm_results).err
	}
	if mmFindPagedList.funcFindPagedList != nil {
		return mmFindPagedList.funcFindPagedList(ctx, listOptions, queryParams)
	}
	mmFindPagedList.t.Fatalf("Unexpected call to TransactionUsecaseMock.FindPagedList. %v %v %v", ctx, listOptions, queryParams)
	return
}

// FindPagedListAfterCounter returns a count of finished TransactionUsecaseMock.FindPagedList invocations
func (mmFindPagedList *TransactionUsecaseMock) FindPagedListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindPagedList.afterFindPagedListCounter)
}

// FindPagedListBeforeCounter returns a count of TransactionUsecaseMock.FindPagedList invocations
func (mmFindPagedList *TransactionUsecaseMock) FindPagedListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindPagedList.beforeFindPagedListCounter)
}

// Calls returns a list of arguments used in each call to TransactionUsecaseMock.FindPagedList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) Calls() []*TransactionUsecaseMockFindPagedListParams {
	mmFindPagedList.mutex.RLock()

	argCopy := make([]*TransactionUsecaseMockFindPagedListParams, len(mmFindPagedList.callArgs))
	copy(argCopy, mmFindPagedList.callArgs)

	mmFindPagedList.mutex.RUnlock()

	return argCopy
}

// MinimockFindPagedListDone returns true if the count of the FindPagedList invocations corresponds
// the number of defined expectations
func (m *TransactionUsecaseMock) MinimockFindPagedListDone() bool {
	if m.FindPagedListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindPagedListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindPagedListMock.invocationsDone()
}

// MinimockFindPagedListInspect logs each unmet expectation
func (m *TransactionUsecaseMock) MinimockFindPagedListInspect() {
	for _, e := range m.FindPagedListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionUsecaseMock.FindPagedList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindPagedListCounter := mm_atomic.LoadUint64(&m.afterFindPagedListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindPagedListMock.defaultExpectation != nil && afterFindPagedListCounter < 1 {
		if m.FindPagedListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionUsecaseMock.FindPagedList at\n%s", m.FindPagedListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionUsecaseMock.FindPagedList at\n%s with params: %#v", m.FindPagedListMock.defaultExpectation.expectationOrigins.origin, *m.FindPagedListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindPagedList != nil && afterFindPagedListCounter < 1 {
		m.t.Errorf("Expected call to TransactionUsecaseMock.FindPagedList at\n%s", m.funcFindPagedListOrigin)
	}

	if !m.FindPagedListMock.invocationsDone() && afterFindPagedListCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionUsecaseMock.FindPagedList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindPagedListMock.expectedInvocations), m.FindPagedListMock.expectedInvocationsOrigin, afterFindPagedListCounter)
	}
}

type mTransactionUsecaseMockFindPagedListAsCSV struct {
	optional           bool
	mock               *TransactionUsecaseMock
	defaultExpectation *TransactionUsecaseMockFindPagedListAsCSVExpectation
	expectations       []*TransactionUsecaseMockFindPagedListAsCSVExpectation

	callArgs []*TransactionUsecaseMockFindPagedListAsCSVParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionUsecaseMockFindPagedListAsCSVExpectation specifies expectation struct of the TransactionUsecase.FindPagedListAsCSV
type TransactionUsecaseMockFindPagedListAsCSVExpectation struct {
	mock               *TransactionUsecaseMock
	params             *TransactionUsecaseMockFindPagedListAsCSVParams
	paramPtrs          *TransactionUsecaseMockFindPagedListAsCSVParamPtrs
	expectationOrigins TransactionUsecaseMockFindPagedListAsCSVExpectationOrigins
	results            *TransactionUsecaseMockFindPagedListAsCSVResults
	returnOrigin       string
	Counter            uint64
}

// TransactionUsecaseMockFindPagedListAsCSVParams contains parameters of the TransactionUsecase.FindPagedListAsCSV
type TransactionUsecaseMockFindPagedListAsCSVParams struct {
	ctx         context.Context
	listOptions *mm_usecase.TransactionListOptions
	queryParams *uctypes.QueryGetListParams
}

// TransactionUsecaseMockFindPagedListAsCSVParamPtrs contains pointers to parameters of the TransactionUsecase.FindPagedListAsCSV
type TransactionUsecaseMockFindPagedListAsCSVParamPtrs struct {
	ctx         *context.Context
	listOptions **mm_usecase.TransactionListOptions
	queryParams **uctypes.QueryGetListParams
}

// TransactionUsecaseMockFindPagedListAsCSVResults contains results of the TransactionUsecase.FindPagedListAsCSV
type TransactionUsecaseMockFindPagedListAsCSVResults struct {
	res   []byte
	total uint64
	err   error
}

// TransactionUsecaseMockFindPagedListAsCSVOrigins contains origins of expectations of the TransactionUsecase.FindPagedListAsCSV
type TransactionUsecaseMockFindPagedListAsCSVExpectationOrigins struct {
	origin            string
	originCtx         string
	originListOptions string
	originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) Optional() *mTransactionUsecaseMockFindPagedListAsCSV {
	mmFindPagedListAsCSV.optional = true
	return mmFindPagedListAsCSV
}

// Expect sets up expected params for TransactionUsecase.FindPagedListAsCSV
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) Expect(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *mTransactionUsecaseMockFindPagedListAsCSV {
	if mmFindPagedListAsCSV.mock.funcFindPagedListAsCSV != nil {
		mmFindPagedListAsCSV.mock.t.Fatalf("TransactionUsecaseMock.FindPagedListAsCSV mock is already set by Set")
	}

	if mmFindPagedListAsCSV.defaultExpectation == nil {
		mmFindPagedListAsCSV.defaultExpectation = &TransactionUsecaseMockFindPagedListAsCSVExpectation{}
	}

	if mmFindPagedListAsCSV.defaultExpectation.paramPtrs != nil {
		mmFindPagedListAsCSV.mock.t.Fatalf("TransactionUsecaseMock.FindPagedListAsCSV mock is already set by ExpectParams functions")
	}

	mmFindPagedListAsCSV.defaultExpectation.params = &TransactionUsecaseMockFindPagedListAsCSVParams{ctx, listOptions, queryParams}
	mmFindPagedListAsCSV.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindPagedListAsCSV.expectations {
		if minimock.Equal(e.params, mmFindPagedListAsCSV.defaultExpectation.params) {
			mmFindPagedListAsCSV.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindPagedListAsCSV.defaultExpectation.params)
		}
	}

	return mmFindPagedListAsCSV
}

// ExpectCtxParam1 sets up expected param ctx for TransactionUsecase.FindPagedListAsCSV
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) ExpectCtxParam1(ctx context.Context) *mTransactionUsecaseMockFindPagedListAsCSV {
	if mmFindPagedListAsCSV.mock.funcFindPagedListAsCSV != nil {
		mmFindPagedListAsCSV.mock.t.Fatalf("TransactionUsecaseMock.FindPagedListAsCSV mock is already set by Set")
	}

	if mmFindPagedListAsCSV.defaultExpectation == nil {
		mmFindPagedListAsCSV.defaultExpectation = &TransactionUsecaseMockFindPagedListAsCSVExpectation{}
	}

	if mmFindPagedListAsCSV.defaultExpectation.params != nil {
		mmFindPagedListAsCSV.mock.t.Fatalf("TransactionUsecaseMock.FindPagedListAsCSV mock is already set by Expect")
	}

	if mmFindPagedListAsCSV.defaultExpectation.paramPtrs == nil {
		mmFindPagedListAsCSV.defaultExpectation.paramPtrs = &TransactionUsecaseMockFindPagedListAsCSVParamPtrs{}
	}
	mmFindPagedListAsCSV.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindPagedListAsCSV.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindPagedListAsCSV
}

// ExpectListOptionsParam2 sets up expected param listOptions for TransactionUsecase.FindPagedListAsCSV
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) ExpectListOptionsParam2(listOptions *mm_usecase.TransactionListOptions) *mTransactionUsecaseMockFindPagedListAsCSV {
	if mmFindPagedListAsCSV.mock.funcFindPagedListAsCSV != nil {
		mmFindPagedListAsCSV.mock.t.Fatalf("TransactionUsecaseMock.FindPagedListAsCSV mock is already set by Set")
	}

	if mmFindPagedListAsCSV.defaultExpectation == nil {
		mmFindPagedListAsCSV.defaultExpectation = &TransactionUsecaseMockFindPagedListAsCSVExpectation{}
	}

	if mmFindPagedListAsCSV.defaultExpectation.params != nil {
		mmFindPagedListAsCSV.mock.t.Fatalf("TransactionUsecaseMock.FindPagedListAsCSV mock is already set by Expect")
	}

	if mmFindPagedListAsCSV.defaultExpectation.paramPtrs == nil {
		mmFindPagedListAsCSV.defaultExpectation.paramPtrs = &TransactionUsecaseMockFindPagedListAsCSVParamPtrs{}
	}
	mmFindPagedListAsCSV.defaultExpectation.paramPtrs.listOptions = &listOptions
	mmFindPagedListAsCSV.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

	return mmFindPagedListAsCSV
}

// ExpectQueryParamsParam3 sets up expected param queryParams for TransactionUsecase.FindPagedListAsCSV
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mTransactionUsecaseMockFindPagedListAsCSV {
	if mmFindPagedListAsCSV.mock.funcFindPagedListAsCSV != nil {
		mmFindPagedListAsCSV.mock.t.Fatalf("TransactionUsecaseMock.FindPagedListAsCSV mock is already set by Set")
	}

	if mmFindPagedListAsCSV.defaultExpectation == nil {
		mmFindPagedListAsCSV.defaultExpectation = &TransactionUsecaseMockFindPagedListAsCSVExpectation{}
	}

	if mmFindPagedListAsCSV.defaultExpectation.params != nil {
		mmFindPagedListAsCSV.mock.t.Fatalf("TransactionUsecaseMock.FindPagedListAsCSV mock is already set by Expect")
	}

	if mmFindPagedListAsCSV.defaultExpectation.paramPtrs == nil {
		mmFindPagedListAsCSV.defaultExpectation.paramPtrs = &TransactionUsecaseMockFindPagedListAsCSVParamPtrs{}
	}
	mmFindPagedListAsCSV.defaultExpectation.paramPtrs.queryParams = &queryParams
	mmFindPagedListAsCSV.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

	return mmFindPagedListAsCSV
}

// Inspect accepts an inspector function that has same arguments as the TransactionUsecase.FindPagedListAsCSV
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) Inspect(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)) *mTransactionUsecaseMockFindPagedListAsCSV {
	if mmFindPagedListAsCSV.mock.inspectFuncFindPagedListAsCSV != nil {
		mmFindPagedListAsCSV.mock.t.Fatalf("Inspect function is already set for TransactionUsecaseMock.FindPagedListAsCSV")
	}

	mmFindPagedListAsCSV.mock.inspectFuncFindPagedListAsCSV = f

	return mmFindPagedListAsCSV
}

// Return sets up results that will be returned by TransactionUsecase.FindPagedListAsCSV
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) Return(res []byte, total uint64, err error) *TransactionUsecaseMock {
	if mmFindPagedListAsCSV.mock.funcFindPagedListAsCSV != nil {
		mmFindPagedListAsCSV.mock.t.Fatalf("TransactionUsecaseMock.FindPagedListAsCSV mock is already set by Set")
	}

	if mmFindPagedListAsCSV.defaultExpectation == nil {
		mmFindPagedListAsCSV.defaultExpectation = &TransactionUsecaseMockFindPagedListAsCSVExpectation{mock: mmFindPagedListAsCSV.mock}
	}
	mmFindPagedListAsCSV.defaultExpectation.results = &TransactionUsecaseMockFindPagedListAsCSVResults{res, total, err}
	mmFindPagedListAsCSV.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindPagedListAsCSV.mock
}

// Set uses given function f to mock the TransactionUsecase.FindPagedListAsCSV method
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) Set(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (res []byte, total uint64, err error)) *TransactionUsecaseMock {
	if mmFindPagedListAsCSV.defaultExpectation != nil {
		mmFindPagedListAsCSV.mock.t.Fatalf("Default expectation is already set for the TransactionUsecase.FindPagedListAsCSV method")
	}

	if len(mmFindPagedListAsCSV.expectations) > 0 {
		mmFindPagedListAsCSV.mock.t.Fatalf("Some expectations are already set for the TransactionUsecase.FindPagedListAsCSV method")
	}

	mmFindPagedListAsCSV.mock.funcFindPagedListAsCSV = f
	mmFindPagedListAsCSV.mock.funcFindPagedListAsCSVOrigin = minimock.CallerInfo(1)
	return mmFindPagedListAsCSV.mock
}

// When sets expectation for the TransactionUsecase.FindPagedListAsCSV which will trigger the result defined by the following
// Then helper
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) When(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *TransactionUsecaseMockFindPagedListAsCSVExpectation {
	if mmFindPagedListAsCSV.mock.funcFindPagedListAsCSV != nil {
		mmFindPagedListAsCSV.mock.t.Fatalf("TransactionUsecaseMock.FindPagedListAsCSV mock is already set by Set")
	}

	expectation := &TransactionUsecaseMockFindPagedListAsCSVExpectation{
		mock:               mmFindPagedListAsCSV.mock,
		params:             &TransactionUsecaseMockFindPagedListAsCSVParams{ctx, listOptions, queryParams},
		expectationOrigins: TransactionUsecaseMockFindPagedListAsCSVExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindPagedListAsCSV.expectations = append(mmFindPagedListAsCSV.expectations, expectation)
	return expectation
}

// Then sets up TransactionUsecase.FindPagedListAsCSV return parameters for the expectation previously defined by the When method
func (e *TransactionUsecaseMockFindPagedListAsCSVExpectation) Then(res []byte, total uint64, err error) *TransactionUsecaseMock {
	e.results = &TransactionUsecaseMockFindPagedListAsCSVResults{res, total, err}
	return e.mock
}

// Times sets number of times TransactionUsecase.FindPagedListAsCSV should be invoked
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) Times(n uint64) *mTransactionUsecaseMockFindPagedListAsCSV {
	if n == 0 {
		mmFindPagedListAsCSV.mock.t.Fatalf("Times of TransactionUsecaseMock.FindPagedListAsCSV mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindPagedListAsCSV.expectedInvocations, n)
	mmFindPagedListAsCSV.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindPagedListAsCSV
}

func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) invocationsDone() bool {
	if len(mmFindPagedListAsCSV.expectations) == 0 && mmFindPagedListAsCSV.defaultExpectation == nil && mmFindPagedListAsCSV.mock.funcFindPagedListAsCSV == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindPagedListAsCSV.mock.afterFindPagedListAsCSVCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindPagedListAsCSV.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindPagedListAsCSV implements mm_usecase.TransactionUsecase
func (mmFindPagedListAsCSV *TransactionUsecaseMock) FindPagedListAsCSV(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (res []byte, total uint64, err error) {
	mm_atomic.AddUint64(&mmFindPagedListAsCSV.beforeFindPagedListAsCSVCounter, 1)
	defer mm_atomic.AddUint64(&mmFindPagedListAsCSV.afterFindPagedListAsCSVCounter, 1)

	mmFindPagedListAsCSV.t.Helper()

	if mmFindPagedListAsCSV.inspectFuncFindPagedListAsCSV != nil {
		mmFindPagedListAsCSV.inspectFuncFindPagedListAsCSV(ctx, listOptions, queryParams)
	}

	mm_params := TransactionUsecaseMockFindPagedListAsCSVParams{ctx, listOptions, queryParams}

	// Record call args
	mmFindPagedListAsCSV.FindPagedListAsCSVMock.mutex.Lock()
	mmFindPagedListAsCSV.FindPagedListAsCSVMock.callArgs = append(mmFindPagedListAsCSV.FindPagedListAsCSVMock.callArgs, &mm_params)
	mmFindPagedListAsCSV.FindPagedListAsCSVMock.mutex.Unlock()

	for _, e := range mmFindPagedListAsCSV.FindPagedListAsCSVMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.res, e.results.total, e.results.err
		}
	}

	if mmFindPagedListAsCSV.FindPagedListAsCSVMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindPagedListAsCSV.FindPagedListAsCSVMock.defaultExpectation.Counter, 1)
		mm_want := mmFindPagedListAsCSV.FindPagedListAsCSVMock.defaultExpectation.params
		mm_want_ptrs := mmFindPagedListAsCSV.FindPagedListAsCSVMock.defaultExpectation.paramPtrs

		mm_got := TransactionUsecaseMockFindPagedListAsCSVParams{ctx, listOptions, queryParams}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindPagedListAsCSV.t.Errorf("TransactionUsecaseMock.FindPagedListAsCSV got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindPagedListAsCSV.FindPagedListAsCSVMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.listOptions != nil && !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) {
				mmFindPagedListAsCSV.t.Errorf("TransactionUsecaseMock.FindPagedListAsCSV got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindPagedListAsCSV.FindPagedListAsCSVMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
			}

			if mm_want_ptrs.queryParams != nil && !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) {
				mmFindPagedListAsCSV.t.Errorf("TransactionUsecaseMock.FindPagedListAsCSV got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindPagedListAsCSV.FindPagedListAsCSVMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindPagedListAsCSV.t.Errorf("TransactionUsecaseMock.FindPagedListAsCSV got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindPagedListAsCSV.FindPagedListAsCSVMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindPagedListAsCSV.FindPagedListAsCSVMock.defaultExpectation.results
		if mm_results == nil {
			mmFindPagedListAsCSV.t.Fatal("No results are set for the TransactionUsecaseMock.FindPagedListAsCSV")
		}
		return (*mm_results).res, (*mm_results).total, (*mm_results).err
	}
	if mmFindPagedListAsCSV.funcFindPagedListAsCSV != nil {
		return mmFindPagedListAsCSV.funcFindPagedListAsCSV(ctx, listOptions, queryParams)
	}
	mmFindPagedListAsCSV.t.Fatalf("Unexpected call to TransactionUsecaseMock.FindPagedListAsCSV. %v %v %v", ctx, listOptions, queryParams)
	return
}

// FindPagedListAsCSVAfterCounter returns a count of finished TransactionUsecaseMock.FindPagedListAsCSV invocations
func (mmFindPagedListAsCSV *TransactionUsecaseMock) FindPagedListAsCSVAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindPagedListAsCSV.afterFindPagedListAsCSVCounter)
}

// FindPagedListAsCSVBeforeCounter returns a count of TransactionUsecaseMock.FindPagedListAsCSV invocations
func (mmFindPagedListAsCSV *TransactionUsecaseMock) FindPagedListAsCSVBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindPagedListAsCSV.beforeFindPagedListAsCSVCounter)
}

// Calls returns a list of arguments used in each call to TransactionUsecaseMock.FindPagedListAsCSV.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) Calls() []*TransactionUsecaseMockFindPagedListAsCSVParams {
	mmFindPagedListAsCSV.mutex.RLock()

	argCopy := make([]*TransactionUsecaseMockFindPagedListAsCSVParams, len(mmFindPagedListAsCSV.callArgs))
	copy(argCopy, mmFindPagedListAsCSV.callArgs)

	mmFindPagedListAsCSV.mutex.RUnlock()

	return argCopy
}

// MinimockFindPagedListAsCSVDone returns true if the count of the FindPagedListAsCSV invocations corresponds
// the number of defined expectations
func (m *TransactionUsecaseMock) MinimockFindPagedListAsCSVDone() bool {
	if m.FindPagedListAsCSVMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindPagedListAsCSVMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindPagedListAsCSVMock.invocationsDone()
}

// MinimockFindPagedListAsCSVInspect logs each unmet expectation
func (m *TransactionUsecaseMock) MinimockFindPagedListAsCSVInspect() {
	for _, e := range m.FindPagedListAsCSVMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionUsecaseMock.FindPagedListAsCSV at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindPagedListAsCSVCounter := mm_atomic.LoadUint64(&m.afterFindPagedListAsCSVCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindPagedListAsCSVMock.defaultExpectation != nil && afterFindPagedListAsCSVCounter < 1 {
		if m.FindPagedListAsCSVMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionUsecaseMock.FindPagedListAsCSV at\n%s", m.FindPagedListAsCSVMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionUsecaseMock.FindPagedListAsCSV at\n%s with params: %#v", m.FindPagedListAsCSVMock.defaultExpectation.expectationOrigins.origin, *m.FindPagedListAsCSVMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindPagedListAsCSV != nil && afterFindPagedListAsCSVCounter < 1 {
		m.t.Errorf("Expected call to TransactionUsecaseMock.FindPagedListAsCSV at\n%s", m.funcFindPagedListAsCSVOrigin)
	}

	if !m.FindPagedListAsCSVMock.invocationsDone() && afterFindPagedListAsCSVCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionUsecaseMock.FindPagedListAsCSV at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindPagedListAsCSVMock.expectedInvocations), m.FindPagedListAsCSVMock.expectedInvocationsOrigin, afterFindPagedListAsCSVCounter)
	}
}

type mTransactionUsecaseMockImportTransactionsFromCSV struct {
	optional           bool
	mock               *TransactionUsecaseMock
	defaultExpectation *TransactionUsecaseMockImportTransactionsFromCSVExpectation
	expectations       []*TransactionUsecaseMockImportTransactionsFromCSVExpectation

	callArgs []*TransactionUsecaseMockImportTransactionsFromCSVParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionUsecaseMockImportTransactionsFromCSVExpectation specifies expectation struct of the TransactionUsecase.ImportTransactionsFromCSV
type TransactionUsecaseMockImportTransactionsFromCSVExpectation struct {
	mock               *TransactionUsecaseMock
	params             *TransactionUsecaseMockImportTransactionsFromCSVParams
	paramPtrs          *TransactionUsecaseMockImportTransactionsFromCSVParamPtrs
	expectationOrigins TransactionUsecaseMockImportTransactionsFromCSVExpectationOrigins
	results            *TransactionUsecaseMockImportTransactionsFromCSVResults
	returnOrigin       string
	Counter            uint64
}

// TransactionUsecaseMockImportTransactionsFromCSVParams contains parameters of the TransactionUsecase.ImportTransactionsFromCSV
type TransactionUsecaseMockImportTransactionsFromCSVParams struct {
	ctx       context.Context
	data      []byte
	accountID uuid.UUID
}

// TransactionUsecaseMockImportTransactionsFromCSVParamPtrs contains pointers to parameters of the TransactionUsecase.ImportTransactionsFromCSV
type TransactionUsecaseMockImportTransactionsFromCSVParamPtrs struct {
	ctx       *context.Context
	data      *[]byte
	accountID *uuid.UUID
}

// TransactionUsecaseMockImportTransactionsFromCSVResults contains results of the TransactionUsecase.ImportTransactionsFromCSV
type TransactionUsecaseMockImportTransactionsFromCSVResults struct {
	err error
}

// TransactionUsecaseMockImportTransactionsFromCSVOrigins contains origins of expectations of the TransactionUsecase.ImportTransactionsFromCSV
type TransactionUsecaseMockImportTransactionsFromCSVExpectationOrigins struct {
	origin          string
	originCtx       string
	originData      string
	originAccountID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) Optional() *mTransactionUsecaseMockImportTransactionsFromCSV {
	mmImportTransactionsFromCSV.optional = true
	return mmImportTransactionsFromCSV
}

// Expect sets up expected params for TransactionUsecase.ImportTransactionsFromCSV
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) Expect(ctx context.Context, data []byte, accountID uuid.UUID) *mTransactionUsecaseMockImportTransactionsFromCSV {
	if mmImportTransactionsFromCSV.mock.funcImportTransactionsFromCSV != nil {
		mmImportTransactionsFromCSV.mock.t.Fatalf("TransactionUsecaseMock.ImportTransactionsFromCSV mock is already set by Set")
	}

	if mmImportTransactionsFromCSV.defaultExpectation == nil {
		mmImportTransactionsFromCSV.defaultExpectation = &TransactionUsecaseMockImportTransactionsFromCSVExpectation{}
	}

	if mmImportTransactionsFromCSV.defaultExpectation.paramPtrs != nil {
		mmImportTransactionsFromCSV.mock.t.Fatalf("TransactionUsecaseMock.ImportTransactionsFromCSV mock is already set by ExpectParams functions")
	}

	mmImportTransactionsFromCSV.defaultExpectation.params = &TransactionUsecaseMockImportTransactionsFromCSVParams{ctx, data, accountID}
	mmImportTransactionsFromCSV.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmImportTransactionsFromCSV.expectations {
		if minimock.Equal(e.params, mmImportTransactionsFromCSV.defaultExpectation.params) {
			mmImportTransactionsFromCSV.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmImportTransactionsFromCSV.defaultExpectation.params)
		}
	}

	return mmImportTransactionsFromCSV
}

// ExpectCtxParam1 sets up expected param ctx for TransactionUsecase.ImportTransactionsFromCSV
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) ExpectCtxParam1(ctx context.Context) *mTransactionUsecaseMockImportTransactionsFromCSV {
	if mmImportTransactionsFromCSV.mock.funcImportTransactionsFromCSV != nil {
		mmImportTransactionsFromCSV.mock.t.Fatalf("TransactionUsecaseMock.ImportTransactionsFromCSV mock is already set by Set")
	}

	if mmImportTransactionsFromCSV.defaultExpectation == nil {
		mmImportTransactionsFromCSV.defaultExpectation = &TransactionUsecaseMockImportTransactionsFromCSVExpectation{}
	}

	if mmImportTransactionsFromCSV.defaultExpectation.params != nil {
		mmImportTransactionsFromCSV.mock.t.Fatalf("TransactionUsecaseMock.ImportTransactionsFromCSV mock is already set by Expect")
	}

	if mmImportTransactionsFromCSV.defaultExpectation.paramPtrs == nil {
		mmImportTransactionsFromCSV.defaultExpectation.paramPtrs = &TransactionUsecaseMockImportTransactionsFromCSVParamPtrs{}
	}
	mmImportTransactionsFromCSV.defaultExpectation.paramPtrs.ctx = &ctx
	mmImportTransactionsFromCSV.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmImportTransactionsFromCSV
}

// ExpectDataParam2 sets up expected param data for TransactionUsecase.ImportTransactionsFromCSV
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) ExpectDataParam2(data []byte) *mTransactionUsecaseMockImportTransactionsFromCSV {
	if mmImportTransactionsFromCSV.mock.funcImportTransactionsFromCSV != nil {
		mmImportTransactionsFromCSV.mock.t.Fatalf("TransactionUsecaseMock.ImportTransactionsFromCSV mock is already set by Set")
	}

	if mmImportTransactionsFromCSV.defaultExpectation == nil {
		mmImportTransactionsFromCSV.defaultExpectation = &TransactionUsecaseMockImportTransactionsFromCSVExpectation{}
	}

	if mmImportTransactionsFromCSV.defaultExpectation.params != nil {
		mmImportTransactionsFromCSV.mock.t.Fatalf("TransactionUsecaseMock.ImportTransactionsFromCSV mock is already set by Expect")
	}

	if mmImportTransactionsFromCSV.defaultExpectation.paramPtrs == nil {
		mmImportTransactionsFromCSV.defaultExpectation.paramPtrs = &TransactionUsecaseMockImportTransactionsFromCSVParamPtrs{}
	}
	mmImportTransactionsFromCSV.defaultExpectation.paramPtrs.data = &data
	mmImportTransactionsFromCSV.defaultExpectation.expectationOrigins.originData = minimock.CallerInfo(1)

	return mmImportTransactionsFromCSV
}

// ExpectAccountIDParam3 sets up expected param accountID for TransactionUsecase.ImportTransactionsFromCSV
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) ExpectAccountIDParam3(accountID uuid.UUID) *mTransactionUsecaseMockImportTransactionsFromCSV {
	if mmImportTransactionsFromCSV.mock.funcImportTransactionsFromCSV != nil {
		mmImportTransactionsFromCSV.mock.t.Fatalf("TransactionUsecaseMock.ImportTransactionsFromCSV mock is already set by Set")
	}

	if mmImportTransactionsFromCSV.defaultExpectation == nil {
		mmImportTransactionsFromCSV.defaultExpectation = &TransactionUsecaseMockImportTransactionsFromCSVExpectation{}
	}

	if mmImportTransactionsFromCSV.defaultExpectation.params != nil {
		mmImportTransactionsFromCSV.mock.t.Fatalf("TransactionUsecaseMock.ImportTransactionsFromCSV mock is already set by Expect")
	}

	if mmImportTransactionsFromCSV.defaultExpectation.paramPtrs == nil {
		mmImportTransactionsFromCSV.defaultExpectation.paramPtrs = &TransactionUsecaseMockImportTransactionsFromCSVParamPtrs{}
	}
	mmImportTransactionsFromCSV.defaultExpectation.paramPtrs.accountID = &accountID
	mmImportTransactionsFromCSV.defaultExpectation.expectationOrigins.originAccountID = minimock.CallerInfo(1)

	return mmImportTransactionsFromCSV
}

// Inspect accepts an inspector function that has same arguments as the TransactionUsecase.ImportTransactionsFromCSV
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) Inspect(f func(ctx context.Context, data []byte, accountID uuid.UUID)) *mTransactionUsecaseMockImportTransactionsFromCSV {
	if mmImportTransactionsFromCSV.mock.inspectFuncImportTransactionsFromCSV != nil {
		mmImportTransactionsFromCSV.mock.t.Fatalf("Inspect function is already set for TransactionUsecaseMock.ImportTransactionsFromCSV")
	}

	mmImportTransactionsFromCSV.mock.inspectFuncImportTransactionsFromCSV = f

	return mmImportTransactionsFromCSV
}

// Return sets up results that will be returned by TransactionUsecase.ImportTransactionsFromCSV
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) Return(err error) *TransactionUsecaseMock {
	if mmImportTransactionsFromCSV.mock.funcImportTransactionsFromCSV != nil {
		mmImportTransactionsFromCSV.mock.t.Fatalf("TransactionUsecaseMock.ImportTransactionsFromCSV mock is already set by Set")
	}

	if mmImportTransactionsFromCSV.defaultExpectation == nil {
		mmImportTransactionsFromCSV.defaultExpectation = &TransactionUsecaseMockImportTransactionsFromCSVExpectation{mock: mmImportTransactionsFromCSV.mock}
	}
	mmImportTransactionsFromCSV.defaultExpectation.results = &TransactionUsecaseMockImportTransactionsFromCSVResults{err}
	mmImportTransactionsFromCSV.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmImportTransactionsFromCSV.mock
}

// Set uses given function f to mock the TransactionUsecase.ImportTransactionsFromCSV method
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) Set(f func(ctx context.Context, data []byte, accountID uuid.UUID) (err error)) *TransactionUsecaseMock {
	if mmImportTransactionsFromCSV.defaultExpectation != nil {
		mmImportTransactionsFromCSV.mock.t.Fatalf("Default expectation is already set for the TransactionUsecase.ImportTransactionsFromCSV method")
	}

	if len(mmImportTransactionsFromCSV.expectations) > 0 {
		mmImportTransactionsFromCSV.mock.t.Fatalf("Some expectations are already set for the TransactionUsecase.ImportTransactionsFromCSV method")
	}

	mmImportTransactionsFromCSV.mock.funcImportTransactionsFromCSV = f
	mmImportTransactionsFromCSV.mock.funcImportTransactionsFromCSVOrigin = minimock.CallerInfo(1)
	return mmImportTransactionsFromCSV.mock
}

// When sets expectation for the TransactionUsecase.ImportTransactionsFromCSV which will trigger the result defined by the following
// Then helper
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) When(ctx context.Context, data []byte, accountID uuid.UUID) *TransactionUsecaseMockImportTransactionsFromCSVExpectation {
	if mmImportTransactionsFromCSV.mock.funcImportTransactionsFromCSV != nil {
		mmImportTransactionsFromCSV.mock.t.Fatalf("TransactionUsecaseMock.ImportTransactionsFromCSV mock is already set by Set")
	}

	expectation := &TransactionUsecaseMockImportTransactionsFromCSVExpectation{
		mock:               mmImportTransactionsFromCSV.mock,
		params:             &TransactionUsecaseMockImportTransactionsFromCSVParams{ctx, data, accountID},
		expectationOrigins: TransactionUsecaseMockImportTransactionsFromCSVExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmImportTransactionsFromCSV.expectations = append(mmImportTransactionsFromCSV.expectations, expectation)
	return expectation
}

// Then sets up TransactionUsecase.ImportTransactionsFromCSV return parameters for the expectation previously defined by the When method
func (e *TransactionUsecaseMockImportTransactionsFromCSVExpectation) Then(err error) *TransactionUsecaseMock {
	e.results = &TransactionUsecaseMockImportTransactionsFromCSVResults{err}
	return e.mock
}

// Times sets number of times TransactionUsecase.ImportTransactionsFromCSV should be invoked
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) Times(n uint64) *mTransactionUsecaseMockImportTransactionsFromCSV {
	if n == 0 {
		mmImportTransactionsFromCSV.mock.t.Fatalf("Times of TransactionUsecaseMock.ImportTransactionsFromCSV mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmImportTransactionsFromCSV.expectedInvocations, n)
	mmImportTransactionsFromCSV.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmImportTransactionsFromCSV
}

func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) invocationsDone() bool {
	if len(mmImportTransactionsFromCSV.expectations) == 0 && mmImportTransactionsFromCSV.defaultExpectation == nil && mmImportTransactionsFromCSV.mock.funcImportTransactionsFromCSV == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmImportTransactionsFromCSV.mock.afterImportTransactionsFromCSVCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmImportTransactionsFromCSV.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ImportTransactionsFromCSV implements mm_usecase.TransactionUsecase
func (mmImportTransactionsFromCSV *TransactionUsecaseMock) ImportTransactionsFromCSV(ctx context.Context, data []byte, accountID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmImportTransactionsFromCSV.beforeImportTransactionsFromCSVCounter, 1)
	defer mm_atomic.AddUint64(&mmImportTransactionsFromCSV.afterImportTransactionsFromCSVCounter, 1)

	mmImportTransactionsFromCSV.t.Helper()

	if mmImportTransactionsFromCSV.inspectFuncImportTransactionsFromCSV != nil {
		mmImportTransactionsFromCSV.inspectFuncImportTransactionsFromCSV(ctx, data, accountID)
	}

	mm_params := TransactionUsecaseMockImportTransactionsFromCSVParams{ctx, data, accountID}

	// Record call args
	mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.mutex.Lock()
	mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.callArgs = append(mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.callArgs, &mm_params)
	mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.mutex.Unlock()

	for _, e := range mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.defaultExpectation.Counter, 1)
		mm_want := mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.defaultExpectation.params
		mm_want_ptrs := mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.defaultExpectation.paramPtrs

		mm_got := TransactionUsecaseMockImportTransactionsFromCSVParams{ctx, data, accountID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmImportTransactionsFromCSV.t.Errorf("TransactionUsecaseMock.ImportTransactionsFromCSV got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.data != nil && !minimock.Equal(*mm_want_ptrs.data, mm_got.data) {
				mmImportTransactionsFromCSV.t.Errorf("TransactionUsecaseMock.ImportTransactionsFromCSV got unexpected parameter data, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.defaultExpectation.expectationOrigins.originData, *mm_want_ptrs.data, mm_got.data, minimock.Diff(*mm_want_ptrs.data, mm_got.data))
			}

			if mm_want_ptrs.accountID != nil && !minimock.Equal(*mm_want_ptrs.accountID, mm_got.accountID) {
				mmImportTransactionsFromCSV.t.Errorf("TransactionUsecaseMock.ImportTransactionsFromCSV got unexpected parameter accountID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.defaultExpectation.expectationOrigins.originAccountID, *mm_want_ptrs.accountID, mm_got.accountID, minimock.Diff(*mm_want_ptrs.accountID, mm_got.accountID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmImportTransactionsFromCSV.t.Errorf("TransactionUsecaseMock.ImportTransactionsFromCSV got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.defaultExpectation.results
		if mm_results == nil {
			mmImportTransactionsFromCSV.t.Fatal("No results are set for the TransactionUsecaseMock.ImportTransactionsFromCSV")
		}
		return (*mm_results).err
	}
	if mmImportTransactionsFromCSV.funcImportTransactionsFromCSV != nil {
		return mmImportTransactionsFromCSV.funcImportTransactionsFromCSV(ctx, data, accountID)
	}
	mmImportTransactionsFromCSV.t.Fatalf("Unexpected call to TransactionUsecaseMock.ImportTransactionsFromCSV. %v %v %v", ctx, data, accountID)
	return
}

// ImportTransactionsFromCSVAfterCounter returns a count of finished TransactionUsecaseMock.ImportTransactionsFromCSV invocations
func (mmImportTransactionsFromCSV *TransactionUsecaseMock) ImportTransactionsFromCSVAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImportTransactionsFromCSV.afterImportTransactionsFromCSVCounter)
}

// ImportTransactionsFromCSVBeforeCounter returns a count of TransactionUsecaseMock.ImportTransactionsFromCSV invocations
func (mmImportTransactionsFromCSV *TransactionUsecaseMock) ImportTransactionsFromCSVBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImportTransactionsFromCSV.beforeImportTransactionsFromCSVCounter)
}

// Calls returns a list of arguments used in each call to TransactionUsecaseMock.ImportTransactionsFromCSV.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) Calls() []*TransactionUsecaseMockImportTransactionsFromCSVParams {
	mmImportTransactionsFromCSV.mutex.RLock()

	argCopy := make([]*TransactionUsecaseMockImportTransactionsFromCSVParams, len(mmImportTransactionsFromCSV.callArgs))
	copy(argCopy, mmImportTransactionsFromCSV.callArgs)

	mmImportTransactionsFromCSV.mutex.RUnlock()

	return argCopy
}

// MinimockImportTransactionsFromCSVDone returns true if the count of the ImportTransactionsFromCSV invocations corresponds
// the number of defined expectations
func (m *TransactionUsecaseMock) MinimockImportTransactionsFromCSVDone() bool {
	if m.ImportTransactionsFromCSVMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ImportTransactionsFromCSVMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ImportTransactionsFromCSVMock.invocationsDone()
}

// MinimockImportTransactionsFromCSVInspect logs each unmet expectation
func (m *TransactionUsecaseMock) MinimockImportTransactionsFromCSVInspect() {
	for _, e := range m.ImportTransactionsFromCSVMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionUsecaseMock.ImportTransactionsFromCSV at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterImportTransactionsFromCSVCounter := mm_atomic.LoadUint64(&m.afterImportTransactionsFromCSVCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ImportTransactionsFromCSVMock.defaultExpectation != nil && afterImportTransactionsFromCSVCounter < 1 {
		if m.ImportTransactionsFromCSVMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionUsecaseMock.ImportTransactionsFromCSV at\n%s", m.ImportTransactionsFromCSVMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionUsecaseMock.ImportTransactionsFromCSV at\n%s with params: %#v", m.ImportTransactionsFromCSVMock.defaultExpectation.expectationOrigins.origin, *m.ImportTransactionsFromCSVMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcImportTransactionsFromCSV != nil && afterImportTransactionsFromCSVCounter < 1 {
		m.t.Errorf("Expected call to TransactionUsecaseMock.ImportTransactionsFromCSV at\n%s", m.funcImportTransactionsFromCSVOrigin)
	}

	if !m.ImportTransactionsFromCSVMock.invocationsDone() && afterImportTransactionsFromCSVCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionUsecaseMock.ImportTransactionsFromCSV at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ImportTransactionsFromCSVMock.expectedInvocations), m.ImportTransactionsFromCSVMock.expectedInvocationsOrigin, afterImportTransactionsFromCSVCounter)
	}
}

type mTransactionUsecaseMockPatchTransactionByDTO struct {
	optional           bool
	mock               *TransactionUsecaseMock
	defaultExpectation *TransactionUsecaseMockPatchTransactionByDTOExpectation
	expectations       []*TransactionUsecaseMockPatchTransactionByDTOExpectation

	callArgs []*TransactionUsecaseMockPatchTransactionByDTOParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionUsecaseMockPatchTransactionByDTOExpectation specifies expectation struct of the TransactionUsecase.PatchTransactionByDTO
type TransactionUsecaseMockPatchTransactionByDTOExpectation struct {
	mock               *TransactionUsecaseMock
	params             *TransactionUsecaseMockPatchTransactionByDTOParams
	paramPtrs          *TransactionUsecaseMockPatchTransactionByDTOParamPtrs
	expectationOrigins TransactionUsecaseMockPatchTransactionByDTOExpectationOrigins
	results            *TransactionUsecaseMockPatchTransactionByDTOResults
	returnOrigin       string
	Counter            uint64
}

// TransactionUsecaseMockPatchTransactionByDTOParams contains parameters of the TransactionUsecase.PatchTransactionByDTO
type TransactionUsecaseMockPatchTransactionByDTOParams struct {
	ctx              context.Context
	id               uuid.UUID
	in               mm_usecase.PatchTransactionDataInput
	skipVersionCheck bool
}

// TransactionUsecaseMockPatchTransactionByDTOParamPtrs contains pointers to parameters of the TransactionUsecase.PatchTransactionByDTO
type TransactionUsecaseMockPatchTransactionByDTOParamPtrs struct {
	ctx              *context.Context
	id               *uuid.UUID
	in               *mm_usecase.PatchTransactionDataInput
	skipVersionCheck *bool
}

// TransactionUsecaseMockPatchTransactionByDTOResults contains results of the TransactionUsecase.PatchTransactionByDTO
type TransactionUsecaseMockPatchTransactionByDTOResults struct {
	err error
}

// TransactionUsecaseMockPatchTransactionByDTOOrigins contains origins of expectations of the TransactionUsecase.PatchTransactionByDTO
type TransactionUsecaseMockPatchTransactionByDTOExpectationOrigins struct {
	origin                 string
	originCtx              string
	originId               string
	originIn               string
	originSkipVersionCheck string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) Optional() *mTransactionUsecaseMockPatchTransactionByDTO {
	mmPatchTransactionByDTO.optional = true
	return mmPatchTransactionByDTO
}

// Expect sets up expected params for TransactionUsecase.PatchTransactionByDTO
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) Expect(ctx context.Context, id uuid.UUID, in mm_usecase.PatchTransactionDataInput, skipVersionCheck bool) *mTransactionUsecaseMockPatchTransactionByDTO {
	if mmPatchTransactionByDTO.mock.funcPatchTransactionByDTO != nil {
		mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Set")
	}

	if mmPatchTransactionByDTO.defaultExpectation == nil {
		mmPatchTransactionByDTO.defaultExpectation = &TransactionUsecaseMockPatchTransactionByDTOExpectation{}
	}

	if mmPatchTransactionByDTO.defaultExpectation.paramPtrs != nil {
		mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by ExpectParams functions")
	}

	mmPatchTransactionByDTO.defaultExpectation.params = &TransactionUsecaseMockPatchTransactionByDTOParams{ctx, id, in, skipVersionCheck}
	mmPatchTransactionByDTO.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPatchTransactionByDTO.expectations {
		if minimock.Equal(e.params, mmPatchTransactionByDTO.defaultExpectation.params) {
			mmPatchTransactionByDTO.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPatchTransactionByDTO.defaultExpectation.params)
		}
	}

	return mmPatchTransactionByDTO
}

// ExpectCtxParam1 sets up expected param ctx for TransactionUsecase.PatchTransactionByDTO
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) ExpectCtxParam1(ctx context.Context) *mTransactionUsecaseMockPatchTransactionByDTO {
	if mmPatchTransactionByDTO.mock.funcPatchTransactionByDTO != nil {
		mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Set")
	}

	if mmPatchTransactionByDTO.defaultExpectation == nil {
		mmPatchTransactionByDTO.defaultExpectation = &TransactionUsecaseMockPatchTransactionByDTOExpectation{}
	}

	if mmPatchTransactionByDTO.defaultExpectation.params != nil {
		mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Expect")
	}

	if mmPatchTransactionByDTO.defaultExpectation.paramPtrs == nil {
		mmPatchTransactionByDTO.defaultExpectation.paramPtrs = &TransactionUsecaseMockPatchTransactionByDTOParamPtrs{}
	}
	mmPatchTransactionByDTO.defaultExpectation.paramPtrs.ctx = &ctx
	mmPatchTransactionByDTO.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPatchTransactionByDTO
}

// ExpectIdParam2 sets up expected param id for TransactionUsecase.PatchTransactionByDTO
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) ExpectIdParam2(id uuid.UUID) *mTransactionUsecaseMockPatchTransactionByDTO {
	if mmPatchTransactionByDTO.mock.funcPatchTransactionByDTO != nil {
		mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Set")
	}

	if mmPatchTransactionByDTO.defaultExpectation == nil {
		mmPatchTransactionByDTO.defaultExpectation = &TransactionUsecaseMockPatchTransactionByDTOExpectation{}
	}

	if mmPatchTransactionByDTO.defaultExpectation.params != nil {
		mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Expect")
	}

	if mmPatchTransactionByDTO.defaultExpectation.paramPtrs == nil {
		mmPatchTransactionByDTO.defaultExpectation.paramPtrs = &TransactionUsecaseMockPatchTransactionByDTOParamPtrs{}
	}
	mmPatchTransactionByDTO.defaultExpectation.paramPtrs.id = &id
	mmPatchTransactionByDTO.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmPatchTransactionByDTO
}

// ExpectInParam3 sets up expected param in for TransactionUsecase.PatchTransactionByDTO
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) ExpectInParam3(in mm_usecase.PatchTransactionDataInput) *mTransactionUsecaseMockPatchTransactionByDTO {
	if mmPatchTransactionByDTO.mock.funcPatchTransactionByDTO != nil {
		mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Set")
	}

	if mmPatchTransactionByDTO.defaultExpectation == nil {
		mmPatchTransactionByDTO.defaultExpectation = &TransactionUsecaseMockPatchTransactionByDTOExpectation{}
	}

	if mmPatchTransactionByDTO.defaultExpectation.params != nil {
		mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Expect")
	}

	if mmPatchTransactionByDTO.defaultExpectation.paramPtrs == nil {
		mmPatchTransactionByDTO.defaultExpectation.paramPtrs = &TransactionUsecaseMockPatchTransactionByDTOParamPtrs{}
	}
	mmPatchTransactionByDTO.defaultExpectation.paramPtrs.in = &in
	mmPatchTransactionByDTO.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmPatchTransactionByDTO
}

// ExpectSkipVersionCheckParam4 sets up expected param skipVersionCheck for TransactionUsecase.PatchTransactionByDTO
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) ExpectSkipVersionCheckParam4(skipVersionCheck bool) *mTransactionUsecaseMockPatchTransactionByDTO {
	if mmPatchTransactionByDTO.mock.funcPatchTransactionByDTO != nil {
		mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Set")
	}

	if mmPatchTransactionByDTO.defaultExpectation == nil {
		mmPatchTransactionByDTO.defaultExpectation = &TransactionUsecaseMockPatchTransactionByDTOExpectation{}
	}

	if mmPatchTransactionByDTO.defaultExpectation.params != nil {
		mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Expect")
	}

	if mmPatchTransactionByDTO.defaultExpectation.paramPtrs == nil {
		mmPatchTransactionByDTO.defaultExpectation.paramPtrs = &TransactionUsecaseMockPatchTransactionByDTOParamPtrs{}
	}
	mmPatchTransactionByDTO.defaultExpectation.paramPtrs.skipVersionCheck = &skipVersionCheck
	mmPatchTransactionByDTO.defaultExpectation.expectationOrigins.originSkipVersionCheck = minimock.CallerInfo(1)

	return mmPatchTransactionByDTO
}

// Inspect accepts an inspector function that has same arguments as the TransactionUsecase.PatchTransactionByDTO
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) Inspect(f func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchTransactionDataInput, skipVersionCheck bool)) *mTransactionUsecaseMockPatchTransactionByDTO {
	if mmPatchTransactionByDTO.mock.inspectFuncPatchTransactionByDTO != nil {
		mmPatchTransactionByDTO.mock.t.Fatalf("Inspect function is already set for TransactionUsecaseMock.PatchTransactionByDTO")
	}

	mmPatchTransactionByDTO.mock.inspectFuncPatchTransactionByDTO = f

	return mmPatchTransactionByDTO
}

// Return sets up results that will be returned by TransactionUsecase.PatchTransactionByDTO
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) Return(err error) *TransactionUsecaseMock {
	if mmPatchTransactionByDTO.mock.funcPatchTransactionByDTO != nil {
		mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Set")
	}

	if mmPatchTransactionByDTO.defaultExpectation == nil {
		mmPatchTransactionByDTO.defaultExpectation = &TransactionUsecaseMockPatchTransactionByDTOExpectation{mock: mmPatchTransactionByDTO.mock}
	}
	mmPatchTransactionByDTO.defaultExpectation.results = &TransactionUsecaseMockPatchTransactionByDTOResults{err}
	mmPatchTransactionByDTO.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPatchTransactionByDTO.mock
}

// Set uses given function f to mock the TransactionUsecase.PatchTransactionByDTO method
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) Set(f func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchTransactionDataInput, skipVersionCheck bool) (err error)) *TransactionUsecaseMock {
	if mmPatchTransactionByDTO.defaultExpectation != nil {
		mmPatchTransactionByDTO.mock.t.Fatalf("Default expectation is already set for the TransactionUsecase.PatchTransactionByDTO method")
	}

	if len(mmPatchTransactionByDTO.expectations) > 0 {
		mmPatchTransactionByDTO.mock.t.Fatalf("Some expectations are already set for the TransactionUsecase.PatchTransactionByDTO method")
	}

	mmPatchTransactionByDTO.mock.funcPatchTransactionByDTO = f
	mmPatchTransactionByDTO.mock.funcPatchTransactionByDTOOrigin = minimock.CallerInfo(1)
	return mmPatchTransactionByDTO.mock
}

// When sets expectation for the TransactionUsecase.PatchTransactionByDTO which will trigger the result defined by the following
// Then helper
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) When(ctx context.Context, id uuid.UUID, in mm_usecase.PatchTransactionDataInput, skipVersionCheck bool) *TransactionUsecaseMockPatchTransactionByDTOExpectation {
	if mmPatchTransactionByDTO.mock.funcPatchTransactionByDTO != nil {
		mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Set")
	}

	expectation := &TransactionUsecaseMockPatchTransactionByDTOExpectation{
		mock:               mmPatchTransactionByDTO.mock,
		params:             &TransactionUsecaseMockPatchTransactionByDTOParams{ctx, id, in, skipVersionCheck},
		expectationOrigins: TransactionUsecaseMockPatchTransactionByDTOExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPatchTransactionByDTO.expectations = append(mmPatchTransactionByDTO.expectations, expectation)
	return expectation
}

// Then sets up TransactionUsecase.PatchTransactionByDTO return parameters for the expectation previously defined by the When method
func (e *TransactionUsecaseMockPatchTransactionByDTOExpectation) Then(err error) *TransactionUsecaseMock {
	e.results = &TransactionUsecaseMockPatchTransactionByDTOResults{err}
	return e.mock
}

// Times sets number of times TransactionUsecase.PatchTransactionByDTO should be invoked
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) Times(n uint64) *mTransactionUsecaseMockPatchTransactionByDTO {
	if n == 0 {
		mmPatchTransactionByDTO.mock.t.Fatalf("Times of TransactionUsecaseMock.PatchTransactionByDTO mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPatchTransactionByDTO.expectedInvocations, n)
	mmPatchTransactionByDTO.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPatchTransactionByDTO
}

func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) invocationsDone() bool {
	if len(mmPatchTransactionByDTO.expectations) == 0 && mmPatchTransactionByDTO.defaultExpectation == nil && mmPatchTransactionByDTO.mock.funcPatchTransactionByDTO == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPatchTransactionByDTO.mock.afterPatchTransactionByDTOCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPatchTransactionByDTO.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PatchTransactionByDTO implements mm_usecase.TransactionUsecase
func (mmPatchTransactionByDTO *TransactionUsecaseMock) PatchTransactionByDTO(ctx context.Context, id uuid.UUID, in mm_usecase.PatchTransactionDataInput, skipVersionCheck bool) (err error) {
	mm_atomic.AddUint64(&mmPatchTransactionByDTO.beforePatchTransactionByDTOCounter, 1)
	defer mm_atomic.AddUint64(&mmPatchTransactionByDTO.afterPatchTransactionByDTOCounter, 1)

	mmPatchTransactionByDTO.t.Helper()

	if mmPatchTransactionByDTO.inspectFuncPatchTransactionByDTO != nil {
		mmPatchTransactionByDTO.inspectFuncPatchTransactionByDTO(ctx, id, in, skipVersionCheck)
	}

	mm_params := TransactionUsecaseMockPatchTransactionByDTOParams{ctx, id, in, skipVersionCheck}

	// Record call args
	mmPatchTransactionByDTO.PatchTransactionByDTOMock.mutex.Lock()
	mmPatchTransactionByDTO.PatchTransactionByDTOMock.callArgs = append(mmPatchTransactionByDTO.PatchTransactionByDTOMock.callArgs, &mm_params)
	mmPatchTransactionByDTO.PatchTransactionByDTOMock.mutex.Unlock()

	for _, e := range mmPatchTransactionByDTO.PatchTransactionByDTOMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPatchTransactionByDTO.PatchTransactionByDTOMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPatchTransactionByDTO.PatchTransactionByDTOMock.defaultExpectation.Counter, 1)
		mm_want := mmPatchTransactionByDTO.PatchTransactionByDTOMock.defaultExpectation.params
		mm_want_ptrs := mmPatchTransactionByDTO.PatchTransactionByDTOMock.defaultExpectation.paramPtrs

		mm_got := TransactionUsecaseMockPatchTransactionByDTOParams{ctx, id, in, skipVersionCheck}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPatchTransactionByDTO.t.Errorf("TransactionUsecaseMock.PatchTransactionByDTO got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatchTransactionByDTO.PatchTransactionByDTOMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmPatchTransactionByDTO.t.Errorf("TransactionUsecaseMock.PatchTransactionByDTO got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatchTransactionByDTO.PatchTransactionByDTOMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmPatchTransactionByDTO.t.Errorf("TransactionUsecaseMock.PatchTransactionByDTO got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatchTransactionByDTO.PatchTransactionByDTOMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.skipVersionCheck != nil && !minimock.Equal(*mm_want_ptrs.skipVersionCheck, mm_got.skipVersionCheck) {
				mmPatchTransactionByDTO.t.Errorf("TransactionUsecaseMock.PatchTransactionByDTO got unexpected parameter skipVersionCheck, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPatchTransactionByDTO.PatchTransactionByDTOMock.defaultExpectation.expectationOrigins.originSkipVersionCheck, *mm_want_ptrs.skipVersionCheck, mm_got.skipVersionCheck, minimock.Diff(*mm_want_ptrs.skipVersionCheck, mm_got.skipVersionCheck))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPatchTransactionByDTO.t.Errorf("TransactionUsecaseMock.PatchTransactionByDTO got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPatchTransactionByDTO.PatchTransactionByDTOMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPatchTransactionByDTO.PatchTransactionByDTOMock.defaultExpectation.results
		if mm_results == nil {
			mmPatchTransactionByDTO.t.Fatal("No results are set for the TransactionUsecaseMock.PatchTransactionByDTO")
		}
		return (*mm_results).err
	}
	if mmPatchTransactionByDTO.funcPatchTransactionByDTO != nil {
		return mmPatchTransactionByDTO.funcPatchTransactionByDTO(ctx, id, in, skipVersionCheck)
	}
	mmPatchTransactionByDTO.t.Fatalf("Unexpected call to TransactionUsecaseMock.PatchTransactionByDTO. %v %v %v %v", ctx, id, in, skipVersionCheck)
	return
}

// PatchTransactionByDTOAfterCounter returns a count of finished TransactionUsecaseMock.PatchTransactionByDTO invocations
func (mmPatchTransactionByDTO *TransactionUsecaseMock) PatchTransactionByDTOAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPatchTransactionByDTO.afterPatchTransactionByDTOCounter)
}

// PatchTransactionByDTOBeforeCounter returns a count of TransactionUsecaseMock.PatchTransactionByDTO invocations
func (mmPatchTransactionByDTO *TransactionUsecaseMock) PatchTransactionByDTOBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPatchTransactionByDTO.beforePatchTransactionByDTOCounter)
}

// Calls returns a list of arguments used in each call to TransactionUsecaseMock.PatchTransactionByDTO.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) Calls() []*TransactionUsecaseMockPatchTransactionByDTOParams {
	mmPatchTransactionByDTO.mutex.RLock()

	argCopy := make([]*TransactionUsecaseMockPatchTransactionByDTOParams, len(mmPatchTransactionByDTO.callArgs))
	copy(argCopy, mmPatchTransactionByDTO.callArgs)

	mmPatchTransactionByDTO.mutex.RUnlock()

	return argCopy
}

// MinimockPatchTransactionByDTODone returns true if the count of the PatchTransactionByDTO invocations corresponds
// the number of defined expectations
func (m *TransactionUsecaseMock) MinimockPatchTransactionByDTODone() bool {
	if m.PatchTransactionByDTOMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PatchTransactionByDTOMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PatchTransactionByDTOMock.invocationsDone()
}

// MinimockPatchTransactionByDTOInspect logs each unmet expectation
func (m *TransactionUsecaseMock) MinimockPatchTransactionByDTOInspect() {
	for _, e := range m.PatchTransactionByDTOMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionUsecaseMock.PatchTransactionByDTO at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPatchTransactionByDTOCounter := mm_atomic.LoadUint64(&m.afterPatchTransactionByDTOCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PatchTransactionByDTOMock.defaultExpectation != nil && afterPatchTransactionByDTOCounter < 1 {
		if m.PatchTransactionByDTOMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionUsecaseMock.PatchTransactionByDTO at\n%s", m.PatchTransactionByDTOMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionUsecaseMock.PatchTransactionByDTO at\n%s with params: %#v", m.PatchTransactionByDTOMock.defaultExpectation.expectationOrigins.origin, *m.PatchTransactionByDTOMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPatchTransactionByDTO != nil && afterPatchTransactionByDTOCounter < 1 {
		m.t.Errorf("Expected call to TransactionUsecaseMock.PatchTransactionByDTO at\n%s", m.funcPatchTransactionByDTOOrigin)
	}

	if !m.PatchTransactionByDTOMock.invocationsDone() && afterPatchTransactionByDTOCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionUsecaseMock.PatchTransactionByDTO at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PatchTransactionByDTOMock.expectedInvocations), m.PatchTransactionByDTOMock.expectedInvocationsOrigin, afterPatchTransactionByDTOCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TransactionUsecaseMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCountReportItemsInspect()

			m.MinimockCreateTransactionByDTOInspect()

			m.MinimockDeleteTransactionByIDInspect()

			m.MinimockFindListInspect()

			m.MinimockFindListInMapInspect()

			m.MinimockFindOneByIDInspect()

			m.MinimockFindPagedListInspect()

			m.MinimockFindPagedListAsCSVInspect()

			m.MinimockImportTransactionsFromCSVInspect()

			m.MinimockPatchTransactionByDTOInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TransactionUsecaseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TransactionUsecaseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCountReportItemsDone() &&
		m.MinimockCreateTransactionByDTODone() &&
		m.MinimockDeleteTransactionByIDDone() &&
		m.MinimockFindListDone() &&
		m.MinimockFindListInMapDone() &&
		m.MinimockFindOneByIDDone() &&
		m.MinimockFindPagedListDone() &&
		m.MinimockFindPagedListAsCSVDone() &&
		m.MinimockImportTransactionsFromCSVDone() &&
		m.MinimockPatchTransactionByDTODone()
}
