// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase.TransactionCSVRepository -o transaction_csv_repository.go -n TransactionCSVRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
	"github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
	mm_usecase "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
)

// TransactionCSVRepositoryMock implements mm_usecase.TransactionCSVRepository
type TransactionCSVRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcItemsFromCSV          func(ctx context.Context, data []byte, accountID uuid.UUID) (items []*entity.Transaction, err error)
	funcItemsFromCSVOrigin    string
	inspectFuncItemsFromCSV   func(ctx context.Context, data []byte, accountID uuid.UUID)
	afterItemsFromCSVCounter  uint64
	beforeItemsFromCSVCounter uint64
	ItemsFromCSVMock          mTransactionCSVRepositoryMockItemsFromCSV

	funcItemsToCSV          func(ctx context.Context, items []*mm_usecase.TransactionDTO) (ba1 []byte, err error)
	funcItemsToCSVOrigin    string
	inspectFuncItemsToCSV   func(ctx context.Context, items []*mm_usecase.TransactionDTO)
	afterItemsToCSVCounter  uint64
	beforeItemsToCSVCounter uint64
	ItemsToCSVMock          mTransactionCSVRepositoryMockItemsToCSV
}

// NewTransactionCSVRepositoryMock returns a mock for mm_usecase.TransactionCSVRepository
func NewTransactionCSVRepositoryMock(t minimock.Tester) *TransactionCSVRepositoryMock {
	m := &TransactionCSVRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ItemsFromCSVMock = mTransactionCSVRepositoryMockItemsFromCSV{mock: m}
	m.ItemsFromCSVMock.callArgs = []*TransactionCSVRepositoryMockItemsFromCSVParams{}

	m.ItemsToCSVMock = mTransactionCSVRepositoryMockItemsToCSV{mock: m}
	m.ItemsToCSVMock.callArgs = []*TransactionCSVRepositoryMockItemsToCSVParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTransactionCSVRepositoryMockItemsFromCSV struct {
	optional           bool
	mock               *TransactionCSVRepositoryMock
	defaultExpectation *TransactionCSVRepositoryMockItemsFromCSVExpectation
	expectations       []*TransactionCSVRepositoryMockItemsFromCSVExpectation

	callArgs []*TransactionCSVRepositoryMockItemsFromCSVParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionCSVRepositoryMockItemsFromCSVExpectation specifies expectation struct of the TransactionCSVRepository.ItemsFromCSV
type TransactionCSVRepositoryMockItemsFromCSVExpectation struct {
	mock               *TransactionCSVRepositoryMock
	params             *TransactionCSVRepositoryMockItemsFromCSVParams
	paramPtrs          *TransactionCSVRepositoryMockItemsFromCSVParamPtrs
	expectationOrigins TransactionCSVRepositoryMockItemsFromCSVExpectationOrigins
	results            *TransactionCSVRepositoryMockItemsFromCSVResults
	returnOrigin       string
	Counter            uint64
}

// TransactionCSVRepositoryMockItemsFromCSVParams contains parameters of the TransactionCSVRepository.ItemsFromCSV
type TransactionCSVRepositoryMockItemsFromCSVParams struct {
	ctx       context.Context
	data      []byte
	accountID uuid.UUID
}

// TransactionCSVRepositoryMockItemsFromCSVParamPtrs contains pointers to parameters of the TransactionCSVRepository.ItemsFromCSV
type TransactionCSVRepositoryMockItemsFromCSVParamPtrs struct {
	ctx       *context.Context
	data      *[]byte
	accountID *uuid.UUID
}

// TransactionCSVRepositoryMockItemsFromCSVResults contains results of the TransactionCSVRepository.ItemsFromCSV
type TransactionCSVRepositoryMockItemsFromCSVResults struct {
	items []*entity.Transaction
	err   error
}

// TransactionCSVRepositoryMockItemsFromCSVOrigins contains origins of expectations of the TransactionCSVRepository.ItemsFromCSV
type TransactionCSVRepositoryMockItemsFromCSVExpectationOrigins struct {
	origin          string
	originCtx       string
	originData      string
	originAccountID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) Optional() *mTransactionCSVRepositoryMockItemsFromCSV {
	mmItemsFromCSV.optional = true
	return mmItemsFromCSV
}

// Expect sets up expected params for TransactionCSVRepository.ItemsFromCSV
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) Expect(ctx context.Context, data []byte, accountID uuid.UUID) *mTransactionCSVRepositoryMockItemsFromCSV {
	if mmItemsFromCSV.mock.funcItemsFromCSV != nil {
		mmItemsFromCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsFromCSV mock is already set by Set")
	}

	if mmItemsFromCSV.defaultExpectation == nil {
		mmItemsFromCSV.defaultExpectation = &TransactionCSVRepositoryMockItemsFromCSVExpectation{}
	}

	if mmItemsFromCSV.defaultExpectation.paramPtrs != nil {
		mmItemsFromCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsFromCSV mock is already set by ExpectParams functions")
	}

	mmItemsFromCSV.defaultExpectation.params = &TransactionCSVRepositoryMockItemsFromCSVParams{ctx, data, accountID}
	mmItemsFromCSV.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmItemsFromCSV.expectations {
		if minimock.Equal(e.params, mmItemsFromCSV.defaultExpectation.params) {
			mmItemsFromCSV.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmItemsFromCSV.defaultExpectation.params)
		}
	}

	return mmItemsFromCSV
}

// ExpectCtxParam1 sets up expected param ctx for TransactionCSVRepository.ItemsFromCSV
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) ExpectCtxParam1(ctx context.Context) *mTransactionCSVRepositoryMockItemsFromCSV {
	if mmItemsFromCSV.mock.funcItemsFromCSV != nil {
		mmItemsFromCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsFromCSV mock is already set by Set")
	}

	if mmItemsFromCSV.defaultExpectation == nil {
		mmItemsFromCSV.defaultExpectation = &TransactionCSVRepositoryMockItemsFromCSVExpectation{}
	}

	if mmItemsFromCSV.defaultExpectation.params != nil {
		mmItemsFromCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsFromCSV mock is already set by Expect")
	}

	if mmItemsFromCSV.defaultExpectation.paramPtrs == nil {
		mmItemsFromCSV.defaultExpectation.paramPtrs = &TransactionCSVRepositoryMockItemsFromCSVParamPtrs{}
	}
	mmItemsFromCSV.defaultExpectation.paramPtrs.ctx = &ctx
	mmItemsFromCSV.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmItemsFromCSV
}

// ExpectDataParam2 sets up expected param data for TransactionCSVRepository.ItemsFromCSV
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) ExpectDataParam2(data []byte) *mTransactionCSVRepositoryMockItemsFromCSV {
	if mmItemsFromCSV.mock.funcItemsFromCSV != nil {
		mmItemsFromCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsFromCSV mock is already set by Set")
	}

	if mmItemsFromCSV.defaultExpectation == nil {
		mmItemsFromCSV.defaultExpectation = &TransactionCSVRepositoryMockItemsFromCSVExpectation{}
	}

	if mmItemsFromCSV.defaultExpectation.params != nil {
		mmItemsFromCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsFromCSV mock is already set by Expect")
	}

	if mmItemsFromCSV.defaultExpectation.paramPtrs == nil {
		mmItemsFromCSV.defaultExpectation.paramPtrs = &TransactionCSVRepositoryMockItemsFromCSVParamPtrs{}
	}
	mmItemsFromCSV.defaultExpectation.paramPtrs.data = &data
	mmItemsFromCSV.defaultExpectation.expectationOrigins.originData = minimock.CallerInfo(1)

	return mmItemsFromCSV
}

// ExpectAccountIDParam3 sets up expected param accountID for TransactionCSVRepository.ItemsFromCSV
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) ExpectAccountIDParam3(accountID uuid.UUID) *mTransactionCSVRepositoryMockItemsFromCSV {
	if mmItemsFromCSV.mock.funcItemsFromCSV != nil {
		mmItemsFromCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsFromCSV mock is already set by Set")
	}

	if mmItemsFromCSV.defaultExpectation == nil {
		mmItemsFromCSV.defaultExpectation = &TransactionCSVRepositoryMockItemsFromCSVExpectation{}
	}

	if mmItemsFromCSV.defaultExpectation.params != nil {
		mmItemsFromCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsFromCSV mock is already set by Expect")
	}

	if mmItemsFromCSV.defaultExpectation.paramPtrs == nil {
		mmItemsFromCSV.defaultExpectation.paramPtrs = &TransactionCSVRepositoryMockItemsFromCSVParamPtrs{}
	}
	mmItemsFromCSV.defaultExpectation.paramPtrs.accountID = &accountID
	mmItemsFromCSV.defaultExpectation.expectationOrigins.originAccountID = minimock.CallerInfo(1)

	return mmItemsFromCSV
}

// Inspect accepts an inspector function that has same arguments as the TransactionCSVRepository.ItemsFromCSV
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) Inspect(f func(ctx context.Context, data []byte, accountID uuid.UUID)) *mTransactionCSVRepositoryMockItemsFromCSV {
	if mmItemsFromCSV.mock.inspectFuncItemsFromCSV != nil {
		mmItemsFromCSV.mock.t.Fatalf("Inspect function is already set for TransactionCSVRepositoryMock.ItemsFromCSV")
	}

	mmItemsFromCSV.mock.inspectFuncItemsFromCSV = f

	return mmItemsFromCSV
}

// Return sets up results that will be returned by TransactionCSVRepository.ItemsFromCSV
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) Return(items []*entity.Transaction, err error) *TransactionCSVRepositoryMock {
	if mmItemsFromCSV.mock.funcItemsFromCSV != nil {
		mmItemsFromCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsFromCSV mock is already set by Set")
	}

	if mmItemsFromCSV.defaultExpectation == nil {
		mmItemsFromCSV.defaultExpectation = &TransactionCSVRepositoryMockItemsFromCSVExpectation{mock: mmItemsFromCSV.mock}
	}
	mmItemsFromCSV.defaultExpectation.results = &TransactionCSVRepositoryMockItemsFromCSVResults{items, err}
	mmItemsFromCSV.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmItemsFromCSV.mock
}

// Set uses given function f to mock the TransactionCSVRepository.ItemsFromCSV method
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) Set(f func(ctx context.Context, data []byte, accountID uuid.UUID) (items []*entity.Transaction, err error)) *TransactionCSVRepositoryMock {
	if mmItemsFromCSV.defaultExpectation != nil {
		mmItemsFromCSV.mock.t.Fatalf("Default expectation is already set for the TransactionCSVRepository.ItemsFromCSV method")
	}

	if len(mmItemsFromCSV.expectations) > 0 {
		mmItemsFromCSV.mock.t.Fatalf("Some expectations are already set for the TransactionCSVRepository.ItemsFromCSV method")
	}

	mmItemsFromCSV.mock.funcItemsFromCSV = f
	mmItemsFromCSV.mock.funcItemsFromCSVOrigin = minimock.CallerInfo(1)
	return mmItemsFromCSV.mock
}

// When sets expectation for the TransactionCSVRepository.ItemsFromCSV which will trigger the result defined by the following
// Then helper
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) When(ctx context.Context, data []byte, accountID uuid.UUID) *TransactionCSVRepositoryMockItemsFromCSVExpectation {
	if mmItemsFromCSV.mock.funcItemsFromCSV != nil {
		mmItemsFromCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsFromCSV mock is already set by Set")
	}

	expectation := &TransactionCSVRepositoryMockItemsFromCSVExpectation{
		mock:               mmItemsFromCSV.mock,
		params:             &TransactionCSVRepositoryMockItemsFromCSVParams{ctx, data, accountID},
		expectationOrigins: TransactionCSVRepositoryMockItemsFromCSVExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmItemsFromCSV.expectations = append(mmItemsFromCSV.expectations, expectation)
	return expectation
}

// Then sets up TransactionCSVRepository.ItemsFromCSV return parameters for the expectation previously defined by the When method
func (e *TransactionCSVRepositoryMockItemsFromCSVExpectation) Then(items []*entity.Transaction, err error) *TransactionCSVRepositoryMock {
	e.results = &TransactionCSVRepositoryMockItemsFromCSVResults{items, err}
	return e.mock
}

// Times sets number of times TransactionCSVRepository.ItemsFromCSV should be invoked
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) Times(n uint64) *mTransactionCSVRepositoryMockItemsFromCSV {
	if n == 0 {
		mmItemsFromCSV.mock.t.Fatalf("Times of TransactionCSVRepositoryMock.ItemsFromCSV mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmItemsFromCSV.expectedInvocations, n)
	mmItemsFromCSV.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmItemsFromCSV
}

func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) invocationsDone() bool {
	if len(mmItemsFromCSV.expectations) == 0 && mmItemsFromCSV.defaultExpectation == nil && mmItemsFromCSV.mock.funcItemsFromCSV == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmItemsFromCSV.mock.afterItemsFromCSVCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmItemsFromCSV.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ItemsFromCSV implements mm_usecase.TransactionCSVRepository
func (mmItemsFromCSV *TransactionCSVRepositoryMock) ItemsFromCSV(ctx context.Context, data []byte, accountID uuid.UUID) (items []*entity.Transaction, err error) {
	mm_atomic.AddUint64(&mmItemsFromCSV.beforeItemsFromCSVCounter, 1)
	defer mm_atomic.AddUint64(&mmItemsFromCSV.afterItemsFromCSVCounter, 1)

	mmItemsFromCSV.t.Helper()

	if mmItemsFromCSV.inspectFuncItemsFromCSV != nil {
		mmItemsFromCSV.inspectFuncItemsFromCSV(ctx, data, accountID)
	}

	mm_params := TransactionCSVRepositoryMockItemsFromCSVParams{ctx, data, accountID}

	// Record call args
	mmItemsFromCSV.ItemsFromCSVMock.mutex.Lock()
	mmItemsFromCSV.ItemsFromCSVMock.callArgs = append(mmItemsFromCSV.ItemsFromCSVMock.callArgs, &mm_params)
	mmItemsFromCSV.ItemsFromCSVMock.mutex.Unlock()

	for _, e := range mmItemsFromCSV.ItemsFromCSVMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.items, e.results.err
		}
	}

	if mmItemsFromCSV.ItemsFromCSVMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmItemsFromCSV.ItemsFromCSVMock.defaultExpectation.Counter, 1)
		mm_want := mmItemsFromCSV.ItemsFromCSVMock.defaultExpectation.params
		mm_want_ptrs := mmItemsFromCSV.ItemsFromCSVMock.defaultExpectation.paramPtrs

		mm_got := TransactionCSVRepositoryMockItemsFromCSVParams{ctx, data, accountID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmItemsFromCSV.t.Errorf("TransactionCSVRepositoryMock.ItemsFromCSV got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmItemsFromCSV.ItemsFromCSVMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.data != nil && !minimock.Equal(*mm_want_ptrs.data, mm_got.data) {
				mmItemsFromCSV.t.Errorf("TransactionCSVRepositoryMock.ItemsFromCSV got unexpected parameter data, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmItemsFromCSV.ItemsFromCSVMock.defaultExpectation.expectationOrigins.originData, *mm_want_ptrs.data, mm_got.data, minimock.Diff(*mm_want_ptrs.data, mm_got.data))
			}

			if mm_want_ptrs.accountID != nil && !minimock.Equal(*mm_want_ptrs.accountID, mm_got.accountID) {
				mmItemsFromCSV.t.Errorf("TransactionCSVRepositoryMock.ItemsFromCSV got unexpected parameter accountID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmItemsFromCSV.ItemsFromCSVMock.defaultExpectation.expectationOrigins.originAccountID, *mm_want_ptrs.accountID, mm_got.accountID, minimock.Diff(*mm_want_ptrs.accountID, mm_got.accountID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmItemsFromCSV.t.Errorf("TransactionCSVRepositoryMock.ItemsFromCSV got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmItemsFromCSV.ItemsFromCSVMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmItemsFromCSV.ItemsFromCSVMock.defaultExpectation.results
		if mm_results == nil {
			mmItemsFromCSV.t.Fatal("No results are set for the TransactionCSVRepositoryMock.ItemsFromCSV")
		}
		return (*mm_results).items, (*mm_results).err
	}
	if mmItemsFromCSV.funcItemsFromCSV != nil {
		return mmItemsFromCSV.funcItemsFromCSV(ctx, data, accountID)
	}
	mmItemsFromCSV.t.Fatalf("Unexpected call to TransactionCSVRepositoryMock.ItemsFromCSV. %v %v %v", ctx, data, accountID)
	return
}

// ItemsFromCSVAfterCounter returns a count of finished TransactionCSVRepositoryMock.ItemsFromCSV invocations
func (mmItemsFromCSV *TransactionCSVRepositoryMock) ItemsFromCSVAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmItemsFromCSV.afterItemsFromCSVCounter)
}

// ItemsFromCSVBeforeCounter returns a count of TransactionCSVRepositoryMock.ItemsFromCSV invocations
func (mmItemsFromCSV *TransactionCSVRepositoryMock) ItemsFromCSVBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmItemsFromCSV.beforeItemsFromCSVCounter)
}

// Calls returns a list of arguments used in each call to TransactionCSVRepositoryMock.ItemsFromCSV.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) Calls() []*TransactionCSVRepositoryMockItemsFromCSVParams {
	mmItemsFromCSV.mutex.RLock()

	argCopy := make([]*TransactionCSVRepositoryMockItemsFromCSVParams, len(mmItemsFromCSV.callArgs))
	copy(argCopy, mmItemsFromCSV.callArgs)

	mmItemsFromCSV.mutex.RUnlock()

	return argCopy
}

// MinimockItemsFromCSVDone returns true if the count of the ItemsFromCSV invocations corresponds
// the number of defined expectations
func (m *TransactionCSVRepositoryMock) MinimockItemsFromCSVDone() bool {
	if m.ItemsFromCSVMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ItemsFromCSVMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ItemsFromCSVMock.invocationsDone()
}

// MinimockItemsFromCSVInspect logs each unmet expectation
func (m *TransactionCSVRepositoryMock) MinimockItemsFromCSVInspect() {
	for _, e := range m.ItemsFromCSVMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionCSVRepositoryMock.ItemsFromCSV at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterItemsFromCSVCounter := mm_atomic.LoadUint64(&m.afterItemsFromCSVCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ItemsFromCSVMock.defaultExpectation != nil && afterItemsFromCSVCounter < 1 {
		if m.ItemsFromCSVMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionCSVRepositoryMock.ItemsFromCSV at\n%s", m.ItemsFromCSVMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionCSVRepositoryMock.ItemsFromCSV at\n%s with params: %#v", m.ItemsFromCSVMock.defaultExpectation.expectationOrigins.origin, *m.ItemsFromCSVMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcItemsFromCSV != nil && afterItemsFromCSVCounter < 1 {
		m.t.Errorf("Expected call to TransactionCSVRepositoryMock.ItemsFromCSV at\n%s", m.funcItemsFromCSVOrigin)
	}

	if !m.ItemsFromCSVMock.invocationsDone() && afterItemsFromCSVCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionCSVRepositoryMock.ItemsFromCSV at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ItemsFromCSVMock.expectedInvocations), m.ItemsFromCSVMock.expectedInvocationsOrigin, afterItemsFromCSVCounter)
	}
}

type mTransactionCSVRepositoryMockItemsToCSV struct {
	optional           bool
	mock               *TransactionCSVRepositoryMock
	defaultExpectation *TransactionCSVRepositoryMockItemsToCSVExpectation
	expectations       []*TransactionCSVRepositoryMockItemsToCSVExpectation

	callArgs []*TransactionCSVRepositoryMockItemsToCSVParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionCSVRepositoryMockItemsToCSVExpectation specifies expectation struct of the TransactionCSVRepository.ItemsToCSV
type TransactionCSVRepositoryMockItemsToCSVExpectation struct {
	mock               *TransactionCSVRepositoryMock
	params             *TransactionCSVRepositoryMockItemsToCSVParams
	paramPtrs          *TransactionCSVRepositoryMockItemsToCSVParamPtrs
	expectationOrigins TransactionCSVRepositoryMockItemsToCSVExpectationOrigins
	results            *TransactionCSVRepositoryMockItemsToCSVResults
	returnOrigin       string
	Counter            uint64
}

// TransactionCSVRepositoryMockItemsToCSVParams contains parameters of the TransactionCSVRepository.ItemsToCSV
type TransactionCSVRepositoryMockItemsToCSVParams struct {
	ctx   context.Context
	items []*mm_usecase.TransactionDTO
}

// TransactionCSVRepositoryMockItemsToCSVParamPtrs contains pointers to parameters of the TransactionCSVRepository.ItemsToCSV
type TransactionCSVRepositoryMockItemsToCSVParamPtrs struct {
	ctx   *context.Context
	items *[]*mm_usecase.TransactionDTO
}

// TransactionCSVRepositoryMockItemsToCSVResults contains results of the TransactionCSVRepository.ItemsToCSV
type TransactionCSVRepositoryMockItemsToCSVResults struct {
	ba1 []byte
	err error
}

// TransactionCSVRepositoryMockItemsToCSVOrigins contains origins of expectations of the TransactionCSVRepository.ItemsToCSV
type TransactionCSVRepositoryMockItemsToCSVExpectationOrigins struct {
	origin      string
	originCtx   string
	originItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) Optional() *mTransactionCSVRepositoryMockItemsToCSV {
	mmItemsToCSV.optional = true
	return mmItemsToCSV
}

// Expect sets up expected params for TransactionCSVRepository.ItemsToCSV
func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) Expect(ctx context.Context, items []*mm_usecase.TransactionDTO) *mTransactionCSVRepositoryMockItemsToCSV {
	if mmItemsToCSV.mock.funcItemsToCSV != nil {
		mmItemsToCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsToCSV mock is already set by Set")
	}

	if mmItemsToCSV.defaultExpectation == nil {
		mmItemsToCSV.defaultExpectation = &TransactionCSVRepositoryMockItemsToCSVExpectation{}
	}

	if mmItemsToCSV.defaultExpectation.paramPtrs != nil {
		mmItemsToCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsToCSV mock is already set by ExpectParams functions")
	}

	mmItemsToCSV.defaultExpectation.params = &TransactionCSVRepositoryMockItemsToCSVParams{ctx, items}
	mmItemsToCSV.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmItemsToCSV.expectations {
		if minimock.Equal(e.params, mmItemsToCSV.defaultExpectation.params) {
			mmItemsToCSV.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmItemsToCSV.defaultExpectation.params)
		}
	}

	return mmItemsToCSV
}

// ExpectCtxParam1 sets up expected param ctx for TransactionCSVRepository.ItemsToCSV
func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) ExpectCtxParam1(ctx context.Context) *mTransactionCSVRepositoryMockItemsToCSV {
	if mmItemsToCSV.mock.funcItemsToCSV != nil {
		mmItemsToCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsToCSV mock is already set by Set")
	}

	if mmItemsToCSV.defaultExpectation == nil {
		mmItemsToCSV.defaultExpectation = &TransactionCSVRepositoryMockItemsToCSVExpectation{}
	}

	if mmItemsToCSV.defaultExpectation.params != nil {
		mmItemsToCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsToCSV mock is already set by Expect")
	}

	if mmItemsToCSV.defaultExpectation.paramPtrs == nil {
		mmItemsToCSV.defaultExpectation.paramPtrs = &TransactionCSVRepositoryMockItemsToCSVParamPtrs{}
	}
	mmItemsToCSV.defaultExpectation.paramPtrs.ctx = &ctx
	mmItemsToCSV.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmItemsToCSV
}

// ExpectItemsParam2 sets up expected param items for TransactionCSVRepository.ItemsToCSV
func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) ExpectItemsParam2(items []*mm_usecase.TransactionDTO) *mTransactionCSVRepositoryMockItemsToCSV {
	if mmItemsToCSV.mock.funcItemsToCSV != nil {
		mmItemsToCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsToCSV mock is already set by Set")
	}

	if mmItemsToCSV.defaultExpectation == nil {
		mmItemsToCSV.defaultExpectation = &TransactionCSVRepositoryMockItemsToCSVExpectation{}
	}

	if mmItemsToCSV.defaultExpectation.params != nil {
		mmItemsToCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsToCSV mock is already set by Expect")
	}

	if mmItemsToCSV.defaultExpectation.paramPtrs == nil {
		mmItemsToCSV.defaultExpectation.paramPtrs = &TransactionCSVRepositoryMockItemsToCSVParamPtrs{}
	}
	mmItemsToCSV.defaultExpectation.paramPtrs.items = &items
	mmItemsToCSV.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmItemsToCSV
}

// Inspect accepts an inspector function that has same arguments as the TransactionCSVRepository.ItemsToCSV
func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) Inspect(f func(ctx context.Context, items []*mm_usecase.TransactionDTO)) *mTransactionCSVRepositoryMockItemsToCSV {
	if mmItemsToCSV.mock.inspectFuncItemsToCSV != nil {
		mmItemsToCSV.mock.t.Fatalf("Inspect function is already set for TransactionCSVRepositoryMock.ItemsToCSV")
	}

	mmItemsToCSV.mock.inspectFuncItemsToCSV = f

	return mmItemsToCSV
}

// Return sets up results that will be returned by TransactionCSVRepository.ItemsToCSV
func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) Return(ba1 []byte, err error) *TransactionCSVRepositoryMock {
	if mmItemsToCSV.mock.funcItemsToCSV != nil {
		mmItemsToCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsToCSV mock is already set by Set")
	}

	if mmItemsToCSV.defaultExpectation == nil {
		mmItemsToCSV.defaultExpectation = &TransactionCSVRepositoryMockItemsToCSVExpectation{mock: mmItemsToCSV.mock}
	}
	mmItemsToCSV.defaultExpectation.results = &TransactionCSVRepositoryMockItemsToCSVResults{ba1, err}
	mmItemsToCSV.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmItemsToCSV.mock
}

// Set uses given function f to mock the TransactionCSVRepository.ItemsToCSV method
func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) Set(f func(ctx context.Context, items []*mm_usecase.TransactionDTO) (ba1 []byte, err error)) *TransactionCSVRepositoryMock {
	if mmItemsToCSV.defaultExpectation != nil {
		mmItemsToCSV.mock.t.Fatalf("Default expectation is already set for the TransactionCSVRepository.ItemsToCSV method")
	}

	if len(mmItemsToCSV.expectations) > 0 {
		mmItemsToCSV.mock.t.Fatalf("Some expectations are already set for the TransactionCSVRepository.ItemsToCSV method")
	}

	mmItemsToCSV.mock.funcItemsToCSV = f
	mmItemsToCSV.mock.funcItemsToCSVOrigin = minimock.CallerInfo(1)
	return mmItemsToCSV.mock
}

// When sets expectation for the TransactionCSVRepository.ItemsToCSV which will trigger the result defined by the following
// Then helper
func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) When(ctx context.Context, items []*mm_usecase.TransactionDTO) *TransactionCSVRepositoryMockItemsToCSVExpectation {
	if mmItemsToCSV.mock.funcItemsToCSV != nil {
		mmItemsToCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsToCSV mock is already set by Set")
	}

	expectation := &TransactionCSVRepositoryMockItemsToCSVExpectation{
		mock:               mmItemsToCSV.mock,
		params:             &TransactionCSVRepositoryMockItemsToCSVParams{ctx, items},
		expectationOrigins: TransactionCSVRepositoryMockItemsToCSVExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmItemsToCSV.expectations = append(mmItemsToCSV.expectations, expectation)
	return expectation
}

// Then sets up TransactionCSVRepository.ItemsToCSV return parameters for the expectation previously defined by the When method
func (e *TransactionCSVRepositoryMockItemsToCSVExpectation) Then(ba1 []byte, err error) *TransactionCSVRepositoryMock {
	e.results = &TransactionCSVRepositoryMockItemsToCSVResults{ba1, err}
	return e.mock
}

// Times sets number of times TransactionCSVRepository.ItemsToCSV should be invoked
func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) Times(n uint64) *mTransactionCSVRepositoryMockItemsToCSV {
	if n == 0 {
		mmItemsToCSV.mock.t.Fatalf("Times of TransactionCSVRepositoryMock.ItemsToCSV mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmItemsToCSV.expectedInvocations, n)
	mmItemsToCSV.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmItemsToCSV
}

func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) invocationsDone() bool {
	if len(mmItemsToCSV.expectations) == 0 && mmItemsToCSV.defaultExpectation == nil && mmItemsToCSV.mock.funcItemsToCSV == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmItemsToCSV.mock.afterItemsToCSVCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmItemsToCSV.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ItemsToCSV implements mm_usecase.TransactionCSVRepository
func (mmItemsToCSV *TransactionCSVRepositoryMock) ItemsToCSV(ctx context.Context, items []*mm_usecase.TransactionDTO) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmItemsToCSV.beforeItemsToCSVCounter, 1)
	defer mm_atomic.AddUint64(&mmItemsToCSV.afterItemsToCSVCounter, 1)

	mmItemsToCSV.t.Helper()

	if mmItemsToCSV.inspectFuncItemsToCSV != nil {
		mmItemsToCSV.inspectFuncItemsToCSV(ctx, items)
	}

	mm_params := TransactionCSVRepositoryMockItemsToCSVParams{ctx, items}

	// Record call args
	mmItemsToCSV.ItemsToCSVMock.mutex.Lock()
	mmItemsToCSV.ItemsToCSVMock.callArgs = append(mmItemsToCSV.ItemsToCSVMock.callArgs, &mm_params)
	mmItemsToCSV.ItemsToCSVMock.mutex.Unlock()

	for _, e := range mmItemsToCSV.ItemsToCSVMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmItemsToCSV.ItemsToCSVMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmItemsToCSV.ItemsToCSVMock.defaultExpectation.Counter, 1)
		mm_want := mmItemsToCSV.ItemsToCSVMock.defaultExpectation.params
		mm_want_ptrs := mmItemsToCSV.ItemsToCSVMock.defaultExpectation.paramPtrs

		mm_got := TransactionCSVRepositoryMockItemsToCSVParams{ctx, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmItemsToCSV.t.Errorf("TransactionCSVRepositoryMock.ItemsToCSV got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmItemsToCSV.ItemsToCSVMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmItemsToCSV.t.Errorf("TransactionCSVRepositoryMock.ItemsToCSV got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmItemsToCSV.ItemsToCSVMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmItemsToCSV.t.Errorf("TransactionCSVRepositoryMock.ItemsToCSV got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmItemsToCSV.ItemsToCSVMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmItemsToCSV.ItemsToCSVMock.defaultExpectation.results
		if mm_results == nil {
			mmItemsToCSV.t.Fatal("No results are set for the TransactionCSVRepositoryMock.ItemsToCSV")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmItemsToCSV.funcItemsToCSV != nil {
		return mmItemsToCSV.funcItemsToCSV(ctx, items)
	}
	mmItemsToCSV.t.Fatalf("Unexpected call to TransactionCSVRepositoryMock.ItemsToCSV. %v %v", ctx, items)
	return
}

// ItemsToCSVAfterCounter returns a count of finished TransactionCSVRepositoryMock.ItemsToCSV invocations
func (mmItemsToCSV *TransactionCSVRepositoryMock) ItemsToCSVAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmItemsToCSV.afterItemsToCSVCounter)
}

// ItemsToCSVBeforeCounter returns a count of TransactionCSVRepositoryMock.ItemsToCSV invocations
func (mmItemsToCSV *TransactionCSVRepositoryMock) ItemsToCSVBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmItemsToCSV.beforeItemsToCSVCounter)
}

// Calls returns a list of arguments used in each call to TransactionCSVRepositoryMock.ItemsToCSV.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) Calls() []*TransactionCSVRepositoryMockItemsToCSVParams {
	mmItemsToCSV.mutex.RLock()

	argCopy := make([]*TransactionCSVRepositoryMockItemsToCSVParams, len(mmItemsToCSV.callArgs))
	copy(argCopy, mmItemsToCSV.callArgs)

	mmItemsToCSV.mutex.RUnlock()

	return argCopy
}

// MinimockItemsToCSVDone returns true if the count of the ItemsToCSV invocations corresponds
// the number of defined expectations
func (m *TransactionCSVRepositoryMock) MinimockItemsToCSVDone() bool {
	if m.ItemsToCSVMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ItemsToCSVMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ItemsToCSVMock.invocationsDone()
}

// MinimockItemsToCSVInspect logs each unmet expectation
func (m *TransactionCSVRepositoryMock) MinimockItemsToCSVInspect() {
	for _, e := range m.ItemsToCSVMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionCSVRepositoryMock.ItemsToCSV at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterItemsToCSVCounter := mm_atomic.LoadUint64(&m.afterItemsToCSVCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ItemsToCSVMock.defaultExpectation != nil && afterItemsToCSVCounter < 1 {
		if m.ItemsToCSVMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionCSVRepositoryMock.ItemsToCSV at\n%s", m.ItemsToCSVMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionCSVRepositoryMock.ItemsToCSV at\n%s with params: %#v", m.ItemsToCSVMock.defaultExpectation.expectationOrigins.origin, *m.ItemsToCSVMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcItemsToCSV != nil && afterItemsToCSVCounter < 1 {
		m.t.Errorf("Expected call to TransactionCSVRepositoryMock.ItemsToCSV at\n%s", m.funcItemsToCSVOrigin)
	}

	if !m.ItemsToCSVMock.invocationsDone() && afterItemsToCSVCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionCSVRepositoryMock.ItemsToCSV at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ItemsToCSVMock.expectedInvocations), m.ItemsToCSVMock.expectedInvocationsOrigin, afterItemsToCSVCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TransactionCSVRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockItemsFromCSVInspect()

			m.MinimockItemsToCSVInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TransactionCSVRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TransactionCSVRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockItemsFromCSVDone() &&
		m.MinimockItemsToCSVDone()
}
