// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase.TransactionRepository -o transaction_repository.go -n TransactionRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
	"github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
	"github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
	mm_usecase "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
)

// TransactionRepositoryMock implements mm_usecase.TransactionRepository
type TransactionRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCountReportItems          func(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter) (items []*entity.AccountTransactionReportItem, err error)
	funcCountReportItemsOrigin    string
	inspectFuncCountReportItems   func(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter)
	afterCountReportItemsCounter  uint64
	beforeCountReportItemsCounter uint64
	CountReportItemsMock          mTransactionRepositoryMockCountReportItems

	funcCreate          func(ctx context.Context, item *entity.Transaction) (err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, item *entity.Transaction)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mTransactionRepositoryMockCreate

	funcFindList          func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Transaction, err error)
	funcFindListOrigin    string
	inspectFuncFindList   func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)
	afterFindListCounter  uint64
	beforeFindListCounter uint64
	FindListMock          mTransactionRepositoryMockFindList

	funcFindOneByID          func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (transaction *entity.Transaction, err error)
	funcFindOneByIDOrigin    string
	inspectFuncFindOneByID   func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)
	afterFindOneByIDCounter  uint64
	beforeFindOneByIDCounter uint64
	FindOneByIDMock          mTransactionRepositoryMockFindOneByID

	funcFindPagedList          func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Transaction, total uint64, err error)
	funcFindPagedListOrigin    string
	inspectFuncFindPagedList   func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)
	afterFindPagedListCounter  uint64
	beforeFindPagedListCounter uint64
	FindPagedListMock          mTransactionRepositoryMockFindPagedList

	funcUpdate          func(ctx context.Context, item *entity.Transaction) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, item *entity.Transaction)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mTransactionRepositoryMockUpdate
}

// NewTransactionRepositoryMock returns a mock for mm_usecase.TransactionRepository
func NewTransactionRepositoryMock(t minimock.Tester) *TransactionRepositoryMock {
	m := &TransactionRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CountReportItemsMock = mTransactionRepositoryMockCountReportItems{mock: m}
	m.CountReportItemsMock.callArgs = []*TransactionRepositoryMockCountReportItemsParams{}

	m.CreateMock = mTransactionRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*TransactionRepositoryMockCreateParams{}

	m.FindListMock = mTransactionRepositoryMockFindList{mock: m}
	m.FindListMock.callArgs = []*TransactionRepositoryMockFindListParams{}

	m.FindOneByIDMock = mTransactionRepositoryMockFindOneByID{mock: m}
	m.FindOneByIDMock.callArgs = []*TransactionRepositoryMockFindOneByIDParams{}

	m.FindPagedListMock = mTransactionRepositoryMockFindPagedList{mock: m}
	m.FindPagedListMock.callArgs = []*TransactionRepositoryMockFindPagedListParams{}

	m.UpdateMock = mTransactionRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*TransactionRepositoryMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTransactionRepositoryMockCountReportItems struct {
	optional           bool
	mock               *TransactionRepositoryMock
	defaultExpectation *TransactionRepositoryMockCountReportItemsExpectation
	expectations       []*TransactionRepositoryMockCountReportItemsExpectation

	callArgs []*TransactionRepositoryMockCountReportItemsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionRepositoryMockCountReportItemsExpectation specifies expectation struct of the TransactionRepository.CountReportItems
type TransactionRepositoryMockCountReportItemsExpectation struct {
	mock               *TransactionRepositoryMock
	params             *TransactionRepositoryMockCountReportItemsParams
	paramPtrs          *TransactionRepositoryMockCountReportItemsParamPtrs
	expectationOrigins TransactionRepositoryMockCountReportItemsExpectationOrigins
	results            *TransactionRepositoryMockCountReportItemsResults
	returnOrigin       string
	Counter            uint64
}

// TransactionRepositoryMockCountReportItemsParams contains parameters of the TransactionRepository.CountReportItems
type TransactionRepositoryMockCountReportItemsParams struct {
	ctx         context.Context
	queryFilter mm_usecase.CountReportItemsQueryFilter
}

// TransactionRepositoryMockCountReportItemsParamPtrs contains pointers to parameters of the TransactionRepository.CountReportItems
type TransactionRepositoryMockCountReportItemsParamPtrs struct {
	ctx         *context.Context
	queryFilter *mm_usecase.CountReportItemsQueryFilter
}

// TransactionRepositoryMockCountReportItemsResults contains results of the TransactionRepository.CountReportItems
type TransactionRepositoryMockCountReportItemsResults struct {
	items []*entity.AccountTransactionReportItem
	err   error
}

// TransactionRepositoryMockCountReportItemsOrigins contains origins of expectations of the TransactionRepository.CountReportItems
type TransactionRepositoryMockCountReportItemsExpectationOrigins struct {
	origin            string
	originCtx         string
	originQueryFilter string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) Optional() *mTransactionRepositoryMockCountReportItems {
	mmCountReportItems.optional = true
	return mmCountReportItems
}

// Expect sets up expected params for TransactionRepository.CountReportItems
func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) Expect(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter) *mTransactionRepositoryMockCountReportItems {
	if mmCountReportItems.mock.funcCountReportItems != nil {
		mmCountReportItems.mock.t.Fatalf("TransactionRepositoryMock.CountReportItems mock is already set by Set")
	}

	if mmCountReportItems.defaultExpectation == nil {
		mmCountReportItems.defaultExpectation = &TransactionRepositoryMockCountReportItemsExpectation{}
	}

	if mmCountReportItems.defaultExpectation.paramPtrs != nil {
		mmCountReportItems.mock.t.Fatalf("TransactionRepositoryMock.CountReportItems mock is already set by ExpectParams functions")
	}

	mmCountReportItems.defaultExpectation.params = &TransactionRepositoryMockCountReportItemsParams{ctx, queryFilter}
	mmCountReportItems.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCountReportItems.expectations {
		if minimock.Equal(e.params, mmCountReportItems.defaultExpectation.params) {
			mmCountReportItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCountReportItems.defaultExpectation.params)
		}
	}

	return mmCountReportItems
}

// ExpectCtxParam1 sets up expected param ctx for TransactionRepository.CountReportItems
func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) ExpectCtxParam1(ctx context.Context) *mTransactionRepositoryMockCountReportItems {
	if mmCountReportItems.mock.funcCountReportItems != nil {
		mmCountReportItems.mock.t.Fatalf("TransactionRepositoryMock.CountReportItems mock is already set by Set")
	}

	if mmCountReportItems.defaultExpectation == nil {
		mmCountReportItems.defaultExpectation = &TransactionRepositoryMockCountReportItemsExpectation{}
	}

	if mmCountReportItems.defaultExpectation.params != nil {
		mmCountReportItems.mock.t.Fatalf("TransactionRepositoryMock.CountReportItems mock is already set by Expect")
	}

	if mmCountReportItems.defaultExpectation.paramPtrs == nil {
		mmCountReportItems.defaultExpectation.paramPtrs = &TransactionRepositoryMockCountReportItemsParamPtrs{}
	}
	mmCountReportItems.defaultExpectation.paramPtrs.ctx = &ctx
	mmCountReportItems.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCountReportItems
}

// ExpectQueryFilterParam2 sets up expected param queryFilter for TransactionRepository.CountReportItems
func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) ExpectQueryFilterParam2(queryFilter mm_usecase.CountReportItemsQueryFilter) *mTransactionRepositoryMockCountReportItems {
	if mmCountReportItems.mock.funcCountReportItems != nil {
		mmCountReportItems.mock.t.Fatalf("TransactionRepositoryMock.CountReportItems mock is already set by Set")
	}

	if mmCountReportItems.defaultExpectation == nil {
		mmCountReportItems.defaultExpectation = &TransactionRepositoryMockCountReportItemsExpectation{}
	}

	if mmCountReportItems.defaultExpectation.params != nil {
		mmCountReportItems.mock.t.Fatalf("TransactionRepositoryMock.CountReportItems mock is already set by Expect")
	}

	if mmCountReportItems.defaultExpectation.paramPtrs == nil {
		mmCountReportItems.defaultExpectation.paramPtrs = &TransactionRepositoryMockCountReportItemsParamPtrs{}
	}
	mmCountReportItems.defaultExpectation.paramPtrs.queryFilter = &queryFilter
	mmCountReportItems.defaultExpectation.expectationOrigins.originQueryFilter = minimock.CallerInfo(1)

	return mmCountReportItems
}

// Inspect accepts an inspector function that has same arguments as the TransactionRepository.CountReportItems
func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) Inspect(f func(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter)) *mTransactionRepositoryMockCountReportItems {
	if mmCountReportItems.mock.inspectFuncCountReportItems != nil {
		mmCountReportItems.mock.t.Fatalf("Inspect function is already set for TransactionRepositoryMock.CountReportItems")
	}

	mmCountReportItems.mock.inspectFuncCountReportItems = f

	return mmCountReportItems
}

// Return sets up results that will be returned by TransactionRepository.CountReportItems
func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) Return(items []*entity.AccountTransactionReportItem, err error) *TransactionRepositoryMock {
	if mmCountReportItems.mock.funcCountReportItems != nil {
		mmCountReportItems.mock.t.Fatalf("TransactionRepositoryMock.CountReportItems mock is already set by Set")
	}

	if mmCountReportItems.defaultExpectation == nil {
		mmCountReportItems.defaultExpectation = &TransactionRepositoryMockCountReportItemsExpectation{mock: mmCountReportItems.mock}
	}
	mmCountReportItems.defaultExpectation.results = &TransactionRepositoryMockCountReportItemsResults{items, err}
	mmCountReportItems.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCountReportItems.mock
}

// Set uses given function f to mock the TransactionRepository.CountReportItems method
func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) Set(f func(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter) (items []*entity.AccountTransactionReportItem, err error)) *TransactionRepositoryMock {
	if mmCountReportItems.defaultExpectation != nil {
		mmCountReportItems.mock.t.Fatalf("Default expectation is already set for the TransactionRepository.CountReportItems method")
	}

	if len(mmCountReportItems.expectations) > 0 {
		mmCountReportItems.mock.t.Fatalf("Some expectations are already set for the TransactionRepository.CountReportItems method")
	}

	mmCountReportItems.mock.funcCountReportItems = f
	mmCountReportItems.mock.funcCountReportItemsOrigin = minimock.CallerInfo(1)
	return mmCountReportItems.mock
}

// When sets expectation for the TransactionRepository.CountReportItems which will trigger the result defined by the following
// Then helper
func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) When(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter) *TransactionRepositoryMockCountReportItemsExpectation {
	if mmCountReportItems.mock.funcCountReportItems != nil {
		mmCountReportItems.mock.t.Fatalf("TransactionRepositoryMock.CountReportItems mock is already set by Set")
	}

	expectation := &TransactionRepositoryMockCountReportItemsExpectation{
		mock:               mmCountReportItems.mock,
		params:             &TransactionRepositoryMockCountReportItemsParams{ctx, queryFilter},
		expectationOrigins: TransactionRepositoryMockCountReportItemsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCountReportItems.expectations = append(mmCountReportItems.expectations, expectation)
	return expectation
}

// Then sets up TransactionRepository.CountReportItems return parameters for the expectation previously defined by the When method
func (e *TransactionRepositoryMockCountReportItemsExpectation) Then(items []*entity.AccountTransactionReportItem, err error) *TransactionRepositoryMock {
	e.results = &TransactionRepositoryMockCountReportItemsResults{items, err}
	return e.mock
}

// Times sets number of times TransactionRepository.CountReportItems should be invoked
func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) Times(n uint64) *mTransactionRepositoryMockCountReportItems {
	if n == 0 {
		mmCountReportItems.mock.t.Fatalf("Times of TransactionRepositoryMock.CountReportItems mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCountReportItems.expectedInvocations, n)
	mmCountReportItems.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCountReportItems
}

func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) invocationsDone() bool {
	if len(mmCountReportItems.expectations) == 0 && mmCountReportItems.defaultExpectation == nil && mmCountReportItems.mock.funcCountReportItems == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCountReportItems.mock.afterCountReportItemsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCountReportItems.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CountReportItems implements mm_usecase.TransactionRepository
func (mmCountReportItems *TransactionRepositoryMock) CountReportItems(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter) (items []*entity.AccountTransactionReportItem, err error) {
	mm_atomic.AddUint64(&mmCountReportItems.beforeCountReportItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmCountReportItems.afterCountReportItemsCounter, 1)

	mmCountReportItems.t.Helper()

	if mmCountReportItems.inspectFuncCountReportItems != nil {
		mmCountReportItems.inspectFuncCountReportItems(ctx, queryFilter)
	}

	mm_params := TransactionRepositoryMockCountReportItemsParams{ctx, queryFilter}

	// Record call args
	mmCountReportItems.CountReportItemsMock.mutex.Lock()
	mmCountReportItems.CountReportItemsMock.callArgs = append(mmCountReportItems.CountReportItemsMock.callArgs, &mm_params)
	mmCountReportItems.CountReportItemsMock.mutex.Unlock()

	for _, e := range mmCountReportItems.CountReportItemsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.items, e.results.err
		}
	}

	if mmCountReportItems.CountReportItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCountReportItems.CountReportItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmCountReportItems.CountReportItemsMock.defaultExpectation.params
		mm_want_ptrs := mmCountReportItems.CountReportItemsMock.defaultExpectation.paramPtrs

		mm_got := TransactionRepositoryMockCountReportItemsParams{ctx, queryFilter}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCountReportItems.t.Errorf("TransactionRepositoryMock.CountReportItems got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCountReportItems.CountReportItemsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.queryFilter != nil && !minimock.Equal(*mm_want_ptrs.queryFilter, mm_got.queryFilter) {
				mmCountReportItems.t.Errorf("TransactionRepositoryMock.CountReportItems got unexpected parameter queryFilter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCountReportItems.CountReportItemsMock.defaultExpectation.expectationOrigins.originQueryFilter, *mm_want_ptrs.queryFilter, mm_got.queryFilter, minimock.Diff(*mm_want_ptrs.queryFilter, mm_got.queryFilter))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCountReportItems.t.Errorf("TransactionRepositoryMock.CountReportItems got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCountReportItems.CountReportItemsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCountReportItems.CountReportItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmCountReportItems.t.Fatal("No results are set for the TransactionRepositoryMock.CountReportItems")
		}
		return (*mm_results).items, (*mm_results).err
	}
	if mmCountReportItems.funcCountReportItems != nil {
		return mmCountReportItems.funcCountReportItems(ctx, queryFilter)
	}
	mmCountReportItems.t.Fatalf("Unexpected call to TransactionRepositoryMock.CountReportItems. %v %v", ctx, queryFilter)
	return
}

// CountReportItemsAfterCounter returns a count of finished TransactionRepositoryMock.CountReportItems invocations
func (mmCountReportItems *TransactionRepositoryMock) CountReportItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCountReportItems.afterCountReportItemsCounter)
}

// CountReportItemsBeforeCounter returns a count of TransactionRepositoryMock.CountReportItems invocations
func (mmCountReportItems *TransactionRepositoryMock) CountReportItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCountReportItems.beforeCountReportItemsCounter)
}

// Calls returns a list of arguments used in each call to TransactionRepositoryMock.CountReportItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) Calls() []*TransactionRepositoryMockCountReportItemsParams {
	mmCountReportItems.mutex.RLock()

	argCopy := make([]*TransactionRepositoryMockCountReportItemsParams, len(mmCountReportItems.callArgs))
	copy(argCopy, mmCountReportItems.callArgs)

	mmCountReportItems.mutex.RUnlock()

	return argCopy
}

// MinimockCountReportItemsDone returns true if the count of the CountReportItems invocations corresponds
// the number of defined expectations
func (m *TransactionRepositoryMock) MinimockCountReportItemsDone() bool {
	if m.CountReportItemsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CountReportItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CountReportItemsMock.invocationsDone()
}

// MinimockCountReportItemsInspect logs each unmet expectation
func (m *TransactionRepositoryMock) MinimockCountReportItemsInspect() {
	for _, e := range m.CountReportItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionRepositoryMock.CountReportItems at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCountReportItemsCounter := mm_atomic.LoadUint64(&m.afterCountReportItemsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CountReportItemsMock.defaultExpectation != nil && afterCountReportItemsCounter < 1 {
		if m.CountReportItemsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionRepositoryMock.CountReportItems at\n%s", m.CountReportItemsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionRepositoryMock.CountReportItems at\n%s with params: %#v", m.CountReportItemsMock.defaultExpectation.expectationOrigins.origin, *m.CountReportItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCountReportItems != nil && afterCountReportItemsCounter < 1 {
		m.t.Errorf("Expected call to TransactionRepositoryMock.CountReportItems at\n%s", m.funcCountReportItemsOrigin)
	}

	if !m.CountReportItemsMock.invocationsDone() && afterCountReportItemsCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionRepositoryMock.CountReportItems at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CountReportItemsMock.expectedInvocations), m.CountReportItemsMock.expectedInvocationsOrigin, afterCountReportItemsCounter)
	}
}

type mTransactionRepositoryMockCreate struct {
	optional           bool
	mock               *TransactionRepositoryMock
	defaultExpectation *TransactionRepositoryMockCreateExpectation
	expectations       []*TransactionRepositoryMockCreateExpectation

	callArgs []*TransactionRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionRepositoryMockCreateExpectation specifies expectation struct of the TransactionRepository.Create
type TransactionRepositoryMockCreateExpectation struct {
	mock               *TransactionRepositoryMock
	params             *TransactionRepositoryMockCreateParams
	paramPtrs          *TransactionRepositoryMockCreateParamPtrs
	expectationOrigins TransactionRepositoryMockCreateExpectationOrigins
	results            *TransactionRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// TransactionRepositoryMockCreateParams contains parameters of the TransactionRepository.Create
type TransactionRepositoryMockCreateParams struct {
	ctx  context.Context
	item *entity.Transaction
}

// TransactionRepositoryMockCreateParamPtrs contains pointers to parameters of the TransactionRepository.Create
type TransactionRepositoryMockCreateParamPtrs struct {
	ctx  *context.Context
	item **entity.Transaction
}

// TransactionRepositoryMockCreateResults contains results of the TransactionRepository.Create
type TransactionRepositoryMockCreateResults struct {
	err error
}

// TransactionRepositoryMockCreateOrigins contains origins of expectations of the TransactionRepository.Create
type TransactionRepositoryMockCreateExpectationOrigins struct {
	origin     string
	originCtx  string
	originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mTransactionRepositoryMockCreate) Optional() *mTransactionRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for TransactionRepository.Create
func (mmCreate *mTransactionRepositoryMockCreate) Expect(ctx context.Context, item *entity.Transaction) *mTransactionRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("TransactionRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &TransactionRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("TransactionRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &TransactionRepositoryMockCreateParams{ctx, item}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for TransactionRepository.Create
func (mmCreate *mTransactionRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mTransactionRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("TransactionRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &TransactionRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("TransactionRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &TransactionRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectItemParam2 sets up expected param item for TransactionRepository.Create
func (mmCreate *mTransactionRepositoryMockCreate) ExpectItemParam2(item *entity.Transaction) *mTransactionRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("TransactionRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &TransactionRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("TransactionRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &TransactionRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.item = &item
	mmCreate.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the TransactionRepository.Create
func (mmCreate *mTransactionRepositoryMockCreate) Inspect(f func(ctx context.Context, item *entity.Transaction)) *mTransactionRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for TransactionRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by TransactionRepository.Create
func (mmCreate *mTransactionRepositoryMockCreate) Return(err error) *TransactionRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("TransactionRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &TransactionRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &TransactionRepositoryMockCreateResults{err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the TransactionRepository.Create method
func (mmCreate *mTransactionRepositoryMockCreate) Set(f func(ctx context.Context, item *entity.Transaction) (err error)) *TransactionRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the TransactionRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the TransactionRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the TransactionRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mTransactionRepositoryMockCreate) When(ctx context.Context, item *entity.Transaction) *TransactionRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("TransactionRepositoryMock.Create mock is already set by Set")
	}

	expectation := &TransactionRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &TransactionRepositoryMockCreateParams{ctx, item},
		expectationOrigins: TransactionRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up TransactionRepository.Create return parameters for the expectation previously defined by the When method
func (e *TransactionRepositoryMockCreateExpectation) Then(err error) *TransactionRepositoryMock {
	e.results = &TransactionRepositoryMockCreateResults{err}
	return e.mock
}

// Times sets number of times TransactionRepository.Create should be invoked
func (mmCreate *mTransactionRepositoryMockCreate) Times(n uint64) *mTransactionRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of TransactionRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mTransactionRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_usecase.TransactionRepository
func (mmCreate *TransactionRepositoryMock) Create(ctx context.Context, item *entity.Transaction) (err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, item)
	}

	mm_params := TransactionRepositoryMockCreateParams{ctx, item}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := TransactionRepositoryMockCreateParams{ctx, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("TransactionRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmCreate.t.Errorf("TransactionRepositoryMock.Create got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("TransactionRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the TransactionRepositoryMock.Create")
		}
		return (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, item)
	}
	mmCreate.t.Fatalf("Unexpected call to TransactionRepositoryMock.Create. %v %v", ctx, item)
	return
}

// CreateAfterCounter returns a count of finished TransactionRepositoryMock.Create invocations
func (mmCreate *TransactionRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of TransactionRepositoryMock.Create invocations
func (mmCreate *TransactionRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to TransactionRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mTransactionRepositoryMockCreate) Calls() []*TransactionRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*TransactionRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *TransactionRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *TransactionRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to TransactionRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mTransactionRepositoryMockFindList struct {
	optional           bool
	mock               *TransactionRepositoryMock
	defaultExpectation *TransactionRepositoryMockFindListExpectation
	expectations       []*TransactionRepositoryMockFindListExpectation

	callArgs []*TransactionRepositoryMockFindListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionRepositoryMockFindListExpectation specifies expectation struct of the TransactionRepository.FindList
type TransactionRepositoryMockFindListExpectation struct {
	mock               *TransactionRepositoryMock
	params             *TransactionRepositoryMockFindListParams
	paramPtrs          *TransactionRepositoryMockFindListParamPtrs
	expectationOrigins TransactionRepositoryMockFindListExpectationOrigins
	results            *TransactionRepositoryMockFindListResults
	returnOrigin       string
	Counter            uint64
}

// TransactionRepositoryMockFindListParams contains parameters of the TransactionRepository.FindList
type TransactionRepositoryMockFindListParams struct {
	ctx         context.Context
	listOptions *mm_usecase.TransactionListOptions
	queryParams *uctypes.QueryGetListParams
}

// TransactionRepositoryMockFindListParamPtrs contains pointers to parameters of the TransactionRepository.FindList
type TransactionRepositoryMockFindListParamPtrs struct {
	ctx         *context.Context
	listOptions **mm_usecase.TransactionListOptions
	queryParams **uctypes.QueryGetListParams
}

// TransactionRepositoryMockFindListResults contains results of the TransactionRepository.FindList
type TransactionRepositoryMockFindListResults struct {
	items []*entity.Transaction
	err   error
}

// TransactionRepositoryMockFindListOrigins contains origins of expectations of the TransactionRepository.FindList
type TransactionRepositoryMockFindListExpectationOrigins struct {
	origin            string
	originCtx         string
	originListOptions string
	originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindList *mTransactionRepositoryMockFindList) Optional() *mTransactionRepositoryMockFindList {
	mmFindList.optional = true
	return mmFindList
}

// Expect sets up expected params for TransactionRepository.FindList
func (mmFindList *mTransactionRepositoryMockFindList) Expect(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *mTransactionRepositoryMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("TransactionRepositoryMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &TransactionRepositoryMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.paramPtrs != nil {
		mmFindList.mock.t.Fatalf("TransactionRepositoryMock.FindList mock is already set by ExpectParams functions")
	}

	mmFindList.defaultExpectation.params = &TransactionRepositoryMockFindListParams{ctx, listOptions, queryParams}
	mmFindList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindList.expectations {
		if minimock.Equal(e.params, mmFindList.defaultExpectation.params) {
			mmFindList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindList.defaultExpectation.params)
		}
	}

	return mmFindList
}

// ExpectCtxParam1 sets up expected param ctx for TransactionRepository.FindList
func (mmFindList *mTransactionRepositoryMockFindList) ExpectCtxParam1(ctx context.Context) *mTransactionRepositoryMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("TransactionRepositoryMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &TransactionRepositoryMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.params != nil {
		mmFindList.mock.t.Fatalf("TransactionRepositoryMock.FindList mock is already set by Expect")
	}

	if mmFindList.defaultExpectation.paramPtrs == nil {
		mmFindList.defaultExpectation.paramPtrs = &TransactionRepositoryMockFindListParamPtrs{}
	}
	mmFindList.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindList
}

// ExpectListOptionsParam2 sets up expected param listOptions for TransactionRepository.FindList
func (mmFindList *mTransactionRepositoryMockFindList) ExpectListOptionsParam2(listOptions *mm_usecase.TransactionListOptions) *mTransactionRepositoryMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("TransactionRepositoryMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &TransactionRepositoryMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.params != nil {
		mmFindList.mock.t.Fatalf("TransactionRepositoryMock.FindList mock is already set by Expect")
	}

	if mmFindList.defaultExpectation.paramPtrs == nil {
		mmFindList.defaultExpectation.paramPtrs = &TransactionRepositoryMockFindListParamPtrs{}
	}
	mmFindList.defaultExpectation.paramPtrs.listOptions = &listOptions
	mmFindList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

	return mmFindList
}

// ExpectQueryParamsParam3 sets up expected param queryParams for TransactionRepository.FindList
func (mmFindList *mTransactionRepositoryMockFindList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mTransactionRepositoryMockFindList {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("TransactionRepositoryMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &TransactionRepositoryMockFindListExpectation{}
	}

	if mmFindList.defaultExpectation.params != nil {
		mmFindList.mock.t.Fatalf("TransactionRepositoryMock.FindList mock is already set by Expect")
	}

	if mmFindList.defaultExpectation.paramPtrs == nil {
		mmFindList.defaultExpectation.paramPtrs = &TransactionRepositoryMockFindListParamPtrs{}
	}
	mmFindList.defaultExpectation.paramPtrs.queryParams = &queryParams
	mmFindList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

	return mmFindList
}

// Inspect accepts an inspector function that has same arguments as the TransactionRepository.FindList
func (mmFindList *mTransactionRepositoryMockFindList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)) *mTransactionRepositoryMockFindList {
	if mmFindList.mock.inspectFuncFindList != nil {
		mmFindList.mock.t.Fatalf("Inspect function is already set for TransactionRepositoryMock.FindList")
	}

	mmFindList.mock.inspectFuncFindList = f

	return mmFindList
}

// Return sets up results that will be returned by TransactionRepository.FindList
func (mmFindList *mTransactionRepositoryMockFindList) Return(items []*entity.Transaction, err error) *TransactionRepositoryMock {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("TransactionRepositoryMock.FindList mock is already set by Set")
	}

	if mmFindList.defaultExpectation == nil {
		mmFindList.defaultExpectation = &TransactionRepositoryMockFindListExpectation{mock: mmFindList.mock}
	}
	mmFindList.defaultExpectation.results = &TransactionRepositoryMockFindListResults{items, err}
	mmFindList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindList.mock
}

// Set uses given function f to mock the TransactionRepository.FindList method
func (mmFindList *mTransactionRepositoryMockFindList) Set(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Transaction, err error)) *TransactionRepositoryMock {
	if mmFindList.defaultExpectation != nil {
		mmFindList.mock.t.Fatalf("Default expectation is already set for the TransactionRepository.FindList method")
	}

	if len(mmFindList.expectations) > 0 {
		mmFindList.mock.t.Fatalf("Some expectations are already set for the TransactionRepository.FindList method")
	}

	mmFindList.mock.funcFindList = f
	mmFindList.mock.funcFindListOrigin = minimock.CallerInfo(1)
	return mmFindList.mock
}

// When sets expectation for the TransactionRepository.FindList which will trigger the result defined by the following
// Then helper
func (mmFindList *mTransactionRepositoryMockFindList) When(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *TransactionRepositoryMockFindListExpectation {
	if mmFindList.mock.funcFindList != nil {
		mmFindList.mock.t.Fatalf("TransactionRepositoryMock.FindList mock is already set by Set")
	}

	expectation := &TransactionRepositoryMockFindListExpectation{
		mock:               mmFindList.mock,
		params:             &TransactionRepositoryMockFindListParams{ctx, listOptions, queryParams},
		expectationOrigins: TransactionRepositoryMockFindListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindList.expectations = append(mmFindList.expectations, expectation)
	return expectation
}

// Then sets up TransactionRepository.FindList return parameters for the expectation previously defined by the When method
func (e *TransactionRepositoryMockFindListExpectation) Then(items []*entity.Transaction, err error) *TransactionRepositoryMock {
	e.results = &TransactionRepositoryMockFindListResults{items, err}
	return e.mock
}

// Times sets number of times TransactionRepository.FindList should be invoked
func (mmFindList *mTransactionRepositoryMockFindList) Times(n uint64) *mTransactionRepositoryMockFindList {
	if n == 0 {
		mmFindList.mock.t.Fatalf("Times of TransactionRepositoryMock.FindList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindList.expectedInvocations, n)
	mmFindList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindList
}

func (mmFindList *mTransactionRepositoryMockFindList) invocationsDone() bool {
	if len(mmFindList.expectations) == 0 && mmFindList.defaultExpectation == nil && mmFindList.mock.funcFindList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindList.mock.afterFindListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindList implements mm_usecase.TransactionRepository
func (mmFindList *TransactionRepositoryMock) FindList(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Transaction, err error) {
	mm_atomic.AddUint64(&mmFindList.beforeFindListCounter, 1)
	defer mm_atomic.AddUint64(&mmFindList.afterFindListCounter, 1)

	mmFindList.t.Helper()

	if mmFindList.inspectFuncFindList != nil {
		mmFindList.inspectFuncFindList(ctx, listOptions, queryParams)
	}

	mm_params := TransactionRepositoryMockFindListParams{ctx, listOptions, queryParams}

	// Record call args
	mmFindList.FindListMock.mutex.Lock()
	mmFindList.FindListMock.callArgs = append(mmFindList.FindListMock.callArgs, &mm_params)
	mmFindList.FindListMock.mutex.Unlock()

	for _, e := range mmFindList.FindListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.items, e.results.err
		}
	}

	if mmFindList.FindListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindList.FindListMock.defaultExpectation.Counter, 1)
		mm_want := mmFindList.FindListMock.defaultExpectation.params
		mm_want_ptrs := mmFindList.FindListMock.defaultExpectation.paramPtrs

		mm_got := TransactionRepositoryMockFindListParams{ctx, listOptions, queryParams}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindList.t.Errorf("TransactionRepositoryMock.FindList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindList.FindListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.listOptions != nil && !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) {
				mmFindList.t.Errorf("TransactionRepositoryMock.FindList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindList.FindListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
			}

			if mm_want_ptrs.queryParams != nil && !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) {
				mmFindList.t.Errorf("TransactionRepositoryMock.FindList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindList.FindListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindList.t.Errorf("TransactionRepositoryMock.FindList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindList.FindListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindList.FindListMock.defaultExpectation.results
		if mm_results == nil {
			mmFindList.t.Fatal("No results are set for the TransactionRepositoryMock.FindList")
		}
		return (*mm_results).items, (*mm_results).err
	}
	if mmFindList.funcFindList != nil {
		return mmFindList.funcFindList(ctx, listOptions, queryParams)
	}
	mmFindList.t.Fatalf("Unexpected call to TransactionRepositoryMock.FindList. %v %v %v", ctx, listOptions, queryParams)
	return
}

// FindListAfterCounter returns a count of finished TransactionRepositoryMock.FindList invocations
func (mmFindList *TransactionRepositoryMock) FindListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindList.afterFindListCounter)
}

// FindListBeforeCounter returns a count of TransactionRepositoryMock.FindList invocations
func (mmFindList *TransactionRepositoryMock) FindListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindList.beforeFindListCounter)
}

// Calls returns a list of arguments used in each call to TransactionRepositoryMock.FindList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindList *mTransactionRepositoryMockFindList) Calls() []*TransactionRepositoryMockFindListParams {
	mmFindList.mutex.RLock()

	argCopy := make([]*TransactionRepositoryMockFindListParams, len(mmFindList.callArgs))
	copy(argCopy, mmFindList.callArgs)

	mmFindList.mutex.RUnlock()

	return argCopy
}

// MinimockFindListDone returns true if the count of the FindList invocations corresponds
// the number of defined expectations
func (m *TransactionRepositoryMock) MinimockFindListDone() bool {
	if m.FindListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindListMock.invocationsDone()
}

// MinimockFindListInspect logs each unmet expectation
func (m *TransactionRepositoryMock) MinimockFindListInspect() {
	for _, e := range m.FindListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionRepositoryMock.FindList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindListCounter := mm_atomic.LoadUint64(&m.afterFindListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindListMock.defaultExpectation != nil && afterFindListCounter < 1 {
		if m.FindListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionRepositoryMock.FindList at\n%s", m.FindListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionRepositoryMock.FindList at\n%s with params: %#v", m.FindListMock.defaultExpectation.expectationOrigins.origin, *m.FindListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindList != nil && afterFindListCounter < 1 {
		m.t.Errorf("Expected call to TransactionRepositoryMock.FindList at\n%s", m.funcFindListOrigin)
	}

	if !m.FindListMock.invocationsDone() && afterFindListCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionRepositoryMock.FindList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindListMock.expectedInvocations), m.FindListMock.expectedInvocationsOrigin, afterFindListCounter)
	}
}

type mTransactionRepositoryMockFindOneByID struct {
	optional           bool
	mock               *TransactionRepositoryMock
	defaultExpectation *TransactionRepositoryMockFindOneByIDExpectation
	expectations       []*TransactionRepositoryMockFindOneByIDExpectation

	callArgs []*TransactionRepositoryMockFindOneByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionRepositoryMockFindOneByIDExpectation specifies expectation struct of the TransactionRepository.FindOneByID
type TransactionRepositoryMockFindOneByIDExpectation struct {
	mock               *TransactionRepositoryMock
	params             *TransactionRepositoryMockFindOneByIDParams
	paramPtrs          *TransactionRepositoryMockFindOneByIDParamPtrs
	expectationOrigins TransactionRepositoryMockFindOneByIDExpectationOrigins
	results            *TransactionRepositoryMockFindOneByIDResults
	returnOrigin       string
	Counter            uint64
}

// TransactionRepositoryMockFindOneByIDParams contains parameters of the TransactionRepository.FindOneByID
type TransactionRepositoryMockFindOneByIDParams struct {
	ctx         context.Context
	id          uuid.UUID
	queryParams *uctypes.QueryGetOneParams
}

// TransactionRepositoryMockFindOneByIDParamPtrs contains pointers to parameters of the TransactionRepository.FindOneByID
type TransactionRepositoryMockFindOneByIDParamPtrs struct {
	ctx         *context.Context
	id          *uuid.UUID
	queryParams **uctypes.QueryGetOneParams
}

// TransactionRepositoryMockFindOneByIDResults contains results of the TransactionRepository.FindOneByID
type TransactionRepositoryMockFindOneByIDResults struct {
	transaction *entity.Transaction
	err         error
}

// TransactionRepositoryMockFindOneByIDOrigins contains origins of expectations of the TransactionRepository.FindOneByID
type TransactionRepositoryMockFindOneByIDExpectationOrigins struct {
	origin            string
	originCtx         string
	originId          string
	originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) Optional() *mTransactionRepositoryMockFindOneByID {
	mmFindOneByID.optional = true
	return mmFindOneByID
}

// Expect sets up expected params for TransactionRepository.FindOneByID
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) Expect(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *mTransactionRepositoryMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("TransactionRepositoryMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &TransactionRepositoryMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.paramPtrs != nil {
		mmFindOneByID.mock.t.Fatalf("TransactionRepositoryMock.FindOneByID mock is already set by ExpectParams functions")
	}

	mmFindOneByID.defaultExpectation.params = &TransactionRepositoryMockFindOneByIDParams{ctx, id, queryParams}
	mmFindOneByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindOneByID.expectations {
		if minimock.Equal(e.params, mmFindOneByID.defaultExpectation.params) {
			mmFindOneByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindOneByID.defaultExpectation.params)
		}
	}

	return mmFindOneByID
}

// ExpectCtxParam1 sets up expected param ctx for TransactionRepository.FindOneByID
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) ExpectCtxParam1(ctx context.Context) *mTransactionRepositoryMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("TransactionRepositoryMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &TransactionRepositoryMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.params != nil {
		mmFindOneByID.mock.t.Fatalf("TransactionRepositoryMock.FindOneByID mock is already set by Expect")
	}

	if mmFindOneByID.defaultExpectation.paramPtrs == nil {
		mmFindOneByID.defaultExpectation.paramPtrs = &TransactionRepositoryMockFindOneByIDParamPtrs{}
	}
	mmFindOneByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindOneByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindOneByID
}

// ExpectIdParam2 sets up expected param id for TransactionRepository.FindOneByID
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) ExpectIdParam2(id uuid.UUID) *mTransactionRepositoryMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("TransactionRepositoryMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &TransactionRepositoryMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.params != nil {
		mmFindOneByID.mock.t.Fatalf("TransactionRepositoryMock.FindOneByID mock is already set by Expect")
	}

	if mmFindOneByID.defaultExpectation.paramPtrs == nil {
		mmFindOneByID.defaultExpectation.paramPtrs = &TransactionRepositoryMockFindOneByIDParamPtrs{}
	}
	mmFindOneByID.defaultExpectation.paramPtrs.id = &id
	mmFindOneByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmFindOneByID
}

// ExpectQueryParamsParam3 sets up expected param queryParams for TransactionRepository.FindOneByID
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetOneParams) *mTransactionRepositoryMockFindOneByID {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("TransactionRepositoryMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &TransactionRepositoryMockFindOneByIDExpectation{}
	}

	if mmFindOneByID.defaultExpectation.params != nil {
		mmFindOneByID.mock.t.Fatalf("TransactionRepositoryMock.FindOneByID mock is already set by Expect")
	}

	if mmFindOneByID.defaultExpectation.paramPtrs == nil {
		mmFindOneByID.defaultExpectation.paramPtrs = &TransactionRepositoryMockFindOneByIDParamPtrs{}
	}
	mmFindOneByID.defaultExpectation.paramPtrs.queryParams = &queryParams
	mmFindOneByID.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

	return mmFindOneByID
}

// Inspect accepts an inspector function that has same arguments as the TransactionRepository.FindOneByID
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) Inspect(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)) *mTransactionRepositoryMockFindOneByID {
	if mmFindOneByID.mock.inspectFuncFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("Inspect function is already set for TransactionRepositoryMock.FindOneByID")
	}

	mmFindOneByID.mock.inspectFuncFindOneByID = f

	return mmFindOneByID
}

// Return sets up results that will be returned by TransactionRepository.FindOneByID
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) Return(transaction *entity.Transaction, err error) *TransactionRepositoryMock {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("TransactionRepositoryMock.FindOneByID mock is already set by Set")
	}

	if mmFindOneByID.defaultExpectation == nil {
		mmFindOneByID.defaultExpectation = &TransactionRepositoryMockFindOneByIDExpectation{mock: mmFindOneByID.mock}
	}
	mmFindOneByID.defaultExpectation.results = &TransactionRepositoryMockFindOneByIDResults{transaction, err}
	mmFindOneByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindOneByID.mock
}

// Set uses given function f to mock the TransactionRepository.FindOneByID method
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) Set(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (transaction *entity.Transaction, err error)) *TransactionRepositoryMock {
	if mmFindOneByID.defaultExpectation != nil {
		mmFindOneByID.mock.t.Fatalf("Default expectation is already set for the TransactionRepository.FindOneByID method")
	}

	if len(mmFindOneByID.expectations) > 0 {
		mmFindOneByID.mock.t.Fatalf("Some expectations are already set for the TransactionRepository.FindOneByID method")
	}

	mmFindOneByID.mock.funcFindOneByID = f
	mmFindOneByID.mock.funcFindOneByIDOrigin = minimock.CallerInfo(1)
	return mmFindOneByID.mock
}

// When sets expectation for the TransactionRepository.FindOneByID which will trigger the result defined by the following
// Then helper
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) When(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *TransactionRepositoryMockFindOneByIDExpectation {
	if mmFindOneByID.mock.funcFindOneByID != nil {
		mmFindOneByID.mock.t.Fatalf("TransactionRepositoryMock.FindOneByID mock is already set by Set")
	}

	expectation := &TransactionRepositoryMockFindOneByIDExpectation{
		mock:               mmFindOneByID.mock,
		params:             &TransactionRepositoryMockFindOneByIDParams{ctx, id, queryParams},
		expectationOrigins: TransactionRepositoryMockFindOneByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindOneByID.expectations = append(mmFindOneByID.expectations, expectation)
	return expectation
}

// Then sets up TransactionRepository.FindOneByID return parameters for the expectation previously defined by the When method
func (e *TransactionRepositoryMockFindOneByIDExpectation) Then(transaction *entity.Transaction, err error) *TransactionRepositoryMock {
	e.results = &TransactionRepositoryMockFindOneByIDResults{transaction, err}
	return e.mock
}

// Times sets number of times TransactionRepository.FindOneByID should be invoked
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) Times(n uint64) *mTransactionRepositoryMockFindOneByID {
	if n == 0 {
		mmFindOneByID.mock.t.Fatalf("Times of TransactionRepositoryMock.FindOneByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindOneByID.expectedInvocations, n)
	mmFindOneByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindOneByID
}

func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) invocationsDone() bool {
	if len(mmFindOneByID.expectations) == 0 && mmFindOneByID.defaultExpectation == nil && mmFindOneByID.mock.funcFindOneByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindOneByID.mock.afterFindOneByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindOneByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindOneByID implements mm_usecase.TransactionRepository
func (mmFindOneByID *TransactionRepositoryMock) FindOneByID(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (transaction *entity.Transaction, err error) {
	mm_atomic.AddUint64(&mmFindOneByID.beforeFindOneByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmFindOneByID.afterFindOneByIDCounter, 1)

	mmFindOneByID.t.Helper()

	if mmFindOneByID.inspectFuncFindOneByID != nil {
		mmFindOneByID.inspectFuncFindOneByID(ctx, id, queryParams)
	}

	mm_params := TransactionRepositoryMockFindOneByIDParams{ctx, id, queryParams}

	// Record call args
	mmFindOneByID.FindOneByIDMock.mutex.Lock()
	mmFindOneByID.FindOneByIDMock.callArgs = append(mmFindOneByID.FindOneByIDMock.callArgs, &mm_params)
	mmFindOneByID.FindOneByIDMock.mutex.Unlock()

	for _, e := range mmFindOneByID.FindOneByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.transaction, e.results.err
		}
	}

	if mmFindOneByID.FindOneByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindOneByID.FindOneByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmFindOneByID.FindOneByIDMock.defaultExpectation.params
		mm_want_ptrs := mmFindOneByID.FindOneByIDMock.defaultExpectation.paramPtrs

		mm_got := TransactionRepositoryMockFindOneByIDParams{ctx, id, queryParams}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindOneByID.t.Errorf("TransactionRepositoryMock.FindOneByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmFindOneByID.t.Errorf("TransactionRepositoryMock.FindOneByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.queryParams != nil && !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) {
				mmFindOneByID.t.Errorf("TransactionRepositoryMock.FindOneByID got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindOneByID.t.Errorf("TransactionRepositoryMock.FindOneByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindOneByID.FindOneByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmFindOneByID.t.Fatal("No results are set for the TransactionRepositoryMock.FindOneByID")
		}
		return (*mm_results).transaction, (*mm_results).err
	}
	if mmFindOneByID.funcFindOneByID != nil {
		return mmFindOneByID.funcFindOneByID(ctx, id, queryParams)
	}
	mmFindOneByID.t.Fatalf("Unexpected call to TransactionRepositoryMock.FindOneByID. %v %v %v", ctx, id, queryParams)
	return
}

// FindOneByIDAfterCounter returns a count of finished TransactionRepositoryMock.FindOneByID invocations
func (mmFindOneByID *TransactionRepositoryMock) FindOneByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindOneByID.afterFindOneByIDCounter)
}

// FindOneByIDBeforeCounter returns a count of TransactionRepositoryMock.FindOneByID invocations
func (mmFindOneByID *TransactionRepositoryMock) FindOneByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindOneByID.beforeFindOneByIDCounter)
}

// Calls returns a list of arguments used in each call to TransactionRepositoryMock.FindOneByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) Calls() []*TransactionRepositoryMockFindOneByIDParams {
	mmFindOneByID.mutex.RLock()

	argCopy := make([]*TransactionRepositoryMockFindOneByIDParams, len(mmFindOneByID.callArgs))
	copy(argCopy, mmFindOneByID.callArgs)

	mmFindOneByID.mutex.RUnlock()

	return argCopy
}

// MinimockFindOneByIDDone returns true if the count of the FindOneByID invocations corresponds
// the number of defined expectations
func (m *TransactionRepositoryMock) MinimockFindOneByIDDone() bool {
	if m.FindOneByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindOneByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindOneByIDMock.invocationsDone()
}

// MinimockFindOneByIDInspect logs each unmet expectation
func (m *TransactionRepositoryMock) MinimockFindOneByIDInspect() {
	for _, e := range m.FindOneByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionRepositoryMock.FindOneByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindOneByIDCounter := mm_atomic.LoadUint64(&m.afterFindOneByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindOneByIDMock.defaultExpectation != nil && afterFindOneByIDCounter < 1 {
		if m.FindOneByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionRepositoryMock.FindOneByID at\n%s", m.FindOneByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionRepositoryMock.FindOneByID at\n%s with params: %#v", m.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *m.FindOneByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindOneByID != nil && afterFindOneByIDCounter < 1 {
		m.t.Errorf("Expected call to TransactionRepositoryMock.FindOneByID at\n%s", m.funcFindOneByIDOrigin)
	}

	if !m.FindOneByIDMock.invocationsDone() && afterFindOneByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionRepositoryMock.FindOneByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindOneByIDMock.expectedInvocations), m.FindOneByIDMock.expectedInvocationsOrigin, afterFindOneByIDCounter)
	}
}

type mTransactionRepositoryMockFindPagedList struct {
	optional           bool
	mock               *TransactionRepositoryMock
	defaultExpectation *TransactionRepositoryMockFindPagedListExpectation
	expectations       []*TransactionRepositoryMockFindPagedListExpectation

	callArgs []*TransactionRepositoryMockFindPagedListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionRepositoryMockFindPagedListExpectation specifies expectation struct of the TransactionRepository.FindPagedList
type TransactionRepositoryMockFindPagedListExpectation struct {
	mock               *TransactionRepositoryMock
	params             *TransactionRepositoryMockFindPagedListParams
	paramPtrs          *TransactionRepositoryMockFindPagedListParamPtrs
	expectationOrigins TransactionRepositoryMockFindPagedListExpectationOrigins
	results            *TransactionRepositoryMockFindPagedListResults
	returnOrigin       string
	Counter            uint64
}

// TransactionRepositoryMockFindPagedListParams contains parameters of the TransactionRepository.FindPagedList
type TransactionRepositoryMockFindPagedListParams struct {
	ctx         context.Context
	listOptions *mm_usecase.TransactionListOptions
	queryParams *uctypes.QueryGetListParams
}

// TransactionRepositoryMockFindPagedListParamPtrs contains pointers to parameters of the TransactionRepository.FindPagedList
type TransactionRepositoryMockFindPagedListParamPtrs struct {
	ctx         *context.Context
	listOptions **mm_usecase.TransactionListOptions
	queryParams **uctypes.QueryGetListParams
}

// TransactionRepositoryMockFindPagedListResults contains results of the TransactionRepository.FindPagedList
type TransactionRepositoryMockFindPagedListResults struct {
	items []*entity.Transaction
	total uint64
	err   error
}

// TransactionRepositoryMockFindPagedListOrigins contains origins of expectations of the TransactionRepository.FindPagedList
type TransactionRepositoryMockFindPagedListExpectationOrigins struct {
	origin            string
	originCtx         string
	originListOptions string
	originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) Optional() *mTransactionRepositoryMockFindPagedList {
	mmFindPagedList.optional = true
	return mmFindPagedList
}

// Expect sets up expected params for TransactionRepository.FindPagedList
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) Expect(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *mTransactionRepositoryMockFindPagedList {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("TransactionRepositoryMock.FindPagedList mock is already set by Set")
	}

	if mmFindPagedList.defaultExpectation == nil {
		mmFindPagedList.defaultExpectation = &TransactionRepositoryMockFindPagedListExpectation{}
	}

	if mmFindPagedList.defaultExpectation.paramPtrs != nil {
		mmFindPagedList.mock.t.Fatalf("TransactionRepositoryMock.FindPagedList mock is already set by ExpectParams functions")
	}

	mmFindPagedList.defaultExpectation.params = &TransactionRepositoryMockFindPagedListParams{ctx, listOptions, queryParams}
	mmFindPagedList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindPagedList.expectations {
		if minimock.Equal(e.params, mmFindPagedList.defaultExpectation.params) {
			mmFindPagedList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindPagedList.defaultExpectation.params)
		}
	}

	return mmFindPagedList
}

// ExpectCtxParam1 sets up expected param ctx for TransactionRepository.FindPagedList
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) ExpectCtxParam1(ctx context.Context) *mTransactionRepositoryMockFindPagedList {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("TransactionRepositoryMock.FindPagedList mock is already set by Set")
	}

	if mmFindPagedList.defaultExpectation == nil {
		mmFindPagedList.defaultExpectation = &TransactionRepositoryMockFindPagedListExpectation{}
	}

	if mmFindPagedList.defaultExpectation.params != nil {
		mmFindPagedList.mock.t.Fatalf("TransactionRepositoryMock.FindPagedList mock is already set by Expect")
	}

	if mmFindPagedList.defaultExpectation.paramPtrs == nil {
		mmFindPagedList.defaultExpectation.paramPtrs = &TransactionRepositoryMockFindPagedListParamPtrs{}
	}
	mmFindPagedList.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindPagedList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindPagedList
}

// ExpectListOptionsParam2 sets up expected param listOptions for TransactionRepository.FindPagedList
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) ExpectListOptionsParam2(listOptions *mm_usecase.TransactionListOptions) *mTransactionRepositoryMockFindPagedList {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("TransactionRepositoryMock.FindPagedList mock is already set by Set")
	}

	if mmFindPagedList.defaultExpectation == nil {
		mmFindPagedList.defaultExpectation = &TransactionRepositoryMockFindPagedListExpectation{}
	}

	if mmFindPagedList.defaultExpectation.params != nil {
		mmFindPagedList.mock.t.Fatalf("TransactionRepositoryMock.FindPagedList mock is already set by Expect")
	}

	if mmFindPagedList.defaultExpectation.paramPtrs == nil {
		mmFindPagedList.defaultExpectation.paramPtrs = &TransactionRepositoryMockFindPagedListParamPtrs{}
	}
	mmFindPagedList.defaultExpectation.paramPtrs.listOptions = &listOptions
	mmFindPagedList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

	return mmFindPagedList
}

// ExpectQueryParamsParam3 sets up expected param queryParams for TransactionRepository.FindPagedList
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mTransactionRepositoryMockFindPagedList {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("TransactionRepositoryMock.FindPagedList mock is already set by Set")
	}

	if mmFindPagedList.defaultExpectation == nil {
		mmFindPagedList.defaultExpectation = &TransactionRepositoryMockFindPagedListExpectation{}
	}

	if mmFindPagedList.defaultExpectation.params != nil {
		mmFindPagedList.mock.t.Fatalf("TransactionRepositoryMock.FindPagedList mock is already set by Expect")
	}

	if mmFindPagedList.defaultExpectation.paramPtrs == nil {
		mmFindPagedList.defaultExpectation.paramPtrs = &TransactionRepositoryMockFindPagedListParamPtrs{}
	}
	mmFindPagedList.defaultExpectation.paramPtrs.queryParams = &queryParams
	mmFindPagedList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

	return mmFindPagedList
}

// Inspect accepts an inspector function that has same arguments as the TransactionRepository.FindPagedList
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)) *mTransactionRepositoryMockFindPagedList {
	if mmFindPagedList.mock.inspectFuncFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("Inspect function is already set for TransactionRepositoryMock.FindPagedList")
	}

	mmFindPagedList.mock.inspectFuncFindPagedList = f

	return mmFindPagedList
}

// Return sets up results that will be returned by TransactionRepository.FindPagedList
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) Return(items []*entity.Transaction, total uint64, err error) *TransactionRepositoryMock {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("TransactionRepositoryMock.FindPagedList mock is already set by Set")
	}

	if mmFindPagedList.defaultExpectation == nil {
		mmFindPagedList.defaultExpectation = &TransactionRepositoryMockFindPagedListExpectation{mock: mmFindPagedList.mock}
	}
	mmFindPagedList.defaultExpectation.results = &TransactionRepositoryMockFindPagedListResults{items, total, err}
	mmFindPagedList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindPagedList.mock
}

// Set uses given function f to mock the TransactionRepository.FindPagedList method
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) Set(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Transaction, total uint64, err error)) *TransactionRepositoryMock {
	if mmFindPagedList.defaultExpectation != nil {
		mmFindPagedList.mock.t.Fatalf("Default expectation is already set for the TransactionRepository.FindPagedList method")
	}

	if len(mmFindPagedList.expectations) > 0 {
		mmFindPagedList.mock.t.Fatalf("Some expectations are already set for the TransactionRepository.FindPagedList method")
	}

	mmFindPagedList.mock.funcFindPagedList = f
	mmFindPagedList.mock.funcFindPagedListOrigin = minimock.CallerInfo(1)
	return mmFindPagedList.mock
}

// When sets expectation for the TransactionRepository.FindPagedList which will trigger the result defined by the following
// Then helper
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) When(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *TransactionRepositoryMockFindPagedListExpectation {
	if mmFindPagedList.mock.funcFindPagedList != nil {
		mmFindPagedList.mock.t.Fatalf("TransactionRepositoryMock.FindPagedList mock is already set by Set")
	}

	expectation := &TransactionRepositoryMockFindPagedListExpectation{
		mock:               mmFindPagedList.mock,
		params:             &TransactionRepositoryMockFindPagedListParams{ctx, listOptions, queryParams},
		expectationOrigins: TransactionRepositoryMockFindPagedListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindPagedList.expectations = append(mmFindPagedList.expectations, expectation)
	return expectation
}

// Then sets up TransactionRepository.FindPagedList return parameters for the expectation previously defined by the When method
func (e *TransactionRepositoryMockFindPagedListExpectation) Then(items []*entity.Transaction, total uint64, err error) *TransactionRepositoryMock {
	e.results = &TransactionRepositoryMockFindPagedListResults{items, total, err}
	return e.mock
}

// Times sets number of times TransactionRepository.FindPagedList should be invoked
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) Times(n uint64) *mTransactionRepositoryMockFindPagedList {
	if n == 0 {
		mmFindPagedList.mock.t.Fatalf("Times of TransactionRepositoryMock.FindPagedList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindPagedList.expectedInvocations, n)
	mmFindPagedList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindPagedList
}

func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) invocationsDone() bool {
	if len(mmFindPagedList.expectations) == 0 && mmFindPagedList.defaultExpectation == nil && mmFindPagedList.mock.funcFindPagedList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindPagedList.mock.afterFindPagedListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindPagedList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindPagedList implements mm_usecase.TransactionRepository
func (mmFindPagedList *TransactionRepositoryMock) FindPagedList(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Transaction, total uint64, err error) {
	mm_atomic.AddUint64(&mmFindPagedList.beforeFindPagedListCounter, 1)
	defer mm_atomic.AddUint64(&mmFindPagedList.afterFindPagedListCounter, 1)

	mmFindPagedList.t.Helper()

	if mmFindPagedList.inspectFuncFindPagedList != nil {
		mmFindPagedList.inspectFuncFindPagedList(ctx, listOptions, queryParams)
	}

	mm_params := TransactionRepositoryMockFindPagedListParams{ctx, listOptions, queryParams}

	// Record call args
	mmFindPagedList.FindPagedListMock.mutex.Lock()
	mmFindPagedList.FindPagedListMock.callArgs = append(mmFindPagedList.FindPagedListMock.callArgs, &mm_params)
	mmFindPagedList.FindPagedListMock.mutex.Unlock()

	for _, e := range mmFindPagedList.FindPagedListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.items, e.results.total, e.results.err
		}
	}

	if mmFindPagedList.FindPagedListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindPagedList.FindPagedListMock.defaultExpectation.Counter, 1)
		mm_want := mmFindPagedList.FindPagedListMock.defaultExpectation.params
		mm_want_ptrs := mmFindPagedList.FindPagedListMock.defaultExpectation.paramPtrs

		mm_got := TransactionRepositoryMockFindPagedListParams{ctx, listOptions, queryParams}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindPagedList.t.Errorf("TransactionRepositoryMock.FindPagedList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.listOptions != nil && !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) {
				mmFindPagedList.t.Errorf("TransactionRepositoryMock.FindPagedList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
			}

			if mm_want_ptrs.queryParams != nil && !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) {
				mmFindPagedList.t.Errorf("TransactionRepositoryMock.FindPagedList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindPagedList.t.Errorf("TransactionRepositoryMock.FindPagedList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindPagedList.FindPagedListMock.defaultExpectation.results
		if mm_results == nil {
			mmFindPagedList.t.Fatal("No results are set for the TransactionRepositoryMock.FindPagedList")
		}
		return (*mm_results).items, (*mm_results).total, (*mm_results).err
	}
	if mmFindPagedList.funcFindPagedList != nil {
		return mmFindPagedList.funcFindPagedList(ctx, listOptions, queryParams)
	}
	mmFindPagedList.t.Fatalf("Unexpected call to TransactionRepositoryMock.FindPagedList. %v %v %v", ctx, listOptions, queryParams)
	return
}

// FindPagedListAfterCounter returns a count of finished TransactionRepositoryMock.FindPagedList invocations
func (mmFindPagedList *TransactionRepositoryMock) FindPagedListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindPagedList.afterFindPagedListCounter)
}

// FindPagedListBeforeCounter returns a count of TransactionRepositoryMock.FindPagedList invocations
func (mmFindPagedList *TransactionRepositoryMock) FindPagedListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindPagedList.beforeFindPagedListCounter)
}

// Calls returns a list of arguments used in each call to TransactionRepositoryMock.FindPagedList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) Calls() []*TransactionRepositoryMockFindPagedListParams {
	mmFindPagedList.mutex.RLock()

	argCopy := make([]*TransactionRepositoryMockFindPagedListParams, len(mmFindPagedList.callArgs))
	copy(argCopy, mmFindPagedList.callArgs)

	mmFindPagedList.mutex.RUnlock()

	return argCopy
}

// MinimockFindPagedListDone returns true if the count of the FindPagedList invocations corresponds
// the number of defined expectations
func (m *TransactionRepositoryMock) MinimockFindPagedListDone() bool {
	if m.FindPagedListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindPagedListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindPagedListMock.invocationsDone()
}

// MinimockFindPagedListInspect logs each unmet expectation
func (m *TransactionRepositoryMock) MinimockFindPagedListInspect() {
	for _, e := range m.FindPagedListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionRepositoryMock.FindPagedList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindPagedListCounter := mm_atomic.LoadUint64(&m.afterFindPagedListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindPagedListMock.defaultExpectation != nil && afterFindPagedListCounter < 1 {
		if m.FindPagedListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionRepositoryMock.FindPagedList at\n%s", m.FindPagedListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionRepositoryMock.FindPagedList at\n%s with params: %#v", m.FindPagedListMock.defaultExpectation.expectationOrigins.origin, *m.FindPagedListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindPagedList != nil && afterFindPagedListCounter < 1 {
		m.t.Errorf("Expected call to TransactionRepositoryMock.FindPagedList at\n%s", m.funcFindPagedListOrigin)
	}

	if !m.FindPagedListMock.invocationsDone() && afterFindPagedListCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionRepositoryMock.FindPagedList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindPagedListMock.expectedInvocations), m.FindPagedListMock.expectedInvocationsOrigin, afterFindPagedListCounter)
	}
}

type mTransactionRepositoryMockUpdate struct {
	optional           bool
	mock               *TransactionRepositoryMock
	defaultExpectation *TransactionRepositoryMockUpdateExpectation
	expectations       []*TransactionRepositoryMockUpdateExpectation

	callArgs []*TransactionRepositoryMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionRepositoryMockUpdateExpectation specifies expectation struct of the TransactionRepository.Update
type TransactionRepositoryMockUpdateExpectation struct {
	mock               *TransactionRepositoryMock
	params             *TransactionRepositoryMockUpdateParams
	paramPtrs          *TransactionRepositoryMockUpdateParamPtrs
	expectationOrigins TransactionRepositoryMockUpdateExpectationOrigins
	results            *TransactionRepositoryMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// TransactionRepositoryMockUpdateParams contains parameters of the TransactionRepository.Update
type TransactionRepositoryMockUpdateParams struct {
	ctx  context.Context
	item *entity.Transaction
}

// TransactionRepositoryMockUpdateParamPtrs contains pointers to parameters of the TransactionRepository.Update
type TransactionRepositoryMockUpdateParamPtrs struct {
	ctx  *context.Context
	item **entity.Transaction
}

// TransactionRepositoryMockUpdateResults contains results of the TransactionRepository.Update
type TransactionRepositoryMockUpdateResults struct {
	err error
}

// TransactionRepositoryMockUpdateOrigins contains origins of expectations of the TransactionRepository.Update
type TransactionRepositoryMockUpdateExpectationOrigins struct {
	origin     string
	originCtx  string
	originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mTransactionRepositoryMockUpdate) Optional() *mTransactionRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for TransactionRepository.Update
func (mmUpdate *mTransactionRepositoryMockUpdate) Expect(ctx context.Context, item *entity.Transaction) *mTransactionRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("TransactionRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &TransactionRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("TransactionRepositoryMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &TransactionRepositoryMockUpdateParams{ctx, item}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for TransactionRepository.Update
func (mmUpdate *mTransactionRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mTransactionRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("TransactionRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &TransactionRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("TransactionRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &TransactionRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectItemParam2 sets up expected param item for TransactionRepository.Update
func (mmUpdate *mTransactionRepositoryMockUpdate) ExpectItemParam2(item *entity.Transaction) *mTransactionRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("TransactionRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &TransactionRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("TransactionRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &TransactionRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.item = &item
	mmUpdate.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the TransactionRepository.Update
func (mmUpdate *mTransactionRepositoryMockUpdate) Inspect(f func(ctx context.Context, item *entity.Transaction)) *mTransactionRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for TransactionRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by TransactionRepository.Update
func (mmUpdate *mTransactionRepositoryMockUpdate) Return(err error) *TransactionRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("TransactionRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &TransactionRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &TransactionRepositoryMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the TransactionRepository.Update method
func (mmUpdate *mTransactionRepositoryMockUpdate) Set(f func(ctx context.Context, item *entity.Transaction) (err error)) *TransactionRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the TransactionRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the TransactionRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the TransactionRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mTransactionRepositoryMockUpdate) When(ctx context.Context, item *entity.Transaction) *TransactionRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("TransactionRepositoryMock.Update mock is already set by Set")
	}

	expectation := &TransactionRepositoryMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &TransactionRepositoryMockUpdateParams{ctx, item},
		expectationOrigins: TransactionRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up TransactionRepository.Update return parameters for the expectation previously defined by the When method
func (e *TransactionRepositoryMockUpdateExpectation) Then(err error) *TransactionRepositoryMock {
	e.results = &TransactionRepositoryMockUpdateResults{err}
	return e.mock
}

// Times sets number of times TransactionRepository.Update should be invoked
func (mmUpdate *mTransactionRepositoryMockUpdate) Times(n uint64) *mTransactionRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of TransactionRepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mTransactionRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_usecase.TransactionRepository
func (mmUpdate *TransactionRepositoryMock) Update(ctx context.Context, item *entity.Transaction) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, item)
	}

	mm_params := TransactionRepositoryMockUpdateParams{ctx, item}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := TransactionRepositoryMockUpdateParams{ctx, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("TransactionRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmUpdate.t.Errorf("TransactionRepositoryMock.Update got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("TransactionRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the TransactionRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, item)
	}
	mmUpdate.t.Fatalf("Unexpected call to TransactionRepositoryMock.Update. %v %v", ctx, item)
	return
}

// UpdateAfterCounter returns a count of finished TransactionRepositoryMock.Update invocations
func (mmUpdate *TransactionRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of TransactionRepositoryMock.Update invocations
func (mmUpdate *TransactionRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to TransactionRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mTransactionRepositoryMockUpdate) Calls() []*TransactionRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*TransactionRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *TransactionRepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *TransactionRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to TransactionRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionRepositoryMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TransactionRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCountReportItemsInspect()

			m.MinimockCreateInspect()

			m.MinimockFindListInspect()

			m.MinimockFindOneByIDInspect()

			m.MinimockFindPagedListInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TransactionRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TransactionRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCountReportItemsDone() &&
		m.MinimockCreateDone() &&
		m.MinimockFindListDone() &&
		m.MinimockFindOneByIDDone() &&
		m.MinimockFindPagedListDone() &&
		m.MinimockUpdateDone()
}
