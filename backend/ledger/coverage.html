
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/m11ano/budget_planner/backend/ledger/cmd/main.go (0.0%)</option>
				
				<option value="file1">github.com/m11ano/budget_planner/backend/ledger/internal/app/config/config.go (0.0%)</option>
				
				<option value="file2">github.com/m11ano/budget_planner/backend/ledger/internal/app/errors/app_error.go (0.0%)</option>
				
				<option value="file3">github.com/m11ano/budget_planner/backend/ledger/internal/app/errors/chain_error.go (0.0%)</option>
				
				<option value="file4">github.com/m11ano/budget_planner/backend/ledger/internal/app/errors/grpc.go (0.0%)</option>
				
				<option value="file5">github.com/m11ano/budget_planner/backend/ledger/internal/app/errors/helpers.go (0.0%)</option>
				
				<option value="file6">github.com/m11ano/budget_planner/backend/ledger/internal/app/errors/json_struct.go (0.0%)</option>
				
				<option value="file7">github.com/m11ano/budget_planner/backend/ledger/internal/app/errors/mark_error.go (0.0%)</option>
				
				<option value="file8">github.com/m11ano/budget_planner/backend/ledger/internal/app/fxboot/backend_app.go (0.0%)</option>
				
				<option value="file9">github.com/m11ano/budget_planner/backend/ledger/internal/app/fxboot/fxboot.go (0.0%)</option>
				
				<option value="file10">github.com/m11ano/budget_planner/backend/ledger/internal/app/fxboot/providing/backoff.go (0.0%)</option>
				
				<option value="file11">github.com/m11ano/budget_planner/backend/ledger/internal/app/fxboot/providing/db_clients.go (0.0%)</option>
				
				<option value="file12">github.com/m11ano/budget_planner/backend/ledger/internal/app/fxboot/providing/delivery_grpc.go (0.0%)</option>
				
				<option value="file13">github.com/m11ano/budget_planner/backend/ledger/internal/app/fxboot/providing/fx_logger.go (0.0%)</option>
				
				<option value="file14">github.com/m11ano/budget_planner/backend/ledger/internal/app/fxboot/providing/logger.go (0.0%)</option>
				
				<option value="file15">github.com/m11ano/budget_planner/backend/ledger/internal/app/fxboot/providing/redis.go (0.0%)</option>
				
				<option value="file16">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/controller/add_budget.go (0.0%)</option>
				
				<option value="file17">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/controller/add_transaction.go (0.0%)</option>
				
				<option value="file18">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/controller/controller.go (0.0%)</option>
				
				<option value="file19">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/controller/csv_export_transactions.go (0.0%)</option>
				
				<option value="file20">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/controller/csv_import_transactions.go (0.0%)</option>
				
				<option value="file21">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/controller/delete_budget.go (0.0%)</option>
				
				<option value="file22">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/controller/delete_transaction.go (0.0%)</option>
				
				<option value="file23">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/controller/dto.go (0.0%)</option>
				
				<option value="file24">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/controller/get_budget.go (0.0%)</option>
				
				<option value="file25">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/controller/get_transaction.go (0.0%)</option>
				
				<option value="file26">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/controller/helpers.go (0.0%)</option>
				
				<option value="file27">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/controller/list_budgets.go (0.0%)</option>
				
				<option value="file28">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/controller/list_categories.go (0.0%)</option>
				
				<option value="file29">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/controller/list_reports.go (0.0%)</option>
				
				<option value="file30">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/controller/list_transactions.go (0.0%)</option>
				
				<option value="file31">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/controller/patch_budget.go (0.0%)</option>
				
				<option value="file32">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/controller/patch_transaction.go (0.0%)</option>
				
				<option value="file33">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/interceptor_auth.go (0.0%)</option>
				
				<option value="file34">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/interceptor_errors.go (0.0%)</option>
				
				<option value="file35">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/interceptor_logger.go (0.0%)</option>
				
				<option value="file36">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/interceptor_request_id.go (0.0%)</option>
				
				<option value="file37">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/interceptor_request_ip.go (0.0%)</option>
				
				<option value="file38">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/interceptor_validate.go (0.0%)</option>
				
				<option value="file39">github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/server.go (0.0%)</option>
				
				<option value="file40">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity/account_transaction_report.go (0.0%)</option>
				
				<option value="file41">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity/budget.go (0.0%)</option>
				
				<option value="file42">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity/category.go (0.0%)</option>
				
				<option value="file43">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity/transaction.go (0.0%)</option>
				
				<option value="file44">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/init.go (0.0%)</option>
				
				<option value="file45">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/csv/transaction/commands.go (0.0%)</option>
				
				<option value="file46">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/csv/transaction/repository.go (0.0%)</option>
				
				<option value="file47">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/pg/budget.go (0.0%)</option>
				
				<option value="file48">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/pg/budget/commands.go (0.0%)</option>
				
				<option value="file49">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/pg/budget/queries.go (0.0%)</option>
				
				<option value="file50">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/pg/budget/repository.go (0.0%)</option>
				
				<option value="file51">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/pg/category.go (0.0%)</option>
				
				<option value="file52">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/pg/category/queries.go (0.0%)</option>
				
				<option value="file53">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/pg/category/repository.go (0.0%)</option>
				
				<option value="file54">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/pg/transaction.go (0.0%)</option>
				
				<option value="file55">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/pg/transaction/commands.go (0.0%)</option>
				
				<option value="file56">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/pg/transaction/queries.go (0.0%)</option>
				
				<option value="file57">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/pg/transaction/repository.go (0.0%)</option>
				
				<option value="file58">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/redis/budget.go (0.0%)</option>
				
				<option value="file59">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/redis/budget/commands.go (0.0%)</option>
				
				<option value="file60">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/redis/budget/queries.go (0.0%)</option>
				
				<option value="file61">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/redis/budget/repository.go (0.0%)</option>
				
				<option value="file62">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/redis/transaction.go (0.0%)</option>
				
				<option value="file63">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/redis/transaction/commands.go (0.0%)</option>
				
				<option value="file64">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/redis/transaction/queries.go (0.0%)</option>
				
				<option value="file65">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/redis/transaction/repository.go (0.0%)</option>
				
				<option value="file66">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/budget/commands.go (61.4%)</option>
				
				<option value="file67">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/budget/helpers.go (67.6%)</option>
				
				<option value="file68">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/budget/impl.go (100.0%)</option>
				
				<option value="file69">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/budget/queries.go (77.0%)</option>
				
				<option value="file70">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/category/helpers.go (100.0%)</option>
				
				<option value="file71">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/category/impl.go (100.0%)</option>
				
				<option value="file72">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/category/queries.go (83.3%)</option>
				
				<option value="file73">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/facade.go (0.0%)</option>
				
				<option value="file74">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/mocks/budget_cache_repository.go (0.0%)</option>
				
				<option value="file75">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/mocks/budget_repository.go (0.0%)</option>
				
				<option value="file76">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/mocks/budget_usecase.go (0.0%)</option>
				
				<option value="file77">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/mocks/category_repository.go (0.0%)</option>
				
				<option value="file78">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/mocks/category_usecase.go (0.0%)</option>
				
				<option value="file79">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/mocks/transaction_cache_repository.go (0.0%)</option>
				
				<option value="file80">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/mocks/transaction_csv_repository.go (0.0%)</option>
				
				<option value="file81">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/mocks/transaction_repository.go (0.0%)</option>
				
				<option value="file82">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/mocks/transaction_usecase.go (0.0%)</option>
				
				<option value="file83">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/transaction/commands.go (43.6%)</option>
				
				<option value="file84">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/transaction/helpers.go (74.1%)</option>
				
				<option value="file85">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/transaction/impl.go (100.0%)</option>
				
				<option value="file86">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/transaction/queries.go (34.6%)</option>
				
				<option value="file87">github.com/m11ano/budget_planner/backend/ledger/internal/infra/db/migrations.go (0.0%)</option>
				
				<option value="file88">github.com/m11ano/budget_planner/backend/ledger/internal/infra/loghandler/context.go (0.0%)</option>
				
				<option value="file89">github.com/m11ano/budget_planner/backend/ledger/internal/infra/loghandler/handler.go (0.0%)</option>
				
				<option value="file90">github.com/m11ano/budget_planner/backend/ledger/internal/infra/redis/client.go (0.0%)</option>
				
				<option value="file91">github.com/m11ano/budget_planner/backend/ledger/pkg/backoff/controller.go (0.0%)</option>
				
				<option value="file92">github.com/m11ano/budget_planner/backend/ledger/pkg/backoff/heap.go (0.0%)</option>
				
				<option value="file93">github.com/m11ano/budget_planner/backend/ledger/pkg/backoff/options.go (0.0%)</option>
				
				<option value="file94">github.com/m11ano/budget_planner/backend/ledger/pkg/backoff/session.go (0.0%)</option>
				
				<option value="file95">github.com/m11ano/budget_planner/backend/ledger/pkg/dbhelper/helpers.go (72.7%)</option>
				
				<option value="file96">github.com/m11ano/budget_planner/backend/ledger/pkg/emailnormalize/emailnormalize.go (0.0%)</option>
				
				<option value="file97">github.com/m11ano/budget_planner/backend/ledger/pkg/pgclient/impl.go (98.5%)</option>
				
				<option value="file98">github.com/m11ano/budget_planner/backend/ledger/pkg/pgclient/mock.go (0.0%)</option>
				
				<option value="file99">github.com/m11ano/budget_planner/backend/ledger/pkg/pgclient/test_connection.go (100.0%)</option>
				
				<option value="file100">github.com/m11ano/budget_planner/backend/ledger/pkg/pgclient/tracer.go (0.0%)</option>
				
				<option value="file101">github.com/m11ano/budget_planner/backend/ledger/pkg/prettylog/prettylog.go (71.0%)</option>
				
				<option value="file102">github.com/m11ano/budget_planner/backend/ledger/pkg/proto_pb/ledger_service/service.pb.go (0.0%)</option>
				
				<option value="file103">github.com/m11ano/budget_planner/backend/ledger/pkg/proto_pb/ledger_service/service.pb.validate.go (0.0%)</option>
				
				<option value="file104">github.com/m11ano/budget_planner/backend/ledger/pkg/proto_pb/ledger_service/service_grpc.pb.go (0.0%)</option>
				
				<option value="file105">github.com/m11ano/budget_planner/backend/ledger/pkg/validation/format_errors.go (0.0%)</option>
				
				<option value="file106">github.com/m11ano/budget_planner/backend/ledger/pkg/validation/validator.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "github.com/m11ano/budget_planner/backend/ledger/internal/app"
        "github.com/m11ano/budget_planner/backend/ledger/internal/app/config"
        "github.com/m11ano/budget_planner/backend/ledger/internal/app/fxboot"
        "go.uber.org/fx"
)

func main() <span class="cov0" title="0">{
        cfg := config.LoadConfig("configs/base.yml", "configs/base.local.yml")

        appOptions := fxboot.BackendAppGetOptionsMap(app.IDBackend, cfg)

        app := fx.New(
                fxboot.OptionsMapToSlice(appOptions)...,
        )

        app.Run()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "log"
        "os"

        "github.com/ilyakaznacheev/cleanenv"
)

type Config struct {
        BackendApp struct {
                Name    string `yaml:"name" env:"BACKEND_APP_NAME" env-default:"backend"`
                Version string `yaml:"version" env:"BACKEND_APP_VERSION" env-default:"1.0.0"`
                Base    struct {
                        StartTimeoutSec int  `yaml:"start_timeout_sec" env:"BACKEND_APP_BASE_START_TIMEOUT_SEC" env-default:"10"`
                        StopTimeoutSec  int  `yaml:"stop_timeout_sec" env:"BACKEND_APP_BASE_STOP_TIMEOUT_SEC" env-default:"2"`
                        IsProd          bool `yaml:"is_prod" env:"BACKEND_APP_BASE_IS_PROD" env-default:"false"`
                        UseFxLogger     bool `yaml:"use_fx_logger" env:"BACKEND_APP_BASE_USE_FX_LOGGER" env-default:"true"`
                        UseLogger       bool `yaml:"use_logger" env:"BACKEND_APP_BASE_USE_LOGGER" env-default:"true"`
                        LogSQLQueries   bool `yaml:"log_sql_queries" env:"BACKEND_APP_BASE_LOG_SQL_QUERIES" env-default:"true"`
                        LogHTTP         bool `yaml:"log_http" env:"BACKEND_APP_BASE_LOG_HTTP" env-default:"true"`
                } `yaml:"base"`
                GRPC struct {
                        Port       int  `yaml:"port" env:"BACKEND_APP_GRPC_PORT" env-default:"50051"`
                        LogQueries bool `yaml:"log_queries" env:"BACKEND_APP_GRPC_LOG_QUERIES" env-default:"false"`
                } `yaml:"grpc"`
        } `yaml:"backend_app"`
        Postgres struct {
                MaxAttempts         int    `yaml:"max_attempts" env:"POSTGRES_MAX_ATTEMPTS" env-default:"3"`
                AttemptSleepSeconds int    `yaml:"attempt_sleep_seconds" env:"POSTGRES_ATTEMPT_SLEEP_SECONDS" env-default:"1"`
                MigrationsPath      string `yaml:"migrations_path" env:"POSTGRES_MIGRATIONS_PATH" env-default:"migrations"`
                Master              struct {
                        DSN string `yaml:"dsn" env:"POSTGRES_MASTER_DSN"`
                } `yaml:"master"`
        } `yaml:"postgres"`
        Auth struct {
                AccessTokenLifetimeSec int `yaml:"access_token_lifetime_sec" env:"AUTH_ACCESS_TOKEN_LIFETIME_SEC" env-default:"300"`
                // nolint
                RefreshTokenLifetimeHrs int    `yaml:"refresh_token_lifetime_hours" env:"AUTH_REFRESH_TOKEN_LIFETIME_HRS" env-default:"720"`
                JwtAccessSecret         string `yaml:"jwt_access_secret" env:"AUTH_JWT_ACCESS_SECRET"`
                JwtRefreshSecret        string `yaml:"jwt_refresh_secret" env:"AUTH_JWT_REFRESH_SECRET"`
        }
        Redis struct {
                Addr     string `yaml:"addr" env:"REDIS_ADDR"`
                Password string `yaml:"password" env:"REDIS_PASSWORD"`
        }
}

func LoadConfig(files ...string) Config <span class="cov0" title="0">{
        var Config Config

        for _, file := range files </span><span class="cov0" title="0">{
                if _, err := os.Stat(file); err == nil </span><span class="cov0" title="0">{
                        err := cleanenv.ReadConfig(file, &amp;Config)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal("config file error", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return Config</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package errors contains app error struct and helpers
package errors

import (
        "errors"
        "fmt"
        "log/slog"
        "maps"
        "strings"
)

type appErrorDetail struct {
        Value    any
        IsHidden bool
}

// AppError - структура для оборачивания сторонних ошибок в цепочку вызовов и хранения метаданных
type AppError struct {
        parent   error
        is       error
        chainMsg []string
        errMsg   string
        hints    []string
        meta     ErrorMeta
        details  map[string]appErrorDetail
}

// ErrorMeta - структура для хранения метаданных
type ErrorMeta struct {
        Code     errorCode
        TextCode string
}

// NewError - создает новую ошибку
func NewError(msg string, code errorCode, textCode string, hints []string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                chainMsg: []string{msg},
                errMsg:   msg,
                hints:    hints,
                meta: ErrorMeta{
                        Code:     code,
                        TextCode: textCode,
                },
        }
}</span>

// Copy - создает копию ошибки
func (e *AppError) Copy() *AppError <span class="cov0" title="0">{
        cp := &amp;AppError{
                parent: e,
                is:     e.is,
                errMsg: e.errMsg,
                hints:  e.hints,
                meta: ErrorMeta{
                        Code:     e.meta.Code,
                        TextCode: e.meta.TextCode,
                },
                details: nil,
        }

        if e.chainMsg != nil </span><span class="cov0" title="0">{
                cp.chainMsg = make([]string, len(e.chainMsg))
                copy(cp.chainMsg, e.chainMsg)
        }</span>

        <span class="cov0" title="0">if e.details != nil </span><span class="cov0" title="0">{
                cp.details = make(map[string]appErrorDetail, len(e.details))
                maps.Copy(cp.details, e.details)
        }</span>

        <span class="cov0" title="0">return cp</span>
}

func (e *AppError) chain(chainMsg string) *AppError <span class="cov0" title="0">{
        cp := e.Copy()
        if chainMsg != "" </span><span class="cov0" title="0">{
                cp.chainMsg = append(cp.chainMsg, fmt.Sprintf("[%s]", chainMsg))
        }</span>

        <span class="cov0" title="0">return cp</span>
}

// WithParent - создает копию ошибки с измененной ссылкой на родительскую ошибку и цепочку вызовов
func (e *AppError) WithParent(err error) *AppError <span class="cov0" title="0">{
        cp := e.Copy()

        cp.parent = err
        cp.is = e
        curChainMsh := e.chainMsg
        cp.chainMsg = make([]string, 0, len(curChainMsh)+1)
        cp.chainMsg = append(cp.chainMsg, err.Error())
        cp.chainMsg = append(cp.chainMsg, curChainMsh...)

        return cp
}</span>

// WithWrap - создает обертку для текущей ошибки на основе переданной ошибки
func (e *AppError) WithWrap(err error) *AppError <span class="cov0" title="0">{
        cp := e.Copy()

        cp.is = err
        cp.chainMsg = make([]string, 0, len(e.chainMsg)+1)
        cp.chainMsg = append(cp.chainMsg, e.chainMsg...)

        newChainMsg := getChainMsg(err)
        if newChainMsg != nil </span><span class="cov0" title="0">{
                cp.chainMsg = append(cp.chainMsg, newChainMsg...)
        }</span>

        <span class="cov0" title="0">if newErrMsg, ok := NearestErrMsg(err); ok </span><span class="cov0" title="0">{
                cp.errMsg = newErrMsg
        }</span> else<span class="cov0" title="0"> {
                cp.errMsg = err.Error()
        }</span>

        <span class="cov0" title="0">var appErr *AppError
        if errors.As(err, &amp;appErr) </span><span class="cov0" title="0">{
                cp.meta = appErr.meta
        }</span>

        <span class="cov0" title="0">return cp</span>
}

// Is - реализация интерфейса error, проверка идентификации
func (e *AppError) Is(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if e == err || e.is == err </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// Unwrap - реализация интерфейса error, возвращает родительскую ошибку
func (e *AppError) Unwrap() error <span class="cov0" title="0">{
        return e.parent
}</span>

// Error - реализация интерфейса error, возвращает строку с цепочкой вызовов
func (e *AppError) Error() string <span class="cov0" title="0">{
        var bldr strings.Builder
        for i := len(e.chainMsg) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                bldr.WriteString(e.chainMsg[i])
                if i != 0 </span><span class="cov0" title="0">{
                        bldr.WriteString(" : ")
                }</span>
        }

        <span class="cov0" title="0">return bldr.String()</span>
}

// Extend - наследовать ошибку без цепочки вызовов
func (e *AppError) Extend(errMsg string) *AppError <span class="cov0" title="0">{
        newErr := e.Copy()

        newErr.errMsg = errMsg
        newErr.chainMsg = []string{errMsg}

        return newErr
}</span>

// ExtendWithChain - наследовать ошибку вместе с цепочкой
func (e *AppError) ExtendWithChain(errMsg string) *AppError <span class="cov0" title="0">{
        newErr := e.Copy()

        newErr.errMsg = errMsg
        newErr.chainMsg = append(newErr.chainMsg, errMsg)

        return newErr
}</span>

// WithMeta - создает копию ошибки с измененным метаданными
func (e *AppError) WithMeta(meta ErrorMeta) *AppError <span class="cov0" title="0">{
        newErr := e.Copy()

        newErr.meta = meta

        return newErr
}</span>

// WithCode - создает копию ошибки с измененным кодом
func (e *AppError) WithCode(code errorCode) *AppError <span class="cov0" title="0">{
        newErr := e.Copy()

        newErr.meta.Code = code

        return newErr
}</span>

// WithTextCode - создает копию ошибки с измененным текстовым кодом
func (e *AppError) WithTextCode(textCode string) *AppError <span class="cov0" title="0">{
        newErr := e.Copy()

        newErr.meta.TextCode = textCode

        return newErr
}</span>

// WithDetail - создает копию ошибки с измененным детализацией
func (e *AppError) WithDetail(key string, isHidden bool, value any) *AppError <span class="cov0" title="0">{
        newErr := e.Copy()

        if newErr.details == nil </span><span class="cov0" title="0">{
                newErr.details = make(map[string]appErrorDetail, 1)
        }</span>

        <span class="cov0" title="0">newErr.details[key] = appErrorDetail{
                Value:    value,
                IsHidden: isHidden,
        }

        return newErr</span>
}

// WithHints - создает копию ошибки с измененными подсказками для пользователей
func (e *AppError) WithHints(hints ...string) *AppError <span class="cov0" title="0">{
        newErr := e.Copy()

        newErr.hints = hints

        return newErr
}</span>

// Hints - получить подсказки для пользователей
func (e *AppError) Hints() []string <span class="cov0" title="0">{
        return e.hints
}</span>

// HintsStr - получить подсказки для пользователей в виде одной строки
func (e *AppError) HintsStr(delimiter string) string <span class="cov0" title="0">{
        return strings.Join(e.hints, delimiter)
}</span>

// Meta - получить метаданные ошибки
func (e *AppError) Meta() ErrorMeta <span class="cov0" title="0">{
        return e.meta
}</span>

// Detail - получить деталь ошибки
func (e *AppError) Detail(key string) (appErrorDetail, bool) <span class="cov0" title="0">{
        item, ok := e.details[key]

        return item, ok
}</span>

// Details - получить детали ошибки
func (e *AppError) Details(withHidden bool) map[string]any <span class="cov0" title="0">{
        result := make(map[string]any, len(e.details))

        for k, v := range e.details </span><span class="cov0" title="0">{
                if withHidden || !v.IsHidden </span><span class="cov0" title="0">{
                        result[k] = v.Value
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// ErrMsg - получить текст ошибки без цепочки вызовов
func (e *AppError) ErrMsg() string <span class="cov0" title="0">{
        return e.errMsg
}</span>

// LogValue - интерфейс для логеров
func (e *AppError) LogValue() slog.Value <span class="cov0" title="0">{
        jsonStruct := ToJSONStruct(e, true, false)
        return jsonStruct.ToSlogValue()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package errors

import (
        "fmt"
        "strings"
)

// ChainError - структура для оборачивания сторонних ошибок в цепочку вызовов
type ChainError struct {
        parent   error
        chainMsg []string
}

func (e *ChainError) copy() *ChainError <span class="cov0" title="0">{
        cp := &amp;ChainError{
                parent: e.parent,
        }

        if e.chainMsg != nil </span><span class="cov0" title="0">{
                cp.chainMsg = make([]string, len(e.chainMsg))
                copy(cp.chainMsg, e.chainMsg)
        }</span>

        <span class="cov0" title="0">return cp</span>
}

// Error - реализация интерфейса error, возвращает строку с цепочкой вызовов
func (e *ChainError) Error() string <span class="cov0" title="0">{
        var bldr strings.Builder
        for i := len(e.chainMsg) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                bldr.WriteString(e.chainMsg[i])
                if i != 0 </span><span class="cov0" title="0">{
                        bldr.WriteString(" : ")
                }</span>
        }

        <span class="cov0" title="0">return bldr.String()</span>
}

// Is - реализация интерфейса error, проверка идентификации
func (e *ChainError) Is(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if e == err </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// Unwrap - реализация интерфейса error, возвращает родительскую ошибку
func (e *ChainError) Unwrap() error <span class="cov0" title="0">{
        return e.parent
}</span>

// Chain - оборачивает ошибку в цепочку
func Chain(err error, chainMsg string) error <span class="cov0" title="0">{
        if appErr, ok := err.(*AppError); ok </span><span class="cov0" title="0">{
                return appErr.chain(chainMsg)
        }</span>

        <span class="cov0" title="0">if chainErr, ok := err.(*ChainError); ok </span><span class="cov0" title="0">{
                cp := chainErr.copy()
                if chainMsg != "" </span><span class="cov0" title="0">{
                        cp.chainMsg = append(cp.chainMsg, fmt.Sprintf("[%s]", chainMsg))
                }</span>
                <span class="cov0" title="0">return cp</span>
        }

        <span class="cov0" title="0">return &amp;ChainError{
                parent:   err,
                chainMsg: []string{fmt.Sprintf("[%s]", chainMsg)},
        }</span>
}

// Chainf - оборачивает ошибку в цепочку с форматированием
func Chainf(err error, format string, args ...interface{}) error <span class="cov0" title="0">{
        chainMsg := fmt.Sprintf(format, args...)

        return Chain(err, chainMsg)
}</span>

func getChainMsg(err error) []string <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if chainErr, ok := err.(*ChainError); ok </span><span class="cov0" title="0">{
                return chainErr.chainMsg
        }</span>

        <span class="cov0" title="0">if appErr, ok := err.(*AppError); ok </span><span class="cov0" title="0">{
                return appErr.chainMsg
        }</span>

        <span class="cov0" title="0">return []string{err.Error()}</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package errors

import (
        "cmp"
        "fmt"
        "slices"
        "strconv"
        "strings"

        "google.golang.org/genproto/googleapis/rpc/errdetails"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// ToGrpcStatus - преобразует error в GrpcStatus
func ToGrpcStatus(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">appErr, ok := ExtractError(err)
        if !ok </span><span class="cov0" title="0">{
                st, ok := status.FromError(err)
                if !ok </span><span class="cov0" title="0">{
                        return status.Error(codes.Unknown, err.Error())
                }</span>

                <span class="cov0" title="0">return st.Err()</span>
        }

        <span class="cov0" title="0">code := mapToGrpcCode(appErr.Meta().Code)
        textCode := appErr.Meta().TextCode

        meta := make(map[string]string)

        errMsg := textCode

        hints, ok := NearestHints(err)
        if ok </span><span class="cov0" title="0">{
                hitText := strings.Join(hints, "; ")

                if errMsg != "" </span><span class="cov0" title="0">{
                        errMsg = fmt.Sprintf("%s: %s", errMsg, hitText)
                }</span> else<span class="cov0" title="0"> {
                        errMsg = hitText
                }</span>

                <span class="cov0" title="0">for i, hint := range hints </span><span class="cov0" title="0">{
                        meta[fmt.Sprintf("hint_%d", i)] = hint
                }</span>
        }

        <span class="cov0" title="0">details := appErr.Details(false)
        for k, v := range details </span><span class="cov0" title="0">{
                var value string

                switch v := v.(type) </span>{
                case string:<span class="cov0" title="0">
                        value = v</span>
                case []byte:<span class="cov0" title="0">
                        value = string(v)</span>
                case int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                        value = fmt.Sprintf("%d", v)</span>
                case float32, float64:<span class="cov0" title="0">
                        value = fmt.Sprintf("%d", v)</span>
                default:<span class="cov0" title="0">
                        value = fmt.Sprintf("%v", v)</span>
                }

                <span class="cov0" title="0">meta[fmt.Sprintf("detail_%s", k)] = value</span>
        }

        <span class="cov0" title="0">detail := &amp;errdetails.ErrorInfo{
                Reason:   textCode,
                Metadata: meta,
        }

        st, stErr := status.New(code, errMsg).WithDetails(detail)
        if stErr != nil </span><span class="cov0" title="0">{
                return status.Error(codes.Unknown, stErr.Error())
        }</span>

        <span class="cov0" title="0">return st.Err()</span>
}

var grpcCodeByAppCode = map[errorCode]codes.Code{
        errorCodeBadRequest:    codes.InvalidArgument,
        errorCodeUnauthorized:  codes.Unauthenticated,
        errorCodeForbidden:     codes.PermissionDenied,
        errorCodeNotFound:      codes.NotFound,
        errorCodeConflict:      codes.Aborted,
        errorCodeUnprocessable: codes.FailedPrecondition,
        errorTooManyRequests:   codes.ResourceExhausted,
        errorCodeInternal:      codes.Internal,
}

func mapToGrpcCode(app errorCode) codes.Code <span class="cov0" title="0">{
        if c, ok := grpcCodeByAppCode[app]; ok </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return codes.Unknown</span>
}

func FromGRPCError(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">st, ok := status.FromError(err)
        if !ok </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var info *errdetails.ErrorInfo
        for _, d := range st.Details() </span><span class="cov0" title="0">{
                if v, ok := d.(*errdetails.ErrorInfo); ok </span><span class="cov0" title="0">{
                        info = v
                        break</span>
                }
        }

        <span class="cov0" title="0">textCode := ""
        if info != nil &amp;&amp; info.Reason != "" </span><span class="cov0" title="0">{
                textCode = info.Reason
        }</span>

        <span class="cov0" title="0">var base *AppError
        if textCode != "" </span><span class="cov0" title="0">{
                if ae := appErrorByTextCode(textCode); ae != nil </span><span class="cov0" title="0">{
                        base = ae
                }</span>
        }
        <span class="cov0" title="0">if base == nil </span><span class="cov0" title="0">{
                base = appErrorByGrpcCode(st.Code())
        }</span>
        <span class="cov0" title="0">if base == nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var hints []string
        details := map[string]any{}

        if info != nil &amp;&amp; info.Metadata != nil </span><span class="cov0" title="0">{
                type pair struct {
                        i int
                        v string
                }

                hp := make([]pair, 0, len(info.Metadata))

                for k, v := range info.Metadata </span><span class="cov0" title="0">{
                        switch </span>{
                        case strings.HasPrefix(k, "hint_"):<span class="cov0" title="0">
                                if idx, err := strconv.Atoi(strings.TrimPrefix(k, "hint_")); err == nil </span><span class="cov0" title="0">{
                                        hp = append(hp, pair{i: idx, v: v})
                                }</span>

                        case strings.HasPrefix(k, "detail_"):<span class="cov0" title="0">
                                key := strings.TrimPrefix(k, "detail_")
                                if key != "" </span><span class="cov0" title="0">{
                                        details[key] = v
                                }</span>
                        }
                }

                <span class="cov0" title="0">slices.SortFunc(hp, func(a, b pair) int </span><span class="cov0" title="0">{
                        return cmp.Compare(a.i, b.i)
                }</span>)

                <span class="cov0" title="0">hints = make([]string, 0, len(hp))
                for _, p := range hp </span><span class="cov0" title="0">{
                        if p.v != "" </span><span class="cov0" title="0">{
                                hints = append(hints, p.v)
                        }</span>
                }
        }

        <span class="cov0" title="0">cp := base.Extend(st.Message())

        if textCode != "" </span><span class="cov0" title="0">{
                cp = cp.WithTextCode(textCode)
        }</span>

        <span class="cov0" title="0">if len(hints) &gt; 0 </span><span class="cov0" title="0">{
                cp = cp.WithHints(hints...)
        }</span>

        <span class="cov0" title="0">for k, v := range details </span><span class="cov0" title="0">{
                cp = cp.WithDetail(k, false, v)
        }</span>

        <span class="cov0" title="0">return cp</span>
}

func appErrorByTextCode(textCode string) *AppError <span class="cov0" title="0">{
        switch textCode </span>{
        case "BAD_REQUEST":<span class="cov0" title="0">
                return ErrBadRequest</span>
        case "UNAUTHORIZED":<span class="cov0" title="0">
                return ErrUnauthorized</span>
        case "FORBIDDEN":<span class="cov0" title="0">
                return ErrForbidden</span>
        case "NOT_FOUND":<span class="cov0" title="0">
                return ErrNotFound</span>
        case "CONFLICT":<span class="cov0" title="0">
                return ErrConflict</span>
        case "TOO_MANY_REQUESTS":<span class="cov0" title="0">
                return ErrTooManyRequests</span>
        case "UNPROCESSABLE":<span class="cov0" title="0">
                return ErrUnprocessable</span>
        case "INTERNAL_ERROR":<span class="cov0" title="0">
                return ErrInternal</span>
        case "UNIQUE_VIOLATION":<span class="cov0" title="0">
                return ErrUniqueViolation</span>
        case "VERSION_CONFLICT":<span class="cov0" title="0">
                return ErrVersionConflict</span>
        case "BACKOFF":<span class="cov0" title="0">
                return ErrBackoff</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

func appErrorByGrpcCode(code codes.Code) *AppError <span class="cov0" title="0">{
        switch code </span>{
        case codes.InvalidArgument:<span class="cov0" title="0">
                return ErrBadRequest</span>
        case codes.Unauthenticated:<span class="cov0" title="0">
                return ErrUnauthorized</span>
        case codes.PermissionDenied:<span class="cov0" title="0">
                return ErrForbidden</span>
        case codes.NotFound:<span class="cov0" title="0">
                return ErrNotFound</span>
        case codes.Aborted:<span class="cov0" title="0">
                return ErrConflict</span>
        case codes.ResourceExhausted:<span class="cov0" title="0">
                return ErrTooManyRequests</span>
        case codes.FailedPrecondition:<span class="cov0" title="0">
                return ErrUnprocessable</span>
        case codes.Internal:<span class="cov0" title="0">
                return ErrInternal</span>
        default:<span class="cov0" title="0">
                return ErrInternal</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package errors

import (
        "errors"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

// ExtractError - ищет ближайшую ошибку AppError
func ExtractError(err error) (*AppError, bool) <span class="cov0" title="0">{
        var appErr *AppError
        if errors.As(err, &amp;appErr) </span><span class="cov0" title="0">{
                return appErr, true
        }</span>

        <span class="cov0" title="0">return nil, false</span>
}

// NearestHints - ищет ближайший непустой слайс подсказок
func NearestHints(err error) ([]string, bool) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        return nil, false
                }</span>
                <span class="cov0" title="0">if appErr, ok := err.(*AppError); ok </span><span class="cov0" title="0">{
                        if len(appErr.hints) &gt; 0 </span><span class="cov0" title="0">{
                                return appErr.hints, true
                        }</span>
                        <span class="cov0" title="0">err = appErr.Unwrap()
                        continue</span>
                }
                <span class="cov0" title="0">if chainErr, ok := err.(*ChainError); ok </span><span class="cov0" title="0">{
                        err = chainErr.Unwrap()
                        continue</span>
                }
                <span class="cov0" title="0">err = errors.Unwrap(err)</span>
        }
}

// NearestErrMsg - ищет только сообщение об ошибке в AppError
func NearestErrMsg(err error) (string, bool) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        return "", false
                }</span>
                <span class="cov0" title="0">if appErr, ok := err.(*AppError); ok </span><span class="cov0" title="0">{
                        if len(appErr.errMsg) &gt; 0 </span><span class="cov0" title="0">{
                                return appErr.errMsg, true
                        }</span>
                        <span class="cov0" title="0">err = appErr.Unwrap()
                        continue</span>
                }
                <span class="cov0" title="0">if chainErr, ok := err.(*ChainError); ok </span><span class="cov0" title="0">{
                        err = chainErr.Unwrap()
                        continue</span>
                }
                <span class="cov0" title="0">err = errors.Unwrap(err)</span>
        }
}

// NearestError - ищет либо сообщение об ошибке в Error, либо текст сторонней ошибки
func NearestError(err error) (string, bool) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        return "", false
                }</span>
                <span class="cov0" title="0">if appErr, ok := err.(*AppError); ok </span><span class="cov0" title="0">{
                        if len(appErr.errMsg) &gt; 0 </span><span class="cov0" title="0">{
                                return appErr.errMsg, true
                        }</span>
                        <span class="cov0" title="0">err = appErr.Unwrap()
                        continue</span>
                }
                <span class="cov0" title="0">if chainErr, ok := err.(*ChainError); ok </span><span class="cov0" title="0">{
                        err = chainErr.Unwrap()
                        continue</span>
                }
                <span class="cov0" title="0">if err.Error() != "" </span><span class="cov0" title="0">{
                        return err.Error(), true
                }</span>
                <span class="cov0" title="0">err = errors.Unwrap(err)</span>
        }
}

// WithHints - добавляет подсказки к error.
// Ищет ближайший AppError и копируется. Если не найдено - создается копия ErrInternal
func WithHints(err error, hints ...string) *AppError <span class="cov0" title="0">{
        var foundAppErr *AppError

        lookingErr := err
        for lookingErr != nil </span><span class="cov0" title="0">{

                if appErr, ok := lookingErr.(*AppError); ok </span><span class="cov0" title="0">{
                        foundAppErr = appErr
                        break</span>
                }
                <span class="cov0" title="0">if chainErr, ok := lookingErr.(*ChainError); ok </span><span class="cov0" title="0">{
                        lookingErr = chainErr.Unwrap()
                        continue</span>
                }
                <span class="cov0" title="0">lookingErr = errors.Unwrap(lookingErr)</span>
        }

        <span class="cov0" title="0">var cp *AppError
        if foundAppErr != nil </span><span class="cov0" title="0">{
                cp = foundAppErr.Copy()
        }</span> else<span class="cov0" title="0"> {
                cp = ErrInternal.Copy()
        }</span>
        <span class="cov0" title="0">cp.parent = err
        cp.hints = hints

        return cp</span>
}

// CheckIsTxСoncurrentExec - проверяет, является ли ошибка pgx о конкурентном выполнении транзакции
func CheckIsTxСoncurrentExec(err error) bool <span class="cov0" title="0">{
        var pgErr *pgconn.PgError
        if errors.As(err, &amp;pgErr) &amp;&amp; (pgErr.Code == "40001" || pgErr.Code == "25P02") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return errors.Is(err, ErrTxСoncurrentExec)</span>
}

// ConvertPgxToAppErr - конвертирует ошибку pgx в ошибку приложения
func ConvertPgxToAppErr(err error) (error, bool) <span class="cov0" title="0">{
        if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                return ErrStoreNoRows.WithWrap(err), true
        }</span>
        <span class="cov0" title="0">var pgErr *pgconn.PgError
        if errors.As(err, &amp;pgErr) </span><span class="cov0" title="0">{
                switch pgErr.Code </span>{
                case "40001":<span class="cov0" title="0">
                        return ErrTxСoncurrentExec.WithWrap(err), true</span>
                case "25P02":<span class="cov0" title="0">
                        return ErrTxСoncurrentExec.WithWrap(err), true</span>
                case "23505":<span class="cov0" title="0">
                        return ErrStoreUniqueViolation.WithWrap(err).WithDetail("column", true, pgErr.ColumnName), true</span>
                case "23503":<span class="cov0" title="0">
                        return ErrStoreForeignKeyViolation.WithWrap(err).WithDetail("column", true, pgErr.ColumnName), true</span>
                case "23502":<span class="cov0" title="0">
                        return ErrStoreNotNullViolation.WithWrap(err).WithDetail("column", true, pgErr.ColumnName), true</span>
                case "23514":<span class="cov0" title="0">
                        return ErrStoreCheckViolation.WithWrap(err).WithDetail("constraint", true, pgErr.ConstraintName), true</span>
                case "23001":<span class="cov0" title="0">
                        return ErrStoreRestrictViolation.WithWrap(err).WithDetail("constraint", true, pgErr.ConstraintName), true</span>
                case "23000":<span class="cov0" title="0">
                        return ErrStoreIntegrityViolation.WithWrap(err).WithDetail("constraint", true, pgErr.ConstraintName), true</span>
                default:<span class="cov0" title="0">
                        return ErrInternal.WithWrap(err), false</span>
                }
        }
        <span class="cov0" title="0">return err, false</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package errors

import "log/slog"

// JSONStruct - структура для json
type JSONStruct struct {
        Message  string         `json:"message"`
        ChainMsg string         `json:"chainMsg,omitempty"`
        TextCode string         `json:"textCode,omitempty"`
        Code     int            `json:"code,omitempty"`
        Hints    []string       `json:"hints,omitempty"`
        Details  map[string]any `json:"details,omitempty"`
}

// ToSlogValue - преобразует error в slog.Value
func (e *JSONStruct) ToSlogValue() slog.Value <span class="cov0" title="0">{
        attrs := []slog.Attr{
                slog.String("message", e.Message),
                slog.String("textCode", e.TextCode),
                slog.Int("code", e.Code),
        }

        if e.ChainMsg != e.Message </span><span class="cov0" title="0">{
                attrs = append(attrs, slog.String("chainMsg", e.ChainMsg))
        }</span>

        <span class="cov0" title="0">if len(e.Hints) &gt; 0 </span><span class="cov0" title="0">{
                attrs = append(attrs, slog.Any("hints", e.Hints))
        }</span>

        <span class="cov0" title="0">if len(e.Details) &gt; 0 </span><span class="cov0" title="0">{
                attrs = append(attrs, slog.Any("details", e.Details))
        }</span>

        <span class="cov0" title="0">return slog.GroupValue(attrs...)</span>
}

// ToJSONStruct - преобразует error в ErrorJsonStruct
func ToJSONStruct(err error, addHiddenDetails bool, addHints bool) JSONStruct <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return JSONStruct{}
        }</span>

        <span class="cov0" title="0">appErr, ok := ExtractError(err)
        if !ok </span><span class="cov0" title="0">{
                return JSONStruct{
                        Message: err.Error(),
                }
        }</span>

        <span class="cov0" title="0">errStruct := JSONStruct{
                Message:  appErr.ErrMsg(),
                ChainMsg: appErr.Error(),
                TextCode: appErr.meta.TextCode,
                Code:     int(appErr.meta.Code),
                Details:  appErr.Details(addHiddenDetails),
        }

        if addHints </span><span class="cov0" title="0">{
                errStruct.Hints = appErr.Hints()
        }</span>

        <span class="cov0" title="0">return errStruct</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package errors

type markError struct {
        source error
        mark   error
}

// Error - реализация интерфейса error
func (e *markError) Error() string <span class="cov0" title="0">{
        return e.source.Error()
}</span>

// Unwrap - реализация интерфейса error, возвращает родительскую ошибку
func (e *markError) Unwrap() error <span class="cov0" title="0">{
        return e.source
}</span>

// Is - реализация интерфейса error, проверка идентификации
func (e *markError) Is(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return e.source == err || e.mark == err</span>
}

// Mark - поменить source ошибку mark ошибкой (для errors.Is)
func Mark(source error, mark error) error <span class="cov0" title="0">{
        return &amp;markError{source: source, mark: mark}
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package fxboot

import (
        "context"
        "log/slog"
        "time"

        "github.com/m11ano/budget_planner/backend/ledger/internal/app"
        "github.com/m11ano/budget_planner/backend/ledger/internal/app/config"
        "github.com/m11ano/budget_planner/backend/ledger/internal/app/fxboot/invoking"
        "github.com/m11ano/budget_planner/backend/ledger/internal/app/fxboot/providing"
        deliveryGRPC "github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/db"
        "github.com/m11ano/budget_planner/backend/ledger/pkg/backoff"
        "github.com/m11ano/budget_planner/backend/ledger/pkg/pgclient"
        "github.com/redis/go-redis/v9"
        "go.uber.org/fx"
        "go.uber.org/fx/fxevent"
        "google.golang.org/grpc"
)

func BackendAppGetOptionsMap(appID app.ID, cfg config.Config) OptionsMap <span class="cov0" title="0">{
        return OptionsMap{
                Providing: map[ProvidingID]fx.Option{
                        ProvidingAppID: fx.Provide(func() app.ID </span><span class="cov0" title="0">{
                                return appID
                        }</span>),
                        ProvidingIDFXTimeouts: fx.Options(
                                fx.StartTimeout(time.Second*time.Duration(cfg.BackendApp.Base.StartTimeoutSec)),
                                fx.StopTimeout(time.Second*time.Duration(cfg.BackendApp.Base.StopTimeoutSec)),
                        ),
                        ProvidingIDConfig: fx.Provide(func() config.Config <span class="cov0" title="0">{
                                return cfg
                        }</span>),
                        ProvidingIDLogger: fx.Provide(func(cfg config.Config) *slog.Logger <span class="cov0" title="0">{
                                return providing.NewLogger(
                                        cfg.BackendApp.Name,
                                        cfg.BackendApp.Version,
                                        cfg.BackendApp.Base.UseLogger,
                                        cfg.BackendApp.Base.IsProd,
                                )
                        }</span>),
                        ProvidingIDFXLogger: fx.WithLogger(func(cfg config.Config) fxevent.Logger <span class="cov0" title="0">{
                                return providing.NewFXLogger(cfg.BackendApp.Base.UseFxLogger)
                        }</span>),
                        ProvidingIDDBClients: fx.Provide(
                                func(logger *slog.Logger, cfg config.Config, shutdown fx.Shutdowner) db.MasterClient <span class="cov0" title="0">{
                                        return providing.NewDBClients(
                                                cfg.Postgres.Master.DSN,
                                                cfg.BackendApp.Base.LogSQLQueries,
                                                logger,
                                                shutdown,
                                        )
                                }</span>,
                        ),
                        ProvidingRedisClient: fx.Provide(
                                func(cfg config.Config) *redis.Client <span class="cov0" title="0">{
                                        return providing.NewRedisClient(cfg)
                                }</span>,
                        ),
                        ProvidingIDBackoff:      fx.Provide(providing.NewBackoff),
                        ProvidingGRPCServer:     providing.DeliveryGRPC,
                        ProvidingIDBudgetModule: budget.FxModule,
                },
                Invokes: []fx.Option{
                        fx.Invoke(BackendAppInitInvoke),
                },
        }
}

type BAckendInvokeInput struct {
        fx.In

        LC             fx.Lifecycle
        Shutdowner     fx.Shutdowner
        Invokes        []invoking.InvokeInit `group:"InvokeInit"`
        Logger         *slog.Logger
        Cfg            config.Config
        DBMasterClient db.MasterClient
        BackoffCtrl    *backoff.Controller
        GRPCServer     *grpc.Server
        RedisClient    *redis.Client
}

func BackendAppInitInvoke(
        in BAckendInvokeInput,
) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        go func() </span><span class="cov0" title="0">{
                &lt;-ctx.Done()
                err := in.Shutdowner.Shutdown()
                if err != nil </span><span class="cov0" title="0">{
                        in.Logger.Error("failed to shutdown", slog.Any("error", err))
                }</span>
        }()

        <span class="cov0" title="0">in.LC.Append(fx.Hook{
                OnStart: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        // Тестирование соединения с мастером postgress
                        err := pgclient.TestConnection(
                                ctx,
                                in.DBMasterClient,
                                in.Logger,
                                in.Cfg.Postgres.MaxAttempts,
                                in.Cfg.Postgres.AttemptSleepSeconds,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                in.Logger.ErrorContext(ctx, "failed to test master db connection", slog.Any("error", err))
                                return err
                        }</span>

                        <span class="cov0" title="0">in.Logger.InfoContext(
                                ctx,
                                "successfully connected to Postgress",
                                slog.String("serverID", in.DBMasterClient.ServerID()),
                        )

                        // Миграции goose
                        err = db.UpMigrations(in.Cfg.Postgres.Master.DSN, in.Cfg.Postgres.MigrationsPath, in.Logger)
                        if err != nil </span><span class="cov0" title="0">{
                                in.Logger.ErrorContext(ctx, "failed to run migrations", slog.Any("error", err))
                                return err
                        }</span>

                        // Запускаем invoke функции до открытия
                        <span class="cov0" title="0">for _, invokeItem := range in.Invokes </span><span class="cov0" title="0">{
                                if invokeItem.StartBeforeOpen != nil </span><span class="cov0" title="0">{
                                        err := invokeItem.StartBeforeOpen(ctx)
                                        if err != nil </span><span class="cov0" title="0">{
                                                in.Logger.ErrorContext(ctx, "failed to execute invoke fn start before open", slog.Any("error", err))
                                                return err
                                        }</span>
                                }
                        }

                        // Запускаем redis
                        <span class="cov0" title="0">if err := in.RedisClient.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">in.Logger.InfoContext(ctx, "successfully connected to Redis")

                        // Запускаем grpc сервер
                        if in.Cfg.BackendApp.GRPC.Port &gt; 0 </span><span class="cov0" title="0">{
                                in.Logger.InfoContext(ctx, "starting gRPC server", slog.Int("port", in.Cfg.BackendApp.GRPC.Port))
                                go func() </span><span class="cov0" title="0">{
                                        err := deliveryGRPC.Start(in.GRPCServer, in.Cfg.BackendApp.GRPC.Port)
                                        if err != nil </span><span class="cov0" title="0">{
                                                in.Logger.ErrorContext(ctx, "failed to start gRPC server", slog.Any("error", err.Error()))
                                                cancel()
                                        }</span>
                                }()
                        }

                        // Запускаем invoke функции после открытия
                        <span class="cov0" title="0">for _, invokeItem := range in.Invokes </span><span class="cov0" title="0">{
                                if invokeItem.StartAfterOpen != nil </span><span class="cov0" title="0">{
                                        err := invokeItem.StartAfterOpen(ctx)
                                        if err != nil </span><span class="cov0" title="0">{
                                                in.Logger.ErrorContext(ctx, "failed to execute invoke fn start after open", slog.Any("error", err))
                                                return err
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">return nil</span>
                },
                OnStop: func(ctx context.Context) error <span class="cov0" title="0">{
                        for _, invokeItem := range in.Invokes </span><span class="cov0" title="0">{
                                if invokeItem.Stop != nil </span><span class="cov0" title="0">{
                                        err := invokeItem.Stop(ctx)
                                        if err != nil </span><span class="cov0" title="0">{
                                                in.Logger.ErrorContext(ctx, "failed to execute invoke fn stop", slog.Any("error", err))
                                                return err
                                        }</span>
                                }
                        }

                        // Останавливаем gRPC
                        <span class="cov0" title="0">if in.Cfg.BackendApp.GRPC.Port &gt; 0 </span><span class="cov0" title="0">{
                                in.Logger.InfoContext(ctx, "stopping gRPC server")
                                in.GRPCServer.GracefulStop()
                        }</span>

                        // Закрываем postgress
                        <span class="cov0" title="0">in.DBMasterClient.Close()
                        in.Logger.InfoContext(ctx, "closing db clients")

                        // Останавливаем backoff
                        in.BackoffCtrl.Stop(ctx)

                        return nil</span>
                },
        })
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package fxboot

import (
        "go.uber.org/fx"
)

type ProvidingID int

const (
        // ProvidingAppID - app id
        ProvidingAppID ProvidingID = iota

        // ProvidingIDFXTimeouts - fx timeouts
        ProvidingIDFXTimeouts

        // ProvidingIDConfig - app config
        ProvidingIDConfig

        // ProvidingIDLogger - logger
        ProvidingIDLogger

        // ProvidingIDFXLogger - fx logger
        ProvidingIDFXLogger

        // ProvidingIDDBClients - db clients
        ProvidingIDDBClients

        // ProvidingIDRedisClient - redis
        ProvidingRedisClient

        // ProvidingIDBackoff - backoff
        ProvidingIDBackoff

        // ProvidingGRPCServer - grpc
        ProvidingGRPCServer

        // ProvidingIDBudgetModule - budget
        ProvidingIDBudgetModule
)

type OptionsMap struct {
        Providing map[ProvidingID]fx.Option
        Invokes   []fx.Option
}

func OptionsMapToSlice(optionsMap OptionsMap) []fx.Option <span class="cov0" title="0">{
        result := make([]fx.Option, 0)

        for _, option := range optionsMap.Providing </span><span class="cov0" title="0">{
                result = append(result, option)
        }</span>

        <span class="cov0" title="0">result = append(result, optionsMap.Invokes...)

        return result</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package providing

import "github.com/m11ano/budget_planner/backend/ledger/pkg/backoff"

func NewBackoff() *backoff.Controller <span class="cov0" title="0">{
        return backoff.NewController()
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package providing

import (
        "context"
        "log/slog"

        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/db"
        "github.com/m11ano/budget_planner/backend/ledger/pkg/pgclient"
        "go.uber.org/fx"
)

func NewDBClients(masterDSN string, logQueries bool, logger *slog.Logger, shutdown fx.Shutdowner) db.MasterClient <span class="cov0" title="0">{
        master, err := pgclient.NewClient(
                context.Background(),
                "master",
                masterDSN,
                pgclient.NewClientOpts{
                        Logger:     logger,
                        LogQueries: logQueries,
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create master client", slog.Any("error", err))
                // nolint
                _ = shutdown.Shutdown()
        }</span>

        <span class="cov0" title="0">return master</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package providing

import (
        "io"
        "log/slog"

        "github.com/m11ano/budget_planner/backend/ledger/internal/app/config"
        deliveryGRPC "github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc"
        controllerGRPC "github.com/m11ano/budget_planner/backend/ledger/internal/delivery/grpc/controller"
        "go.uber.org/fx"
        "google.golang.org/grpc"
)

var DeliveryGRPC = fx.Options(
        fx.Provide(func(logger *slog.Logger, cfg config.Config) *grpc.Server <span class="cov0" title="0">{
                if !cfg.BackendApp.GRPC.LogQueries </span><span class="cov0" title="0">{
                        logger = slog.New(slog.NewTextHandler(io.Discard, nil))
                }</span>
                <span class="cov0" title="0">return deliveryGRPC.New(logger, cfg)</span>
        }),
        fx.Invoke(controllerGRPC.Register),
)
</pre>
		
		<pre class="file" id="file13" style="display: none">package providing

import (
        "os"

        "go.uber.org/fx/fxevent"
)

func NewFXLogger(useLogger bool) fxevent.Logger <span class="cov0" title="0">{
        if !useLogger </span><span class="cov0" title="0">{
                return fxevent.NopLogger
        }</span>
        <span class="cov0" title="0">return &amp;fxevent.ConsoleLogger{
                W: os.Stdout,
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package providing

import (
        "io"
        "log/slog"
        "os"

        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/loghandler"
        "github.com/m11ano/budget_planner/backend/ledger/pkg/prettylog"
)

func NewLogger(appName string, appVersion string, useLogger bool, isProd bool) *slog.Logger <span class="cov0" title="0">{
        var appLogger *slog.Logger

        switch </span>{
        case !useLogger:<span class="cov0" title="0">
                appLogger = slog.New(loghandler.NewHandlerMiddleware(slog.NewTextHandler(io.Discard, nil)))</span>
        case isProd:<span class="cov0" title="0">
                appLogger = slog.New(loghandler.NewHandlerMiddleware(slog.NewJSONHandler(os.Stdout, nil)))</span>
        default:<span class="cov0" title="0">
                appLogger = slog.New(loghandler.NewHandlerMiddleware(prettylog.NewHandler(nil)))</span>
        }

        <span class="cov0" title="0">appLogger = appLogger.With("app_name", appName).With("app_version", appVersion)

        return appLogger</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package providing

import (
        "github.com/m11ano/budget_planner/backend/ledger/internal/app/config"
        redisClient "github.com/m11ano/budget_planner/backend/ledger/internal/infra/redis"
        "github.com/redis/go-redis/v9"
)

func NewRedisClient(cfg config.Config) *redis.Client <span class="cov0" title="0">{
        return redisClient.NewRedisClient(redisClient.ClientConfig{
                Addr:     cfg.Redis.Addr,
                Password: cfg.Redis.Password,
        })
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package controller

import (
        "context"
        "fmt"

        "cloud.google.com/go/civil"
        "github.com/govalues/decimal"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        budgetUC "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        desc "github.com/m11ano/budget_planner/backend/ledger/pkg/proto_pb/ledger_service"
)

func (c *controller) AddBudget(ctx context.Context, req *desc.AddBudgetRequest) (*desc.AddBudgetResponse, error) <span class="cov0" title="0">{
        const op = "AddBudget"

        authData := auth.GetAuthData(ctx)
        if authData == nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrUnauthorized, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">amount, err := decimal.Parse(req.Amount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid amount"), "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">period, err := civil.ParseDate(
                fmt.Sprintf("%04d-%02d-%02d", req.Period.Year, req.Period.Month, 1),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid period"), "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">itemDTO, err := c.budgetFacade.Budget.CreateBudgetByDTO(
                ctx,
                budgetUC.CreateBudgetDataInput{
                        AccountID:  authData.AccountID,
                        Amount:     amount,
                        Period:     period,
                        CategoryID: uint64(req.CategoryId),
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">out := &amp;desc.AddBudgetResponse{
                Item: BudgetToProto(itemDTO),
        }

        return out, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package controller

import (
        "context"
        "fmt"

        "cloud.google.com/go/civil"
        "github.com/govalues/decimal"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        budgetUC "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        desc "github.com/m11ano/budget_planner/backend/ledger/pkg/proto_pb/ledger_service"
)

func (c *controller) AddTransaction(ctx context.Context, req *desc.AddTransactionRequest) (*desc.AddTransactionResponse, error) <span class="cov0" title="0">{
        const op = "AddTransaction"

        authData := auth.GetAuthData(ctx)
        if authData == nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrUnauthorized, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">amount, err := decimal.Parse(req.Amount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid amount"), "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">occuredOn, err := civil.ParseDate(
                fmt.Sprintf("%04d-%02d-%02d", req.OccurredOn.Year, req.OccurredOn.Month, req.OccurredOn.Day),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid occured_on"), "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">itemDTO, err := c.budgetFacade.Transaction.CreateTransactionByDTO(
                ctx,
                budgetUC.CreateTransactionDataInput{
                        AccountID:   authData.AccountID,
                        IsIncome:    req.IsIncome,
                        Amount:      amount,
                        OccurredOn:  occuredOn,
                        CategoryID:  uint64(req.CategoryId),
                        Description: req.Description,
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">out := &amp;desc.AddTransactionResponse{
                Item: TransactionToProto(itemDTO),
        }

        return out, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package controller

import (
        "github.com/m11ano/budget_planner/backend/ledger/internal/app/config"
        budgetUC "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        "github.com/m11ano/budget_planner/backend/ledger/pkg/backoff"
        desc "github.com/m11ano/budget_planner/backend/ledger/pkg/proto_pb/ledger_service"
        "google.golang.org/grpc"
)

type controller struct {
        desc.UnimplementedLedgerServer
        pkg          string
        cfg          config.Config
        backoff      *backoff.Controller
        budgetFacade *budgetUC.Facade
}

func Register(
        gRPCServer *grpc.Server,
        cfg config.Config,
        backoffCtrl *backoff.Controller,
        budgetFacade *budgetUC.Facade,
) <span class="cov0" title="0">{
        ctrl := &amp;controller{
                pkg:          "grpc.Controller",
                cfg:          cfg,
                backoff:      backoffCtrl,
                budgetFacade: budgetFacade,
        }

        desc.RegisterLedgerServer(gRPCServer, ctrl)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package controller

import (
        "context"
        "fmt"

        "cloud.google.com/go/civil"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        budgetUC "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        desc "github.com/m11ano/budget_planner/backend/ledger/pkg/proto_pb/ledger_service"
)

func (c *controller) CSVExportTransactions(
        ctx context.Context,
        req *desc.ListTransactionsRequest,
) (*desc.CSVExportTransactionsResponse, error) <span class="cov0" title="0">{
        const op = "CSVExportTransactions"

        authData := auth.GetAuthData(ctx)
        if authData == nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrUnauthorized, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">if req.Limit &lt; 1 </span><span class="cov0" title="0">{
                req.Limit = 100
        }</span>

        <span class="cov0" title="0">if req.Limit &gt; 100 </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrBadRequest.WithHints("limit must be &lt;= 100"), "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">listOptions := &amp;budgetUC.TransactionListOptions{
                Sort: []uctypes.SortOption[budgetUC.TransactionListOptionsSortField]{
                        {
                                Field:  budgetUC.TransactionListOptionsSortFieldOccurredOn,
                                IsDesc: true,
                        },
                        {
                                Field:  budgetUC.TransactionListOptionsSortFieldCreatedAt,
                                IsDesc: true,
                        },
                },
                FilterAccountID: &amp;authData.AccountID,
        }

        if req.FilterOccurredOnFrom != nil </span><span class="cov0" title="0">{
                occuredOn, err := civil.ParseDate(
                        fmt.Sprintf(
                                "%04d-%02d-%02d",
                                req.FilterOccurredOnFrom.Year,
                                req.FilterOccurredOnFrom.Month,
                                req.FilterOccurredOnFrom.Day,
                        ),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(
                                appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid filter_occurred_on_from"), "%s.%s", c.pkg, op)
                }</span>

                <span class="cov0" title="0">listOptions.FilterOccurredOnFrom = &amp;occuredOn</span>
        }

        <span class="cov0" title="0">if req.FilterOccurredOnTo != nil </span><span class="cov0" title="0">{
                occuredOn, err := civil.ParseDate(
                        fmt.Sprintf(
                                "%04d-%02d-%02d",
                                req.FilterOccurredOnTo.Year,
                                req.FilterOccurredOnTo.Month,
                                req.FilterOccurredOnTo.Day,
                        ),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(
                                appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid filter_occurred_on_to"), "%s.%s", c.pkg, op)
                }</span>

                <span class="cov0" title="0">listOptions.FilterOccurredOnTo = &amp;occuredOn</span>
        }

        <span class="cov0" title="0">data, total, err := c.budgetFacade.Transaction.FindPagedListAsCSV(
                ctx,
                listOptions,
                &amp;uctypes.QueryGetListParams{
                        Limit:  uint64(req.Limit),
                        Offset: uint64(req.Offset),
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">out := &amp;desc.CSVExportTransactionsResponse{
                Data:  data,
                Total: int64(total),
        }

        return out, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package controller

import (
        "context"

        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        desc "github.com/m11ano/budget_planner/backend/ledger/pkg/proto_pb/ledger_service"
)

func (c *controller) CSVImportTransactions(
        ctx context.Context,
        req *desc.CSVImportTransactionsRequest,
) (*desc.CSVImportTransactionsResponse, error) <span class="cov0" title="0">{
        const op = "CSVImportTransactions"

        authData := auth.GetAuthData(ctx)
        if authData == nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrUnauthorized, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">err := c.budgetFacade.Transaction.ImportTransactionsFromCSV(
                ctx,
                req.Data,
                authData.AccountID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">return &amp;desc.CSVImportTransactionsResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package controller

import (
        "context"

        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        desc "github.com/m11ano/budget_planner/backend/ledger/pkg/proto_pb/ledger_service"
)

func (c *controller) DeleteBudget(ctx context.Context, req *desc.DeleteBudgetRequest) (*desc.DeleteBudgetResponse, error) <span class="cov0" title="0">{
        const op = "DeleteBudget"

        authData := auth.GetAuthData(ctx)
        if authData == nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrUnauthorized, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">budgetID, err := uuid.Parse(req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid id"), "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">err = c.budgetFacade.Budget.DeleteBudgetByID(
                ctx,
                budgetID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">return &amp;desc.DeleteBudgetResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package controller

import (
        "context"

        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        desc "github.com/m11ano/budget_planner/backend/ledger/pkg/proto_pb/ledger_service"
)

func (c *controller) DeleteTransaction(
        ctx context.Context,
        req *desc.DeleteTransactionRequest,
) (*desc.DeleteTransactionResponse, error) <span class="cov0" title="0">{
        const op = "DeleteTransaction"

        authData := auth.GetAuthData(ctx)
        if authData == nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrUnauthorized, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">transactionID, err := uuid.Parse(req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid id"), "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">err = c.budgetFacade.Transaction.DeleteTransactionByID(
                ctx,
                transactionID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">return &amp;desc.DeleteTransactionResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package controller

import (
        budgetEntity "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        budgetUC "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        desc "github.com/m11ano/budget_planner/backend/ledger/pkg/proto_pb/ledger_service"
        "github.com/samber/lo"
)

func TransactionToProto(itemDTO *budgetUC.TransactionDTO) *desc.Transaction <span class="cov0" title="0">{
        return &amp;desc.Transaction{
                Id:        itemDTO.Transaction.ID.String(),
                AccountId: itemDTO.Transaction.AccountID.String(),
                IsIncome:  itemDTO.Transaction.IsIncome,
                Amount:    itemDTO.Transaction.Amount.String(),
                OccurredOn: &amp;desc.Date{
                        Year:  int32(itemDTO.Transaction.OccurredOn.Year),
                        Month: int32(itemDTO.Transaction.OccurredOn.Month),
                        Day:   int32(itemDTO.Transaction.OccurredOn.Day),
                },
                CategoryId:  int64(itemDTO.Transaction.CategoryID),
                Description: itemDTO.Transaction.Description,
                CreatedAt:   toProtoTimestamp(&amp;itemDTO.Transaction.CreatedAt),
                UpdatedAt:   toProtoTimestamp(&amp;itemDTO.Transaction.UpdatedAt),
        }
}</span>

func BudgetToProto(itemDTO *budgetUC.BudgetDTO) *desc.Budget <span class="cov0" title="0">{
        return &amp;desc.Budget{
                Id:        itemDTO.Budget.ID.String(),
                AccountId: itemDTO.Budget.AccountID.String(),
                Amount:    itemDTO.Budget.Amount.String(),
                Period: &amp;desc.DateMonth{
                        Year:  int32(itemDTO.Budget.Period.Year),
                        Month: int32(itemDTO.Budget.Period.Month),
                },
                CategoryId: int64(itemDTO.Budget.CategoryID),
                CreatedAt:  toProtoTimestamp(&amp;itemDTO.Budget.CreatedAt),
                UpdatedAt:  toProtoTimestamp(&amp;itemDTO.Budget.UpdatedAt),
        }
}</span>

func ReportToProto(itemDTO *budgetEntity.ReportItem) *desc.PeriodReport <span class="cov0" title="0">{
        periodReport := &amp;desc.PeriodReport{
                PeriodStart: &amp;desc.Date{
                        Year:  int32(itemDTO.DateFrom.Year),
                        Month: int32(itemDTO.DateFrom.Month),
                        Day:   int32(itemDTO.DateFrom.Day),
                },
                PeriodEnd: &amp;desc.Date{
                        Year:  int32(itemDTO.DateTo.Year),
                        Month: int32(itemDTO.DateTo.Month),
                        Day:   int32(itemDTO.DateTo.Day),
                },
                Items: make([]*desc.ReportItem, 0, len(itemDTO.Items)),
        }

        for _, item := range itemDTO.Items </span><span class="cov0" title="0">{
                repItem := &amp;desc.ReportItem{
                        CategoryId: int64(item.CategoryID),
                }

                if item.Sum != nil </span><span class="cov0" title="0">{
                        repItem.Sum = lo.ToPtr(item.Sum.String())
                }</span>

                <span class="cov0" title="0">spentBudget, err := item.SpentBudget()
                if err == nil &amp;&amp; spentBudget != nil </span><span class="cov0" title="0">{
                        repItem.SpentBudget = lo.ToPtr(spentBudget.String())
                }</span>

                <span class="cov0" title="0">if item.BudgetAmount != nil </span><span class="cov0" title="0">{
                        repItem.ItemBudget = lo.ToPtr(item.BudgetAmount.String())
                }</span>

                <span class="cov0" title="0">periodReport.Items = append(periodReport.Items, repItem)</span>
        }

        <span class="cov0" title="0">return periodReport</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package controller

import (
        "context"

        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        desc "github.com/m11ano/budget_planner/backend/ledger/pkg/proto_pb/ledger_service"
)

func (c *controller) GetBudget(ctx context.Context, req *desc.GetBudgetRequest) (*desc.GetBudgetResponse, error) <span class="cov0" title="0">{
        const op = "GetBudget"

        authData := auth.GetAuthData(ctx)
        if authData == nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrUnauthorized, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">budgetID, err := uuid.Parse(req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid id"), "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">itemDTO, hitCache, err := c.budgetFacade.Budget.FindOneByID(ctx, budgetID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">out := &amp;desc.GetBudgetResponse{
                Item:     BudgetToProto(itemDTO),
                HitCache: hitCache,
        }

        return out, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package controller

import (
        "context"

        "github.com/google/uuid"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        desc "github.com/m11ano/budget_planner/backend/ledger/pkg/proto_pb/ledger_service"
)

func (c *controller) GetTransaction(
        ctx context.Context,
        req *desc.GetTransactionRequest,
) (*desc.GetTransactionResponse, error) <span class="cov0" title="0">{
        const op = "GetTransaction"

        transactionID, err := uuid.Parse(req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid id"), "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">itemDTO, err := c.budgetFacade.Transaction.FindOneByID(ctx, transactionID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">out := &amp;desc.GetTransactionResponse{
                Item: TransactionToProto(itemDTO),
        }

        return out, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package controller

import (
        "time"

        "google.golang.org/protobuf/types/known/timestamppb"
)

func toProtoTimestamp(t *time.Time) *timestamppb.Timestamp <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return timestamppb.New(*t)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package controller

import (
        "context"
        "fmt"

        "cloud.google.com/go/civil"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        budgetUC "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        desc "github.com/m11ano/budget_planner/backend/ledger/pkg/proto_pb/ledger_service"
)

func (c *controller) ListBudgets(
        ctx context.Context,
        req *desc.ListBudgetsRequest,
) (*desc.ListBudgetsResponse, error) <span class="cov0" title="0">{
        const op = "ListBudgets"

        authData := auth.GetAuthData(ctx)
        if authData == nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrUnauthorized, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">if req.Limit &lt; 1 </span><span class="cov0" title="0">{
                req.Limit = 100
        }</span>

        <span class="cov0" title="0">if req.Limit &gt; 100 </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrBadRequest.WithHints("limit must be &lt;= 100"), "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">listOptions := &amp;budgetUC.BudgetListOptions{
                Sort: []uctypes.SortOption[budgetUC.BudgetListOptionsSortField]{
                        {
                                Field:  budgetUC.BudgetListOptionsSortFieldPeriod,
                                IsDesc: true,
                        },
                },
                FilterAccountID: &amp;authData.AccountID,
        }

        if req.FilterPeriodFrom != nil </span><span class="cov0" title="0">{
                occuredOn, err := civil.ParseDate(
                        fmt.Sprintf(
                                "%04d-%02d-%02d",
                                req.FilterPeriodFrom.Year,
                                req.FilterPeriodFrom.Month,
                                1,
                        ),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(
                                appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid filter_period_from"), "%s.%s", c.pkg, op)
                }</span>

                <span class="cov0" title="0">listOptions.FilterPeriodFrom = &amp;occuredOn</span>
        }

        <span class="cov0" title="0">if req.FilterPeriodTo != nil </span><span class="cov0" title="0">{
                occuredOn, err := civil.ParseDate(
                        fmt.Sprintf(
                                "%04d-%02d-%02d",
                                req.FilterPeriodTo.Year,
                                req.FilterPeriodTo.Month,
                                1,
                        ),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(
                                appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid filter_period_to"), "%s.%s", c.pkg, op)
                }</span>

                <span class="cov0" title="0">listOptions.FilterPeriodTo = &amp;occuredOn</span>
        }

        <span class="cov0" title="0">items, total, hitCache, err := c.budgetFacade.Budget.FindPagedList(
                ctx,
                listOptions,
                &amp;uctypes.QueryGetListParams{
                        Limit:  uint64(req.Limit),
                        Offset: uint64(req.Offset),
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">out := &amp;desc.ListBudgetsResponse{
                Items:    make([]*desc.Budget, 0, len(items)),
                Total:    int64(total),
                HitCache: hitCache,
        }

        for _, item := range items </span><span class="cov0" title="0">{
                out.Items = append(out.Items, BudgetToProto(item))
        }</span>

        <span class="cov0" title="0">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package controller

import (
        "context"

        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        budgetUC "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        desc "github.com/m11ano/budget_planner/backend/ledger/pkg/proto_pb/ledger_service"
)

func (c *controller) ListCategories(ctx context.Context, req *desc.ListCategoriesRequest) (*desc.ListCategoriesResponse, error) <span class="cov0" title="0">{
        const op = "ListCategories"

        items, err := c.budgetFacade.Category.FindList(
                ctx,
                &amp;budgetUC.CategoryListOptions{
                        Sort: []uctypes.SortOption[budgetUC.CategoryListOptionsSortField]{
                                {
                                        Field:  budgetUC.CategoryListOptionsSortFieldID,
                                        IsDesc: false,
                                },
                        },
                },
                nil,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">out := &amp;desc.ListCategoriesResponse{
                Items: make([]*desc.Category, 0, len(items)),
        }

        for _, item := range items </span><span class="cov0" title="0">{
                out.Items = append(out.Items, &amp;desc.Category{
                        Id:    int64(item.Category.ID),
                        Title: item.Category.Title,
                })
        }</span>

        <span class="cov0" title="0">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package controller

import (
        "context"
        "fmt"

        "cloud.google.com/go/civil"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        budgetUC "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        desc "github.com/m11ano/budget_planner/backend/ledger/pkg/proto_pb/ledger_service"
)

func (c *controller) ListReports(
        ctx context.Context,
        req *desc.ListReportsRequest,
) (*desc.ListReportsResponse, error) <span class="cov0" title="0">{
        const op = "ListReports"

        authData := auth.GetAuthData(ctx)
        if authData == nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrUnauthorized, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">queryFilter := budgetUC.CountReportItemsQueryFilter{
                AccountID: authData.AccountID,
        }

        if req.DateFrom != nil </span><span class="cov0" title="0">{
                date, err := civil.ParseDate(
                        fmt.Sprintf(
                                "%04d-%02d-%02d",
                                req.DateFrom.Year,
                                req.DateFrom.Month,
                                req.DateFrom.Day,
                        ),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(
                                appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid date_from"), "%s.%s", c.pkg, op)
                }</span>

                <span class="cov0" title="0">queryFilter.DateFrom = &amp;date</span>
        }

        <span class="cov0" title="0">if req.DateTo != nil </span><span class="cov0" title="0">{
                date, err := civil.ParseDate(
                        fmt.Sprintf(
                                "%04d-%02d-%02d",
                                req.DateTo.Year,
                                req.DateTo.Month,
                                req.DateTo.Day,
                        ),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(
                                appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid date_to"), "%s.%s", c.pkg, op)
                }</span>

                <span class="cov0" title="0">queryFilter.DateTo = &amp;date</span>
        }

        <span class="cov0" title="0">items, hitCache, err := c.budgetFacade.Transaction.CountReportItems(
                ctx,
                queryFilter,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">out := &amp;desc.ListReportsResponse{
                Reports:  make([]*desc.PeriodReport, 0, len(items)),
                HitCache: hitCache,
        }

        for _, item := range items </span><span class="cov0" title="0">{
                out.Reports = append(out.Reports, ReportToProto(item))
        }</span>

        <span class="cov0" title="0">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package controller

import (
        "context"
        "fmt"

        "cloud.google.com/go/civil"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        budgetUC "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        desc "github.com/m11ano/budget_planner/backend/ledger/pkg/proto_pb/ledger_service"
)

func (c *controller) ListTransactions(
        ctx context.Context,
        req *desc.ListTransactionsRequest,
) (*desc.ListTransactionsResponse, error) <span class="cov0" title="0">{
        const op = "ListTransactions"

        authData := auth.GetAuthData(ctx)
        if authData == nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrUnauthorized, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">if req.Limit &lt; 1 </span><span class="cov0" title="0">{
                req.Limit = 100
        }</span>

        <span class="cov0" title="0">if req.Limit &gt; 100 </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrBadRequest.WithHints("limit must be &lt;= 100"), "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">listOptions := &amp;budgetUC.TransactionListOptions{
                Sort: []uctypes.SortOption[budgetUC.TransactionListOptionsSortField]{
                        {
                                Field:  budgetUC.TransactionListOptionsSortFieldOccurredOn,
                                IsDesc: true,
                        },
                        {
                                Field:  budgetUC.TransactionListOptionsSortFieldCreatedAt,
                                IsDesc: true,
                        },
                },
                FilterAccountID: &amp;authData.AccountID,
        }

        if req.FilterOccurredOnFrom != nil </span><span class="cov0" title="0">{
                occuredOn, err := civil.ParseDate(
                        fmt.Sprintf(
                                "%04d-%02d-%02d",
                                req.FilterOccurredOnFrom.Year,
                                req.FilterOccurredOnFrom.Month,
                                req.FilterOccurredOnFrom.Day,
                        ),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(
                                appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid filter_occurred_on_from"), "%s.%s", c.pkg, op)
                }</span>

                <span class="cov0" title="0">listOptions.FilterOccurredOnFrom = &amp;occuredOn</span>
        }

        <span class="cov0" title="0">if req.FilterOccurredOnTo != nil </span><span class="cov0" title="0">{
                occuredOn, err := civil.ParseDate(
                        fmt.Sprintf(
                                "%04d-%02d-%02d",
                                req.FilterOccurredOnTo.Year,
                                req.FilterOccurredOnTo.Month,
                                req.FilterOccurredOnTo.Day,
                        ),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(
                                appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid filter_occurred_on_to"), "%s.%s", c.pkg, op)
                }</span>

                <span class="cov0" title="0">listOptions.FilterOccurredOnTo = &amp;occuredOn</span>
        }

        <span class="cov0" title="0">items, total, err := c.budgetFacade.Transaction.FindPagedList(
                ctx,
                listOptions,
                &amp;uctypes.QueryGetListParams{
                        Limit:  uint64(req.Limit),
                        Offset: uint64(req.Offset),
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">out := &amp;desc.ListTransactionsResponse{
                Items: make([]*desc.Transaction, 0, len(items)),
                Total: int64(total),
        }

        for _, item := range items </span><span class="cov0" title="0">{
                out.Items = append(out.Items, TransactionToProto(item))
        }</span>

        <span class="cov0" title="0">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package controller

import (
        "context"
        "fmt"

        "cloud.google.com/go/civil"
        "github.com/google/uuid"
        "github.com/govalues/decimal"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        budgetUC "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        desc "github.com/m11ano/budget_planner/backend/ledger/pkg/proto_pb/ledger_service"
        "github.com/samber/lo"
)

func (c *controller) PatchBudget(ctx context.Context, req *desc.PatchBudgetRequest) (*desc.PatchBudgetResponse, error) <span class="cov0" title="0">{
        const op = "PatchBudget"

        authData := auth.GetAuthData(ctx)
        if authData == nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrUnauthorized, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">budgetID, err := uuid.Parse(req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid id"), "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">patch := budgetUC.PatchBudgetDataInput{}

        if req.Amount != nil </span><span class="cov0" title="0">{
                amount, err := decimal.Parse(*req.Amount)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid amount"), "%s.%s", c.pkg, op)
                }</span>

                <span class="cov0" title="0">patch.Amount = &amp;amount</span>
        }

        <span class="cov0" title="0">if req.Period != nil </span><span class="cov0" title="0">{
                period, err := civil.ParseDate(
                        fmt.Sprintf("%04d-%02d-%02d", req.Period.Year, req.Period.Month, 1),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(
                                appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid period"), "%s.%s", c.pkg, op)
                }</span>

                <span class="cov0" title="0">patch.Period = &amp;period</span>
        }

        <span class="cov0" title="0">if req.CategoryId != nil </span><span class="cov0" title="0">{
                patch.CategoryID = lo.ToPtr(uint64(*req.CategoryId))
        }</span>

        <span class="cov0" title="0">err = c.budgetFacade.Budget.PatchBudgetByDTO(
                ctx,
                budgetID,
                patch,
                true,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">itemDTO, _, err := c.budgetFacade.Budget.FindOneByID(ctx, budgetID, &amp;uctypes.QueryGetOneParams{
                SkipCache: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">out := &amp;desc.PatchBudgetResponse{
                Item: BudgetToProto(itemDTO),
        }

        return out, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package controller

import (
        "context"
        "fmt"

        "cloud.google.com/go/civil"
        "github.com/google/uuid"
        "github.com/govalues/decimal"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        budgetUC "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        desc "github.com/m11ano/budget_planner/backend/ledger/pkg/proto_pb/ledger_service"
        "github.com/samber/lo"
)

func (c *controller) PatchTransaction(
        ctx context.Context,
        req *desc.PatchTransactionRequest,
) (*desc.PatchTransactionResponse, error) <span class="cov0" title="0">{
        const op = "PatchTransaction"

        authData := auth.GetAuthData(ctx)
        if authData == nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrUnauthorized, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">transactionID, err := uuid.Parse(req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid id"), "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">patch := budgetUC.PatchTransactionDataInput{}

        if req.Amount != nil </span><span class="cov0" title="0">{
                amount, err := decimal.Parse(*req.Amount)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid amount"), "%s.%s", c.pkg, op)
                }</span>

                <span class="cov0" title="0">patch.Amount = &amp;amount</span>
        }

        <span class="cov0" title="0">if req.OccurredOn != nil </span><span class="cov0" title="0">{
                occuredOn, err := civil.ParseDate(
                        fmt.Sprintf("%04d-%02d-%02d", req.OccurredOn.Year, req.OccurredOn.Month, req.OccurredOn.Day),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(
                                appErrors.ErrBadRequest.WithWrap(err).WithHints("invalid occured_on"), "%s.%s", c.pkg, op)
                }</span>

                <span class="cov0" title="0">patch.OccurredOn = &amp;occuredOn</span>
        }

        <span class="cov0" title="0">if req.CategoryId != nil </span><span class="cov0" title="0">{
                patch.CategoryID = lo.ToPtr(uint64(*req.CategoryId))
        }</span>

        <span class="cov0" title="0">if req.Description != nil </span><span class="cov0" title="0">{
                patch.Description = lo.ToPtr(*req.Description)
        }</span>

        <span class="cov0" title="0">err = c.budgetFacade.Transaction.PatchTransactionByDTO(
                ctx,
                transactionID,
                patch,
                true,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">itemDTO, err := c.budgetFacade.Transaction.FindOneByID(ctx, transactionID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", c.pkg, op)
        }</span>

        <span class="cov0" title="0">out := &amp;desc.PatchTransactionResponse{
                Item: TransactionToProto(itemDTO),
        }

        return out, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package grpc

import (
        "context"
        "errors"
        "strings"

        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        "github.com/m11ano/budget_planner/backend/ledger/internal/app/config"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/loghandler"
        "google.golang.org/grpc"
        "google.golang.org/grpc/metadata"
)

func interceptorAuth(cfg config.Config) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                req any,
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (any, error) </span><span class="cov0" title="0">{
                md, ok := metadata.FromIncomingContext(ctx)
                if !ok </span><span class="cov0" title="0">{
                        return handler(ctx, req)
                }</span>

                <span class="cov0" title="0">authHeaders := md.Get("authorization")
                if len(authHeaders) == 0 </span><span class="cov0" title="0">{
                        return handler(ctx, req)
                }</span>

                <span class="cov0" title="0">authHeader := authHeaders[0]
                accessToken := strings.TrimPrefix(authHeader, "Bearer ")

                if accessToken == "" </span><span class="cov0" title="0">{
                        return handler(ctx, req)
                }</span>

                <span class="cov0" title="0">claims, err := auth.ParseAccessToken(accessToken, true, []byte(cfg.Auth.JwtAccessSecret))
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, auth.ErrInvalidToken) </span><span class="cov0" title="0">{
                                return handler(ctx, req)
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }

                <span class="cov0" title="0">authData, err := auth.ClaimsToAuthData(claims)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">ctx = auth.SetAuthData(ctx, authData)

                ctx = loghandler.SetContextData(ctx, "request.account.id", claims.AccountId)

                return handler(ctx, req)</span>
        }
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package grpc

import (
        "context"

        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        "google.golang.org/grpc"
)

func interceptorErrors() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                req any,
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (any, error) </span><span class="cov0" title="0">{
                data, err := handler(ctx, req)

                return data, appErrors.ToGrpcStatus(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package grpc

import (
        "context"
        "log/slog"

        "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging"
)

func interceptorLogger(logger *slog.Logger) logging.Logger <span class="cov0" title="0">{
        return logging.LoggerFunc(func(ctx context.Context, lvl logging.Level, msg string, fields ...any) </span><span class="cov0" title="0">{
                logger.Log(ctx, slog.Level(lvl), msg, fields...)
        }</span>)
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package grpc

import (
        "context"

        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/loghandler"
        "google.golang.org/grpc"
        "google.golang.org/grpc/metadata"
)

type contextReqIDKey string

const (
        requestIDKey         contextReqIDKey = "x-request-id"
        metadataRequestIDKey string          = "x-request-id"
)

func interceptorRequestID() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                req any,
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (any, error) </span><span class="cov0" title="0">{
                var reqID string
                if md, ok := metadata.FromIncomingContext(ctx); ok </span><span class="cov0" title="0">{
                        if vals := md.Get(metadataRequestIDKey); len(vals) &gt; 0 </span><span class="cov0" title="0">{
                                reqID = vals[0]
                        }</span>
                }

                <span class="cov0" title="0">if reqID == "" </span><span class="cov0" title="0">{
                        reqID = uuid.New().String()
                }</span>

                <span class="cov0" title="0">ctx = context.WithValue(ctx, requestIDKey, reqID)
                ctx = loghandler.SetContextData(ctx, "request.id", reqID)

                return handler(ctx, req)</span>
        }
}

func GetRequestID(ctx context.Context) string <span class="cov0" title="0">{
        if v := ctx.Value(requestIDKey); v != nil </span><span class="cov0" title="0">{
                if id, ok := v.(string); ok </span><span class="cov0" title="0">{
                        return id
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package grpc

import (
        "context"
        "net"
        "strings"

        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/loghandler"
        "google.golang.org/grpc"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/peer"
)

func getClientIPFromGRPCRequest(ctx context.Context) string <span class="cov0" title="0">{
        if md, ok := metadata.FromIncomingContext(ctx); ok </span><span class="cov0" title="0">{
                if xff := md.Get("x-forwarded-for"); len(xff) &gt; 0 </span><span class="cov0" title="0">{
                        parts := strings.Split(xff[0], ",")
                        ip := strings.TrimSpace(parts[0])
                        if net.ParseIP(ip) != nil </span><span class="cov0" title="0">{
                                return ip
                        }</span>
                }

                <span class="cov0" title="0">if xri := md.Get("x-real-ip"); len(xri) &gt; 0 </span><span class="cov0" title="0">{
                        ip := strings.TrimSpace(xri[0])
                        if net.ParseIP(ip) != nil </span><span class="cov0" title="0">{
                                return ip
                        }</span>
                }
        }

        <span class="cov0" title="0">if p, ok := peer.FromContext(ctx); ok </span><span class="cov0" title="0">{
                host, _, err := net.SplitHostPort(p.Addr.String())
                if err == nil </span><span class="cov0" title="0">{
                        return host
                }</span>
                <span class="cov0" title="0">return p.Addr.String()</span>
        }

        <span class="cov0" title="0">return ""</span>
}

type contextReqIPKey string

const (
        contextReqIPKeyValue contextReqIPKey = "x-request-ip"
)

func interceptorRequestIP() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                req any,
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (any, error) </span><span class="cov0" title="0">{
                requestIP := getClientIPFromGRPCRequest(ctx)

                ctx = context.WithValue(ctx, contextReqIPKeyValue, requestIP)
                ctx = loghandler.SetContextData(ctx, "request.ip", requestIP)

                return handler(ctx, req)
        }</span>
}

func GetClientIP(ctx context.Context) string <span class="cov0" title="0">{
        if v := ctx.Value(contextReqIPKeyValue); v != nil </span><span class="cov0" title="0">{
                if id, ok := v.(string); ok </span><span class="cov0" title="0">{
                        return id
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package grpc

import (
        "context"

        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        "google.golang.org/grpc"
)

func interceptorValidate(
        ctx context.Context,
        req any,
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
) (resp any, err error) <span class="cov0" title="0">{
        if reqV, ok := req.(interface{ ValidateAll() error }); ok </span><span class="cov0" title="0">{
                if err := reqV.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.ErrBadRequest.WithWrap(err).WithHints(err.Error())
                }</span>
        }
        <span class="cov0" title="0">return handler(ctx, req)</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package grpc

import (
        "fmt"
        "log/slog"
        "net"

        "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging"
        "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/recovery"
        "github.com/m11ano/budget_planner/backend/ledger/internal/app/config"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/reflection"
        "google.golang.org/grpc/status"
)

func New(logger *slog.Logger, cfg config.Config) *grpc.Server <span class="cov0" title="0">{
        loggingOpts := []logging.Option{
                logging.WithLogOnEvents(
                        logging.FinishCall,
                        logging.PayloadReceived,
                        logging.PayloadSent,
                ),
        }

        recoveryOpts := []recovery.Option{
                recovery.WithRecoveryHandler(func(p interface{}) (err error) </span><span class="cov0" title="0">{
                        logger.Error("recovered from panic", slog.Any("panic", p))
                        return status.Errorf(codes.Internal, "internal error")
                }</span>),
        }

        <span class="cov0" title="0">unaryInterceptors := []grpc.UnaryServerInterceptor{
                interceptorErrors(),
                recovery.UnaryServerInterceptor(recoveryOpts...),
                interceptorRequestIP(),
                interceptorRequestID(),
                interceptorAuth(cfg),
                interceptorValidate,
                logging.UnaryServerInterceptor(interceptorLogger(logger), loggingOpts...),
        }

        streamInterceptors := []grpc.StreamServerInterceptor{}

        gRPCServer := grpc.NewServer(
                grpc.ChainUnaryInterceptor(unaryInterceptors...),
                grpc.ChainStreamInterceptor(streamInterceptors...),
        )

        reflection.Register(gRPCServer)

        return gRPCServer</span>
}

func Start(grpcServer *grpc.Server, port int) error <span class="cov0" title="0">{
        lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen gRPC: %w", err)
        }</span>

        <span class="cov0" title="0">if err := grpcServer.Serve(lis); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to serve gRPC: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package entity

import (
        "cloud.google.com/go/civil"
        "github.com/google/uuid"
        "github.com/govalues/decimal"
        "github.com/samber/lo"
)

type AccountTransactionReportItem struct {
        Sum          *decimal.Decimal
        Period       civil.Date
        CategoryID   uint64
        BudgetID     *uuid.UUID
        BudgetAmount *decimal.Decimal
}

func (item *AccountTransactionReportItem) SpentBudget() (*decimal.Decimal, error) <span class="cov0" title="0">{
        if item.Sum == nil || item.BudgetAmount == nil || item.BudgetAmount.IsZero() </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if item.Sum.Cmp(decimal.Zero) &gt;= 0 </span><span class="cov0" title="0">{
                return lo.ToPtr(decimal.Zero), nil
        }</span>

        <span class="cov0" title="0">spentBudget, err := item.Sum.Neg().Quo(*item.BudgetAmount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">spentBudgetPercents, err := spentBudget.Mul(decimal.Hundred)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return lo.ToPtr(spentBudgetPercents.Trunc(2)), nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package entity

import (
        "time"

        "cloud.google.com/go/civil"
        "github.com/google/uuid"
        "github.com/govalues/decimal"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
)

var ErrBudgetAmountInvalid = appErrors.ErrBadRequest.Extend("budget amount is invalid").
        WithTextCode("BUDGET_AMOUNT_INVALID").WithHints("budget amount is invalid")

type Budget struct {
        ID         uuid.UUID
        AccountID  uuid.UUID
        Period     civil.Date
        CategoryID uint64
        Amount     decimal.Decimal

        CreatedAt time.Time
        UpdatedAt time.Time
        DeletedAt *time.Time
}

func (item *Budget) Version() int64 <span class="cov0" title="0">{
        return item.UpdatedAt.UnixMicro()
}</span>

func (item *Budget) SetAmount(value decimal.Decimal) error <span class="cov0" title="0">{
        if value.Cmp(decimal.Zero) == -1 </span><span class="cov0" title="0">{
                return ErrIncomeAmountInvalid
        }</span>

        <span class="cov0" title="0">value = value.Trunc(2)

        item.Amount = value

        return nil</span>
}

func (item *Budget) SetPeriod(value civil.Date) error <span class="cov0" title="0">{
        value.Day = 1
        item.Period = value

        return nil
}</span>

func NewBudget(
        accountID uuid.UUID,
        amount decimal.Decimal,
        period civil.Date,
        categoryID uint64,
) (*Budget, error) <span class="cov0" title="0">{
        timeNow := time.Now().Truncate(time.Microsecond)

        item := &amp;Budget{
                ID:         uuid.New(),
                AccountID:  accountID,
                CategoryID: categoryID,
                CreatedAt:  timeNow,
                UpdatedAt:  timeNow,
        }

        err := item.SetAmount(amount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = item.SetPeriod(period)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return item, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package entity

import (
        "strings"
        "time"

        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
)

var ErrTitleInvalid = appErrors.ErrBadRequest.Extend("title is invalid")

type Category struct {
        ID    uint64
        Title string

        CreatedAt time.Time
        UpdatedAt time.Time
        DeletedAt *time.Time
}

func (item *Category) Version() int64 <span class="cov0" title="0">{
        return item.UpdatedAt.UnixMicro()
}</span>

func (item *Category) SetTitle(value string) error <span class="cov0" title="0">{
        value = strings.TrimSpace(value)

        if value == "" </span><span class="cov0" title="0">{
                return ErrTitleInvalid
        }</span>

        <span class="cov0" title="0">item.Title = value

        return nil</span>
}

func NewCategory(
        title string,
) (*Category, error) <span class="cov0" title="0">{
        timeNow := time.Now().Truncate(time.Microsecond)

        item := &amp;Category{
                CreatedAt: timeNow,
                UpdatedAt: timeNow,
        }

        err := item.SetTitle(title)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return item, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package entity

import (
        "strings"
        "time"

        "cloud.google.com/go/civil"
        "github.com/google/uuid"
        "github.com/govalues/decimal"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
)

var (
        ErrIncomeAmountInvalid = appErrors.ErrBadRequest.Extend("income amount is invalid").
                                WithTextCode("INCOME_AMOUNT_INVALID").WithHints("income amount is invalid")

        ErrOutcomeAmountInvalid = appErrors.ErrBadRequest.Extend("outcome amount is invalid").
                                WithTextCode("OUTCOME_AMOUNT_INVALID").WithHints("outcome amount is invalid")
)

type Transaction struct {
        ID          uuid.UUID
        AccountID   uuid.UUID
        IsIncome    bool
        Amount      decimal.Decimal
        OccurredOn  civil.Date
        CategoryID  uint64
        Description string

        CreatedAt time.Time
        UpdatedAt time.Time
        DeletedAt *time.Time
}

func (item *Transaction) Version() int64 <span class="cov0" title="0">{
        return item.UpdatedAt.UnixMicro()
}</span>

func (item *Transaction) SetDescription(value string) error <span class="cov0" title="0">{
        value = strings.TrimSpace(value)

        item.Description = value

        return nil
}</span>

func (item *Transaction) SetAmount(value decimal.Decimal) error <span class="cov0" title="0">{
        if item.IsIncome &amp;&amp; value.Cmp(decimal.Zero) == -1 </span><span class="cov0" title="0">{
                return ErrIncomeAmountInvalid
        }</span> else<span class="cov0" title="0"> if !item.IsIncome &amp;&amp; value.Cmp(decimal.Zero) == 1 </span><span class="cov0" title="0">{
                return ErrOutcomeAmountInvalid
        }</span>

        <span class="cov0" title="0">value = value.Trunc(2)

        item.Amount = value

        return nil</span>
}

func (item *Transaction) SetOccuredOn(value civil.Date) error <span class="cov0" title="0">{
        item.OccurredOn = value

        return nil
}</span>

func NewTransaction(
        accountID uuid.UUID,
        isIncome bool,
        amount decimal.Decimal,
        occurredOn civil.Date,
        categoryID uint64,
) (*Transaction, error) <span class="cov0" title="0">{
        timeNow := time.Now().Truncate(time.Microsecond)

        item := &amp;Transaction{
                ID:         uuid.New(),
                AccountID:  accountID,
                IsIncome:   isIncome,
                CategoryID: categoryID,
                CreatedAt:  timeNow,
                UpdatedAt:  timeNow,
        }

        err := item.SetAmount(amount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = item.SetOccuredOn(occurredOn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return item, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package budget

import (
        "log/slog"

        "github.com/m11ano/budget_planner/backend/ledger/internal/app"
        "github.com/m11ano/budget_planner/backend/ledger/internal/app/fxboot/invoking"
)

func Init(_ app.ID, logger *slog.Logger) invoking.InvokeInit <span class="cov0" title="0">{
        return invoking.InvokeInit{}
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package transaction

import (
        "bytes"
        "context"
        "encoding/csv"
        "fmt"
        "strconv"
        "strings"

        "cloud.google.com/go/civil"
        "github.com/google/uuid"
        "github.com/govalues/decimal"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
)

func (r *Repository) ItemsToCSV(ctx context.Context, items []*usecase.TransactionDTO) ([]byte, error) <span class="cov0" title="0">{
        const op = "ItemsToCSV"

        buf := &amp;bytes.Buffer{}
        writer := csv.NewWriter(buf)

        buf.Write([]byte{0xEF, 0xBB, 0xBF})

        headers := []string{
                "ID",
                "AccountID",
                "IsIncome",
                "Amount",
                "OccurredOn",
                "Description",
                "CategoryID",
                "CategoryTitle",
        }

        if err := writer.Write(headers); err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">for _, row := range items </span><span class="cov0" title="0">{
                row := []string{
                        row.Transaction.ID.String(),
                        row.Transaction.AccountID.String(),
                        fmt.Sprintf("%t", row.Transaction.IsIncome),
                        row.Transaction.Amount.String(),
                        row.Transaction.OccurredOn.String(),
                        row.Transaction.Description,
                        fmt.Sprintf("%d", row.Transaction.CategoryID),
                        row.Category.Title,
                }

                if err := writer.Write(row); err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(err, "%s.%s", r.pkg, op)
                }</span>
        }

        <span class="cov0" title="0">writer.Flush()
        if err := writer.Error(); err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

func (r *Repository) ItemsFromCSV(ctx context.Context, data []byte, accountID uuid.UUID) ([]*entity.Transaction, error) <span class="cov0" title="0">{
        const op = "ItemsFromCSV"

        reader := csv.NewReader(bytes.NewReader(data))

        records, err := reader.ReadAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">out := make([]*entity.Transaction, 0, len(records))

        for idx, row := range records </span><span class="cov0" title="0">{
                if len(row) &lt; 5 </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(
                                appErrors.ErrBadRequest.WithHints("invalid number of columns", fmt.Sprintf("line %d", idx+1)),
                                "%s.%s",
                                r.pkg,
                                op,
                        )
                }</span>

                <span class="cov0" title="0">isIncome := false
                if strings.ToLower(row[0]) == "true" </span><span class="cov0" title="0">{
                        isIncome = true
                }</span>

                <span class="cov0" title="0">amount, err := decimal.Parse(row[1])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(
                                appErrors.ErrBadRequest.WithParent(err).WithHints("invalid amount", fmt.Sprintf("line %d", idx)),
                                "%s.%s",
                                r.pkg,
                                op,
                        )
                }</span>

                <span class="cov0" title="0">occurredOn, err := civil.ParseDate(row[2])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(
                                appErrors.ErrBadRequest.WithParent(err).WithHints("invalid occurred_on", fmt.Sprintf("line %d", idx+1)),
                                "%s.%s",
                                r.pkg,
                                op,
                        )
                }</span>

                <span class="cov0" title="0">categoryID, err := strconv.ParseUint(row[4], 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(
                                appErrors.ErrBadRequest.WithParent(err).WithHints("invalid category_id", fmt.Sprintf("line %d", idx+1)),
                                "%s.%s",
                                r.pkg,
                                op,
                        )
                }</span>

                <span class="cov0" title="0">transaction, err := entity.NewTransaction(
                        accountID,
                        isIncome,
                        amount,
                        occurredOn,
                        categoryID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        appErr, ok := appErrors.ExtractError(err)
                        if ok </span><span class="cov0" title="0">{
                                hints := appErr.Hints()
                                hints = append(hints, fmt.Sprintf("line %d", idx+1))

                                return nil, appErrors.Chainf(
                                        appErr.WithHints(hints...),
                                        "%s.%s: line %d",
                                        r.pkg,
                                        op,
                                        idx+1,
                                )
                        }</span>
                        <span class="cov0" title="0">return nil, appErrors.Chainf(err, "%s.%s: line %d", r.pkg, op, idx+1)</span>
                }

                <span class="cov0" title="0">err = transaction.SetDescription(row[3])
                if err != nil </span><span class="cov0" title="0">{
                        appErr, ok := appErrors.ExtractError(err)
                        if ok </span><span class="cov0" title="0">{
                                hints := appErr.Hints()
                                hints = append(hints, fmt.Sprintf("line %d", idx+1))

                                return nil, appErrors.Chainf(
                                        appErr.WithHints(hints...),
                                        "%s.%s: line %d",
                                        r.pkg,
                                        op,
                                        idx+1,
                                )
                        }</span>
                        <span class="cov0" title="0">return nil, appErrors.Chainf(err, "%s.%s: line %d", r.pkg, op, idx+1)</span>
                }

                <span class="cov0" title="0">out = append(out, transaction)</span>
        }

        <span class="cov0" title="0">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package transaction

import (
        "log/slog"
)

type Repository struct {
        pkg    string
        logger *slog.Logger
}

func NewRepository(logger *slog.Logger) *Repository <span class="cov0" title="0">{
        return &amp;Repository{
                pkg:    "Budget.repository.CSVTransaction",
                logger: logger,
        }
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package pg

import (
        "time"

        "cloud.google.com/go/civil"
        "github.com/google/uuid"
        "github.com/govalues/decimal"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/pkg/dbhelper"
)

const (
        BudgetTable = "budget"
)

var BudgetTableFields = []string{}

func init() <span class="cov0" title="0">{
        BudgetTableFields = dbhelper.ExtractDBFields(&amp;BudgetDBModel{})
}</span>

type BudgetDBModel struct {
        ID         uuid.UUID       `db:"id"`
        AccountID  uuid.UUID       `db:"account_id"`
        Period     civil.Date      `db:"period"`
        CategoryID uint64          `db:"category_id"`
        Amount     decimal.Decimal `db:"amount"`

        CreatedAt time.Time  `db:"created_at"`
        UpdatedAt time.Time  `db:"updated_at"`
        DeletedAt *time.Time `db:"deleted_at"`
}

func (db *BudgetDBModel) ToEntity() *entity.Budget <span class="cov0" title="0">{
        return &amp;entity.Budget{
                ID:         db.ID,
                AccountID:  db.AccountID,
                Amount:     db.Amount,
                CategoryID: db.CategoryID,
                Period:     db.Period,

                CreatedAt: db.CreatedAt,
                UpdatedAt: db.UpdatedAt,
                DeletedAt: db.DeletedAt,
        }
}</span>

func MapBudgetEntityToDBModel(entity *entity.Budget) *BudgetDBModel <span class="cov0" title="0">{
        return &amp;BudgetDBModel{
                ID:         entity.ID,
                AccountID:  entity.AccountID,
                Amount:     entity.Amount,
                CategoryID: entity.CategoryID,
                Period:     entity.Period,

                CreatedAt: entity.CreatedAt,
                UpdatedAt: entity.UpdatedAt,
                DeletedAt: entity.DeletedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package budget

import (
        "context"
        "log/slog"
        "time"

        "github.com/Masterminds/squirrel"
        "github.com/google/uuid"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/pg"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/loghandler"
        "github.com/m11ano/budget_planner/backend/ledger/pkg/dbhelper"
)

func (r *Repository) Create(ctx context.Context, item *entity.Budget) error <span class="cov0" title="0">{
        const op = "Create"

        dataMap, err := dbhelper.DBModelToMap(pg.MapBudgetEntityToDBModel(item))
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "convert struct to db map", slog.Any("error", err))
                return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">query, args, err := r.qb.Insert(pg.BudgetTable).SetMap(dataMap).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">_, err = r.pgClient.GetConn(ctx).Exec(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *Repository) Update(ctx context.Context, item *entity.Budget) error <span class="cov0" title="0">{
        const op = "Update"

        currentUpdatedAt := item.UpdatedAt
        timeNow := time.Now().Truncate(time.Microsecond)

        dataMap, err := dbhelper.DBModelToMap(pg.MapBudgetEntityToDBModel(item))
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "convert struct to db map", slog.Any("error", err))
                return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>
        <span class="cov0" title="0">delete(dataMap, "id")
        dataMap["updated_at"] = timeNow

        err = r.pgClient.Do(ctx, func(ctx context.Context) error </span><span class="cov0" title="0">{
                checkQuery, checkArgs, err := r.qb.Select("id").From(pg.BudgetTable).Where(squirrel.Eq{"id": item.ID}).ToSql()
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "building check query", slog.Any("error", err))
                        return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
                }</span>

                <span class="cov0" title="0">var checkID uuid.UUID
                err = r.pgClient.GetConn(ctx).QueryRow(ctx, checkQuery, checkArgs...).Scan(&amp;checkID)
                if err != nil </span><span class="cov0" title="0">{
                        convErr, ok := appErrors.ConvertPgxToAppErr(err)
                        if !ok </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(loghandler.WithSource(ctx), "executing check query", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
                }

                <span class="cov0" title="0">updQuery, updArgs, err := r.qb.Update(pg.BudgetTable).Where(
                        squirrel.Eq{"id": item.ID, "updated_at": currentUpdatedAt}).SetMap(dataMap).ToSql()
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                        return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
                }</span>

                <span class="cov0" title="0">cmdTag, err := r.pgClient.GetConn(ctx).Exec(ctx, updQuery, updArgs...)
                if err != nil </span><span class="cov0" title="0">{
                        convErr, ok := appErrors.ConvertPgxToAppErr(err)
                        if !ok </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(loghandler.WithSource(ctx), "executing query", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
                }

                <span class="cov0" title="0">if cmdTag.RowsAffected() == 0 </span><span class="cov0" title="0">{
                        return appErrors.Chainf(appErrors.ErrConflict, "%s.%s", r.pkg, op)
                }</span>

                <span class="cov0" title="0">item.UpdatedAt = timeNow

                return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package budget

import (
        "context"
        "log/slog"

        "github.com/Masterminds/squirrel"
        "github.com/georgysavva/scany/v2/pgxscan"
        "github.com/google/uuid"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/pg"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/loghandler"
)

func (r *Repository) buildWhereForList(listOptions *usecase.BudgetListOptions, withDeleted bool) (where squirrel.And) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if !withDeleted </span><span class="cov0" title="0">{
                        where = append(where, squirrel.Expr("deleted_at IS NULL"))
                }</span>
        }()

        <span class="cov0" title="0">if listOptions == nil </span><span class="cov0" title="0">{
                return where
        }</span>

        <span class="cov0" title="0">if listOptions.FilterAccountID != nil </span><span class="cov0" title="0">{
                where = append(where, squirrel.Eq{"account_id": *listOptions.FilterAccountID})
        }</span>

        <span class="cov0" title="0">if listOptions.FilterPeriod != nil </span><span class="cov0" title="0">{
                where = append(where, squirrel.Eq{"period": *listOptions.FilterPeriod})
        }</span>

        <span class="cov0" title="0">if listOptions.FilterCategoryID != nil </span><span class="cov0" title="0">{
                where = append(where, squirrel.Eq{"category_id": *listOptions.FilterCategoryID})
        }</span>

        <span class="cov0" title="0">if listOptions.FilterPeriodFrom != nil </span><span class="cov0" title="0">{
                where = append(where, squirrel.GtOrEq{"period": *listOptions.FilterPeriodFrom})
        }</span>

        <span class="cov0" title="0">if listOptions.FilterPeriodTo != nil </span><span class="cov0" title="0">{
                where = append(where, squirrel.LtOrEq{"period": *listOptions.FilterPeriodTo})
        }</span>

        <span class="cov0" title="0">return where</span>
}

func (r *Repository) buildSortForList(listOptions *usecase.BudgetListOptions) []string <span class="cov0" title="0">{
        if listOptions == nil || len(listOptions.Sort) == 0 </span><span class="cov0" title="0">{
                return []string{"created_at DESC"}
        }</span>

        <span class="cov0" title="0">sort := make([]string, 0, len(listOptions.Sort))

        for _, sortOption := range listOptions.Sort </span><span class="cov0" title="0">{
                switch sortOption.Field </span>{
                case usecase.BudgetListOptionsSortFieldPeriod:<span class="cov0" title="0">
                        if sortOption.IsDesc </span><span class="cov0" title="0">{
                                sort = append(sort, "period DESC")
                        }</span> else<span class="cov0" title="0"> {
                                sort = append(sort, "period ASC")
                        }</span>
                case usecase.BudgetListOptionsSortFieldCreatedAt:<span class="cov0" title="0">
                        if sortOption.IsDesc </span><span class="cov0" title="0">{
                                sort = append(sort, "created_at DESC")
                        }</span> else<span class="cov0" title="0"> {
                                sort = append(sort, "created_at ASC")
                        }</span>
                }
        }

        <span class="cov0" title="0">return sort</span>
}

func (r *Repository) FindList(
        ctx context.Context,
        listOptions *usecase.BudgetListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]*entity.Budget, error) <span class="cov0" title="0">{
        const op = "FindList"

        withDeleted := queryParams != nil &amp;&amp; queryParams.WithDeleted

        where := r.buildWhereForList(listOptions, withDeleted)

        fields := pg.BudgetTableFields

        q := r.qb.Select(fields...).From(pg.BudgetTable).Where(where)

        sort := r.buildSortForList(listOptions)
        if len(sort) &gt; 0 </span><span class="cov0" title="0">{
                q = q.OrderBy(sort...)
        }</span>

        <span class="cov0" title="0">if queryParams != nil </span><span class="cov0" title="0">{
                if queryParams.ForUpdateSkipLocked </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE SKIP LOCKED")
                }</span> else<span class="cov0" title="0"> if queryParams.ForUpdate </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE")
                }</span> else<span class="cov0" title="0"> if queryParams.ForShare </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR SHARE")
                }</span>

                <span class="cov0" title="0">if queryParams.Limit &gt; 0 </span><span class="cov0" title="0">{
                        q = q.Limit(queryParams.Limit)
                }</span>

                <span class="cov0" title="0">if queryParams.Offset &gt; 0 </span><span class="cov0" title="0">{
                        q = q.Offset(queryParams.Offset)
                }</span>
        }

        <span class="cov0" title="0">query, args, err := q.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                return nil, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">rows, err := r.pgClient.GetConn(ctx).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "query row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        dbData := []*pg.BudgetDBModel{}

        if err := pgxscan.ScanAll(&amp;dbData, rows); err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "scan row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">result := make([]*entity.Budget, 0, len(dbData))
        for _, dbItem := range dbData </span><span class="cov0" title="0">{
                result = append(result, dbItem.ToEntity())
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (r *Repository) FindPagedList(
        ctx context.Context,
        listOptions *usecase.BudgetListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]*entity.Budget, uint64, error) <span class="cov0" title="0">{
        const op = "FindPagedList"

        withDeleted := queryParams != nil &amp;&amp; queryParams.WithDeleted

        where := r.buildWhereForList(listOptions, withDeleted)

        fields := pg.BudgetTableFields

        q := r.qb.Select(fields...).From(pg.BudgetTable).Where(where)

        sort := r.buildSortForList(listOptions)
        if len(sort) &gt; 0 </span><span class="cov0" title="0">{
                q = q.OrderBy(sort...)
        }</span>

        <span class="cov0" title="0">if queryParams != nil </span><span class="cov0" title="0">{
                if queryParams.ForUpdateSkipLocked </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE SKIP LOCKED")
                }</span> else<span class="cov0" title="0"> if queryParams.ForUpdate </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE")
                }</span> else<span class="cov0" title="0"> if queryParams.ForShare </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR SHARE")
                }</span>

                <span class="cov0" title="0">if queryParams.Limit &gt; 0 </span><span class="cov0" title="0">{
                        q = q.Limit(queryParams.Limit)
                }</span>

                <span class="cov0" title="0">if queryParams.Offset &gt; 0 </span><span class="cov0" title="0">{
                        q = q.Offset(queryParams.Offset)
                }</span>
        }

        <span class="cov0" title="0">query, args, err := q.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                return nil, 0, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">totalQ := r.qb.Select("COUNT(*) as total").From(pg.BudgetTable).Where(where)
        totalQuery, totalArgs, err := totalQ.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query for total", slog.Any("error", err))
                return nil, 0, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">var total uint64
        var result []*entity.Budget

        err = r.pgClient.Do(ctx, func(ctx context.Context) error </span><span class="cov0" title="0">{
                rows, err := r.pgClient.GetConn(ctx).Query(ctx, query, args...)
                if err != nil </span><span class="cov0" title="0">{
                        convErr, ok := appErrors.ConvertPgxToAppErr(err)
                        if !ok </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(loghandler.WithSource(ctx), "query row error", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
                }

                <span class="cov0" title="0">defer rows.Close()

                dbData := []*pg.BudgetDBModel{}

                if err := pgxscan.ScanAll(&amp;dbData, rows); err != nil </span><span class="cov0" title="0">{
                        convErr, ok := appErrors.ConvertPgxToAppErr(err)
                        if !ok </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(loghandler.WithSource(ctx), "scan row error", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
                }

                <span class="cov0" title="0">result = make([]*entity.Budget, 0, len(dbData))
                for _, dbItem := range dbData </span><span class="cov0" title="0">{
                        result = append(result, dbItem.ToEntity())
                }</span>

                <span class="cov0" title="0">row := r.pgClient.GetConn(ctx).QueryRow(ctx, totalQuery, totalArgs...)
                if err := row.Scan(&amp;total); err != nil </span><span class="cov0" title="0">{
                        convErr, ok := appErrors.ConvertPgxToAppErr(err)
                        if !ok </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(loghandler.WithSource(ctx), "scan total error", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return result, total, nil</span>
}

func (r *Repository) FindOneByID(
        ctx context.Context,
        id uuid.UUID,
        queryParams *uctypes.QueryGetOneParams,
) (*entity.Budget, error) <span class="cov0" title="0">{
        const op = "FindOneByID"

        withDeleted := queryParams != nil &amp;&amp; queryParams.WithDeleted

        where := squirrel.And{
                squirrel.Eq{"id": id},
        }

        if !withDeleted </span><span class="cov0" title="0">{
                where = append(where, squirrel.Expr("deleted_at IS NULL"))
        }</span>

        <span class="cov0" title="0">q := r.qb.Select(pg.BudgetTableFields...).From(pg.BudgetTable).Where(where)

        if queryParams != nil </span><span class="cov0" title="0">{
                if queryParams.ForUpdateSkipLocked </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE SKIP LOCKED")
                }</span> else<span class="cov0" title="0"> if queryParams.ForUpdate </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE")
                }</span> else<span class="cov0" title="0"> if queryParams.ForShare </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR SHARE")
                }</span>
        }

        <span class="cov0" title="0">query, args, err := q.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                return nil, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">rows, err := r.pgClient.GetConn(ctx).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "query row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        dbData := &amp;pg.BudgetDBModel{}

        if err := pgxscan.ScanOne(dbData, rows); err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "scan row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">return dbData.ToEntity(), nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package budget

import (
        "log/slog"

        "github.com/Masterminds/squirrel"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/db"
)

type Repository struct {
        pkg      string
        logger   *slog.Logger
        pgClient db.MasterClient
        qb       squirrel.StatementBuilderType
}

func NewRepository(logger *slog.Logger, pgClient db.MasterClient) *Repository <span class="cov0" title="0">{
        return &amp;Repository{
                pkg:      "Budget.repository.Budget",
                logger:   logger,
                pgClient: pgClient,
                qb:       squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar),
        }
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package pg

import (
        "time"

        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/pkg/dbhelper"
)

const (
        CategoryTable = "category"
)

var CategoryTableFields = []string{}

func init() <span class="cov0" title="0">{
        CategoryTableFields = dbhelper.ExtractDBFields(&amp;CategoryDBModel{})
}</span>

type CategoryDBModel struct {
        ID    uint64 `db:"id"`
        Title string `db:"title"`

        CreatedAt time.Time  `db:"created_at"`
        UpdatedAt time.Time  `db:"updated_at"`
        DeletedAt *time.Time `db:"deleted_at"`
}

func (db *CategoryDBModel) ToEntity() *entity.Category <span class="cov0" title="0">{
        return &amp;entity.Category{
                ID:    db.ID,
                Title: db.Title,

                CreatedAt: db.CreatedAt,
                UpdatedAt: db.UpdatedAt,
                DeletedAt: db.DeletedAt,
        }
}</span>

func MapCategoryEntityToDBModel(entity *entity.Category) *CategoryDBModel <span class="cov0" title="0">{
        return &amp;CategoryDBModel{
                ID:    entity.ID,
                Title: entity.Title,

                CreatedAt: entity.CreatedAt,
                UpdatedAt: entity.UpdatedAt,
                DeletedAt: entity.DeletedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package category

import (
        "context"
        "log/slog"

        "github.com/Masterminds/squirrel"
        "github.com/georgysavva/scany/v2/pgxscan"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/pg"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/loghandler"
)

func (r *Repository) buildWhereForList(listOptions *usecase.CategoryListOptions, withDeleted bool) (where squirrel.And) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if !withDeleted </span><span class="cov0" title="0">{
                        where = append(where, squirrel.Expr("deleted_at IS NULL"))
                }</span>
        }()

        <span class="cov0" title="0">if listOptions == nil </span><span class="cov0" title="0">{
                return where
        }</span>

        <span class="cov0" title="0">if listOptions.FilterIDs != nil </span><span class="cov0" title="0">{
                where = append(where, squirrel.Eq{"id": *listOptions.FilterIDs})
        }</span>

        <span class="cov0" title="0">return where</span>
}

func (r *Repository) buildSortForList(listOptions *usecase.CategoryListOptions) []string <span class="cov0" title="0">{
        if listOptions == nil || len(listOptions.Sort) == 0 </span><span class="cov0" title="0">{
                return []string{"id DESC"}
        }</span>

        <span class="cov0" title="0">sort := make([]string, 0, len(listOptions.Sort))

        for _, sortOption := range listOptions.Sort </span><span class="cov0" title="0">{
                switch sortOption.Field </span>{
                case usecase.CategoryListOptionsSortFieldID:<span class="cov0" title="0">
                        if sortOption.IsDesc </span><span class="cov0" title="0">{
                                sort = append(sort, "id DESC")
                        }</span> else<span class="cov0" title="0"> {
                                sort = append(sort, "id ASC")
                        }</span>
                }
        }

        <span class="cov0" title="0">return sort</span>
}

func (r *Repository) FindList(
        ctx context.Context,
        listOptions *usecase.CategoryListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]*entity.Category, error) <span class="cov0" title="0">{
        const op = "FindList"

        withDeleted := queryParams != nil &amp;&amp; queryParams.WithDeleted

        where := r.buildWhereForList(listOptions, withDeleted)

        fields := pg.CategoryTableFields

        q := r.qb.Select(fields...).From(pg.CategoryTable).Where(where)

        sort := r.buildSortForList(listOptions)
        if len(sort) &gt; 0 </span><span class="cov0" title="0">{
                q = q.OrderBy(sort...)
        }</span>

        <span class="cov0" title="0">if queryParams != nil </span><span class="cov0" title="0">{
                if queryParams.ForUpdateSkipLocked </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE SKIP LOCKED")
                }</span> else<span class="cov0" title="0"> if queryParams.ForUpdate </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE")
                }</span> else<span class="cov0" title="0"> if queryParams.ForShare </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR SHARE")
                }</span>

                <span class="cov0" title="0">if queryParams.Limit &gt; 0 </span><span class="cov0" title="0">{
                        q = q.Limit(queryParams.Limit)
                }</span>

                <span class="cov0" title="0">if queryParams.Offset &gt; 0 </span><span class="cov0" title="0">{
                        q = q.Offset(queryParams.Offset)
                }</span>
        }

        <span class="cov0" title="0">query, args, err := q.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                return nil, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">rows, err := r.pgClient.GetConn(ctx).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "query row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        dbData := []*pg.CategoryDBModel{}

        if err := pgxscan.ScanAll(&amp;dbData, rows); err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "scan row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">result := make([]*entity.Category, 0, len(dbData))
        for _, dbItem := range dbData </span><span class="cov0" title="0">{
                result = append(result, dbItem.ToEntity())
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (r *Repository) FindOneByID(
        ctx context.Context,
        id uint64,
        queryParams *uctypes.QueryGetOneParams,
) (*entity.Category, error) <span class="cov0" title="0">{
        const op = "FindOneByID"

        where := squirrel.And{
                squirrel.Eq{"id": id},
        }

        q := r.qb.Select(pg.CategoryTableFields...).From(pg.CategoryTable).Where(where)

        if queryParams != nil </span><span class="cov0" title="0">{
                if queryParams.ForUpdateSkipLocked </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE SKIP LOCKED")
                }</span> else<span class="cov0" title="0"> if queryParams.ForUpdate </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE")
                }</span> else<span class="cov0" title="0"> if queryParams.ForShare </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR SHARE")
                }</span>
        }

        <span class="cov0" title="0">query, args, err := q.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                return nil, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">rows, err := r.pgClient.GetConn(ctx).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "query row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        dbData := &amp;pg.CategoryDBModel{}

        if err := pgxscan.ScanOne(dbData, rows); err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "scan row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">return dbData.ToEntity(), nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package category

import (
        "log/slog"

        "github.com/Masterminds/squirrel"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/db"
)

type Repository struct {
        pkg      string
        logger   *slog.Logger
        pgClient db.MasterClient
        qb       squirrel.StatementBuilderType
}

func NewRepository(logger *slog.Logger, pgClient db.MasterClient) *Repository <span class="cov0" title="0">{
        return &amp;Repository{
                pkg:      "Budget.repository.Category",
                logger:   logger,
                pgClient: pgClient,
                qb:       squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar),
        }
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package pg

import (
        "time"

        "cloud.google.com/go/civil"
        "github.com/google/uuid"
        "github.com/govalues/decimal"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/pkg/dbhelper"
)

const (
        TransactionTable = "transaction"
)

var TransactionTableFields = []string{}

func init() <span class="cov0" title="0">{
        TransactionTableFields = dbhelper.ExtractDBFields(&amp;TransactionDBModel{})
}</span>

type TransactionDBModel struct {
        ID          uuid.UUID       `db:"id"`
        AccountID   uuid.UUID       `db:"account_id"`
        IsIncome    bool            `db:"is_income"`
        Amount      decimal.Decimal `db:"amount"`
        OccurredOn  civil.Date      `db:"occurred_on"`
        CategoryID  uint64          `db:"category_id"`
        Description string          `db:"description"`

        CreatedAt time.Time  `db:"created_at"`
        UpdatedAt time.Time  `db:"updated_at"`
        DeletedAt *time.Time `db:"deleted_at"`
}

func (db *TransactionDBModel) ToEntity() *entity.Transaction <span class="cov0" title="0">{
        return &amp;entity.Transaction{
                ID:          db.ID,
                AccountID:   db.AccountID,
                IsIncome:    db.IsIncome,
                Amount:      db.Amount,
                OccurredOn:  db.OccurredOn,
                CategoryID:  db.CategoryID,
                Description: db.Description,

                CreatedAt: db.CreatedAt,
                UpdatedAt: db.UpdatedAt,
                DeletedAt: db.DeletedAt,
        }
}</span>

func MapTransactionEntityToDBModel(entity *entity.Transaction) *TransactionDBModel <span class="cov0" title="0">{
        return &amp;TransactionDBModel{
                ID:          entity.ID,
                AccountID:   entity.AccountID,
                IsIncome:    entity.IsIncome,
                Amount:      entity.Amount,
                OccurredOn:  entity.OccurredOn,
                CategoryID:  entity.CategoryID,
                Description: entity.Description,

                CreatedAt: entity.CreatedAt,
                UpdatedAt: entity.UpdatedAt,
                DeletedAt: entity.DeletedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package transaction

import (
        "context"
        "log/slog"
        "time"

        "github.com/Masterminds/squirrel"
        "github.com/google/uuid"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/pg"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/loghandler"
        "github.com/m11ano/budget_planner/backend/ledger/pkg/dbhelper"
)

func (r *Repository) Create(ctx context.Context, item *entity.Transaction) error <span class="cov0" title="0">{
        const op = "Create"

        dataMap, err := dbhelper.DBModelToMap(pg.MapTransactionEntityToDBModel(item))
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "convert struct to db map", slog.Any("error", err))
                return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">query, args, err := r.qb.Insert(pg.TransactionTable).SetMap(dataMap).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">_, err = r.pgClient.GetConn(ctx).Exec(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "executing query", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *Repository) Update(ctx context.Context, item *entity.Transaction) error <span class="cov0" title="0">{
        const op = "Update"

        currentUpdatedAt := item.UpdatedAt
        timeNow := time.Now().Truncate(time.Microsecond)

        dataMap, err := dbhelper.DBModelToMap(pg.MapTransactionEntityToDBModel(item))
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "convert struct to db map", slog.Any("error", err))
                return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>
        <span class="cov0" title="0">delete(dataMap, "id")
        dataMap["updated_at"] = timeNow

        err = r.pgClient.Do(ctx, func(ctx context.Context) error </span><span class="cov0" title="0">{
                checkQuery, checkArgs, err := r.qb.Select("id").From(pg.TransactionTable).Where(squirrel.Eq{"id": item.ID}).ToSql()
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "building check query", slog.Any("error", err))
                        return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
                }</span>

                <span class="cov0" title="0">var checkID uuid.UUID
                err = r.pgClient.GetConn(ctx).QueryRow(ctx, checkQuery, checkArgs...).Scan(&amp;checkID)
                if err != nil </span><span class="cov0" title="0">{
                        convErr, ok := appErrors.ConvertPgxToAppErr(err)
                        if !ok </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(loghandler.WithSource(ctx), "executing check query", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
                }

                <span class="cov0" title="0">updQuery, updArgs, err := r.qb.Update(pg.TransactionTable).Where(
                        squirrel.Eq{"id": item.ID, "updated_at": currentUpdatedAt}).SetMap(dataMap).ToSql()
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                        return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
                }</span>

                <span class="cov0" title="0">cmdTag, err := r.pgClient.GetConn(ctx).Exec(ctx, updQuery, updArgs...)
                if err != nil </span><span class="cov0" title="0">{
                        convErr, ok := appErrors.ConvertPgxToAppErr(err)
                        if !ok </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(loghandler.WithSource(ctx), "executing query", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
                }

                <span class="cov0" title="0">if cmdTag.RowsAffected() == 0 </span><span class="cov0" title="0">{
                        return appErrors.Chainf(appErrors.ErrConflict, "%s.%s", r.pkg, op)
                }</span>

                <span class="cov0" title="0">item.UpdatedAt = timeNow

                return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package transaction

import (
        "context"
        "log/slog"

        "cloud.google.com/go/civil"
        "github.com/Masterminds/squirrel"
        "github.com/georgysavva/scany/v2/pgxscan"
        "github.com/google/uuid"
        "github.com/govalues/decimal"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/pg"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/loghandler"
)

func (r *Repository) buildWhereForList(listOptions *usecase.TransactionListOptions, withDeleted bool) (where squirrel.And) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if !withDeleted </span><span class="cov0" title="0">{
                        where = append(where, squirrel.Expr("deleted_at IS NULL"))
                }</span>
        }()

        <span class="cov0" title="0">if listOptions == nil </span><span class="cov0" title="0">{
                return where
        }</span>

        <span class="cov0" title="0">if listOptions.FilterAccountID != nil </span><span class="cov0" title="0">{
                where = append(where, squirrel.Eq{"account_id": *listOptions.FilterAccountID})
        }</span>

        <span class="cov0" title="0">if listOptions.FilterOccurredOnFrom != nil </span><span class="cov0" title="0">{
                where = append(where, squirrel.GtOrEq{"occurred_on": *listOptions.FilterOccurredOnFrom})
        }</span>

        <span class="cov0" title="0">if listOptions.FilterOccurredOnTo != nil </span><span class="cov0" title="0">{
                where = append(where, squirrel.LtOrEq{"occurred_on": *listOptions.FilterOccurredOnTo})
        }</span>

        <span class="cov0" title="0">return where</span>
}

func (r *Repository) buildSortForList(listOptions *usecase.TransactionListOptions) []string <span class="cov0" title="0">{
        if listOptions == nil || len(listOptions.Sort) == 0 </span><span class="cov0" title="0">{
                return []string{"created_at DESC"}
        }</span>

        <span class="cov0" title="0">sort := make([]string, 0, len(listOptions.Sort))

        for _, sortOption := range listOptions.Sort </span><span class="cov0" title="0">{
                switch sortOption.Field </span>{
                case usecase.TransactionListOptionsSortFieldOccurredOn:<span class="cov0" title="0">
                        if sortOption.IsDesc </span><span class="cov0" title="0">{
                                sort = append(sort, "occurred_on DESC")
                        }</span> else<span class="cov0" title="0"> {
                                sort = append(sort, "occurred_on ASC")
                        }</span>
                case usecase.TransactionListOptionsSortFieldCreatedAt:<span class="cov0" title="0">
                        if sortOption.IsDesc </span><span class="cov0" title="0">{
                                sort = append(sort, "created_at DESC")
                        }</span> else<span class="cov0" title="0"> {
                                sort = append(sort, "created_at ASC")
                        }</span>
                }
        }

        <span class="cov0" title="0">return sort</span>
}

func (r *Repository) FindList(
        ctx context.Context,
        listOptions *usecase.TransactionListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]*entity.Transaction, error) <span class="cov0" title="0">{
        const op = "FindList"

        withDeleted := queryParams != nil &amp;&amp; queryParams.WithDeleted

        where := r.buildWhereForList(listOptions, withDeleted)

        fields := pg.TransactionTableFields

        q := r.qb.Select(fields...).From(pg.TransactionTable).Where(where)

        sort := r.buildSortForList(listOptions)
        if len(sort) &gt; 0 </span><span class="cov0" title="0">{
                q = q.OrderBy(sort...)
        }</span>

        <span class="cov0" title="0">if queryParams != nil </span><span class="cov0" title="0">{
                if queryParams.ForUpdateSkipLocked </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE SKIP LOCKED")
                }</span> else<span class="cov0" title="0"> if queryParams.ForUpdate </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE")
                }</span> else<span class="cov0" title="0"> if queryParams.ForShare </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR SHARE")
                }</span>

                <span class="cov0" title="0">if queryParams.Limit &gt; 0 </span><span class="cov0" title="0">{
                        q = q.Limit(queryParams.Limit)
                }</span>

                <span class="cov0" title="0">if queryParams.Offset &gt; 0 </span><span class="cov0" title="0">{
                        q = q.Offset(queryParams.Offset)
                }</span>
        }

        <span class="cov0" title="0">query, args, err := q.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                return nil, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">rows, err := r.pgClient.GetConn(ctx).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "query row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        dbData := []*pg.TransactionDBModel{}

        if err := pgxscan.ScanAll(&amp;dbData, rows); err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "scan row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">result := make([]*entity.Transaction, 0, len(dbData))
        for _, dbItem := range dbData </span><span class="cov0" title="0">{
                result = append(result, dbItem.ToEntity())
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (r *Repository) FindPagedList(
        ctx context.Context,
        listOptions *usecase.TransactionListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]*entity.Transaction, uint64, error) <span class="cov0" title="0">{
        const op = "FindPagedList"

        withDeleted := queryParams != nil &amp;&amp; queryParams.WithDeleted

        where := r.buildWhereForList(listOptions, withDeleted)

        fields := pg.TransactionTableFields

        q := r.qb.Select(fields...).From(pg.TransactionTable).Where(where)

        sort := r.buildSortForList(listOptions)
        if len(sort) &gt; 0 </span><span class="cov0" title="0">{
                q = q.OrderBy(sort...)
        }</span>

        <span class="cov0" title="0">if queryParams != nil </span><span class="cov0" title="0">{
                if queryParams.ForUpdateSkipLocked </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE SKIP LOCKED")
                }</span> else<span class="cov0" title="0"> if queryParams.ForUpdate </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE")
                }</span> else<span class="cov0" title="0"> if queryParams.ForShare </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR SHARE")
                }</span>

                <span class="cov0" title="0">if queryParams.Limit &gt; 0 </span><span class="cov0" title="0">{
                        q = q.Limit(queryParams.Limit)
                }</span>

                <span class="cov0" title="0">if queryParams.Offset &gt; 0 </span><span class="cov0" title="0">{
                        q = q.Offset(queryParams.Offset)
                }</span>
        }

        <span class="cov0" title="0">query, args, err := q.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                return nil, 0, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">totalQ := r.qb.Select("COUNT(*) as total").From(pg.TransactionTable).Where(where)
        totalQuery, totalArgs, err := totalQ.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query for total", slog.Any("error", err))
                return nil, 0, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">var total uint64
        var result []*entity.Transaction

        err = r.pgClient.Do(ctx, func(ctx context.Context) error </span><span class="cov0" title="0">{
                rows, err := r.pgClient.GetConn(ctx).Query(ctx, query, args...)
                if err != nil </span><span class="cov0" title="0">{
                        convErr, ok := appErrors.ConvertPgxToAppErr(err)
                        if !ok </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(loghandler.WithSource(ctx), "query row error", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
                }

                <span class="cov0" title="0">defer rows.Close()

                dbData := []*pg.TransactionDBModel{}

                if err := pgxscan.ScanAll(&amp;dbData, rows); err != nil </span><span class="cov0" title="0">{
                        convErr, ok := appErrors.ConvertPgxToAppErr(err)
                        if !ok </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(loghandler.WithSource(ctx), "scan row error", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
                }

                <span class="cov0" title="0">result = make([]*entity.Transaction, 0, len(dbData))
                for _, dbItem := range dbData </span><span class="cov0" title="0">{
                        result = append(result, dbItem.ToEntity())
                }</span>

                <span class="cov0" title="0">row := r.pgClient.GetConn(ctx).QueryRow(ctx, totalQuery, totalArgs...)
                if err := row.Scan(&amp;total); err != nil </span><span class="cov0" title="0">{
                        convErr, ok := appErrors.ConvertPgxToAppErr(err)
                        if !ok </span><span class="cov0" title="0">{
                                r.logger.ErrorContext(loghandler.WithSource(ctx), "scan total error", slog.Any("error", err))
                        }</span>
                        <span class="cov0" title="0">return appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return result, total, nil</span>
}

func (r *Repository) FindOneByID(
        ctx context.Context,
        id uuid.UUID,
        queryParams *uctypes.QueryGetOneParams,
) (*entity.Transaction, error) <span class="cov0" title="0">{
        const op = "FindOneByID"

        withDeleted := queryParams != nil &amp;&amp; queryParams.WithDeleted

        where := squirrel.And{
                squirrel.Eq{"id": id},
        }

        if !withDeleted </span><span class="cov0" title="0">{
                where = append(where, squirrel.Expr("deleted_at IS NULL"))
        }</span>

        <span class="cov0" title="0">q := r.qb.Select(pg.TransactionTableFields...).From(pg.TransactionTable).Where(where)

        if queryParams != nil </span><span class="cov0" title="0">{
                if queryParams.ForUpdateSkipLocked </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE SKIP LOCKED")
                }</span> else<span class="cov0" title="0"> if queryParams.ForUpdate </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR UPDATE")
                }</span> else<span class="cov0" title="0"> if queryParams.ForShare </span><span class="cov0" title="0">{
                        q = q.Suffix("FOR SHARE")
                }</span>
        }

        <span class="cov0" title="0">query, args, err := q.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                return nil, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">rows, err := r.pgClient.GetConn(ctx).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "query row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">defer rows.Close()

        dbData := &amp;pg.TransactionDBModel{}

        if err := pgxscan.ScanOne(dbData, rows); err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "scan row error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">return dbData.ToEntity(), nil</span>
}

func (r *Repository) CountReportItems(
        ctx context.Context,
        queryFilter usecase.CountReportItemsQueryFilter,
) ([]*entity.AccountTransactionReportItem, error) <span class="cov0" title="0">{
        const op = "CountReportItems"

        type reportRow struct {
                AccountID    uuid.UUID        `db:"account_id"`
                Sum          decimal.Decimal  `db:"sum"`
                Period       civil.Date       `db:"period"`
                CategoryID   uint64           `db:"category_id"`
                BudgetID     *uuid.UUID       `db:"budget_id"`
                BudgetAmount *decimal.Decimal `db:"budget_amount"`
        }

        where := squirrel.And{
                squirrel.Eq{"account_id": queryFilter.AccountID},
                squirrel.Expr("deleted_at IS NULL"),
        }

        if queryFilter.DateFrom != nil </span><span class="cov0" title="0">{
                where = append(where, squirrel.GtOrEq{"occurred_on": *queryFilter.DateFrom})
        }</span>
        <span class="cov0" title="0">if queryFilter.DateTo != nil </span><span class="cov0" title="0">{
                where = append(where, squirrel.LtOrEq{"occurred_on": *queryFilter.DateTo})
        }</span>
        <span class="cov0" title="0">if queryFilter.CategoryID != nil </span><span class="cov0" title="0">{
                where = append(where, squirrel.Eq{"category_id": *queryFilter.CategoryID})
        }</span>
        <span class="cov0" title="0">if len(queryFilter.ExcludeIDs) &gt; 0 </span><span class="cov0" title="0">{
                where = append(where, squirrel.NotEq{"id": queryFilter.ExcludeIDs})
        }</span>

        <span class="cov0" title="0">periodExpr := "date_trunc('month', occurred_on::timestamp)::date AS period"
        sumExpr := "SUM(amount) AS sum"

        inner := r.qb.
                Select(
                        "account_id",
                        periodExpr,
                        "category_id",
                        sumExpr,
                ).
                From(pg.TransactionTable).
                Where(where).
                GroupBy("account_id", "period", "category_id")

        outer := r.qb.
                Select(
                        "t.account_id",
                        "t.period",
                        "t.category_id",
                        "t.sum",
                        "b.id AS budget_id",
                        "b.amount AS budget_amount",
                ).
                FromSelect(inner, "t").
                LeftJoin(`budget b
                        ON b.account_id = t.account_id
                        AND b.period = t.period
                        AND b.category_id = t.category_id
                        AND b.deleted_at IS NULL`,
                ).
                OrderBy("t.period ASC", "t.category_id ASC")

        query, args, err := outer.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.ErrorContext(loghandler.WithSource(ctx), "building query", slog.Any("error", err))
                return nil, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">rows, err := r.pgClient.GetConn(ctx).Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "query error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }
        <span class="cov0" title="0">defer rows.Close()

        var dbData []*reportRow
        if err := pgxscan.ScanAll(&amp;dbData, rows); err != nil </span><span class="cov0" title="0">{
                convErr, ok := appErrors.ConvertPgxToAppErr(err)
                if !ok </span><span class="cov0" title="0">{
                        r.logger.ErrorContext(loghandler.WithSource(ctx), "scan error", slog.Any("error", err))
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(convErr, "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">result := make([]*entity.AccountTransactionReportItem, 0, len(dbData))
        for _, it := range dbData </span><span class="cov0" title="0">{
                result = append(result, &amp;entity.AccountTransactionReportItem{
                        Sum:          &amp;it.Sum,
                        Period:       it.Period,
                        CategoryID:   it.CategoryID,
                        BudgetID:     it.BudgetID,
                        BudgetAmount: it.BudgetAmount,
                })
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package transaction

import (
        "log/slog"

        "github.com/Masterminds/squirrel"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/db"
)

type Repository struct {
        pkg      string
        logger   *slog.Logger
        pgClient db.MasterClient
        qb       squirrel.StatementBuilderType
}

func NewRepository(logger *slog.Logger, pgClient db.MasterClient) *Repository <span class="cov0" title="0">{
        return &amp;Repository{
                pkg:      "Budget.repository.Transaction",
                logger:   logger,
                pgClient: pgClient,
                qb:       squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar),
        }
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package redis

import (
        "time"

        "cloud.google.com/go/civil"
        "github.com/google/uuid"
        "github.com/govalues/decimal"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
)

type BudgetPagedList struct {
        Items []*BudgetModel `json:"items"`
        Total uint64         `json:"total"`
}

type BudgetModel struct {
        ID         uuid.UUID       `json:"id"`
        AccountID  uuid.UUID       `json:"accountID"`
        Period     civil.Date      `json:"period"`
        CategoryID uint64          `json:"categoryID"`
        Amount     decimal.Decimal `json:"amount"`

        CreatedAt time.Time  `json:"createdAt"`
        UpdatedAt time.Time  `json:"updatedAt"`
        DeletedAt *time.Time `json:"deletedAt"`
}

func (db *BudgetModel) ToEntity() *entity.Budget <span class="cov0" title="0">{
        if db == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;entity.Budget{
                ID:         db.ID,
                AccountID:  db.AccountID,
                Period:     db.Period,
                CategoryID: db.CategoryID,
                Amount:     db.Amount,
                CreatedAt:  db.CreatedAt,
                UpdatedAt:  db.UpdatedAt,
                DeletedAt:  db.DeletedAt,
        }</span>
}

func MapBudgetEntityToDBModel(e *entity.Budget) *BudgetModel <span class="cov0" title="0">{
        if e == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;BudgetModel{
                ID:         e.ID,
                AccountID:  e.AccountID,
                Period:     e.Period,
                CategoryID: e.CategoryID,
                Amount:     e.Amount,
                CreatedAt:  e.CreatedAt,
                UpdatedAt:  e.UpdatedAt,
                DeletedAt:  e.DeletedAt,
        }</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package budget

import (
        "context"
        "encoding/json"
        "time"

        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        redisRepo "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/redis"
)

func (r *Repository) SaveBudgetsList(ctx context.Context, key string, items []*entity.Budget, ttl *time.Duration) error <span class="cov0" title="0">{
        const op = "SaveBudgetsList"

        dbItems := make([]*redisRepo.BudgetModel, 0, len(items))
        for _, it := range items </span><span class="cov0" title="0">{
                dbItems = append(dbItems, redisRepo.MapBudgetEntityToDBModel(it))
        }</span>

        <span class="cov0" title="0">payload, err := json.Marshal(dbItems)
        if err != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(err, "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">var payloadTTL time.Duration
        if ttl != nil </span><span class="cov0" title="0">{
                payloadTTL = *ttl
        }</span>

        <span class="cov0" title="0">cmd := r.redisClient.Set(ctx, key, payload, payloadTTL)
        if cmd.Err() != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(appErrors.ErrInternal.WithWrap(cmd.Err()), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *Repository) SaveBudgetsPagedList(
        ctx context.Context,
        key string,
        items []*entity.Budget,
        total uint64,
        ttl *time.Duration,
) error <span class="cov0" title="0">{
        const op = "SaveBudgetsPagedList"

        dbPayload := &amp;redisRepo.BudgetPagedList{
                Items: make([]*redisRepo.BudgetModel, 0, len(items)),
                Total: total,
        }
        for _, it := range items </span><span class="cov0" title="0">{
                dbPayload.Items = append(dbPayload.Items, redisRepo.MapBudgetEntityToDBModel(it))
        }</span>

        <span class="cov0" title="0">payload, err := json.Marshal(dbPayload)
        if err != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(err, "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">var payloadTTL time.Duration
        if ttl != nil </span><span class="cov0" title="0">{
                payloadTTL = *ttl
        }</span>

        <span class="cov0" title="0">cmd := r.redisClient.Set(ctx, key, payload, payloadTTL)
        if cmd.Err() != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(appErrors.ErrInternal.WithWrap(cmd.Err()), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *Repository) SaveBudget(ctx context.Context, key string, item *entity.Budget, ttl *time.Duration) error <span class="cov0" title="0">{
        const op = "SaveBudget"

        dbItem := redisRepo.MapBudgetEntityToDBModel(item)

        payload, err := json.Marshal(dbItem)
        if err != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(err, "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">var payloadTTL time.Duration
        if ttl != nil </span><span class="cov0" title="0">{
                payloadTTL = *ttl
        }</span>

        <span class="cov0" title="0">cmd := r.redisClient.Set(ctx, key, payload, payloadTTL)
        if cmd.Err() != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(appErrors.ErrInternal.WithWrap(cmd.Err()), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *Repository) ClearForPrefixes(ctx context.Context, prefixes ...string) error <span class="cov0" title="0">{
        const op = "ClearForPrefixes"

        if len(prefixes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">const scanCount int64 = 1000
        const delBatch = 1000

        for _, prefix := range prefixes </span><span class="cov0" title="0">{
                if prefix == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">pattern := prefix + "*"
                var cursor uint64

                keysBatch := make([]string, 0, delBatch)

                for </span><span class="cov0" title="0">{
                        if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                                return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s prefix=%s", r.pkg, op, pattern)
                        }</span>

                        <span class="cov0" title="0">keys, nextCursor, err := r.redisClient.Scan(ctx, cursor, pattern, scanCount).Result()
                        if err != nil </span><span class="cov0" title="0">{
                                return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s prefix=%s", r.pkg, op, pattern)
                        }</span>

                        <span class="cov0" title="0">for _, k := range keys </span><span class="cov0" title="0">{
                                keysBatch = append(keysBatch, k)
                                if len(keysBatch) &gt;= delBatch </span><span class="cov0" title="0">{
                                        if err := r.redisClient.Unlink(ctx, keysBatch...).Err(); err != nil </span><span class="cov0" title="0">{
                                                return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s prefix=%s", r.pkg, op, pattern)
                                        }</span>
                                        <span class="cov0" title="0">keysBatch = keysBatch[:0]</span>
                                }
                        }

                        <span class="cov0" title="0">cursor = nextCursor
                        if cursor == 0 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }

                <span class="cov0" title="0">if len(keysBatch) &gt; 0 </span><span class="cov0" title="0">{
                        if err := r.redisClient.Unlink(ctx, keysBatch...).Err(); err != nil </span><span class="cov0" title="0">{
                                return appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s prefix=%s", r.pkg, op, pattern)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package budget

import (
        "context"
        "encoding/json"

        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        redisRepo "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/redis"
        "github.com/redis/go-redis/v9"
)

func (r *Repository) GetBudgetsList(ctx context.Context, key string) ([]*entity.Budget, error) <span class="cov0" title="0">{
        const op = "GetBudgetsList"

        payload, err := r.redisClient.Get(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                if err == redis.Nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(appErrors.ErrNotFound, "%s.%s", r.pkg, op)
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">dbItems := make([]*redisRepo.BudgetModel, 0)

        err = json.Unmarshal([]byte(payload), &amp;dbItems)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">items := make([]*entity.Budget, 0, len(dbItems))
        for _, it := range dbItems </span><span class="cov0" title="0">{
                items = append(items, it.ToEntity())
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

func (r *Repository) GetBudgetsPagedList(ctx context.Context, key string) ([]*entity.Budget, uint64, error) <span class="cov0" title="0">{
        const op = "GetBudgetsPagedList"

        payload, err := r.redisClient.Get(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                if err == redis.Nil </span><span class="cov0" title="0">{
                        return nil, 0, appErrors.Chainf(appErrors.ErrNotFound, "%s.%s", r.pkg, op)
                }</span>
                <span class="cov0" title="0">return nil, 0, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">dbPayload := &amp;redisRepo.BudgetPagedList{
                Items: make([]*redisRepo.BudgetModel, 0),
        }

        err = json.Unmarshal([]byte(payload), &amp;dbPayload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">items := make([]*entity.Budget, 0, len(dbPayload.Items))
        for _, it := range dbPayload.Items </span><span class="cov0" title="0">{
                items = append(items, it.ToEntity())
        }</span>

        <span class="cov0" title="0">return items, dbPayload.Total, nil</span>
}

func (r *Repository) GetBudget(ctx context.Context, key string) (*entity.Budget, error) <span class="cov0" title="0">{
        const op = "GetBudget"

        payload, err := r.redisClient.Get(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                if err == redis.Nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(appErrors.ErrNotFound, "%s.%s", r.pkg, op)
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">dbItem := &amp;redisRepo.BudgetModel{}

        err = json.Unmarshal([]byte(payload), dbItem)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">return dbItem.ToEntity(), nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package budget

import (
        "log/slog"

        "github.com/redis/go-redis/v9"
)

type Repository struct {
        pkg         string
        logger      *slog.Logger
        redisClient *redis.Client
}

func NewRepository(logger *slog.Logger, redisClient *redis.Client) *Repository <span class="cov0" title="0">{
        return &amp;Repository{
                pkg:         "Budget.repository.RedisBudget",
                logger:      logger,
                redisClient: redisClient,
        }
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package redis

import (
        "cloud.google.com/go/civil"
        "github.com/google/uuid"
        "github.com/govalues/decimal"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
)

type ReportItemModelItem struct {
        Sum          *decimal.Decimal `json:"sum"`
        Period       civil.Date       `json:"period"`
        CategoryID   uint64           `json:"categoryID"`
        BudgetID     *uuid.UUID       `json:"budgetID"`
        BudgetAmount *decimal.Decimal `json:"budgetAmount"`
}

type ReportItemModel struct {
        AccountID uuid.UUID              `json:"accountID"`
        DateFrom  civil.Date             `json:"dateFrom"`
        DateTo    civil.Date             `json:"dateTo"`
        Items     []*ReportItemModelItem `json:"items"`
}

func (db *ReportItemModel) ToEntity() *entity.ReportItem <span class="cov0" title="0">{
        if db == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">items := make([]*entity.AccountTransactionReportItem, 0, len(db.Items))
        for _, it := range db.Items </span><span class="cov0" title="0">{
                if it == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">items = append(items, &amp;entity.AccountTransactionReportItem{
                        Sum:          it.Sum,
                        Period:       it.Period,
                        CategoryID:   it.CategoryID,
                        BudgetID:     it.BudgetID,
                        BudgetAmount: it.BudgetAmount,
                })</span>
        }

        <span class="cov0" title="0">return &amp;entity.ReportItem{
                AccountID: db.AccountID,
                DateFrom:  db.DateFrom,
                DateTo:    db.DateTo,
                Items:     items,
        }</span>
}

func MapTransactionEntityToDBModel(e *entity.ReportItem) *ReportItemModel <span class="cov0" title="0">{
        if e == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">items := make([]*ReportItemModelItem, 0, len(e.Items))
        for _, it := range e.Items </span><span class="cov0" title="0">{
                if it == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">items = append(items, &amp;ReportItemModelItem{
                        Sum:          it.Sum,
                        Period:       it.Period,
                        CategoryID:   it.CategoryID,
                        BudgetID:     it.BudgetID,
                        BudgetAmount: it.BudgetAmount,
                })</span>
        }

        <span class="cov0" title="0">return &amp;ReportItemModel{
                AccountID: e.AccountID,
                DateFrom:  e.DateFrom,
                DateTo:    e.DateTo,
                Items:     items,
        }</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package transaction

import (
        "context"
        "encoding/json"
        "time"

        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        redisRepo "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/redis"
)

func (r *Repository) SaveReports(ctx context.Context, key string, items []*entity.ReportItem, ttl *time.Duration) error <span class="cov0" title="0">{
        const op = "SaveReports"

        dbItems := make([]*redisRepo.ReportItemModel, 0, len(items))
        for _, it := range items </span><span class="cov0" title="0">{
                dbItems = append(dbItems, redisRepo.MapTransactionEntityToDBModel(it))
        }</span>

        <span class="cov0" title="0">payload, err := json.Marshal(dbItems)
        if err != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(err, "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">var payloadTTL time.Duration
        if ttl != nil </span><span class="cov0" title="0">{
                payloadTTL = *ttl
        }</span>

        <span class="cov0" title="0">cmd := r.redisClient.Set(ctx, key, payload, payloadTTL)
        if cmd.Err() != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(appErrors.ErrInternal.WithWrap(cmd.Err()), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package transaction

import (
        "context"
        "encoding/json"

        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        redisRepo "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/repository/redis"
        "github.com/redis/go-redis/v9"
)

func (r *Repository) GetReports(ctx context.Context, key string) ([]*entity.ReportItem, error) <span class="cov0" title="0">{
        const op = "GetReports"

        payload, err := r.redisClient.Get(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                if err == redis.Nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(appErrors.ErrNotFound, "%s.%s", r.pkg, op)
                }</span>
                <span class="cov0" title="0">return nil, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)</span>
        }

        <span class="cov0" title="0">dbItems := make([]*redisRepo.ReportItemModel, 0)

        err = json.Unmarshal([]byte(payload), &amp;dbItems)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrInternal.WithWrap(err), "%s.%s", r.pkg, op)
        }</span>

        <span class="cov0" title="0">items := make([]*entity.ReportItem, 0, len(dbItems))
        for _, it := range dbItems </span><span class="cov0" title="0">{
                items = append(items, it.ToEntity())
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package transaction

import (
        "log/slog"

        "github.com/redis/go-redis/v9"
)

type Repository struct {
        pkg         string
        logger      *slog.Logger
        redisClient *redis.Client
}

func NewRepository(logger *slog.Logger, redisClient *redis.Client) *Repository <span class="cov0" title="0">{
        return &amp;Repository{
                pkg:         "Budget.repository.RedisTransaction",
                logger:      logger,
                redisClient: redisClient,
        }
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package budget

import (
        "context"
        "errors"
        "log/slog"
        "time"

        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/loghandler"
        "github.com/m11ano/budget_planner/backend/ledger/pkg/pgclient"
        "github.com/samber/lo"
)

func (uc *UsecaseImpl) CreateBudgetByDTO(
        ctx context.Context,
        in usecase.CreateBudgetDataInput,
) (*usecase.BudgetDTO, error) <span class="cov8" title="1">{
        const op = "CreateBudgetByDTO"

        if auth.IsNeedToCheckRights(ctx) </span><span class="cov0" title="0">{
                authData := auth.GetAuthData(ctx)
                if authData == nil || authData.AccountID != in.AccountID </span><span class="cov0" title="0">{
                        return nil, appErrors.ErrForbidden
                }</span>
        }

        <span class="cov8" title="1">budget, err := entity.NewBudget(
                in.AccountID,
                in.Amount,
                in.Period,
                in.CategoryID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="1">err = uc.dbMasterClient.DoWithIsoLvl(ctx, pgclient.Serializable, func(ctx context.Context) error </span><span class="cov8" title="1">{
                _, err := uc.categoryRepo.FindOneByID(ctx, budget.CategoryID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, appErrors.ErrNotFound) </span><span class="cov0" title="0">{
                                return appErrors.Chainf(appErrors.ErrBadRequest.WithHints("category not found"), "%s.%s", uc.pkg, op)
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov8" title="1">check, err := uc.budgetRepo.FindList(ctx, &amp;usecase.BudgetListOptions{
                        FilterAccountID:  &amp;budget.AccountID,
                        FilterPeriod:     &amp;budget.Period,
                        FilterCategoryID: &amp;budget.CategoryID,
                }, &amp;uctypes.QueryGetListParams{
                        Limit: 1,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if len(check) &gt; 0 </span><span class="cov0" title="0">{
                        return appErrors.Chainf(
                                appErrors.ErrBadRequest.WithHints("budget for period and category already exists"),
                                "%s.%s", uc.pkg, op)
                }</span>

                <span class="cov8" title="1">err = uc.budgetRepo.Create(ctx, budget)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="1">budgetDTO, err := uc.entitiesToDTO(ctx, []*entity.Budget{budget})
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="1">if len(budgetDTO) == 0 </span><span class="cov0" title="0">{
                uc.logger.ErrorContext(loghandler.WithSource(ctx), "unpredicted empty budget dto")
                return nil, appErrors.Chainf(appErrors.ErrInternal, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="1">base := context.WithoutCancel(ctx)
        clrCtx, cancel := context.WithTimeout(base, time.Second*10)
        go func(ctx context.Context) </span><span class="cov8" title="1">{
                defer cancel()
                err := uc.budgetCacheRepo.ClearForPrefixes(ctx, "Budget::FindList::AccountID:"+budget.AccountID.String())
                if err != nil </span><span class="cov0" title="0">{
                        uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis clear err", slog.Any("error", err))
                }</span>
        }(clrCtx)

        <span class="cov8" title="1">return budgetDTO[0], nil</span>
}

func (uc *UsecaseImpl) PatchBudgetByDTO(
        ctx context.Context,
        id uuid.UUID,
        in usecase.PatchBudgetDataInput,
        skipVersionCheck bool,
) error <span class="cov8" title="1">{
        const op = "PatchBudgetByDTO"

        var accountID uuid.UUID

        err := uc.dbMasterClient.DoWithIsoLvl(ctx, pgclient.Serializable, func(ctx context.Context) error </span><span class="cov8" title="1">{
                budget, err := uc.budgetRepo.FindOneByID(ctx, id, &amp;uctypes.QueryGetOneParams{
                        ForUpdate: true,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">accountID = budget.AccountID

                if auth.IsNeedToCheckRights(ctx) </span><span class="cov0" title="0">{
                        authData := auth.GetAuthData(ctx)
                        if authData == nil || authData.AccountID != budget.AccountID </span><span class="cov0" title="0">{
                                return appErrors.ErrForbidden
                        }</span>
                }

                <span class="cov8" title="1">if !skipVersionCheck &amp;&amp; budget.Version() != in.Version </span><span class="cov0" title="0">{
                        return appErrors.ErrVersionConflict.
                                WithDetail("last_version", false, budget.Version()).
                                WithDetail("last_updated_at", false, budget.UpdatedAt)
                }</span>

                <span class="cov8" title="1">if in.Amount != nil </span><span class="cov8" title="1">{
                        err = budget.SetAmount(*in.Amount)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">checkFilter := &amp;usecase.BudgetListOptions{
                        FilterAccountID:  &amp;budget.AccountID,
                        FilterPeriod:     &amp;budget.Period,
                        FilterCategoryID: &amp;budget.CategoryID,
                }
                needCheck := false

                if in.CategoryID != nil &amp;&amp; *in.CategoryID != budget.CategoryID </span><span class="cov0" title="0">{
                        budget.CategoryID = *in.CategoryID

                        needCheck = true
                        checkFilter.FilterCategoryID = &amp;budget.CategoryID
                }</span>

                <span class="cov8" title="1">if in.Period != nil &amp;&amp;
                        (in.Period.Day != budget.Period.Day ||
                                in.Period.Month != budget.Period.Month ||
                                in.Period.Year != budget.Period.Year) </span><span class="cov0" title="0">{

                        err := budget.SetPeriod(*in.Period)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">needCheck = true
                        checkFilter.FilterPeriod = &amp;budget.Period</span>
                }

                <span class="cov8" title="1">if needCheck </span><span class="cov0" title="0">{
                        check, err := uc.budgetRepo.FindList(ctx, checkFilter, &amp;uctypes.QueryGetListParams{
                                Limit: 1,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if len(check) &gt; 0 </span><span class="cov0" title="0">{
                                return appErrors.Chainf(
                                        appErrors.ErrBadRequest.WithHints("budget for period and category already exists"),
                                        "%s.%s", uc.pkg, op)
                        }</span>
                }

                <span class="cov8" title="1">err = uc.budgetRepo.Update(ctx, budget)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="1">base := context.WithoutCancel(ctx)
        clrCtx, cancel := context.WithTimeout(base, time.Second*10)
        go func(ctx context.Context) </span><span class="cov8" title="1">{
                defer cancel()
                err := uc.budgetCacheRepo.ClearForPrefixes(
                        ctx,
                        buildKeyForFindOneByID(id),
                        "Budget::FindList::AccountID:"+accountID.String(),
                )
                if err != nil </span><span class="cov0" title="0">{
                        uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis clear err", slog.Any("error", err))
                }</span>
        }(clrCtx)

        <span class="cov8" title="1">return nil</span>
}

func (uc *UsecaseImpl) DeleteBudgetByID(ctx context.Context, id uuid.UUID) error <span class="cov8" title="1">{
        const op = "DeleteBudgetByID"

        var accountID uuid.UUID

        err := uc.dbMasterClient.Do(ctx, func(ctx context.Context) error </span><span class="cov8" title="1">{
                budget, err := uc.budgetRepo.FindOneByID(ctx, id, &amp;uctypes.QueryGetOneParams{
                        ForUpdate: true,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">accountID = budget.AccountID

                if auth.IsNeedToCheckRights(ctx) </span><span class="cov0" title="0">{
                        authData := auth.GetAuthData(ctx)
                        if authData == nil || authData.AccountID != budget.AccountID </span><span class="cov0" title="0">{
                                return appErrors.ErrForbidden
                        }</span>
                }

                <span class="cov8" title="1">budget.DeletedAt = lo.ToPtr(time.Now())

                err = uc.budgetRepo.Update(ctx, budget)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="1">base := context.WithoutCancel(ctx)
        clrCtx, cancel := context.WithTimeout(base, time.Second*10)
        go func(ctx context.Context) </span><span class="cov8" title="1">{
                defer cancel()
                err := uc.budgetCacheRepo.ClearForPrefixes(ctx, "Budget::FindList::AccountID:"+accountID.String())
                if err != nil </span><span class="cov0" title="0">{
                        uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis clear err", slog.Any("error", err))
                }</span>
        }(clrCtx)

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package budget

import (
        "context"
        "fmt"
        "strings"

        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
)

func (uc *UsecaseImpl) entitiesToDTO(
        _ context.Context,
        items []*entity.Budget,
) ([]*usecase.BudgetDTO, error) <span class="cov9" title="10">{
        out := make([]*usecase.BudgetDTO, 0, len(items))

        for _, item := range items </span><span class="cov10" title="13">{
                resItem := &amp;usecase.BudgetDTO{
                        Budget: item,
                }

                out = append(out, resItem)
        }</span>

        <span class="cov9" title="10">return out, nil</span>
}

func buildKeyForFindOneByID(id uuid.UUID) string <span class="cov8" title="9">{
        return fmt.Sprintf("Budget::FindOneByID::%s", id.String())
}</span>

func buildKeyForFindList(
        listOptions *usecase.BudgetListOptions,
        queryParams *uctypes.QueryGetListParams,
) string <span class="cov9" title="12">{
        var strBuilder strings.Builder

        strBuilder.WriteString("Budget::FindList")

        if listOptions.FilterAccountID != nil </span><span class="cov9" title="12">{
                strBuilder.WriteString("::AccountID:")
                strBuilder.WriteString(listOptions.FilterAccountID.String())
        }</span>

        <span class="cov9" title="12">if listOptions.FilterPeriod != nil </span><span class="cov0" title="0">{
                strBuilder.WriteString("::Period:")
                strBuilder.WriteString(listOptions.FilterPeriod.String())
        }</span>

        <span class="cov9" title="12">if listOptions.FilterPeriodFrom != nil </span><span class="cov0" title="0">{
                strBuilder.WriteString("::PeriodFrom:")
                strBuilder.WriteString(listOptions.FilterPeriodFrom.String())
        }</span>

        <span class="cov9" title="12">if listOptions.FilterPeriodTo != nil </span><span class="cov0" title="0">{
                strBuilder.WriteString("::PeriodTo:")
                strBuilder.WriteString(listOptions.FilterPeriodTo.String())
        }</span>

        <span class="cov9" title="12">if listOptions.FilterCategoryID != nil </span><span class="cov0" title="0">{
                strBuilder.WriteString("::CategoryID:")
                strBuilder.WriteString(fmt.Sprintf("%d", *listOptions.FilterCategoryID))
        }</span>

        <span class="cov9" title="12">if listOptions.Sort != nil </span><span class="cov0" title="0">{
                strBuilder.WriteString("::Sort:")
                for _, sort := range listOptions.Sort </span><span class="cov0" title="0">{
                        strBuilder.WriteString(fmt.Sprintf("%s:%t", sort.Field, sort.IsDesc))
                }</span>
        }

        <span class="cov9" title="12">if queryParams != nil </span><span class="cov9" title="12">{
                strBuilder.WriteString("::Offset:")
                strBuilder.WriteString(fmt.Sprintf("%d", queryParams.Offset))
                strBuilder.WriteString("::Limit:")
                strBuilder.WriteString(fmt.Sprintf("%d", queryParams.Limit))
        }</span>

        <span class="cov9" title="12">return strBuilder.String()</span>
}

func buildKeyForFindPagedList(
        listOptions *usecase.BudgetListOptions,
        queryParams *uctypes.QueryGetListParams,
) string <span class="cov7" title="6">{
        return fmt.Sprintf("%s::Paged", buildKeyForFindList(listOptions, queryParams))
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">package budget

import (
        "log/slog"

        "github.com/m11ano/budget_planner/backend/ledger/internal/app/config"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/db"
        "golang.org/x/sync/singleflight"
)

type UsecaseImpl struct {
        pkg             string
        logger          *slog.Logger
        cfg             config.Config
        dbMasterClient  db.MasterClient
        sfGroup         singleflight.Group
        budgetRepo      usecase.BudgetRepository
        budgetCacheRepo usecase.BudgetCacheRepository
        categoryRepo    usecase.CategoryRepository
}

func NewUsecaseImpl(
        logger *slog.Logger,
        cfg config.Config,
        dbMasterClient db.MasterClient,
        budgetRepo usecase.BudgetRepository,
        budgetCacheRepo usecase.BudgetCacheRepository,
        categoryRepo usecase.CategoryRepository,
) *UsecaseImpl <span class="cov10" title="13">{
        uc := &amp;UsecaseImpl{
                pkg:             "Budget.Usecase.Budget",
                logger:          logger,
                cfg:             cfg,
                dbMasterClient:  dbMasterClient,
                budgetRepo:      budgetRepo,
                budgetCacheRepo: budgetCacheRepo,
                categoryRepo:    categoryRepo,
        }
        return uc
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package budget

import (
        "context"
        "errors"
        "log/slog"
        "time"

        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/loghandler"

        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
)

type FindOneByIDSFResult struct {
        Item     *entity.Budget
        HitCache bool
}

var budgetCacheTTL = time.Second * 30

func (uc *UsecaseImpl) FindOneByID(
        ctx context.Context,
        id uuid.UUID,
        queryParams *uctypes.QueryGetOneParams,
) (*usecase.BudgetDTO, bool, error) <span class="cov10" title="4">{
        const op = "FindOneByID"

        key := buildKeyForFindOneByID(id)

        result, err, _ := uc.sfGroup.Do(key, func() (any, error) </span><span class="cov10" title="4">{
                if queryParams == nil || !queryParams.SkipCache </span><span class="cov5" title="2">{
                        cacheItem, err := uc.budgetCacheRepo.GetBudget(ctx, key)
                        if err == nil </span><span class="cov1" title="1">{
                                uc.logger.InfoContext(ctx, "Budget::FindOneByID cache hit", slog.Any("key", key))

                                return FindOneByIDSFResult{
                                        Item:     cacheItem,
                                        HitCache: true,
                                }, nil
                        }</span> else<span class="cov1" title="1"> if !errors.Is(err, appErrors.ErrNotFound) </span><span class="cov0" title="0">{
                                uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis get err", slog.Any("error", err))
                        }</span>

                        <span class="cov1" title="1">uc.logger.InfoContext(ctx, "Budget::FindOneByID cache miss", slog.Any("key", key))</span>
                }

                <span class="cov8" title="3">item, err := uc.budgetRepo.FindOneByID(ctx, id, queryParams)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
                }</span>

                <span class="cov5" title="2">err = uc.budgetCacheRepo.SaveBudget(ctx, key, item, &amp;budgetCacheTTL)
                if err != nil </span><span class="cov0" title="0">{
                        uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis save err", slog.Any("error", err))
                }</span>

                <span class="cov5" title="2">return FindOneByIDSFResult{
                        Item:     item,
                        HitCache: false,
                }, nil</span>
        })
        <span class="cov10" title="4">if err != nil </span><span class="cov1" title="1">{
                return nil, false, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="3">sfResult, ok := result.(FindOneByIDSFResult)
        if !ok </span><span class="cov0" title="0">{
                return nil, false, appErrors.Chainf(appErrors.ErrInternal, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="3">if auth.IsNeedToCheckRights(ctx) </span><span class="cov0" title="0">{
                authData := auth.GetAuthData(ctx)
                if authData == nil || authData.AccountID != sfResult.Item.AccountID </span><span class="cov0" title="0">{
                        return nil, sfResult.HitCache, appErrors.ErrForbidden
                }</span>
        }

        <span class="cov8" title="3">dto, err := uc.entitiesToDTO(ctx, []*entity.Budget{sfResult.Item})
        if err != nil </span><span class="cov0" title="0">{
                return nil, sfResult.HitCache, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="3">if len(dto) == 0 </span><span class="cov0" title="0">{
                return nil, sfResult.HitCache, appErrors.Chainf(appErrors.ErrInternal, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="3">return dto[0], sfResult.HitCache, nil</span>
}

type FindListSFResult struct {
        Items    []*entity.Budget
        HitCache bool
}

func (uc *UsecaseImpl) FindList(
        ctx context.Context,
        listOptions *usecase.BudgetListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]*usecase.BudgetDTO, bool, error) <span class="cov8" title="3">{
        const op = "FindList"

        key := buildKeyForFindList(listOptions, queryParams)

        result, err, _ := uc.sfGroup.Do(key, func() (any, error) </span><span class="cov8" title="3">{
                if queryParams == nil || !queryParams.SkipCache </span><span class="cov5" title="2">{
                        cacheItems, err := uc.budgetCacheRepo.GetBudgetsList(ctx, key)
                        if err == nil </span><span class="cov1" title="1">{
                                uc.logger.InfoContext(ctx, "Budget::GetBudgetsList cache hit", slog.Any("key", key))

                                return FindListSFResult{
                                        Items:    cacheItems,
                                        HitCache: true,
                                }, nil
                        }</span> else<span class="cov1" title="1"> if !errors.Is(err, appErrors.ErrNotFound) </span><span class="cov0" title="0">{
                                uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis get err", slog.Any("error", err))
                        }</span>

                        <span class="cov1" title="1">uc.logger.InfoContext(ctx, "Budget::GetBudgetsList cache miss", slog.Any("key", key))</span>
                }

                <span class="cov5" title="2">items, err := uc.budgetRepo.FindList(ctx, listOptions, queryParams)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
                }</span>

                <span class="cov5" title="2">err = uc.budgetCacheRepo.SaveBudgetsList(ctx, key, items, &amp;budgetCacheTTL)
                if err != nil </span><span class="cov0" title="0">{
                        uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis save err", slog.Any("error", err))
                }</span>

                <span class="cov5" title="2">return FindListSFResult{
                        Items:    items,
                        HitCache: false,
                }, nil</span>
        })
        <span class="cov8" title="3">if err != nil </span><span class="cov0" title="0">{
                return nil, false, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="3">sfResult, ok := result.(FindListSFResult)
        if !ok </span><span class="cov0" title="0">{
                return nil, false, appErrors.Chainf(appErrors.ErrInternal, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="3">out, err := uc.entitiesToDTO(ctx, sfResult.Items)
        if err != nil </span><span class="cov0" title="0">{
                return nil, sfResult.HitCache, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="3">return out, sfResult.HitCache, nil</span>
}

type FindPagedListSFResult struct {
        Items    []*entity.Budget
        Total    uint64
        HitCache bool
}

func (uc *UsecaseImpl) FindPagedList(
        ctx context.Context,
        listOptions *usecase.BudgetListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]*usecase.BudgetDTO, uint64, bool, error) <span class="cov8" title="3">{
        const op = "FindPagedList"

        key := buildKeyForFindPagedList(listOptions, queryParams)

        result, err, _ := uc.sfGroup.Do(key, func() (any, error) </span><span class="cov8" title="3">{
                if queryParams == nil || !queryParams.SkipCache </span><span class="cov5" title="2">{
                        cacheItems, total, err := uc.budgetCacheRepo.GetBudgetsPagedList(ctx, key)
                        if err == nil </span><span class="cov1" title="1">{
                                uc.logger.InfoContext(ctx, "Budget::GetBudgetsPagedList cache hit", slog.Any("key", key))

                                return FindPagedListSFResult{
                                        Items:    cacheItems,
                                        Total:    total,
                                        HitCache: true,
                                }, nil
                        }</span> else<span class="cov1" title="1"> if !errors.Is(err, appErrors.ErrNotFound) </span><span class="cov0" title="0">{
                                uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis get err", slog.Any("error", err))
                        }</span>

                        <span class="cov1" title="1">uc.logger.InfoContext(ctx, "Budget::GetBudgetsPagedList cache miss", slog.Any("key", key))</span>
                }

                <span class="cov5" title="2">items, total, err := uc.budgetRepo.FindPagedList(ctx, listOptions, queryParams)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
                }</span>

                <span class="cov5" title="2">err = uc.budgetCacheRepo.SaveBudgetsPagedList(ctx, key, items, total, &amp;budgetCacheTTL)
                if err != nil </span><span class="cov0" title="0">{
                        uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis save err", slog.Any("error", err))
                }</span>

                <span class="cov5" title="2">return FindPagedListSFResult{
                        Items:    items,
                        Total:    total,
                        HitCache: false,
                }, nil</span>
        })
        <span class="cov8" title="3">if err != nil </span><span class="cov0" title="0">{
                return nil, 0, false, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="3">sfResult, ok := result.(FindPagedListSFResult)
        if !ok </span><span class="cov0" title="0">{
                return nil, 0, false, appErrors.Chainf(appErrors.ErrInternal, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="3">out, err := uc.entitiesToDTO(ctx, sfResult.Items)
        if err != nil </span><span class="cov0" title="0">{
                return nil, sfResult.Total, sfResult.HitCache, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="3">return out, sfResult.Total, sfResult.HitCache, nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package category

import (
        "context"

        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
)

func (uc *UsecaseImpl) entitiesToDTO(
        _ context.Context,
        items []*entity.Category,
) ([]*usecase.CategoryDTO, error) <span class="cov10" title="3">{
        out := make([]*usecase.CategoryDTO, 0, len(items))

        for _, item := range items </span><span class="cov10" title="3">{
                resItem := &amp;usecase.CategoryDTO{
                        Category: item,
                }

                out = append(out, resItem)
        }</span>

        <span class="cov10" title="3">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package category

import (
        "log/slog"

        "github.com/m11ano/budget_planner/backend/ledger/internal/app/config"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/db"
)

type UsecaseImpl struct {
        pkg            string
        logger         *slog.Logger
        cfg            config.Config
        dbMasterClient db.MasterClient
        categoryRepo   usecase.CategoryRepository
}

func NewUsecaseImpl(
        logger *slog.Logger,
        cfg config.Config,
        dbMasterClient db.MasterClient,
        categoryRepo usecase.CategoryRepository,
) *UsecaseImpl <span class="cov10" title="5">{
        uc := &amp;UsecaseImpl{
                pkg:            "Budget.Usecase.Category",
                logger:         logger,
                cfg:            cfg,
                dbMasterClient: dbMasterClient,
                categoryRepo:   categoryRepo,
        }
        return uc
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">package category

import (
        "context"

        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"

        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
)

func (uc *UsecaseImpl) FindOneByID(
        ctx context.Context,
        id uint64,
        queryParams *uctypes.QueryGetOneParams,
) (*usecase.CategoryDTO, error) <span class="cov6" title="2">{
        const op = "FindOneByID"

        item, err := uc.categoryRepo.FindOneByID(ctx, id, queryParams)
        if err != nil </span><span class="cov1" title="1">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">dto, err := uc.entitiesToDTO(ctx, []*entity.Category{item})
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">if len(dto) == 0 </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrInternal, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return dto[0], nil</span>
}

func (uc *UsecaseImpl) FindList(
        ctx context.Context,
        listOptions *usecase.CategoryListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]*usecase.CategoryDTO, error) <span class="cov10" title="3">{
        const op = "FindList"

        items, err := uc.categoryRepo.FindList(ctx, listOptions, queryParams)
        if err != nil </span><span class="cov1" title="1">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov6" title="2">out, err := uc.entitiesToDTO(ctx, items)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov6" title="2">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package usecase

type Facade struct {
        Category    CategoryUsecase
        Transaction TransactionUsecase
        Budget      BudgetUsecase
}

func NewFacade(
        category CategoryUsecase,
        transactionUC TransactionUsecase,
        budgetUC BudgetUsecase,
) *Facade <span class="cov0" title="0">{
        return &amp;Facade{
                Category:    category,
                Transaction: transactionUC,
                Budget:      budgetUC,
        }
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase.BudgetCacheRepository -o budget_cache_repository.go -n BudgetCacheRepositoryMock -p mocks

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        "time"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
)

// BudgetCacheRepositoryMock implements mm_usecase.BudgetCacheRepository
type BudgetCacheRepositoryMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcClearForPrefixes          func(ctx context.Context, prefixes ...string) (err error)
        funcClearForPrefixesOrigin    string
        inspectFuncClearForPrefixes   func(ctx context.Context, prefixes ...string)
        afterClearForPrefixesCounter  uint64
        beforeClearForPrefixesCounter uint64
        ClearForPrefixesMock          mBudgetCacheRepositoryMockClearForPrefixes

        funcGetBudget          func(ctx context.Context, key string) (item *entity.Budget, err error)
        funcGetBudgetOrigin    string
        inspectFuncGetBudget   func(ctx context.Context, key string)
        afterGetBudgetCounter  uint64
        beforeGetBudgetCounter uint64
        GetBudgetMock          mBudgetCacheRepositoryMockGetBudget

        funcGetBudgetsList          func(ctx context.Context, key string) (items []*entity.Budget, err error)
        funcGetBudgetsListOrigin    string
        inspectFuncGetBudgetsList   func(ctx context.Context, key string)
        afterGetBudgetsListCounter  uint64
        beforeGetBudgetsListCounter uint64
        GetBudgetsListMock          mBudgetCacheRepositoryMockGetBudgetsList

        funcGetBudgetsPagedList          func(ctx context.Context, key string) (items []*entity.Budget, total uint64, err error)
        funcGetBudgetsPagedListOrigin    string
        inspectFuncGetBudgetsPagedList   func(ctx context.Context, key string)
        afterGetBudgetsPagedListCounter  uint64
        beforeGetBudgetsPagedListCounter uint64
        GetBudgetsPagedListMock          mBudgetCacheRepositoryMockGetBudgetsPagedList

        funcSaveBudget          func(ctx context.Context, key string, item *entity.Budget, ttl *time.Duration) (err error)
        funcSaveBudgetOrigin    string
        inspectFuncSaveBudget   func(ctx context.Context, key string, item *entity.Budget, ttl *time.Duration)
        afterSaveBudgetCounter  uint64
        beforeSaveBudgetCounter uint64
        SaveBudgetMock          mBudgetCacheRepositoryMockSaveBudget

        funcSaveBudgetsList          func(ctx context.Context, key string, items []*entity.Budget, ttl *time.Duration) (err error)
        funcSaveBudgetsListOrigin    string
        inspectFuncSaveBudgetsList   func(ctx context.Context, key string, items []*entity.Budget, ttl *time.Duration)
        afterSaveBudgetsListCounter  uint64
        beforeSaveBudgetsListCounter uint64
        SaveBudgetsListMock          mBudgetCacheRepositoryMockSaveBudgetsList

        funcSaveBudgetsPagedList          func(ctx context.Context, key string, items []*entity.Budget, total uint64, ttl *time.Duration) (err error)
        funcSaveBudgetsPagedListOrigin    string
        inspectFuncSaveBudgetsPagedList   func(ctx context.Context, key string, items []*entity.Budget, total uint64, ttl *time.Duration)
        afterSaveBudgetsPagedListCounter  uint64
        beforeSaveBudgetsPagedListCounter uint64
        SaveBudgetsPagedListMock          mBudgetCacheRepositoryMockSaveBudgetsPagedList
}

// NewBudgetCacheRepositoryMock returns a mock for mm_usecase.BudgetCacheRepository
func NewBudgetCacheRepositoryMock(t minimock.Tester) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        m := &amp;BudgetCacheRepositoryMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.ClearForPrefixesMock = mBudgetCacheRepositoryMockClearForPrefixes{mock: m}
        m.ClearForPrefixesMock.callArgs = []*BudgetCacheRepositoryMockClearForPrefixesParams{}

        m.GetBudgetMock = mBudgetCacheRepositoryMockGetBudget{mock: m}
        m.GetBudgetMock.callArgs = []*BudgetCacheRepositoryMockGetBudgetParams{}

        m.GetBudgetsListMock = mBudgetCacheRepositoryMockGetBudgetsList{mock: m}
        m.GetBudgetsListMock.callArgs = []*BudgetCacheRepositoryMockGetBudgetsListParams{}

        m.GetBudgetsPagedListMock = mBudgetCacheRepositoryMockGetBudgetsPagedList{mock: m}
        m.GetBudgetsPagedListMock.callArgs = []*BudgetCacheRepositoryMockGetBudgetsPagedListParams{}

        m.SaveBudgetMock = mBudgetCacheRepositoryMockSaveBudget{mock: m}
        m.SaveBudgetMock.callArgs = []*BudgetCacheRepositoryMockSaveBudgetParams{}

        m.SaveBudgetsListMock = mBudgetCacheRepositoryMockSaveBudgetsList{mock: m}
        m.SaveBudgetsListMock.callArgs = []*BudgetCacheRepositoryMockSaveBudgetsListParams{}

        m.SaveBudgetsPagedListMock = mBudgetCacheRepositoryMockSaveBudgetsPagedList{mock: m}
        m.SaveBudgetsPagedListMock.callArgs = []*BudgetCacheRepositoryMockSaveBudgetsPagedListParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mBudgetCacheRepositoryMockClearForPrefixes struct {
        optional           bool
        mock               *BudgetCacheRepositoryMock
        defaultExpectation *BudgetCacheRepositoryMockClearForPrefixesExpectation
        expectations       []*BudgetCacheRepositoryMockClearForPrefixesExpectation

        callArgs []*BudgetCacheRepositoryMockClearForPrefixesParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// BudgetCacheRepositoryMockClearForPrefixesExpectation specifies expectation struct of the BudgetCacheRepository.ClearForPrefixes
type BudgetCacheRepositoryMockClearForPrefixesExpectation struct {
        mock               *BudgetCacheRepositoryMock
        params             *BudgetCacheRepositoryMockClearForPrefixesParams
        paramPtrs          *BudgetCacheRepositoryMockClearForPrefixesParamPtrs
        expectationOrigins BudgetCacheRepositoryMockClearForPrefixesExpectationOrigins
        results            *BudgetCacheRepositoryMockClearForPrefixesResults
        returnOrigin       string
        Counter            uint64
}

// BudgetCacheRepositoryMockClearForPrefixesParams contains parameters of the BudgetCacheRepository.ClearForPrefixes
type BudgetCacheRepositoryMockClearForPrefixesParams struct {
        ctx      context.Context
        prefixes []string
}

// BudgetCacheRepositoryMockClearForPrefixesParamPtrs contains pointers to parameters of the BudgetCacheRepository.ClearForPrefixes
type BudgetCacheRepositoryMockClearForPrefixesParamPtrs struct {
        ctx      *context.Context
        prefixes *[]string
}

// BudgetCacheRepositoryMockClearForPrefixesResults contains results of the BudgetCacheRepository.ClearForPrefixes
type BudgetCacheRepositoryMockClearForPrefixesResults struct {
        err error
}

// BudgetCacheRepositoryMockClearForPrefixesOrigins contains origins of expectations of the BudgetCacheRepository.ClearForPrefixes
type BudgetCacheRepositoryMockClearForPrefixesExpectationOrigins struct {
        origin         string
        originCtx      string
        originPrefixes string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) Optional() *mBudgetCacheRepositoryMockClearForPrefixes <span class="cov0" title="0">{
        mmClearForPrefixes.optional = true
        return mmClearForPrefixes
}</span>

// Expect sets up expected params for BudgetCacheRepository.ClearForPrefixes
func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) Expect(ctx context.Context, prefixes ...string) *mBudgetCacheRepositoryMockClearForPrefixes <span class="cov0" title="0">{
        if mmClearForPrefixes.mock.funcClearForPrefixes != nil </span><span class="cov0" title="0">{
                mmClearForPrefixes.mock.t.Fatalf("BudgetCacheRepositoryMock.ClearForPrefixes mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmClearForPrefixes.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmClearForPrefixes.defaultExpectation = &amp;BudgetCacheRepositoryMockClearForPrefixesExpectation{}
        }</span>

        <span class="cov0" title="0">if mmClearForPrefixes.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmClearForPrefixes.mock.t.Fatalf("BudgetCacheRepositoryMock.ClearForPrefixes mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmClearForPrefixes.defaultExpectation.params = &amp;BudgetCacheRepositoryMockClearForPrefixesParams{ctx, prefixes}
        mmClearForPrefixes.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmClearForPrefixes.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmClearForPrefixes.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmClearForPrefixes.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClearForPrefixes.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmClearForPrefixes</span>
}

// ExpectCtxParam1 sets up expected param ctx for BudgetCacheRepository.ClearForPrefixes
func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) ExpectCtxParam1(ctx context.Context) *mBudgetCacheRepositoryMockClearForPrefixes <span class="cov0" title="0">{
        if mmClearForPrefixes.mock.funcClearForPrefixes != nil </span><span class="cov0" title="0">{
                mmClearForPrefixes.mock.t.Fatalf("BudgetCacheRepositoryMock.ClearForPrefixes mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmClearForPrefixes.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmClearForPrefixes.defaultExpectation = &amp;BudgetCacheRepositoryMockClearForPrefixesExpectation{}
        }</span>

        <span class="cov0" title="0">if mmClearForPrefixes.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmClearForPrefixes.mock.t.Fatalf("BudgetCacheRepositoryMock.ClearForPrefixes mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmClearForPrefixes.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmClearForPrefixes.defaultExpectation.paramPtrs = &amp;BudgetCacheRepositoryMockClearForPrefixesParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmClearForPrefixes.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmClearForPrefixes.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmClearForPrefixes</span>
}

// ExpectPrefixesParam2 sets up expected param prefixes for BudgetCacheRepository.ClearForPrefixes
func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) ExpectPrefixesParam2(prefixes ...string) *mBudgetCacheRepositoryMockClearForPrefixes <span class="cov0" title="0">{
        if mmClearForPrefixes.mock.funcClearForPrefixes != nil </span><span class="cov0" title="0">{
                mmClearForPrefixes.mock.t.Fatalf("BudgetCacheRepositoryMock.ClearForPrefixes mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmClearForPrefixes.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmClearForPrefixes.defaultExpectation = &amp;BudgetCacheRepositoryMockClearForPrefixesExpectation{}
        }</span>

        <span class="cov0" title="0">if mmClearForPrefixes.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmClearForPrefixes.mock.t.Fatalf("BudgetCacheRepositoryMock.ClearForPrefixes mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmClearForPrefixes.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmClearForPrefixes.defaultExpectation.paramPtrs = &amp;BudgetCacheRepositoryMockClearForPrefixesParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmClearForPrefixes.defaultExpectation.paramPtrs.prefixes = &amp;prefixes
        mmClearForPrefixes.defaultExpectation.expectationOrigins.originPrefixes = minimock.CallerInfo(1)

        return mmClearForPrefixes</span>
}

// Inspect accepts an inspector function that has same arguments as the BudgetCacheRepository.ClearForPrefixes
func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) Inspect(f func(ctx context.Context, prefixes ...string)) *mBudgetCacheRepositoryMockClearForPrefixes <span class="cov0" title="0">{
        if mmClearForPrefixes.mock.inspectFuncClearForPrefixes != nil </span><span class="cov0" title="0">{
                mmClearForPrefixes.mock.t.Fatalf("Inspect function is already set for BudgetCacheRepositoryMock.ClearForPrefixes")
        }</span>

        <span class="cov0" title="0">mmClearForPrefixes.mock.inspectFuncClearForPrefixes = f

        return mmClearForPrefixes</span>
}

// Return sets up results that will be returned by BudgetCacheRepository.ClearForPrefixes
func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) Return(err error) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        if mmClearForPrefixes.mock.funcClearForPrefixes != nil </span><span class="cov0" title="0">{
                mmClearForPrefixes.mock.t.Fatalf("BudgetCacheRepositoryMock.ClearForPrefixes mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmClearForPrefixes.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmClearForPrefixes.defaultExpectation = &amp;BudgetCacheRepositoryMockClearForPrefixesExpectation{mock: mmClearForPrefixes.mock}
        }</span>
        <span class="cov0" title="0">mmClearForPrefixes.defaultExpectation.results = &amp;BudgetCacheRepositoryMockClearForPrefixesResults{err}
        mmClearForPrefixes.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmClearForPrefixes.mock</span>
}

// Set uses given function f to mock the BudgetCacheRepository.ClearForPrefixes method
func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) Set(f func(ctx context.Context, prefixes ...string) (err error)) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        if mmClearForPrefixes.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmClearForPrefixes.mock.t.Fatalf("Default expectation is already set for the BudgetCacheRepository.ClearForPrefixes method")
        }</span>

        <span class="cov0" title="0">if len(mmClearForPrefixes.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmClearForPrefixes.mock.t.Fatalf("Some expectations are already set for the BudgetCacheRepository.ClearForPrefixes method")
        }</span>

        <span class="cov0" title="0">mmClearForPrefixes.mock.funcClearForPrefixes = f
        mmClearForPrefixes.mock.funcClearForPrefixesOrigin = minimock.CallerInfo(1)
        return mmClearForPrefixes.mock</span>
}

// When sets expectation for the BudgetCacheRepository.ClearForPrefixes which will trigger the result defined by the following
// Then helper
func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) When(ctx context.Context, prefixes ...string) *BudgetCacheRepositoryMockClearForPrefixesExpectation <span class="cov0" title="0">{
        if mmClearForPrefixes.mock.funcClearForPrefixes != nil </span><span class="cov0" title="0">{
                mmClearForPrefixes.mock.t.Fatalf("BudgetCacheRepositoryMock.ClearForPrefixes mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;BudgetCacheRepositoryMockClearForPrefixesExpectation{
                mock:               mmClearForPrefixes.mock,
                params:             &amp;BudgetCacheRepositoryMockClearForPrefixesParams{ctx, prefixes},
                expectationOrigins: BudgetCacheRepositoryMockClearForPrefixesExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmClearForPrefixes.expectations = append(mmClearForPrefixes.expectations, expectation)
        return expectation</span>
}

// Then sets up BudgetCacheRepository.ClearForPrefixes return parameters for the expectation previously defined by the When method
func (e *BudgetCacheRepositoryMockClearForPrefixesExpectation) Then(err error) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;BudgetCacheRepositoryMockClearForPrefixesResults{err}
        return e.mock
}</span>

// Times sets number of times BudgetCacheRepository.ClearForPrefixes should be invoked
func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) Times(n uint64) *mBudgetCacheRepositoryMockClearForPrefixes <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmClearForPrefixes.mock.t.Fatalf("Times of BudgetCacheRepositoryMock.ClearForPrefixes mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmClearForPrefixes.expectedInvocations, n)
        mmClearForPrefixes.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmClearForPrefixes</span>
}

func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmClearForPrefixes.expectations) == 0 &amp;&amp; mmClearForPrefixes.defaultExpectation == nil &amp;&amp; mmClearForPrefixes.mock.funcClearForPrefixes == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmClearForPrefixes.mock.afterClearForPrefixesCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmClearForPrefixes.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// ClearForPrefixes implements mm_usecase.BudgetCacheRepository
func (mmClearForPrefixes *BudgetCacheRepositoryMock) ClearForPrefixes(ctx context.Context, prefixes ...string) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmClearForPrefixes.beforeClearForPrefixesCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmClearForPrefixes.afterClearForPrefixesCounter, 1)

        mmClearForPrefixes.t.Helper()

        if mmClearForPrefixes.inspectFuncClearForPrefixes != nil </span><span class="cov0" title="0">{
                mmClearForPrefixes.inspectFuncClearForPrefixes(ctx, prefixes...)
        }</span>

        <span class="cov0" title="0">mm_params := BudgetCacheRepositoryMockClearForPrefixesParams{ctx, prefixes}

        // Record call args
        mmClearForPrefixes.ClearForPrefixesMock.mutex.Lock()
        mmClearForPrefixes.ClearForPrefixesMock.callArgs = append(mmClearForPrefixes.ClearForPrefixesMock.callArgs, &amp;mm_params)
        mmClearForPrefixes.ClearForPrefixesMock.mutex.Unlock()

        for _, e := range mmClearForPrefixes.ClearForPrefixesMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmClearForPrefixes.ClearForPrefixesMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmClearForPrefixes.ClearForPrefixesMock.defaultExpectation.Counter, 1)
                mm_want := mmClearForPrefixes.ClearForPrefixesMock.defaultExpectation.params
                mm_want_ptrs := mmClearForPrefixes.ClearForPrefixesMock.defaultExpectation.paramPtrs

                mm_got := BudgetCacheRepositoryMockClearForPrefixesParams{ctx, prefixes}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmClearForPrefixes.t.Errorf("BudgetCacheRepositoryMock.ClearForPrefixes got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmClearForPrefixes.ClearForPrefixesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.prefixes != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.prefixes, mm_got.prefixes) </span><span class="cov0" title="0">{
                                mmClearForPrefixes.t.Errorf("BudgetCacheRepositoryMock.ClearForPrefixes got unexpected parameter prefixes, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmClearForPrefixes.ClearForPrefixesMock.defaultExpectation.expectationOrigins.originPrefixes, *mm_want_ptrs.prefixes, mm_got.prefixes, minimock.Diff(*mm_want_ptrs.prefixes, mm_got.prefixes))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmClearForPrefixes.t.Errorf("BudgetCacheRepositoryMock.ClearForPrefixes got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmClearForPrefixes.ClearForPrefixesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmClearForPrefixes.ClearForPrefixesMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmClearForPrefixes.t.Fatal("No results are set for the BudgetCacheRepositoryMock.ClearForPrefixes")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmClearForPrefixes.funcClearForPrefixes != nil </span><span class="cov0" title="0">{
                return mmClearForPrefixes.funcClearForPrefixes(ctx, prefixes...)
        }</span>
        <span class="cov0" title="0">mmClearForPrefixes.t.Fatalf("Unexpected call to BudgetCacheRepositoryMock.ClearForPrefixes. %v %v", ctx, prefixes)
        return</span>
}

// ClearForPrefixesAfterCounter returns a count of finished BudgetCacheRepositoryMock.ClearForPrefixes invocations
func (mmClearForPrefixes *BudgetCacheRepositoryMock) ClearForPrefixesAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmClearForPrefixes.afterClearForPrefixesCounter)
}</span>

// ClearForPrefixesBeforeCounter returns a count of BudgetCacheRepositoryMock.ClearForPrefixes invocations
func (mmClearForPrefixes *BudgetCacheRepositoryMock) ClearForPrefixesBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmClearForPrefixes.beforeClearForPrefixesCounter)
}</span>

// Calls returns a list of arguments used in each call to BudgetCacheRepositoryMock.ClearForPrefixes.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClearForPrefixes *mBudgetCacheRepositoryMockClearForPrefixes) Calls() []*BudgetCacheRepositoryMockClearForPrefixesParams <span class="cov0" title="0">{
        mmClearForPrefixes.mutex.RLock()

        argCopy := make([]*BudgetCacheRepositoryMockClearForPrefixesParams, len(mmClearForPrefixes.callArgs))
        copy(argCopy, mmClearForPrefixes.callArgs)

        mmClearForPrefixes.mutex.RUnlock()

        return argCopy
}</span>

// MinimockClearForPrefixesDone returns true if the count of the ClearForPrefixes invocations corresponds
// the number of defined expectations
func (m *BudgetCacheRepositoryMock) MinimockClearForPrefixesDone() bool <span class="cov0" title="0">{
        if m.ClearForPrefixesMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.ClearForPrefixesMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.ClearForPrefixesMock.invocationsDone()</span>
}

// MinimockClearForPrefixesInspect logs each unmet expectation
func (m *BudgetCacheRepositoryMock) MinimockClearForPrefixesInspect() <span class="cov0" title="0">{
        for _, e := range m.ClearForPrefixesMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetCacheRepositoryMock.ClearForPrefixes at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterClearForPrefixesCounter := mm_atomic.LoadUint64(&amp;m.afterClearForPrefixesCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.ClearForPrefixesMock.defaultExpectation != nil &amp;&amp; afterClearForPrefixesCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.ClearForPrefixesMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetCacheRepositoryMock.ClearForPrefixes at\n%s", m.ClearForPrefixesMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to BudgetCacheRepositoryMock.ClearForPrefixes at\n%s with params: %#v", m.ClearForPrefixesMock.defaultExpectation.expectationOrigins.origin, *m.ClearForPrefixesMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcClearForPrefixes != nil &amp;&amp; afterClearForPrefixesCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to BudgetCacheRepositoryMock.ClearForPrefixes at\n%s", m.funcClearForPrefixesOrigin)
        }</span>

        <span class="cov0" title="0">if !m.ClearForPrefixesMock.invocationsDone() &amp;&amp; afterClearForPrefixesCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to BudgetCacheRepositoryMock.ClearForPrefixes at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.ClearForPrefixesMock.expectedInvocations), m.ClearForPrefixesMock.expectedInvocationsOrigin, afterClearForPrefixesCounter)
        }</span>
}

type mBudgetCacheRepositoryMockGetBudget struct {
        optional           bool
        mock               *BudgetCacheRepositoryMock
        defaultExpectation *BudgetCacheRepositoryMockGetBudgetExpectation
        expectations       []*BudgetCacheRepositoryMockGetBudgetExpectation

        callArgs []*BudgetCacheRepositoryMockGetBudgetParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// BudgetCacheRepositoryMockGetBudgetExpectation specifies expectation struct of the BudgetCacheRepository.GetBudget
type BudgetCacheRepositoryMockGetBudgetExpectation struct {
        mock               *BudgetCacheRepositoryMock
        params             *BudgetCacheRepositoryMockGetBudgetParams
        paramPtrs          *BudgetCacheRepositoryMockGetBudgetParamPtrs
        expectationOrigins BudgetCacheRepositoryMockGetBudgetExpectationOrigins
        results            *BudgetCacheRepositoryMockGetBudgetResults
        returnOrigin       string
        Counter            uint64
}

// BudgetCacheRepositoryMockGetBudgetParams contains parameters of the BudgetCacheRepository.GetBudget
type BudgetCacheRepositoryMockGetBudgetParams struct {
        ctx context.Context
        key string
}

// BudgetCacheRepositoryMockGetBudgetParamPtrs contains pointers to parameters of the BudgetCacheRepository.GetBudget
type BudgetCacheRepositoryMockGetBudgetParamPtrs struct {
        ctx *context.Context
        key *string
}

// BudgetCacheRepositoryMockGetBudgetResults contains results of the BudgetCacheRepository.GetBudget
type BudgetCacheRepositoryMockGetBudgetResults struct {
        item *entity.Budget
        err  error
}

// BudgetCacheRepositoryMockGetBudgetOrigins contains origins of expectations of the BudgetCacheRepository.GetBudget
type BudgetCacheRepositoryMockGetBudgetExpectationOrigins struct {
        origin    string
        originCtx string
        originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) Optional() *mBudgetCacheRepositoryMockGetBudget <span class="cov0" title="0">{
        mmGetBudget.optional = true
        return mmGetBudget
}</span>

// Expect sets up expected params for BudgetCacheRepository.GetBudget
func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) Expect(ctx context.Context, key string) *mBudgetCacheRepositoryMockGetBudget <span class="cov0" title="0">{
        if mmGetBudget.mock.funcGetBudget != nil </span><span class="cov0" title="0">{
                mmGetBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudget mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetBudget.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetBudget.defaultExpectation = &amp;BudgetCacheRepositoryMockGetBudgetExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetBudget.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudget mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmGetBudget.defaultExpectation.params = &amp;BudgetCacheRepositoryMockGetBudgetParams{ctx, key}
        mmGetBudget.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmGetBudget.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetBudget.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetBudget.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBudget.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmGetBudget</span>
}

// ExpectCtxParam1 sets up expected param ctx for BudgetCacheRepository.GetBudget
func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) ExpectCtxParam1(ctx context.Context) *mBudgetCacheRepositoryMockGetBudget <span class="cov0" title="0">{
        if mmGetBudget.mock.funcGetBudget != nil </span><span class="cov0" title="0">{
                mmGetBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudget mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetBudget.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetBudget.defaultExpectation = &amp;BudgetCacheRepositoryMockGetBudgetExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetBudget.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudget mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetBudget.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetBudget.defaultExpectation.paramPtrs = &amp;BudgetCacheRepositoryMockGetBudgetParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetBudget.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmGetBudget.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmGetBudget</span>
}

// ExpectKeyParam2 sets up expected param key for BudgetCacheRepository.GetBudget
func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) ExpectKeyParam2(key string) *mBudgetCacheRepositoryMockGetBudget <span class="cov0" title="0">{
        if mmGetBudget.mock.funcGetBudget != nil </span><span class="cov0" title="0">{
                mmGetBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudget mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetBudget.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetBudget.defaultExpectation = &amp;BudgetCacheRepositoryMockGetBudgetExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetBudget.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudget mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetBudget.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetBudget.defaultExpectation.paramPtrs = &amp;BudgetCacheRepositoryMockGetBudgetParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetBudget.defaultExpectation.paramPtrs.key = &amp;key
        mmGetBudget.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

        return mmGetBudget</span>
}

// Inspect accepts an inspector function that has same arguments as the BudgetCacheRepository.GetBudget
func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) Inspect(f func(ctx context.Context, key string)) *mBudgetCacheRepositoryMockGetBudget <span class="cov0" title="0">{
        if mmGetBudget.mock.inspectFuncGetBudget != nil </span><span class="cov0" title="0">{
                mmGetBudget.mock.t.Fatalf("Inspect function is already set for BudgetCacheRepositoryMock.GetBudget")
        }</span>

        <span class="cov0" title="0">mmGetBudget.mock.inspectFuncGetBudget = f

        return mmGetBudget</span>
}

// Return sets up results that will be returned by BudgetCacheRepository.GetBudget
func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) Return(item *entity.Budget, err error) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        if mmGetBudget.mock.funcGetBudget != nil </span><span class="cov0" title="0">{
                mmGetBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudget mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetBudget.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetBudget.defaultExpectation = &amp;BudgetCacheRepositoryMockGetBudgetExpectation{mock: mmGetBudget.mock}
        }</span>
        <span class="cov0" title="0">mmGetBudget.defaultExpectation.results = &amp;BudgetCacheRepositoryMockGetBudgetResults{item, err}
        mmGetBudget.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGetBudget.mock</span>
}

// Set uses given function f to mock the BudgetCacheRepository.GetBudget method
func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) Set(f func(ctx context.Context, key string) (item *entity.Budget, err error)) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        if mmGetBudget.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetBudget.mock.t.Fatalf("Default expectation is already set for the BudgetCacheRepository.GetBudget method")
        }</span>

        <span class="cov0" title="0">if len(mmGetBudget.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetBudget.mock.t.Fatalf("Some expectations are already set for the BudgetCacheRepository.GetBudget method")
        }</span>

        <span class="cov0" title="0">mmGetBudget.mock.funcGetBudget = f
        mmGetBudget.mock.funcGetBudgetOrigin = minimock.CallerInfo(1)
        return mmGetBudget.mock</span>
}

// When sets expectation for the BudgetCacheRepository.GetBudget which will trigger the result defined by the following
// Then helper
func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) When(ctx context.Context, key string) *BudgetCacheRepositoryMockGetBudgetExpectation <span class="cov0" title="0">{
        if mmGetBudget.mock.funcGetBudget != nil </span><span class="cov0" title="0">{
                mmGetBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudget mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;BudgetCacheRepositoryMockGetBudgetExpectation{
                mock:               mmGetBudget.mock,
                params:             &amp;BudgetCacheRepositoryMockGetBudgetParams{ctx, key},
                expectationOrigins: BudgetCacheRepositoryMockGetBudgetExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmGetBudget.expectations = append(mmGetBudget.expectations, expectation)
        return expectation</span>
}

// Then sets up BudgetCacheRepository.GetBudget return parameters for the expectation previously defined by the When method
func (e *BudgetCacheRepositoryMockGetBudgetExpectation) Then(item *entity.Budget, err error) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;BudgetCacheRepositoryMockGetBudgetResults{item, err}
        return e.mock
}</span>

// Times sets number of times BudgetCacheRepository.GetBudget should be invoked
func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) Times(n uint64) *mBudgetCacheRepositoryMockGetBudget <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetBudget.mock.t.Fatalf("Times of BudgetCacheRepositoryMock.GetBudget mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetBudget.expectedInvocations, n)
        mmGetBudget.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGetBudget</span>
}

func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmGetBudget.expectations) == 0 &amp;&amp; mmGetBudget.defaultExpectation == nil &amp;&amp; mmGetBudget.mock.funcGetBudget == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetBudget.mock.afterGetBudgetCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetBudget.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetBudget implements mm_usecase.BudgetCacheRepository
func (mmGetBudget *BudgetCacheRepositoryMock) GetBudget(ctx context.Context, key string) (item *entity.Budget, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmGetBudget.beforeGetBudgetCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetBudget.afterGetBudgetCounter, 1)

        mmGetBudget.t.Helper()

        if mmGetBudget.inspectFuncGetBudget != nil </span><span class="cov0" title="0">{
                mmGetBudget.inspectFuncGetBudget(ctx, key)
        }</span>

        <span class="cov0" title="0">mm_params := BudgetCacheRepositoryMockGetBudgetParams{ctx, key}

        // Record call args
        mmGetBudget.GetBudgetMock.mutex.Lock()
        mmGetBudget.GetBudgetMock.callArgs = append(mmGetBudget.GetBudgetMock.callArgs, &amp;mm_params)
        mmGetBudget.GetBudgetMock.mutex.Unlock()

        for _, e := range mmGetBudget.GetBudgetMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.item, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmGetBudget.GetBudgetMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmGetBudget.GetBudgetMock.defaultExpectation.Counter, 1)
                mm_want := mmGetBudget.GetBudgetMock.defaultExpectation.params
                mm_want_ptrs := mmGetBudget.GetBudgetMock.defaultExpectation.paramPtrs

                mm_got := BudgetCacheRepositoryMockGetBudgetParams{ctx, key}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmGetBudget.t.Errorf("BudgetCacheRepositoryMock.GetBudget got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetBudget.GetBudgetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.key != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.key, mm_got.key) </span><span class="cov0" title="0">{
                                mmGetBudget.t.Errorf("BudgetCacheRepositoryMock.GetBudget got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetBudget.GetBudgetMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetBudget.t.Errorf("BudgetCacheRepositoryMock.GetBudget got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmGetBudget.GetBudgetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmGetBudget.GetBudgetMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetBudget.t.Fatal("No results are set for the BudgetCacheRepositoryMock.GetBudget")
                }</span>
                <span class="cov0" title="0">return (*mm_results).item, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmGetBudget.funcGetBudget != nil </span><span class="cov0" title="0">{
                return mmGetBudget.funcGetBudget(ctx, key)
        }</span>
        <span class="cov0" title="0">mmGetBudget.t.Fatalf("Unexpected call to BudgetCacheRepositoryMock.GetBudget. %v %v", ctx, key)
        return</span>
}

// GetBudgetAfterCounter returns a count of finished BudgetCacheRepositoryMock.GetBudget invocations
func (mmGetBudget *BudgetCacheRepositoryMock) GetBudgetAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetBudget.afterGetBudgetCounter)
}</span>

// GetBudgetBeforeCounter returns a count of BudgetCacheRepositoryMock.GetBudget invocations
func (mmGetBudget *BudgetCacheRepositoryMock) GetBudgetBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetBudget.beforeGetBudgetCounter)
}</span>

// Calls returns a list of arguments used in each call to BudgetCacheRepositoryMock.GetBudget.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBudget *mBudgetCacheRepositoryMockGetBudget) Calls() []*BudgetCacheRepositoryMockGetBudgetParams <span class="cov0" title="0">{
        mmGetBudget.mutex.RLock()

        argCopy := make([]*BudgetCacheRepositoryMockGetBudgetParams, len(mmGetBudget.callArgs))
        copy(argCopy, mmGetBudget.callArgs)

        mmGetBudget.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetBudgetDone returns true if the count of the GetBudget invocations corresponds
// the number of defined expectations
func (m *BudgetCacheRepositoryMock) MinimockGetBudgetDone() bool <span class="cov0" title="0">{
        if m.GetBudgetMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.GetBudgetMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.GetBudgetMock.invocationsDone()</span>
}

// MinimockGetBudgetInspect logs each unmet expectation
func (m *BudgetCacheRepositoryMock) MinimockGetBudgetInspect() <span class="cov0" title="0">{
        for _, e := range m.GetBudgetMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudget at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetBudgetCounter := mm_atomic.LoadUint64(&amp;m.afterGetBudgetCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetBudgetMock.defaultExpectation != nil &amp;&amp; afterGetBudgetCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetBudgetMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudget at\n%s", m.GetBudgetMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudget at\n%s with params: %#v", m.GetBudgetMock.defaultExpectation.expectationOrigins.origin, *m.GetBudgetMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetBudget != nil &amp;&amp; afterGetBudgetCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudget at\n%s", m.funcGetBudgetOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetBudgetMock.invocationsDone() &amp;&amp; afterGetBudgetCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to BudgetCacheRepositoryMock.GetBudget at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetBudgetMock.expectedInvocations), m.GetBudgetMock.expectedInvocationsOrigin, afterGetBudgetCounter)
        }</span>
}

type mBudgetCacheRepositoryMockGetBudgetsList struct {
        optional           bool
        mock               *BudgetCacheRepositoryMock
        defaultExpectation *BudgetCacheRepositoryMockGetBudgetsListExpectation
        expectations       []*BudgetCacheRepositoryMockGetBudgetsListExpectation

        callArgs []*BudgetCacheRepositoryMockGetBudgetsListParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// BudgetCacheRepositoryMockGetBudgetsListExpectation specifies expectation struct of the BudgetCacheRepository.GetBudgetsList
type BudgetCacheRepositoryMockGetBudgetsListExpectation struct {
        mock               *BudgetCacheRepositoryMock
        params             *BudgetCacheRepositoryMockGetBudgetsListParams
        paramPtrs          *BudgetCacheRepositoryMockGetBudgetsListParamPtrs
        expectationOrigins BudgetCacheRepositoryMockGetBudgetsListExpectationOrigins
        results            *BudgetCacheRepositoryMockGetBudgetsListResults
        returnOrigin       string
        Counter            uint64
}

// BudgetCacheRepositoryMockGetBudgetsListParams contains parameters of the BudgetCacheRepository.GetBudgetsList
type BudgetCacheRepositoryMockGetBudgetsListParams struct {
        ctx context.Context
        key string
}

// BudgetCacheRepositoryMockGetBudgetsListParamPtrs contains pointers to parameters of the BudgetCacheRepository.GetBudgetsList
type BudgetCacheRepositoryMockGetBudgetsListParamPtrs struct {
        ctx *context.Context
        key *string
}

// BudgetCacheRepositoryMockGetBudgetsListResults contains results of the BudgetCacheRepository.GetBudgetsList
type BudgetCacheRepositoryMockGetBudgetsListResults struct {
        items []*entity.Budget
        err   error
}

// BudgetCacheRepositoryMockGetBudgetsListOrigins contains origins of expectations of the BudgetCacheRepository.GetBudgetsList
type BudgetCacheRepositoryMockGetBudgetsListExpectationOrigins struct {
        origin    string
        originCtx string
        originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) Optional() *mBudgetCacheRepositoryMockGetBudgetsList <span class="cov0" title="0">{
        mmGetBudgetsList.optional = true
        return mmGetBudgetsList
}</span>

// Expect sets up expected params for BudgetCacheRepository.GetBudgetsList
func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) Expect(ctx context.Context, key string) *mBudgetCacheRepositoryMockGetBudgetsList <span class="cov0" title="0">{
        if mmGetBudgetsList.mock.funcGetBudgetsList != nil </span><span class="cov0" title="0">{
                mmGetBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetBudgetsList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetBudgetsList.defaultExpectation = &amp;BudgetCacheRepositoryMockGetBudgetsListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetBudgetsList.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsList mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmGetBudgetsList.defaultExpectation.params = &amp;BudgetCacheRepositoryMockGetBudgetsListParams{ctx, key}
        mmGetBudgetsList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmGetBudgetsList.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetBudgetsList.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetBudgetsList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBudgetsList.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmGetBudgetsList</span>
}

// ExpectCtxParam1 sets up expected param ctx for BudgetCacheRepository.GetBudgetsList
func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) ExpectCtxParam1(ctx context.Context) *mBudgetCacheRepositoryMockGetBudgetsList <span class="cov0" title="0">{
        if mmGetBudgetsList.mock.funcGetBudgetsList != nil </span><span class="cov0" title="0">{
                mmGetBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetBudgetsList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetBudgetsList.defaultExpectation = &amp;BudgetCacheRepositoryMockGetBudgetsListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetBudgetsList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetBudgetsList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetBudgetsList.defaultExpectation.paramPtrs = &amp;BudgetCacheRepositoryMockGetBudgetsListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetBudgetsList.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmGetBudgetsList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmGetBudgetsList</span>
}

// ExpectKeyParam2 sets up expected param key for BudgetCacheRepository.GetBudgetsList
func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) ExpectKeyParam2(key string) *mBudgetCacheRepositoryMockGetBudgetsList <span class="cov0" title="0">{
        if mmGetBudgetsList.mock.funcGetBudgetsList != nil </span><span class="cov0" title="0">{
                mmGetBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetBudgetsList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetBudgetsList.defaultExpectation = &amp;BudgetCacheRepositoryMockGetBudgetsListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetBudgetsList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetBudgetsList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetBudgetsList.defaultExpectation.paramPtrs = &amp;BudgetCacheRepositoryMockGetBudgetsListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetBudgetsList.defaultExpectation.paramPtrs.key = &amp;key
        mmGetBudgetsList.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

        return mmGetBudgetsList</span>
}

// Inspect accepts an inspector function that has same arguments as the BudgetCacheRepository.GetBudgetsList
func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) Inspect(f func(ctx context.Context, key string)) *mBudgetCacheRepositoryMockGetBudgetsList <span class="cov0" title="0">{
        if mmGetBudgetsList.mock.inspectFuncGetBudgetsList != nil </span><span class="cov0" title="0">{
                mmGetBudgetsList.mock.t.Fatalf("Inspect function is already set for BudgetCacheRepositoryMock.GetBudgetsList")
        }</span>

        <span class="cov0" title="0">mmGetBudgetsList.mock.inspectFuncGetBudgetsList = f

        return mmGetBudgetsList</span>
}

// Return sets up results that will be returned by BudgetCacheRepository.GetBudgetsList
func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) Return(items []*entity.Budget, err error) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        if mmGetBudgetsList.mock.funcGetBudgetsList != nil </span><span class="cov0" title="0">{
                mmGetBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetBudgetsList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetBudgetsList.defaultExpectation = &amp;BudgetCacheRepositoryMockGetBudgetsListExpectation{mock: mmGetBudgetsList.mock}
        }</span>
        <span class="cov0" title="0">mmGetBudgetsList.defaultExpectation.results = &amp;BudgetCacheRepositoryMockGetBudgetsListResults{items, err}
        mmGetBudgetsList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGetBudgetsList.mock</span>
}

// Set uses given function f to mock the BudgetCacheRepository.GetBudgetsList method
func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) Set(f func(ctx context.Context, key string) (items []*entity.Budget, err error)) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        if mmGetBudgetsList.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetBudgetsList.mock.t.Fatalf("Default expectation is already set for the BudgetCacheRepository.GetBudgetsList method")
        }</span>

        <span class="cov0" title="0">if len(mmGetBudgetsList.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetBudgetsList.mock.t.Fatalf("Some expectations are already set for the BudgetCacheRepository.GetBudgetsList method")
        }</span>

        <span class="cov0" title="0">mmGetBudgetsList.mock.funcGetBudgetsList = f
        mmGetBudgetsList.mock.funcGetBudgetsListOrigin = minimock.CallerInfo(1)
        return mmGetBudgetsList.mock</span>
}

// When sets expectation for the BudgetCacheRepository.GetBudgetsList which will trigger the result defined by the following
// Then helper
func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) When(ctx context.Context, key string) *BudgetCacheRepositoryMockGetBudgetsListExpectation <span class="cov0" title="0">{
        if mmGetBudgetsList.mock.funcGetBudgetsList != nil </span><span class="cov0" title="0">{
                mmGetBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;BudgetCacheRepositoryMockGetBudgetsListExpectation{
                mock:               mmGetBudgetsList.mock,
                params:             &amp;BudgetCacheRepositoryMockGetBudgetsListParams{ctx, key},
                expectationOrigins: BudgetCacheRepositoryMockGetBudgetsListExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmGetBudgetsList.expectations = append(mmGetBudgetsList.expectations, expectation)
        return expectation</span>
}

// Then sets up BudgetCacheRepository.GetBudgetsList return parameters for the expectation previously defined by the When method
func (e *BudgetCacheRepositoryMockGetBudgetsListExpectation) Then(items []*entity.Budget, err error) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;BudgetCacheRepositoryMockGetBudgetsListResults{items, err}
        return e.mock
}</span>

// Times sets number of times BudgetCacheRepository.GetBudgetsList should be invoked
func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) Times(n uint64) *mBudgetCacheRepositoryMockGetBudgetsList <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetBudgetsList.mock.t.Fatalf("Times of BudgetCacheRepositoryMock.GetBudgetsList mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetBudgetsList.expectedInvocations, n)
        mmGetBudgetsList.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGetBudgetsList</span>
}

func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmGetBudgetsList.expectations) == 0 &amp;&amp; mmGetBudgetsList.defaultExpectation == nil &amp;&amp; mmGetBudgetsList.mock.funcGetBudgetsList == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetBudgetsList.mock.afterGetBudgetsListCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetBudgetsList.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetBudgetsList implements mm_usecase.BudgetCacheRepository
func (mmGetBudgetsList *BudgetCacheRepositoryMock) GetBudgetsList(ctx context.Context, key string) (items []*entity.Budget, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmGetBudgetsList.beforeGetBudgetsListCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetBudgetsList.afterGetBudgetsListCounter, 1)

        mmGetBudgetsList.t.Helper()

        if mmGetBudgetsList.inspectFuncGetBudgetsList != nil </span><span class="cov0" title="0">{
                mmGetBudgetsList.inspectFuncGetBudgetsList(ctx, key)
        }</span>

        <span class="cov0" title="0">mm_params := BudgetCacheRepositoryMockGetBudgetsListParams{ctx, key}

        // Record call args
        mmGetBudgetsList.GetBudgetsListMock.mutex.Lock()
        mmGetBudgetsList.GetBudgetsListMock.callArgs = append(mmGetBudgetsList.GetBudgetsListMock.callArgs, &amp;mm_params)
        mmGetBudgetsList.GetBudgetsListMock.mutex.Unlock()

        for _, e := range mmGetBudgetsList.GetBudgetsListMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.items, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmGetBudgetsList.GetBudgetsListMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmGetBudgetsList.GetBudgetsListMock.defaultExpectation.Counter, 1)
                mm_want := mmGetBudgetsList.GetBudgetsListMock.defaultExpectation.params
                mm_want_ptrs := mmGetBudgetsList.GetBudgetsListMock.defaultExpectation.paramPtrs

                mm_got := BudgetCacheRepositoryMockGetBudgetsListParams{ctx, key}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmGetBudgetsList.t.Errorf("BudgetCacheRepositoryMock.GetBudgetsList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetBudgetsList.GetBudgetsListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.key != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.key, mm_got.key) </span><span class="cov0" title="0">{
                                mmGetBudgetsList.t.Errorf("BudgetCacheRepositoryMock.GetBudgetsList got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetBudgetsList.GetBudgetsListMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetBudgetsList.t.Errorf("BudgetCacheRepositoryMock.GetBudgetsList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmGetBudgetsList.GetBudgetsListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmGetBudgetsList.GetBudgetsListMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetBudgetsList.t.Fatal("No results are set for the BudgetCacheRepositoryMock.GetBudgetsList")
                }</span>
                <span class="cov0" title="0">return (*mm_results).items, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmGetBudgetsList.funcGetBudgetsList != nil </span><span class="cov0" title="0">{
                return mmGetBudgetsList.funcGetBudgetsList(ctx, key)
        }</span>
        <span class="cov0" title="0">mmGetBudgetsList.t.Fatalf("Unexpected call to BudgetCacheRepositoryMock.GetBudgetsList. %v %v", ctx, key)
        return</span>
}

// GetBudgetsListAfterCounter returns a count of finished BudgetCacheRepositoryMock.GetBudgetsList invocations
func (mmGetBudgetsList *BudgetCacheRepositoryMock) GetBudgetsListAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetBudgetsList.afterGetBudgetsListCounter)
}</span>

// GetBudgetsListBeforeCounter returns a count of BudgetCacheRepositoryMock.GetBudgetsList invocations
func (mmGetBudgetsList *BudgetCacheRepositoryMock) GetBudgetsListBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetBudgetsList.beforeGetBudgetsListCounter)
}</span>

// Calls returns a list of arguments used in each call to BudgetCacheRepositoryMock.GetBudgetsList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBudgetsList *mBudgetCacheRepositoryMockGetBudgetsList) Calls() []*BudgetCacheRepositoryMockGetBudgetsListParams <span class="cov0" title="0">{
        mmGetBudgetsList.mutex.RLock()

        argCopy := make([]*BudgetCacheRepositoryMockGetBudgetsListParams, len(mmGetBudgetsList.callArgs))
        copy(argCopy, mmGetBudgetsList.callArgs)

        mmGetBudgetsList.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetBudgetsListDone returns true if the count of the GetBudgetsList invocations corresponds
// the number of defined expectations
func (m *BudgetCacheRepositoryMock) MinimockGetBudgetsListDone() bool <span class="cov0" title="0">{
        if m.GetBudgetsListMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.GetBudgetsListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.GetBudgetsListMock.invocationsDone()</span>
}

// MinimockGetBudgetsListInspect logs each unmet expectation
func (m *BudgetCacheRepositoryMock) MinimockGetBudgetsListInspect() <span class="cov0" title="0">{
        for _, e := range m.GetBudgetsListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudgetsList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetBudgetsListCounter := mm_atomic.LoadUint64(&amp;m.afterGetBudgetsListCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetBudgetsListMock.defaultExpectation != nil &amp;&amp; afterGetBudgetsListCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetBudgetsListMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudgetsList at\n%s", m.GetBudgetsListMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudgetsList at\n%s with params: %#v", m.GetBudgetsListMock.defaultExpectation.expectationOrigins.origin, *m.GetBudgetsListMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetBudgetsList != nil &amp;&amp; afterGetBudgetsListCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudgetsList at\n%s", m.funcGetBudgetsListOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetBudgetsListMock.invocationsDone() &amp;&amp; afterGetBudgetsListCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to BudgetCacheRepositoryMock.GetBudgetsList at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetBudgetsListMock.expectedInvocations), m.GetBudgetsListMock.expectedInvocationsOrigin, afterGetBudgetsListCounter)
        }</span>
}

type mBudgetCacheRepositoryMockGetBudgetsPagedList struct {
        optional           bool
        mock               *BudgetCacheRepositoryMock
        defaultExpectation *BudgetCacheRepositoryMockGetBudgetsPagedListExpectation
        expectations       []*BudgetCacheRepositoryMockGetBudgetsPagedListExpectation

        callArgs []*BudgetCacheRepositoryMockGetBudgetsPagedListParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// BudgetCacheRepositoryMockGetBudgetsPagedListExpectation specifies expectation struct of the BudgetCacheRepository.GetBudgetsPagedList
type BudgetCacheRepositoryMockGetBudgetsPagedListExpectation struct {
        mock               *BudgetCacheRepositoryMock
        params             *BudgetCacheRepositoryMockGetBudgetsPagedListParams
        paramPtrs          *BudgetCacheRepositoryMockGetBudgetsPagedListParamPtrs
        expectationOrigins BudgetCacheRepositoryMockGetBudgetsPagedListExpectationOrigins
        results            *BudgetCacheRepositoryMockGetBudgetsPagedListResults
        returnOrigin       string
        Counter            uint64
}

// BudgetCacheRepositoryMockGetBudgetsPagedListParams contains parameters of the BudgetCacheRepository.GetBudgetsPagedList
type BudgetCacheRepositoryMockGetBudgetsPagedListParams struct {
        ctx context.Context
        key string
}

// BudgetCacheRepositoryMockGetBudgetsPagedListParamPtrs contains pointers to parameters of the BudgetCacheRepository.GetBudgetsPagedList
type BudgetCacheRepositoryMockGetBudgetsPagedListParamPtrs struct {
        ctx *context.Context
        key *string
}

// BudgetCacheRepositoryMockGetBudgetsPagedListResults contains results of the BudgetCacheRepository.GetBudgetsPagedList
type BudgetCacheRepositoryMockGetBudgetsPagedListResults struct {
        items []*entity.Budget
        total uint64
        err   error
}

// BudgetCacheRepositoryMockGetBudgetsPagedListOrigins contains origins of expectations of the BudgetCacheRepository.GetBudgetsPagedList
type BudgetCacheRepositoryMockGetBudgetsPagedListExpectationOrigins struct {
        origin    string
        originCtx string
        originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) Optional() *mBudgetCacheRepositoryMockGetBudgetsPagedList <span class="cov0" title="0">{
        mmGetBudgetsPagedList.optional = true
        return mmGetBudgetsPagedList
}</span>

// Expect sets up expected params for BudgetCacheRepository.GetBudgetsPagedList
func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) Expect(ctx context.Context, key string) *mBudgetCacheRepositoryMockGetBudgetsPagedList <span class="cov0" title="0">{
        if mmGetBudgetsPagedList.mock.funcGetBudgetsPagedList != nil </span><span class="cov0" title="0">{
                mmGetBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetBudgetsPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetBudgetsPagedList.defaultExpectation = &amp;BudgetCacheRepositoryMockGetBudgetsPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetBudgetsPagedList.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsPagedList mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmGetBudgetsPagedList.defaultExpectation.params = &amp;BudgetCacheRepositoryMockGetBudgetsPagedListParams{ctx, key}
        mmGetBudgetsPagedList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmGetBudgetsPagedList.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetBudgetsPagedList.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetBudgetsPagedList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBudgetsPagedList.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmGetBudgetsPagedList</span>
}

// ExpectCtxParam1 sets up expected param ctx for BudgetCacheRepository.GetBudgetsPagedList
func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) ExpectCtxParam1(ctx context.Context) *mBudgetCacheRepositoryMockGetBudgetsPagedList <span class="cov0" title="0">{
        if mmGetBudgetsPagedList.mock.funcGetBudgetsPagedList != nil </span><span class="cov0" title="0">{
                mmGetBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetBudgetsPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetBudgetsPagedList.defaultExpectation = &amp;BudgetCacheRepositoryMockGetBudgetsPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetBudgetsPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetBudgetsPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetBudgetsPagedList.defaultExpectation.paramPtrs = &amp;BudgetCacheRepositoryMockGetBudgetsPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetBudgetsPagedList.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmGetBudgetsPagedList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmGetBudgetsPagedList</span>
}

// ExpectKeyParam2 sets up expected param key for BudgetCacheRepository.GetBudgetsPagedList
func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) ExpectKeyParam2(key string) *mBudgetCacheRepositoryMockGetBudgetsPagedList <span class="cov0" title="0">{
        if mmGetBudgetsPagedList.mock.funcGetBudgetsPagedList != nil </span><span class="cov0" title="0">{
                mmGetBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetBudgetsPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetBudgetsPagedList.defaultExpectation = &amp;BudgetCacheRepositoryMockGetBudgetsPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetBudgetsPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetBudgetsPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetBudgetsPagedList.defaultExpectation.paramPtrs = &amp;BudgetCacheRepositoryMockGetBudgetsPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetBudgetsPagedList.defaultExpectation.paramPtrs.key = &amp;key
        mmGetBudgetsPagedList.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

        return mmGetBudgetsPagedList</span>
}

// Inspect accepts an inspector function that has same arguments as the BudgetCacheRepository.GetBudgetsPagedList
func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) Inspect(f func(ctx context.Context, key string)) *mBudgetCacheRepositoryMockGetBudgetsPagedList <span class="cov0" title="0">{
        if mmGetBudgetsPagedList.mock.inspectFuncGetBudgetsPagedList != nil </span><span class="cov0" title="0">{
                mmGetBudgetsPagedList.mock.t.Fatalf("Inspect function is already set for BudgetCacheRepositoryMock.GetBudgetsPagedList")
        }</span>

        <span class="cov0" title="0">mmGetBudgetsPagedList.mock.inspectFuncGetBudgetsPagedList = f

        return mmGetBudgetsPagedList</span>
}

// Return sets up results that will be returned by BudgetCacheRepository.GetBudgetsPagedList
func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) Return(items []*entity.Budget, total uint64, err error) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        if mmGetBudgetsPagedList.mock.funcGetBudgetsPagedList != nil </span><span class="cov0" title="0">{
                mmGetBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetBudgetsPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetBudgetsPagedList.defaultExpectation = &amp;BudgetCacheRepositoryMockGetBudgetsPagedListExpectation{mock: mmGetBudgetsPagedList.mock}
        }</span>
        <span class="cov0" title="0">mmGetBudgetsPagedList.defaultExpectation.results = &amp;BudgetCacheRepositoryMockGetBudgetsPagedListResults{items, total, err}
        mmGetBudgetsPagedList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGetBudgetsPagedList.mock</span>
}

// Set uses given function f to mock the BudgetCacheRepository.GetBudgetsPagedList method
func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) Set(f func(ctx context.Context, key string) (items []*entity.Budget, total uint64, err error)) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        if mmGetBudgetsPagedList.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetBudgetsPagedList.mock.t.Fatalf("Default expectation is already set for the BudgetCacheRepository.GetBudgetsPagedList method")
        }</span>

        <span class="cov0" title="0">if len(mmGetBudgetsPagedList.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetBudgetsPagedList.mock.t.Fatalf("Some expectations are already set for the BudgetCacheRepository.GetBudgetsPagedList method")
        }</span>

        <span class="cov0" title="0">mmGetBudgetsPagedList.mock.funcGetBudgetsPagedList = f
        mmGetBudgetsPagedList.mock.funcGetBudgetsPagedListOrigin = minimock.CallerInfo(1)
        return mmGetBudgetsPagedList.mock</span>
}

// When sets expectation for the BudgetCacheRepository.GetBudgetsPagedList which will trigger the result defined by the following
// Then helper
func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) When(ctx context.Context, key string) *BudgetCacheRepositoryMockGetBudgetsPagedListExpectation <span class="cov0" title="0">{
        if mmGetBudgetsPagedList.mock.funcGetBudgetsPagedList != nil </span><span class="cov0" title="0">{
                mmGetBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.GetBudgetsPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;BudgetCacheRepositoryMockGetBudgetsPagedListExpectation{
                mock:               mmGetBudgetsPagedList.mock,
                params:             &amp;BudgetCacheRepositoryMockGetBudgetsPagedListParams{ctx, key},
                expectationOrigins: BudgetCacheRepositoryMockGetBudgetsPagedListExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmGetBudgetsPagedList.expectations = append(mmGetBudgetsPagedList.expectations, expectation)
        return expectation</span>
}

// Then sets up BudgetCacheRepository.GetBudgetsPagedList return parameters for the expectation previously defined by the When method
func (e *BudgetCacheRepositoryMockGetBudgetsPagedListExpectation) Then(items []*entity.Budget, total uint64, err error) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;BudgetCacheRepositoryMockGetBudgetsPagedListResults{items, total, err}
        return e.mock
}</span>

// Times sets number of times BudgetCacheRepository.GetBudgetsPagedList should be invoked
func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) Times(n uint64) *mBudgetCacheRepositoryMockGetBudgetsPagedList <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetBudgetsPagedList.mock.t.Fatalf("Times of BudgetCacheRepositoryMock.GetBudgetsPagedList mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetBudgetsPagedList.expectedInvocations, n)
        mmGetBudgetsPagedList.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGetBudgetsPagedList</span>
}

func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmGetBudgetsPagedList.expectations) == 0 &amp;&amp; mmGetBudgetsPagedList.defaultExpectation == nil &amp;&amp; mmGetBudgetsPagedList.mock.funcGetBudgetsPagedList == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetBudgetsPagedList.mock.afterGetBudgetsPagedListCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetBudgetsPagedList.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetBudgetsPagedList implements mm_usecase.BudgetCacheRepository
func (mmGetBudgetsPagedList *BudgetCacheRepositoryMock) GetBudgetsPagedList(ctx context.Context, key string) (items []*entity.Budget, total uint64, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmGetBudgetsPagedList.beforeGetBudgetsPagedListCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetBudgetsPagedList.afterGetBudgetsPagedListCounter, 1)

        mmGetBudgetsPagedList.t.Helper()

        if mmGetBudgetsPagedList.inspectFuncGetBudgetsPagedList != nil </span><span class="cov0" title="0">{
                mmGetBudgetsPagedList.inspectFuncGetBudgetsPagedList(ctx, key)
        }</span>

        <span class="cov0" title="0">mm_params := BudgetCacheRepositoryMockGetBudgetsPagedListParams{ctx, key}

        // Record call args
        mmGetBudgetsPagedList.GetBudgetsPagedListMock.mutex.Lock()
        mmGetBudgetsPagedList.GetBudgetsPagedListMock.callArgs = append(mmGetBudgetsPagedList.GetBudgetsPagedListMock.callArgs, &amp;mm_params)
        mmGetBudgetsPagedList.GetBudgetsPagedListMock.mutex.Unlock()

        for _, e := range mmGetBudgetsPagedList.GetBudgetsPagedListMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.items, e.results.total, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmGetBudgetsPagedList.GetBudgetsPagedListMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmGetBudgetsPagedList.GetBudgetsPagedListMock.defaultExpectation.Counter, 1)
                mm_want := mmGetBudgetsPagedList.GetBudgetsPagedListMock.defaultExpectation.params
                mm_want_ptrs := mmGetBudgetsPagedList.GetBudgetsPagedListMock.defaultExpectation.paramPtrs

                mm_got := BudgetCacheRepositoryMockGetBudgetsPagedListParams{ctx, key}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmGetBudgetsPagedList.t.Errorf("BudgetCacheRepositoryMock.GetBudgetsPagedList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetBudgetsPagedList.GetBudgetsPagedListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.key != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.key, mm_got.key) </span><span class="cov0" title="0">{
                                mmGetBudgetsPagedList.t.Errorf("BudgetCacheRepositoryMock.GetBudgetsPagedList got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetBudgetsPagedList.GetBudgetsPagedListMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetBudgetsPagedList.t.Errorf("BudgetCacheRepositoryMock.GetBudgetsPagedList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmGetBudgetsPagedList.GetBudgetsPagedListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmGetBudgetsPagedList.GetBudgetsPagedListMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetBudgetsPagedList.t.Fatal("No results are set for the BudgetCacheRepositoryMock.GetBudgetsPagedList")
                }</span>
                <span class="cov0" title="0">return (*mm_results).items, (*mm_results).total, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmGetBudgetsPagedList.funcGetBudgetsPagedList != nil </span><span class="cov0" title="0">{
                return mmGetBudgetsPagedList.funcGetBudgetsPagedList(ctx, key)
        }</span>
        <span class="cov0" title="0">mmGetBudgetsPagedList.t.Fatalf("Unexpected call to BudgetCacheRepositoryMock.GetBudgetsPagedList. %v %v", ctx, key)
        return</span>
}

// GetBudgetsPagedListAfterCounter returns a count of finished BudgetCacheRepositoryMock.GetBudgetsPagedList invocations
func (mmGetBudgetsPagedList *BudgetCacheRepositoryMock) GetBudgetsPagedListAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetBudgetsPagedList.afterGetBudgetsPagedListCounter)
}</span>

// GetBudgetsPagedListBeforeCounter returns a count of BudgetCacheRepositoryMock.GetBudgetsPagedList invocations
func (mmGetBudgetsPagedList *BudgetCacheRepositoryMock) GetBudgetsPagedListBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetBudgetsPagedList.beforeGetBudgetsPagedListCounter)
}</span>

// Calls returns a list of arguments used in each call to BudgetCacheRepositoryMock.GetBudgetsPagedList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBudgetsPagedList *mBudgetCacheRepositoryMockGetBudgetsPagedList) Calls() []*BudgetCacheRepositoryMockGetBudgetsPagedListParams <span class="cov0" title="0">{
        mmGetBudgetsPagedList.mutex.RLock()

        argCopy := make([]*BudgetCacheRepositoryMockGetBudgetsPagedListParams, len(mmGetBudgetsPagedList.callArgs))
        copy(argCopy, mmGetBudgetsPagedList.callArgs)

        mmGetBudgetsPagedList.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetBudgetsPagedListDone returns true if the count of the GetBudgetsPagedList invocations corresponds
// the number of defined expectations
func (m *BudgetCacheRepositoryMock) MinimockGetBudgetsPagedListDone() bool <span class="cov0" title="0">{
        if m.GetBudgetsPagedListMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.GetBudgetsPagedListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.GetBudgetsPagedListMock.invocationsDone()</span>
}

// MinimockGetBudgetsPagedListInspect logs each unmet expectation
func (m *BudgetCacheRepositoryMock) MinimockGetBudgetsPagedListInspect() <span class="cov0" title="0">{
        for _, e := range m.GetBudgetsPagedListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudgetsPagedList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetBudgetsPagedListCounter := mm_atomic.LoadUint64(&amp;m.afterGetBudgetsPagedListCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetBudgetsPagedListMock.defaultExpectation != nil &amp;&amp; afterGetBudgetsPagedListCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetBudgetsPagedListMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudgetsPagedList at\n%s", m.GetBudgetsPagedListMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudgetsPagedList at\n%s with params: %#v", m.GetBudgetsPagedListMock.defaultExpectation.expectationOrigins.origin, *m.GetBudgetsPagedListMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetBudgetsPagedList != nil &amp;&amp; afterGetBudgetsPagedListCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to BudgetCacheRepositoryMock.GetBudgetsPagedList at\n%s", m.funcGetBudgetsPagedListOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetBudgetsPagedListMock.invocationsDone() &amp;&amp; afterGetBudgetsPagedListCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to BudgetCacheRepositoryMock.GetBudgetsPagedList at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetBudgetsPagedListMock.expectedInvocations), m.GetBudgetsPagedListMock.expectedInvocationsOrigin, afterGetBudgetsPagedListCounter)
        }</span>
}

type mBudgetCacheRepositoryMockSaveBudget struct {
        optional           bool
        mock               *BudgetCacheRepositoryMock
        defaultExpectation *BudgetCacheRepositoryMockSaveBudgetExpectation
        expectations       []*BudgetCacheRepositoryMockSaveBudgetExpectation

        callArgs []*BudgetCacheRepositoryMockSaveBudgetParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// BudgetCacheRepositoryMockSaveBudgetExpectation specifies expectation struct of the BudgetCacheRepository.SaveBudget
type BudgetCacheRepositoryMockSaveBudgetExpectation struct {
        mock               *BudgetCacheRepositoryMock
        params             *BudgetCacheRepositoryMockSaveBudgetParams
        paramPtrs          *BudgetCacheRepositoryMockSaveBudgetParamPtrs
        expectationOrigins BudgetCacheRepositoryMockSaveBudgetExpectationOrigins
        results            *BudgetCacheRepositoryMockSaveBudgetResults
        returnOrigin       string
        Counter            uint64
}

// BudgetCacheRepositoryMockSaveBudgetParams contains parameters of the BudgetCacheRepository.SaveBudget
type BudgetCacheRepositoryMockSaveBudgetParams struct {
        ctx  context.Context
        key  string
        item *entity.Budget
        ttl  *time.Duration
}

// BudgetCacheRepositoryMockSaveBudgetParamPtrs contains pointers to parameters of the BudgetCacheRepository.SaveBudget
type BudgetCacheRepositoryMockSaveBudgetParamPtrs struct {
        ctx  *context.Context
        key  *string
        item **entity.Budget
        ttl  **time.Duration
}

// BudgetCacheRepositoryMockSaveBudgetResults contains results of the BudgetCacheRepository.SaveBudget
type BudgetCacheRepositoryMockSaveBudgetResults struct {
        err error
}

// BudgetCacheRepositoryMockSaveBudgetOrigins contains origins of expectations of the BudgetCacheRepository.SaveBudget
type BudgetCacheRepositoryMockSaveBudgetExpectationOrigins struct {
        origin     string
        originCtx  string
        originKey  string
        originItem string
        originTtl  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) Optional() *mBudgetCacheRepositoryMockSaveBudget <span class="cov0" title="0">{
        mmSaveBudget.optional = true
        return mmSaveBudget
}</span>

// Expect sets up expected params for BudgetCacheRepository.SaveBudget
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) Expect(ctx context.Context, key string, item *entity.Budget, ttl *time.Duration) *mBudgetCacheRepositoryMockSaveBudget <span class="cov0" title="0">{
        if mmSaveBudget.mock.funcSaveBudget != nil </span><span class="cov0" title="0">{
                mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveBudget.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveBudget.defaultExpectation = &amp;BudgetCacheRepositoryMockSaveBudgetExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveBudget.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmSaveBudget.defaultExpectation.params = &amp;BudgetCacheRepositoryMockSaveBudgetParams{ctx, key, item, ttl}
        mmSaveBudget.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmSaveBudget.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmSaveBudget.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmSaveBudget.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveBudget.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmSaveBudget</span>
}

// ExpectCtxParam1 sets up expected param ctx for BudgetCacheRepository.SaveBudget
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) ExpectCtxParam1(ctx context.Context) *mBudgetCacheRepositoryMockSaveBudget <span class="cov0" title="0">{
        if mmSaveBudget.mock.funcSaveBudget != nil </span><span class="cov0" title="0">{
                mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveBudget.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveBudget.defaultExpectation = &amp;BudgetCacheRepositoryMockSaveBudgetExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveBudget.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSaveBudget.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSaveBudget.defaultExpectation.paramPtrs = &amp;BudgetCacheRepositoryMockSaveBudgetParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSaveBudget.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmSaveBudget.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmSaveBudget</span>
}

// ExpectKeyParam2 sets up expected param key for BudgetCacheRepository.SaveBudget
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) ExpectKeyParam2(key string) *mBudgetCacheRepositoryMockSaveBudget <span class="cov0" title="0">{
        if mmSaveBudget.mock.funcSaveBudget != nil </span><span class="cov0" title="0">{
                mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveBudget.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveBudget.defaultExpectation = &amp;BudgetCacheRepositoryMockSaveBudgetExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveBudget.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSaveBudget.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSaveBudget.defaultExpectation.paramPtrs = &amp;BudgetCacheRepositoryMockSaveBudgetParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSaveBudget.defaultExpectation.paramPtrs.key = &amp;key
        mmSaveBudget.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

        return mmSaveBudget</span>
}

// ExpectItemParam3 sets up expected param item for BudgetCacheRepository.SaveBudget
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) ExpectItemParam3(item *entity.Budget) *mBudgetCacheRepositoryMockSaveBudget <span class="cov0" title="0">{
        if mmSaveBudget.mock.funcSaveBudget != nil </span><span class="cov0" title="0">{
                mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveBudget.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveBudget.defaultExpectation = &amp;BudgetCacheRepositoryMockSaveBudgetExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveBudget.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSaveBudget.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSaveBudget.defaultExpectation.paramPtrs = &amp;BudgetCacheRepositoryMockSaveBudgetParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSaveBudget.defaultExpectation.paramPtrs.item = &amp;item
        mmSaveBudget.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

        return mmSaveBudget</span>
}

// ExpectTtlParam4 sets up expected param ttl for BudgetCacheRepository.SaveBudget
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) ExpectTtlParam4(ttl *time.Duration) *mBudgetCacheRepositoryMockSaveBudget <span class="cov0" title="0">{
        if mmSaveBudget.mock.funcSaveBudget != nil </span><span class="cov0" title="0">{
                mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveBudget.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveBudget.defaultExpectation = &amp;BudgetCacheRepositoryMockSaveBudgetExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveBudget.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSaveBudget.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSaveBudget.defaultExpectation.paramPtrs = &amp;BudgetCacheRepositoryMockSaveBudgetParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSaveBudget.defaultExpectation.paramPtrs.ttl = &amp;ttl
        mmSaveBudget.defaultExpectation.expectationOrigins.originTtl = minimock.CallerInfo(1)

        return mmSaveBudget</span>
}

// Inspect accepts an inspector function that has same arguments as the BudgetCacheRepository.SaveBudget
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) Inspect(f func(ctx context.Context, key string, item *entity.Budget, ttl *time.Duration)) *mBudgetCacheRepositoryMockSaveBudget <span class="cov0" title="0">{
        if mmSaveBudget.mock.inspectFuncSaveBudget != nil </span><span class="cov0" title="0">{
                mmSaveBudget.mock.t.Fatalf("Inspect function is already set for BudgetCacheRepositoryMock.SaveBudget")
        }</span>

        <span class="cov0" title="0">mmSaveBudget.mock.inspectFuncSaveBudget = f

        return mmSaveBudget</span>
}

// Return sets up results that will be returned by BudgetCacheRepository.SaveBudget
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) Return(err error) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        if mmSaveBudget.mock.funcSaveBudget != nil </span><span class="cov0" title="0">{
                mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveBudget.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveBudget.defaultExpectation = &amp;BudgetCacheRepositoryMockSaveBudgetExpectation{mock: mmSaveBudget.mock}
        }</span>
        <span class="cov0" title="0">mmSaveBudget.defaultExpectation.results = &amp;BudgetCacheRepositoryMockSaveBudgetResults{err}
        mmSaveBudget.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmSaveBudget.mock</span>
}

// Set uses given function f to mock the BudgetCacheRepository.SaveBudget method
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) Set(f func(ctx context.Context, key string, item *entity.Budget, ttl *time.Duration) (err error)) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        if mmSaveBudget.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmSaveBudget.mock.t.Fatalf("Default expectation is already set for the BudgetCacheRepository.SaveBudget method")
        }</span>

        <span class="cov0" title="0">if len(mmSaveBudget.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmSaveBudget.mock.t.Fatalf("Some expectations are already set for the BudgetCacheRepository.SaveBudget method")
        }</span>

        <span class="cov0" title="0">mmSaveBudget.mock.funcSaveBudget = f
        mmSaveBudget.mock.funcSaveBudgetOrigin = minimock.CallerInfo(1)
        return mmSaveBudget.mock</span>
}

// When sets expectation for the BudgetCacheRepository.SaveBudget which will trigger the result defined by the following
// Then helper
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) When(ctx context.Context, key string, item *entity.Budget, ttl *time.Duration) *BudgetCacheRepositoryMockSaveBudgetExpectation <span class="cov0" title="0">{
        if mmSaveBudget.mock.funcSaveBudget != nil </span><span class="cov0" title="0">{
                mmSaveBudget.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudget mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;BudgetCacheRepositoryMockSaveBudgetExpectation{
                mock:               mmSaveBudget.mock,
                params:             &amp;BudgetCacheRepositoryMockSaveBudgetParams{ctx, key, item, ttl},
                expectationOrigins: BudgetCacheRepositoryMockSaveBudgetExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmSaveBudget.expectations = append(mmSaveBudget.expectations, expectation)
        return expectation</span>
}

// Then sets up BudgetCacheRepository.SaveBudget return parameters for the expectation previously defined by the When method
func (e *BudgetCacheRepositoryMockSaveBudgetExpectation) Then(err error) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;BudgetCacheRepositoryMockSaveBudgetResults{err}
        return e.mock
}</span>

// Times sets number of times BudgetCacheRepository.SaveBudget should be invoked
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) Times(n uint64) *mBudgetCacheRepositoryMockSaveBudget <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmSaveBudget.mock.t.Fatalf("Times of BudgetCacheRepositoryMock.SaveBudget mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmSaveBudget.expectedInvocations, n)
        mmSaveBudget.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmSaveBudget</span>
}

func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmSaveBudget.expectations) == 0 &amp;&amp; mmSaveBudget.defaultExpectation == nil &amp;&amp; mmSaveBudget.mock.funcSaveBudget == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmSaveBudget.mock.afterSaveBudgetCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmSaveBudget.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// SaveBudget implements mm_usecase.BudgetCacheRepository
func (mmSaveBudget *BudgetCacheRepositoryMock) SaveBudget(ctx context.Context, key string, item *entity.Budget, ttl *time.Duration) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmSaveBudget.beforeSaveBudgetCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmSaveBudget.afterSaveBudgetCounter, 1)

        mmSaveBudget.t.Helper()

        if mmSaveBudget.inspectFuncSaveBudget != nil </span><span class="cov0" title="0">{
                mmSaveBudget.inspectFuncSaveBudget(ctx, key, item, ttl)
        }</span>

        <span class="cov0" title="0">mm_params := BudgetCacheRepositoryMockSaveBudgetParams{ctx, key, item, ttl}

        // Record call args
        mmSaveBudget.SaveBudgetMock.mutex.Lock()
        mmSaveBudget.SaveBudgetMock.callArgs = append(mmSaveBudget.SaveBudgetMock.callArgs, &amp;mm_params)
        mmSaveBudget.SaveBudgetMock.mutex.Unlock()

        for _, e := range mmSaveBudget.SaveBudgetMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmSaveBudget.SaveBudgetMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmSaveBudget.SaveBudgetMock.defaultExpectation.Counter, 1)
                mm_want := mmSaveBudget.SaveBudgetMock.defaultExpectation.params
                mm_want_ptrs := mmSaveBudget.SaveBudgetMock.defaultExpectation.paramPtrs

                mm_got := BudgetCacheRepositoryMockSaveBudgetParams{ctx, key, item, ttl}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmSaveBudget.t.Errorf("BudgetCacheRepositoryMock.SaveBudget got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmSaveBudget.SaveBudgetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.key != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.key, mm_got.key) </span><span class="cov0" title="0">{
                                mmSaveBudget.t.Errorf("BudgetCacheRepositoryMock.SaveBudget got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmSaveBudget.SaveBudgetMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.item != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.item, mm_got.item) </span><span class="cov0" title="0">{
                                mmSaveBudget.t.Errorf("BudgetCacheRepositoryMock.SaveBudget got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmSaveBudget.SaveBudgetMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.ttl != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ttl, mm_got.ttl) </span><span class="cov0" title="0">{
                                mmSaveBudget.t.Errorf("BudgetCacheRepositoryMock.SaveBudget got unexpected parameter ttl, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmSaveBudget.SaveBudgetMock.defaultExpectation.expectationOrigins.originTtl, *mm_want_ptrs.ttl, mm_got.ttl, minimock.Diff(*mm_want_ptrs.ttl, mm_got.ttl))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmSaveBudget.t.Errorf("BudgetCacheRepositoryMock.SaveBudget got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmSaveBudget.SaveBudgetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmSaveBudget.SaveBudgetMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmSaveBudget.t.Fatal("No results are set for the BudgetCacheRepositoryMock.SaveBudget")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmSaveBudget.funcSaveBudget != nil </span><span class="cov0" title="0">{
                return mmSaveBudget.funcSaveBudget(ctx, key, item, ttl)
        }</span>
        <span class="cov0" title="0">mmSaveBudget.t.Fatalf("Unexpected call to BudgetCacheRepositoryMock.SaveBudget. %v %v %v %v", ctx, key, item, ttl)
        return</span>
}

// SaveBudgetAfterCounter returns a count of finished BudgetCacheRepositoryMock.SaveBudget invocations
func (mmSaveBudget *BudgetCacheRepositoryMock) SaveBudgetAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmSaveBudget.afterSaveBudgetCounter)
}</span>

// SaveBudgetBeforeCounter returns a count of BudgetCacheRepositoryMock.SaveBudget invocations
func (mmSaveBudget *BudgetCacheRepositoryMock) SaveBudgetBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmSaveBudget.beforeSaveBudgetCounter)
}</span>

// Calls returns a list of arguments used in each call to BudgetCacheRepositoryMock.SaveBudget.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveBudget *mBudgetCacheRepositoryMockSaveBudget) Calls() []*BudgetCacheRepositoryMockSaveBudgetParams <span class="cov0" title="0">{
        mmSaveBudget.mutex.RLock()

        argCopy := make([]*BudgetCacheRepositoryMockSaveBudgetParams, len(mmSaveBudget.callArgs))
        copy(argCopy, mmSaveBudget.callArgs)

        mmSaveBudget.mutex.RUnlock()

        return argCopy
}</span>

// MinimockSaveBudgetDone returns true if the count of the SaveBudget invocations corresponds
// the number of defined expectations
func (m *BudgetCacheRepositoryMock) MinimockSaveBudgetDone() bool <span class="cov0" title="0">{
        if m.SaveBudgetMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.SaveBudgetMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.SaveBudgetMock.invocationsDone()</span>
}

// MinimockSaveBudgetInspect logs each unmet expectation
func (m *BudgetCacheRepositoryMock) MinimockSaveBudgetInspect() <span class="cov0" title="0">{
        for _, e := range m.SaveBudgetMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudget at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterSaveBudgetCounter := mm_atomic.LoadUint64(&amp;m.afterSaveBudgetCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.SaveBudgetMock.defaultExpectation != nil &amp;&amp; afterSaveBudgetCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.SaveBudgetMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudget at\n%s", m.SaveBudgetMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudget at\n%s with params: %#v", m.SaveBudgetMock.defaultExpectation.expectationOrigins.origin, *m.SaveBudgetMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcSaveBudget != nil &amp;&amp; afterSaveBudgetCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudget at\n%s", m.funcSaveBudgetOrigin)
        }</span>

        <span class="cov0" title="0">if !m.SaveBudgetMock.invocationsDone() &amp;&amp; afterSaveBudgetCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to BudgetCacheRepositoryMock.SaveBudget at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.SaveBudgetMock.expectedInvocations), m.SaveBudgetMock.expectedInvocationsOrigin, afterSaveBudgetCounter)
        }</span>
}

type mBudgetCacheRepositoryMockSaveBudgetsList struct {
        optional           bool
        mock               *BudgetCacheRepositoryMock
        defaultExpectation *BudgetCacheRepositoryMockSaveBudgetsListExpectation
        expectations       []*BudgetCacheRepositoryMockSaveBudgetsListExpectation

        callArgs []*BudgetCacheRepositoryMockSaveBudgetsListParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// BudgetCacheRepositoryMockSaveBudgetsListExpectation specifies expectation struct of the BudgetCacheRepository.SaveBudgetsList
type BudgetCacheRepositoryMockSaveBudgetsListExpectation struct {
        mock               *BudgetCacheRepositoryMock
        params             *BudgetCacheRepositoryMockSaveBudgetsListParams
        paramPtrs          *BudgetCacheRepositoryMockSaveBudgetsListParamPtrs
        expectationOrigins BudgetCacheRepositoryMockSaveBudgetsListExpectationOrigins
        results            *BudgetCacheRepositoryMockSaveBudgetsListResults
        returnOrigin       string
        Counter            uint64
}

// BudgetCacheRepositoryMockSaveBudgetsListParams contains parameters of the BudgetCacheRepository.SaveBudgetsList
type BudgetCacheRepositoryMockSaveBudgetsListParams struct {
        ctx   context.Context
        key   string
        items []*entity.Budget
        ttl   *time.Duration
}

// BudgetCacheRepositoryMockSaveBudgetsListParamPtrs contains pointers to parameters of the BudgetCacheRepository.SaveBudgetsList
type BudgetCacheRepositoryMockSaveBudgetsListParamPtrs struct {
        ctx   *context.Context
        key   *string
        items *[]*entity.Budget
        ttl   **time.Duration
}

// BudgetCacheRepositoryMockSaveBudgetsListResults contains results of the BudgetCacheRepository.SaveBudgetsList
type BudgetCacheRepositoryMockSaveBudgetsListResults struct {
        err error
}

// BudgetCacheRepositoryMockSaveBudgetsListOrigins contains origins of expectations of the BudgetCacheRepository.SaveBudgetsList
type BudgetCacheRepositoryMockSaveBudgetsListExpectationOrigins struct {
        origin      string
        originCtx   string
        originKey   string
        originItems string
        originTtl   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) Optional() *mBudgetCacheRepositoryMockSaveBudgetsList <span class="cov0" title="0">{
        mmSaveBudgetsList.optional = true
        return mmSaveBudgetsList
}</span>

// Expect sets up expected params for BudgetCacheRepository.SaveBudgetsList
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) Expect(ctx context.Context, key string, items []*entity.Budget, ttl *time.Duration) *mBudgetCacheRepositoryMockSaveBudgetsList <span class="cov0" title="0">{
        if mmSaveBudgetsList.mock.funcSaveBudgetsList != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.defaultExpectation = &amp;BudgetCacheRepositoryMockSaveBudgetsListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsList.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmSaveBudgetsList.defaultExpectation.params = &amp;BudgetCacheRepositoryMockSaveBudgetsListParams{ctx, key, items, ttl}
        mmSaveBudgetsList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmSaveBudgetsList.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmSaveBudgetsList.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmSaveBudgetsList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveBudgetsList.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmSaveBudgetsList</span>
}

// ExpectCtxParam1 sets up expected param ctx for BudgetCacheRepository.SaveBudgetsList
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) ExpectCtxParam1(ctx context.Context) *mBudgetCacheRepositoryMockSaveBudgetsList <span class="cov0" title="0">{
        if mmSaveBudgetsList.mock.funcSaveBudgetsList != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.defaultExpectation = &amp;BudgetCacheRepositoryMockSaveBudgetsListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.defaultExpectation.paramPtrs = &amp;BudgetCacheRepositoryMockSaveBudgetsListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSaveBudgetsList.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmSaveBudgetsList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmSaveBudgetsList</span>
}

// ExpectKeyParam2 sets up expected param key for BudgetCacheRepository.SaveBudgetsList
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) ExpectKeyParam2(key string) *mBudgetCacheRepositoryMockSaveBudgetsList <span class="cov0" title="0">{
        if mmSaveBudgetsList.mock.funcSaveBudgetsList != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.defaultExpectation = &amp;BudgetCacheRepositoryMockSaveBudgetsListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.defaultExpectation.paramPtrs = &amp;BudgetCacheRepositoryMockSaveBudgetsListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSaveBudgetsList.defaultExpectation.paramPtrs.key = &amp;key
        mmSaveBudgetsList.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

        return mmSaveBudgetsList</span>
}

// ExpectItemsParam3 sets up expected param items for BudgetCacheRepository.SaveBudgetsList
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) ExpectItemsParam3(items []*entity.Budget) *mBudgetCacheRepositoryMockSaveBudgetsList <span class="cov0" title="0">{
        if mmSaveBudgetsList.mock.funcSaveBudgetsList != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.defaultExpectation = &amp;BudgetCacheRepositoryMockSaveBudgetsListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.defaultExpectation.paramPtrs = &amp;BudgetCacheRepositoryMockSaveBudgetsListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSaveBudgetsList.defaultExpectation.paramPtrs.items = &amp;items
        mmSaveBudgetsList.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

        return mmSaveBudgetsList</span>
}

// ExpectTtlParam4 sets up expected param ttl for BudgetCacheRepository.SaveBudgetsList
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) ExpectTtlParam4(ttl *time.Duration) *mBudgetCacheRepositoryMockSaveBudgetsList <span class="cov0" title="0">{
        if mmSaveBudgetsList.mock.funcSaveBudgetsList != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.defaultExpectation = &amp;BudgetCacheRepositoryMockSaveBudgetsListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.defaultExpectation.paramPtrs = &amp;BudgetCacheRepositoryMockSaveBudgetsListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSaveBudgetsList.defaultExpectation.paramPtrs.ttl = &amp;ttl
        mmSaveBudgetsList.defaultExpectation.expectationOrigins.originTtl = minimock.CallerInfo(1)

        return mmSaveBudgetsList</span>
}

// Inspect accepts an inspector function that has same arguments as the BudgetCacheRepository.SaveBudgetsList
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) Inspect(f func(ctx context.Context, key string, items []*entity.Budget, ttl *time.Duration)) *mBudgetCacheRepositoryMockSaveBudgetsList <span class="cov0" title="0">{
        if mmSaveBudgetsList.mock.inspectFuncSaveBudgetsList != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.mock.t.Fatalf("Inspect function is already set for BudgetCacheRepositoryMock.SaveBudgetsList")
        }</span>

        <span class="cov0" title="0">mmSaveBudgetsList.mock.inspectFuncSaveBudgetsList = f

        return mmSaveBudgetsList</span>
}

// Return sets up results that will be returned by BudgetCacheRepository.SaveBudgetsList
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) Return(err error) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        if mmSaveBudgetsList.mock.funcSaveBudgetsList != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.defaultExpectation = &amp;BudgetCacheRepositoryMockSaveBudgetsListExpectation{mock: mmSaveBudgetsList.mock}
        }</span>
        <span class="cov0" title="0">mmSaveBudgetsList.defaultExpectation.results = &amp;BudgetCacheRepositoryMockSaveBudgetsListResults{err}
        mmSaveBudgetsList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmSaveBudgetsList.mock</span>
}

// Set uses given function f to mock the BudgetCacheRepository.SaveBudgetsList method
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) Set(f func(ctx context.Context, key string, items []*entity.Budget, ttl *time.Duration) (err error)) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        if mmSaveBudgetsList.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.mock.t.Fatalf("Default expectation is already set for the BudgetCacheRepository.SaveBudgetsList method")
        }</span>

        <span class="cov0" title="0">if len(mmSaveBudgetsList.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmSaveBudgetsList.mock.t.Fatalf("Some expectations are already set for the BudgetCacheRepository.SaveBudgetsList method")
        }</span>

        <span class="cov0" title="0">mmSaveBudgetsList.mock.funcSaveBudgetsList = f
        mmSaveBudgetsList.mock.funcSaveBudgetsListOrigin = minimock.CallerInfo(1)
        return mmSaveBudgetsList.mock</span>
}

// When sets expectation for the BudgetCacheRepository.SaveBudgetsList which will trigger the result defined by the following
// Then helper
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) When(ctx context.Context, key string, items []*entity.Budget, ttl *time.Duration) *BudgetCacheRepositoryMockSaveBudgetsListExpectation <span class="cov0" title="0">{
        if mmSaveBudgetsList.mock.funcSaveBudgetsList != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;BudgetCacheRepositoryMockSaveBudgetsListExpectation{
                mock:               mmSaveBudgetsList.mock,
                params:             &amp;BudgetCacheRepositoryMockSaveBudgetsListParams{ctx, key, items, ttl},
                expectationOrigins: BudgetCacheRepositoryMockSaveBudgetsListExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmSaveBudgetsList.expectations = append(mmSaveBudgetsList.expectations, expectation)
        return expectation</span>
}

// Then sets up BudgetCacheRepository.SaveBudgetsList return parameters for the expectation previously defined by the When method
func (e *BudgetCacheRepositoryMockSaveBudgetsListExpectation) Then(err error) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;BudgetCacheRepositoryMockSaveBudgetsListResults{err}
        return e.mock
}</span>

// Times sets number of times BudgetCacheRepository.SaveBudgetsList should be invoked
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) Times(n uint64) *mBudgetCacheRepositoryMockSaveBudgetsList <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmSaveBudgetsList.mock.t.Fatalf("Times of BudgetCacheRepositoryMock.SaveBudgetsList mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmSaveBudgetsList.expectedInvocations, n)
        mmSaveBudgetsList.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmSaveBudgetsList</span>
}

func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmSaveBudgetsList.expectations) == 0 &amp;&amp; mmSaveBudgetsList.defaultExpectation == nil &amp;&amp; mmSaveBudgetsList.mock.funcSaveBudgetsList == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmSaveBudgetsList.mock.afterSaveBudgetsListCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmSaveBudgetsList.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// SaveBudgetsList implements mm_usecase.BudgetCacheRepository
func (mmSaveBudgetsList *BudgetCacheRepositoryMock) SaveBudgetsList(ctx context.Context, key string, items []*entity.Budget, ttl *time.Duration) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmSaveBudgetsList.beforeSaveBudgetsListCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmSaveBudgetsList.afterSaveBudgetsListCounter, 1)

        mmSaveBudgetsList.t.Helper()

        if mmSaveBudgetsList.inspectFuncSaveBudgetsList != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsList.inspectFuncSaveBudgetsList(ctx, key, items, ttl)
        }</span>

        <span class="cov0" title="0">mm_params := BudgetCacheRepositoryMockSaveBudgetsListParams{ctx, key, items, ttl}

        // Record call args
        mmSaveBudgetsList.SaveBudgetsListMock.mutex.Lock()
        mmSaveBudgetsList.SaveBudgetsListMock.callArgs = append(mmSaveBudgetsList.SaveBudgetsListMock.callArgs, &amp;mm_params)
        mmSaveBudgetsList.SaveBudgetsListMock.mutex.Unlock()

        for _, e := range mmSaveBudgetsList.SaveBudgetsListMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmSaveBudgetsList.SaveBudgetsListMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmSaveBudgetsList.SaveBudgetsListMock.defaultExpectation.Counter, 1)
                mm_want := mmSaveBudgetsList.SaveBudgetsListMock.defaultExpectation.params
                mm_want_ptrs := mmSaveBudgetsList.SaveBudgetsListMock.defaultExpectation.paramPtrs

                mm_got := BudgetCacheRepositoryMockSaveBudgetsListParams{ctx, key, items, ttl}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmSaveBudgetsList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmSaveBudgetsList.SaveBudgetsListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.key != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.key, mm_got.key) </span><span class="cov0" title="0">{
                                mmSaveBudgetsList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsList got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmSaveBudgetsList.SaveBudgetsListMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.items != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.items, mm_got.items) </span><span class="cov0" title="0">{
                                mmSaveBudgetsList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsList got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmSaveBudgetsList.SaveBudgetsListMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.ttl != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ttl, mm_got.ttl) </span><span class="cov0" title="0">{
                                mmSaveBudgetsList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsList got unexpected parameter ttl, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmSaveBudgetsList.SaveBudgetsListMock.defaultExpectation.expectationOrigins.originTtl, *mm_want_ptrs.ttl, mm_got.ttl, minimock.Diff(*mm_want_ptrs.ttl, mm_got.ttl))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmSaveBudgetsList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmSaveBudgetsList.SaveBudgetsListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmSaveBudgetsList.SaveBudgetsListMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmSaveBudgetsList.t.Fatal("No results are set for the BudgetCacheRepositoryMock.SaveBudgetsList")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmSaveBudgetsList.funcSaveBudgetsList != nil </span><span class="cov0" title="0">{
                return mmSaveBudgetsList.funcSaveBudgetsList(ctx, key, items, ttl)
        }</span>
        <span class="cov0" title="0">mmSaveBudgetsList.t.Fatalf("Unexpected call to BudgetCacheRepositoryMock.SaveBudgetsList. %v %v %v %v", ctx, key, items, ttl)
        return</span>
}

// SaveBudgetsListAfterCounter returns a count of finished BudgetCacheRepositoryMock.SaveBudgetsList invocations
func (mmSaveBudgetsList *BudgetCacheRepositoryMock) SaveBudgetsListAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmSaveBudgetsList.afterSaveBudgetsListCounter)
}</span>

// SaveBudgetsListBeforeCounter returns a count of BudgetCacheRepositoryMock.SaveBudgetsList invocations
func (mmSaveBudgetsList *BudgetCacheRepositoryMock) SaveBudgetsListBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmSaveBudgetsList.beforeSaveBudgetsListCounter)
}</span>

// Calls returns a list of arguments used in each call to BudgetCacheRepositoryMock.SaveBudgetsList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveBudgetsList *mBudgetCacheRepositoryMockSaveBudgetsList) Calls() []*BudgetCacheRepositoryMockSaveBudgetsListParams <span class="cov0" title="0">{
        mmSaveBudgetsList.mutex.RLock()

        argCopy := make([]*BudgetCacheRepositoryMockSaveBudgetsListParams, len(mmSaveBudgetsList.callArgs))
        copy(argCopy, mmSaveBudgetsList.callArgs)

        mmSaveBudgetsList.mutex.RUnlock()

        return argCopy
}</span>

// MinimockSaveBudgetsListDone returns true if the count of the SaveBudgetsList invocations corresponds
// the number of defined expectations
func (m *BudgetCacheRepositoryMock) MinimockSaveBudgetsListDone() bool <span class="cov0" title="0">{
        if m.SaveBudgetsListMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.SaveBudgetsListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.SaveBudgetsListMock.invocationsDone()</span>
}

// MinimockSaveBudgetsListInspect logs each unmet expectation
func (m *BudgetCacheRepositoryMock) MinimockSaveBudgetsListInspect() <span class="cov0" title="0">{
        for _, e := range m.SaveBudgetsListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudgetsList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterSaveBudgetsListCounter := mm_atomic.LoadUint64(&amp;m.afterSaveBudgetsListCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.SaveBudgetsListMock.defaultExpectation != nil &amp;&amp; afterSaveBudgetsListCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.SaveBudgetsListMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudgetsList at\n%s", m.SaveBudgetsListMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudgetsList at\n%s with params: %#v", m.SaveBudgetsListMock.defaultExpectation.expectationOrigins.origin, *m.SaveBudgetsListMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcSaveBudgetsList != nil &amp;&amp; afterSaveBudgetsListCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudgetsList at\n%s", m.funcSaveBudgetsListOrigin)
        }</span>

        <span class="cov0" title="0">if !m.SaveBudgetsListMock.invocationsDone() &amp;&amp; afterSaveBudgetsListCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to BudgetCacheRepositoryMock.SaveBudgetsList at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.SaveBudgetsListMock.expectedInvocations), m.SaveBudgetsListMock.expectedInvocationsOrigin, afterSaveBudgetsListCounter)
        }</span>
}

type mBudgetCacheRepositoryMockSaveBudgetsPagedList struct {
        optional           bool
        mock               *BudgetCacheRepositoryMock
        defaultExpectation *BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation
        expectations       []*BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation

        callArgs []*BudgetCacheRepositoryMockSaveBudgetsPagedListParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation specifies expectation struct of the BudgetCacheRepository.SaveBudgetsPagedList
type BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation struct {
        mock               *BudgetCacheRepositoryMock
        params             *BudgetCacheRepositoryMockSaveBudgetsPagedListParams
        paramPtrs          *BudgetCacheRepositoryMockSaveBudgetsPagedListParamPtrs
        expectationOrigins BudgetCacheRepositoryMockSaveBudgetsPagedListExpectationOrigins
        results            *BudgetCacheRepositoryMockSaveBudgetsPagedListResults
        returnOrigin       string
        Counter            uint64
}

// BudgetCacheRepositoryMockSaveBudgetsPagedListParams contains parameters of the BudgetCacheRepository.SaveBudgetsPagedList
type BudgetCacheRepositoryMockSaveBudgetsPagedListParams struct {
        ctx   context.Context
        key   string
        items []*entity.Budget
        total uint64
        ttl   *time.Duration
}

// BudgetCacheRepositoryMockSaveBudgetsPagedListParamPtrs contains pointers to parameters of the BudgetCacheRepository.SaveBudgetsPagedList
type BudgetCacheRepositoryMockSaveBudgetsPagedListParamPtrs struct {
        ctx   *context.Context
        key   *string
        items *[]*entity.Budget
        total *uint64
        ttl   **time.Duration
}

// BudgetCacheRepositoryMockSaveBudgetsPagedListResults contains results of the BudgetCacheRepository.SaveBudgetsPagedList
type BudgetCacheRepositoryMockSaveBudgetsPagedListResults struct {
        err error
}

// BudgetCacheRepositoryMockSaveBudgetsPagedListOrigins contains origins of expectations of the BudgetCacheRepository.SaveBudgetsPagedList
type BudgetCacheRepositoryMockSaveBudgetsPagedListExpectationOrigins struct {
        origin      string
        originCtx   string
        originKey   string
        originItems string
        originTotal string
        originTtl   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) Optional() *mBudgetCacheRepositoryMockSaveBudgetsPagedList <span class="cov0" title="0">{
        mmSaveBudgetsPagedList.optional = true
        return mmSaveBudgetsPagedList
}</span>

// Expect sets up expected params for BudgetCacheRepository.SaveBudgetsPagedList
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) Expect(ctx context.Context, key string, items []*entity.Budget, total uint64, ttl *time.Duration) *mBudgetCacheRepositoryMockSaveBudgetsPagedList <span class="cov0" title="0">{
        if mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedList != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.defaultExpectation = &amp;BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsPagedList.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmSaveBudgetsPagedList.defaultExpectation.params = &amp;BudgetCacheRepositoryMockSaveBudgetsPagedListParams{ctx, key, items, total, ttl}
        mmSaveBudgetsPagedList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmSaveBudgetsPagedList.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmSaveBudgetsPagedList.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmSaveBudgetsPagedList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveBudgetsPagedList.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmSaveBudgetsPagedList</span>
}

// ExpectCtxParam1 sets up expected param ctx for BudgetCacheRepository.SaveBudgetsPagedList
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) ExpectCtxParam1(ctx context.Context) *mBudgetCacheRepositoryMockSaveBudgetsPagedList <span class="cov0" title="0">{
        if mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedList != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.defaultExpectation = &amp;BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.defaultExpectation.paramPtrs = &amp;BudgetCacheRepositoryMockSaveBudgetsPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSaveBudgetsPagedList.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmSaveBudgetsPagedList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmSaveBudgetsPagedList</span>
}

// ExpectKeyParam2 sets up expected param key for BudgetCacheRepository.SaveBudgetsPagedList
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) ExpectKeyParam2(key string) *mBudgetCacheRepositoryMockSaveBudgetsPagedList <span class="cov0" title="0">{
        if mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedList != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.defaultExpectation = &amp;BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.defaultExpectation.paramPtrs = &amp;BudgetCacheRepositoryMockSaveBudgetsPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSaveBudgetsPagedList.defaultExpectation.paramPtrs.key = &amp;key
        mmSaveBudgetsPagedList.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

        return mmSaveBudgetsPagedList</span>
}

// ExpectItemsParam3 sets up expected param items for BudgetCacheRepository.SaveBudgetsPagedList
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) ExpectItemsParam3(items []*entity.Budget) *mBudgetCacheRepositoryMockSaveBudgetsPagedList <span class="cov0" title="0">{
        if mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedList != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.defaultExpectation = &amp;BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.defaultExpectation.paramPtrs = &amp;BudgetCacheRepositoryMockSaveBudgetsPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSaveBudgetsPagedList.defaultExpectation.paramPtrs.items = &amp;items
        mmSaveBudgetsPagedList.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

        return mmSaveBudgetsPagedList</span>
}

// ExpectTotalParam4 sets up expected param total for BudgetCacheRepository.SaveBudgetsPagedList
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) ExpectTotalParam4(total uint64) *mBudgetCacheRepositoryMockSaveBudgetsPagedList <span class="cov0" title="0">{
        if mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedList != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.defaultExpectation = &amp;BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.defaultExpectation.paramPtrs = &amp;BudgetCacheRepositoryMockSaveBudgetsPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSaveBudgetsPagedList.defaultExpectation.paramPtrs.total = &amp;total
        mmSaveBudgetsPagedList.defaultExpectation.expectationOrigins.originTotal = minimock.CallerInfo(1)

        return mmSaveBudgetsPagedList</span>
}

// ExpectTtlParam5 sets up expected param ttl for BudgetCacheRepository.SaveBudgetsPagedList
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) ExpectTtlParam5(ttl *time.Duration) *mBudgetCacheRepositoryMockSaveBudgetsPagedList <span class="cov0" title="0">{
        if mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedList != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.defaultExpectation = &amp;BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.defaultExpectation.paramPtrs = &amp;BudgetCacheRepositoryMockSaveBudgetsPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSaveBudgetsPagedList.defaultExpectation.paramPtrs.ttl = &amp;ttl
        mmSaveBudgetsPagedList.defaultExpectation.expectationOrigins.originTtl = minimock.CallerInfo(1)

        return mmSaveBudgetsPagedList</span>
}

// Inspect accepts an inspector function that has same arguments as the BudgetCacheRepository.SaveBudgetsPagedList
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) Inspect(f func(ctx context.Context, key string, items []*entity.Budget, total uint64, ttl *time.Duration)) *mBudgetCacheRepositoryMockSaveBudgetsPagedList <span class="cov0" title="0">{
        if mmSaveBudgetsPagedList.mock.inspectFuncSaveBudgetsPagedList != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.mock.t.Fatalf("Inspect function is already set for BudgetCacheRepositoryMock.SaveBudgetsPagedList")
        }</span>

        <span class="cov0" title="0">mmSaveBudgetsPagedList.mock.inspectFuncSaveBudgetsPagedList = f

        return mmSaveBudgetsPagedList</span>
}

// Return sets up results that will be returned by BudgetCacheRepository.SaveBudgetsPagedList
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) Return(err error) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        if mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedList != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveBudgetsPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.defaultExpectation = &amp;BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation{mock: mmSaveBudgetsPagedList.mock}
        }</span>
        <span class="cov0" title="0">mmSaveBudgetsPagedList.defaultExpectation.results = &amp;BudgetCacheRepositoryMockSaveBudgetsPagedListResults{err}
        mmSaveBudgetsPagedList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmSaveBudgetsPagedList.mock</span>
}

// Set uses given function f to mock the BudgetCacheRepository.SaveBudgetsPagedList method
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) Set(f func(ctx context.Context, key string, items []*entity.Budget, total uint64, ttl *time.Duration) (err error)) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        if mmSaveBudgetsPagedList.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.mock.t.Fatalf("Default expectation is already set for the BudgetCacheRepository.SaveBudgetsPagedList method")
        }</span>

        <span class="cov0" title="0">if len(mmSaveBudgetsPagedList.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.mock.t.Fatalf("Some expectations are already set for the BudgetCacheRepository.SaveBudgetsPagedList method")
        }</span>

        <span class="cov0" title="0">mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedList = f
        mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedListOrigin = minimock.CallerInfo(1)
        return mmSaveBudgetsPagedList.mock</span>
}

// When sets expectation for the BudgetCacheRepository.SaveBudgetsPagedList which will trigger the result defined by the following
// Then helper
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) When(ctx context.Context, key string, items []*entity.Budget, total uint64, ttl *time.Duration) *BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation <span class="cov0" title="0">{
        if mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedList != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.mock.t.Fatalf("BudgetCacheRepositoryMock.SaveBudgetsPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation{
                mock:               mmSaveBudgetsPagedList.mock,
                params:             &amp;BudgetCacheRepositoryMockSaveBudgetsPagedListParams{ctx, key, items, total, ttl},
                expectationOrigins: BudgetCacheRepositoryMockSaveBudgetsPagedListExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmSaveBudgetsPagedList.expectations = append(mmSaveBudgetsPagedList.expectations, expectation)
        return expectation</span>
}

// Then sets up BudgetCacheRepository.SaveBudgetsPagedList return parameters for the expectation previously defined by the When method
func (e *BudgetCacheRepositoryMockSaveBudgetsPagedListExpectation) Then(err error) *BudgetCacheRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;BudgetCacheRepositoryMockSaveBudgetsPagedListResults{err}
        return e.mock
}</span>

// Times sets number of times BudgetCacheRepository.SaveBudgetsPagedList should be invoked
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) Times(n uint64) *mBudgetCacheRepositoryMockSaveBudgetsPagedList <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.mock.t.Fatalf("Times of BudgetCacheRepositoryMock.SaveBudgetsPagedList mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmSaveBudgetsPagedList.expectedInvocations, n)
        mmSaveBudgetsPagedList.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmSaveBudgetsPagedList</span>
}

func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmSaveBudgetsPagedList.expectations) == 0 &amp;&amp; mmSaveBudgetsPagedList.defaultExpectation == nil &amp;&amp; mmSaveBudgetsPagedList.mock.funcSaveBudgetsPagedList == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmSaveBudgetsPagedList.mock.afterSaveBudgetsPagedListCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmSaveBudgetsPagedList.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// SaveBudgetsPagedList implements mm_usecase.BudgetCacheRepository
func (mmSaveBudgetsPagedList *BudgetCacheRepositoryMock) SaveBudgetsPagedList(ctx context.Context, key string, items []*entity.Budget, total uint64, ttl *time.Duration) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmSaveBudgetsPagedList.beforeSaveBudgetsPagedListCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmSaveBudgetsPagedList.afterSaveBudgetsPagedListCounter, 1)

        mmSaveBudgetsPagedList.t.Helper()

        if mmSaveBudgetsPagedList.inspectFuncSaveBudgetsPagedList != nil </span><span class="cov0" title="0">{
                mmSaveBudgetsPagedList.inspectFuncSaveBudgetsPagedList(ctx, key, items, total, ttl)
        }</span>

        <span class="cov0" title="0">mm_params := BudgetCacheRepositoryMockSaveBudgetsPagedListParams{ctx, key, items, total, ttl}

        // Record call args
        mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.mutex.Lock()
        mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.callArgs = append(mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.callArgs, &amp;mm_params)
        mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.mutex.Unlock()

        for _, e := range mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation.Counter, 1)
                mm_want := mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation.params
                mm_want_ptrs := mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation.paramPtrs

                mm_got := BudgetCacheRepositoryMockSaveBudgetsPagedListParams{ctx, key, items, total, ttl}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmSaveBudgetsPagedList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsPagedList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.key != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.key, mm_got.key) </span><span class="cov0" title="0">{
                                mmSaveBudgetsPagedList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsPagedList got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.items != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.items, mm_got.items) </span><span class="cov0" title="0">{
                                mmSaveBudgetsPagedList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsPagedList got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.total != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.total, mm_got.total) </span><span class="cov0" title="0">{
                                mmSaveBudgetsPagedList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsPagedList got unexpected parameter total, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation.expectationOrigins.originTotal, *mm_want_ptrs.total, mm_got.total, minimock.Diff(*mm_want_ptrs.total, mm_got.total))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.ttl != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ttl, mm_got.ttl) </span><span class="cov0" title="0">{
                                mmSaveBudgetsPagedList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsPagedList got unexpected parameter ttl, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation.expectationOrigins.originTtl, *mm_want_ptrs.ttl, mm_got.ttl, minimock.Diff(*mm_want_ptrs.ttl, mm_got.ttl))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmSaveBudgetsPagedList.t.Errorf("BudgetCacheRepositoryMock.SaveBudgetsPagedList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmSaveBudgetsPagedList.SaveBudgetsPagedListMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmSaveBudgetsPagedList.t.Fatal("No results are set for the BudgetCacheRepositoryMock.SaveBudgetsPagedList")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmSaveBudgetsPagedList.funcSaveBudgetsPagedList != nil </span><span class="cov0" title="0">{
                return mmSaveBudgetsPagedList.funcSaveBudgetsPagedList(ctx, key, items, total, ttl)
        }</span>
        <span class="cov0" title="0">mmSaveBudgetsPagedList.t.Fatalf("Unexpected call to BudgetCacheRepositoryMock.SaveBudgetsPagedList. %v %v %v %v %v", ctx, key, items, total, ttl)
        return</span>
}

// SaveBudgetsPagedListAfterCounter returns a count of finished BudgetCacheRepositoryMock.SaveBudgetsPagedList invocations
func (mmSaveBudgetsPagedList *BudgetCacheRepositoryMock) SaveBudgetsPagedListAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmSaveBudgetsPagedList.afterSaveBudgetsPagedListCounter)
}</span>

// SaveBudgetsPagedListBeforeCounter returns a count of BudgetCacheRepositoryMock.SaveBudgetsPagedList invocations
func (mmSaveBudgetsPagedList *BudgetCacheRepositoryMock) SaveBudgetsPagedListBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmSaveBudgetsPagedList.beforeSaveBudgetsPagedListCounter)
}</span>

// Calls returns a list of arguments used in each call to BudgetCacheRepositoryMock.SaveBudgetsPagedList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveBudgetsPagedList *mBudgetCacheRepositoryMockSaveBudgetsPagedList) Calls() []*BudgetCacheRepositoryMockSaveBudgetsPagedListParams <span class="cov0" title="0">{
        mmSaveBudgetsPagedList.mutex.RLock()

        argCopy := make([]*BudgetCacheRepositoryMockSaveBudgetsPagedListParams, len(mmSaveBudgetsPagedList.callArgs))
        copy(argCopy, mmSaveBudgetsPagedList.callArgs)

        mmSaveBudgetsPagedList.mutex.RUnlock()

        return argCopy
}</span>

// MinimockSaveBudgetsPagedListDone returns true if the count of the SaveBudgetsPagedList invocations corresponds
// the number of defined expectations
func (m *BudgetCacheRepositoryMock) MinimockSaveBudgetsPagedListDone() bool <span class="cov0" title="0">{
        if m.SaveBudgetsPagedListMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.SaveBudgetsPagedListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.SaveBudgetsPagedListMock.invocationsDone()</span>
}

// MinimockSaveBudgetsPagedListInspect logs each unmet expectation
func (m *BudgetCacheRepositoryMock) MinimockSaveBudgetsPagedListInspect() <span class="cov0" title="0">{
        for _, e := range m.SaveBudgetsPagedListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudgetsPagedList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterSaveBudgetsPagedListCounter := mm_atomic.LoadUint64(&amp;m.afterSaveBudgetsPagedListCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.SaveBudgetsPagedListMock.defaultExpectation != nil &amp;&amp; afterSaveBudgetsPagedListCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.SaveBudgetsPagedListMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudgetsPagedList at\n%s", m.SaveBudgetsPagedListMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudgetsPagedList at\n%s with params: %#v", m.SaveBudgetsPagedListMock.defaultExpectation.expectationOrigins.origin, *m.SaveBudgetsPagedListMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcSaveBudgetsPagedList != nil &amp;&amp; afterSaveBudgetsPagedListCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to BudgetCacheRepositoryMock.SaveBudgetsPagedList at\n%s", m.funcSaveBudgetsPagedListOrigin)
        }</span>

        <span class="cov0" title="0">if !m.SaveBudgetsPagedListMock.invocationsDone() &amp;&amp; afterSaveBudgetsPagedListCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to BudgetCacheRepositoryMock.SaveBudgetsPagedList at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.SaveBudgetsPagedListMock.expectedInvocations), m.SaveBudgetsPagedListMock.expectedInvocationsOrigin, afterSaveBudgetsPagedListCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *BudgetCacheRepositoryMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockClearForPrefixesInspect()

                        m.MinimockGetBudgetInspect()

                        m.MinimockGetBudgetsListInspect()

                        m.MinimockGetBudgetsPagedListInspect()

                        m.MinimockSaveBudgetInspect()

                        m.MinimockSaveBudgetsListInspect()

                        m.MinimockSaveBudgetsPagedListInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *BudgetCacheRepositoryMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *BudgetCacheRepositoryMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockClearForPrefixesDone() &amp;&amp;
                m.MinimockGetBudgetDone() &amp;&amp;
                m.MinimockGetBudgetsListDone() &amp;&amp;
                m.MinimockGetBudgetsPagedListDone() &amp;&amp;
                m.MinimockSaveBudgetDone() &amp;&amp;
                m.MinimockSaveBudgetsListDone() &amp;&amp;
                m.MinimockSaveBudgetsPagedListDone()
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase.BudgetRepository -o budget_repository.go -n BudgetRepositoryMock -p mocks

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        mm_usecase "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
)

// BudgetRepositoryMock implements mm_usecase.BudgetRepository
type BudgetRepositoryMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcCreate          func(ctx context.Context, item *entity.Budget) (err error)
        funcCreateOrigin    string
        inspectFuncCreate   func(ctx context.Context, item *entity.Budget)
        afterCreateCounter  uint64
        beforeCreateCounter uint64
        CreateMock          mBudgetRepositoryMockCreate

        funcFindList          func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Budget, err error)
        funcFindListOrigin    string
        inspectFuncFindList   func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams)
        afterFindListCounter  uint64
        beforeFindListCounter uint64
        FindListMock          mBudgetRepositoryMockFindList

        funcFindOneByID          func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (budget *entity.Budget, err error)
        funcFindOneByIDOrigin    string
        inspectFuncFindOneByID   func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)
        afterFindOneByIDCounter  uint64
        beforeFindOneByIDCounter uint64
        FindOneByIDMock          mBudgetRepositoryMockFindOneByID

        funcFindPagedList          func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Budget, total uint64, err error)
        funcFindPagedListOrigin    string
        inspectFuncFindPagedList   func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams)
        afterFindPagedListCounter  uint64
        beforeFindPagedListCounter uint64
        FindPagedListMock          mBudgetRepositoryMockFindPagedList

        funcUpdate          func(ctx context.Context, item *entity.Budget) (err error)
        funcUpdateOrigin    string
        inspectFuncUpdate   func(ctx context.Context, item *entity.Budget)
        afterUpdateCounter  uint64
        beforeUpdateCounter uint64
        UpdateMock          mBudgetRepositoryMockUpdate
}

// NewBudgetRepositoryMock returns a mock for mm_usecase.BudgetRepository
func NewBudgetRepositoryMock(t minimock.Tester) *BudgetRepositoryMock <span class="cov0" title="0">{
        m := &amp;BudgetRepositoryMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.CreateMock = mBudgetRepositoryMockCreate{mock: m}
        m.CreateMock.callArgs = []*BudgetRepositoryMockCreateParams{}

        m.FindListMock = mBudgetRepositoryMockFindList{mock: m}
        m.FindListMock.callArgs = []*BudgetRepositoryMockFindListParams{}

        m.FindOneByIDMock = mBudgetRepositoryMockFindOneByID{mock: m}
        m.FindOneByIDMock.callArgs = []*BudgetRepositoryMockFindOneByIDParams{}

        m.FindPagedListMock = mBudgetRepositoryMockFindPagedList{mock: m}
        m.FindPagedListMock.callArgs = []*BudgetRepositoryMockFindPagedListParams{}

        m.UpdateMock = mBudgetRepositoryMockUpdate{mock: m}
        m.UpdateMock.callArgs = []*BudgetRepositoryMockUpdateParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mBudgetRepositoryMockCreate struct {
        optional           bool
        mock               *BudgetRepositoryMock
        defaultExpectation *BudgetRepositoryMockCreateExpectation
        expectations       []*BudgetRepositoryMockCreateExpectation

        callArgs []*BudgetRepositoryMockCreateParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// BudgetRepositoryMockCreateExpectation specifies expectation struct of the BudgetRepository.Create
type BudgetRepositoryMockCreateExpectation struct {
        mock               *BudgetRepositoryMock
        params             *BudgetRepositoryMockCreateParams
        paramPtrs          *BudgetRepositoryMockCreateParamPtrs
        expectationOrigins BudgetRepositoryMockCreateExpectationOrigins
        results            *BudgetRepositoryMockCreateResults
        returnOrigin       string
        Counter            uint64
}

// BudgetRepositoryMockCreateParams contains parameters of the BudgetRepository.Create
type BudgetRepositoryMockCreateParams struct {
        ctx  context.Context
        item *entity.Budget
}

// BudgetRepositoryMockCreateParamPtrs contains pointers to parameters of the BudgetRepository.Create
type BudgetRepositoryMockCreateParamPtrs struct {
        ctx  *context.Context
        item **entity.Budget
}

// BudgetRepositoryMockCreateResults contains results of the BudgetRepository.Create
type BudgetRepositoryMockCreateResults struct {
        err error
}

// BudgetRepositoryMockCreateOrigins contains origins of expectations of the BudgetRepository.Create
type BudgetRepositoryMockCreateExpectationOrigins struct {
        origin     string
        originCtx  string
        originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mBudgetRepositoryMockCreate) Optional() *mBudgetRepositoryMockCreate <span class="cov0" title="0">{
        mmCreate.optional = true
        return mmCreate
}</span>

// Expect sets up expected params for BudgetRepository.Create
func (mmCreate *mBudgetRepositoryMockCreate) Expect(ctx context.Context, item *entity.Budget) *mBudgetRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("BudgetRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;BudgetRepositoryMockCreateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("BudgetRepositoryMock.Create mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmCreate.defaultExpectation.params = &amp;BudgetRepositoryMockCreateParams{ctx, item}
        mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmCreate.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmCreate.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmCreate</span>
}

// ExpectCtxParam1 sets up expected param ctx for BudgetRepository.Create
func (mmCreate *mBudgetRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mBudgetRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("BudgetRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;BudgetRepositoryMockCreateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("BudgetRepositoryMock.Create mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation.paramPtrs = &amp;BudgetRepositoryMockCreateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreate.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmCreate</span>
}

// ExpectItemParam2 sets up expected param item for BudgetRepository.Create
func (mmCreate *mBudgetRepositoryMockCreate) ExpectItemParam2(item *entity.Budget) *mBudgetRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("BudgetRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;BudgetRepositoryMockCreateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("BudgetRepositoryMock.Create mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation.paramPtrs = &amp;BudgetRepositoryMockCreateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreate.defaultExpectation.paramPtrs.item = &amp;item
        mmCreate.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

        return mmCreate</span>
}

// Inspect accepts an inspector function that has same arguments as the BudgetRepository.Create
func (mmCreate *mBudgetRepositoryMockCreate) Inspect(f func(ctx context.Context, item *entity.Budget)) *mBudgetRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.inspectFuncCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Inspect function is already set for BudgetRepositoryMock.Create")
        }</span>

        <span class="cov0" title="0">mmCreate.mock.inspectFuncCreate = f

        return mmCreate</span>
}

// Return sets up results that will be returned by BudgetRepository.Create
func (mmCreate *mBudgetRepositoryMockCreate) Return(err error) *BudgetRepositoryMock <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("BudgetRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;BudgetRepositoryMockCreateExpectation{mock: mmCreate.mock}
        }</span>
        <span class="cov0" title="0">mmCreate.defaultExpectation.results = &amp;BudgetRepositoryMockCreateResults{err}
        mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmCreate.mock</span>
}

// Set uses given function f to mock the BudgetRepository.Create method
func (mmCreate *mBudgetRepositoryMockCreate) Set(f func(ctx context.Context, item *entity.Budget) (err error)) *BudgetRepositoryMock <span class="cov0" title="0">{
        if mmCreate.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Default expectation is already set for the BudgetRepository.Create method")
        }</span>

        <span class="cov0" title="0">if len(mmCreate.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Some expectations are already set for the BudgetRepository.Create method")
        }</span>

        <span class="cov0" title="0">mmCreate.mock.funcCreate = f
        mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
        return mmCreate.mock</span>
}

// When sets expectation for the BudgetRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mBudgetRepositoryMockCreate) When(ctx context.Context, item *entity.Budget) *BudgetRepositoryMockCreateExpectation <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("BudgetRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;BudgetRepositoryMockCreateExpectation{
                mock:               mmCreate.mock,
                params:             &amp;BudgetRepositoryMockCreateParams{ctx, item},
                expectationOrigins: BudgetRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmCreate.expectations = append(mmCreate.expectations, expectation)
        return expectation</span>
}

// Then sets up BudgetRepository.Create return parameters for the expectation previously defined by the When method
func (e *BudgetRepositoryMockCreateExpectation) Then(err error) *BudgetRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;BudgetRepositoryMockCreateResults{err}
        return e.mock
}</span>

// Times sets number of times BudgetRepository.Create should be invoked
func (mmCreate *mBudgetRepositoryMockCreate) Times(n uint64) *mBudgetRepositoryMockCreate <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Times of BudgetRepositoryMock.Create mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmCreate.expectedInvocations, n)
        mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmCreate</span>
}

func (mmCreate *mBudgetRepositoryMockCreate) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmCreate.expectations) == 0 &amp;&amp; mmCreate.defaultExpectation == nil &amp;&amp; mmCreate.mock.funcCreate == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmCreate.mock.afterCreateCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmCreate.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Create implements mm_usecase.BudgetRepository
func (mmCreate *BudgetRepositoryMock) Create(ctx context.Context, item *entity.Budget) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmCreate.beforeCreateCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmCreate.afterCreateCounter, 1)

        mmCreate.t.Helper()

        if mmCreate.inspectFuncCreate != nil </span><span class="cov0" title="0">{
                mmCreate.inspectFuncCreate(ctx, item)
        }</span>

        <span class="cov0" title="0">mm_params := BudgetRepositoryMockCreateParams{ctx, item}

        // Record call args
        mmCreate.CreateMock.mutex.Lock()
        mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &amp;mm_params)
        mmCreate.CreateMock.mutex.Unlock()

        for _, e := range mmCreate.CreateMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmCreate.CreateMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmCreate.CreateMock.defaultExpectation.Counter, 1)
                mm_want := mmCreate.CreateMock.defaultExpectation.params
                mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

                mm_got := BudgetRepositoryMockCreateParams{ctx, item}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmCreate.t.Errorf("BudgetRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.item != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.item, mm_got.item) </span><span class="cov0" title="0">{
                                mmCreate.t.Errorf("BudgetRepositoryMock.Create got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCreate.CreateMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmCreate.t.Errorf("BudgetRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmCreate.CreateMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmCreate.t.Fatal("No results are set for the BudgetRepositoryMock.Create")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmCreate.funcCreate != nil </span><span class="cov0" title="0">{
                return mmCreate.funcCreate(ctx, item)
        }</span>
        <span class="cov0" title="0">mmCreate.t.Fatalf("Unexpected call to BudgetRepositoryMock.Create. %v %v", ctx, item)
        return</span>
}

// CreateAfterCounter returns a count of finished BudgetRepositoryMock.Create invocations
func (mmCreate *BudgetRepositoryMock) CreateAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreate.afterCreateCounter)
}</span>

// CreateBeforeCounter returns a count of BudgetRepositoryMock.Create invocations
func (mmCreate *BudgetRepositoryMock) CreateBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreate.beforeCreateCounter)
}</span>

// Calls returns a list of arguments used in each call to BudgetRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mBudgetRepositoryMockCreate) Calls() []*BudgetRepositoryMockCreateParams <span class="cov0" title="0">{
        mmCreate.mutex.RLock()

        argCopy := make([]*BudgetRepositoryMockCreateParams, len(mmCreate.callArgs))
        copy(argCopy, mmCreate.callArgs)

        mmCreate.mutex.RUnlock()

        return argCopy
}</span>

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *BudgetRepositoryMock) MinimockCreateDone() bool <span class="cov0" title="0">{
        if m.CreateMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.CreateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.CreateMock.invocationsDone()</span>
}

// MinimockCreateInspect logs each unmet expectation
func (m *BudgetRepositoryMock) MinimockCreateInspect() <span class="cov0" title="0">{
        for _, e := range m.CreateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterCreateCounter := mm_atomic.LoadUint64(&amp;m.afterCreateCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.CreateMock.defaultExpectation != nil &amp;&amp; afterCreateCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.CreateMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to BudgetRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcCreate != nil &amp;&amp; afterCreateCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to BudgetRepositoryMock.Create at\n%s", m.funcCreateOrigin)
        }</span>

        <span class="cov0" title="0">if !m.CreateMock.invocationsDone() &amp;&amp; afterCreateCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to BudgetRepositoryMock.Create at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
        }</span>
}

type mBudgetRepositoryMockFindList struct {
        optional           bool
        mock               *BudgetRepositoryMock
        defaultExpectation *BudgetRepositoryMockFindListExpectation
        expectations       []*BudgetRepositoryMockFindListExpectation

        callArgs []*BudgetRepositoryMockFindListParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// BudgetRepositoryMockFindListExpectation specifies expectation struct of the BudgetRepository.FindList
type BudgetRepositoryMockFindListExpectation struct {
        mock               *BudgetRepositoryMock
        params             *BudgetRepositoryMockFindListParams
        paramPtrs          *BudgetRepositoryMockFindListParamPtrs
        expectationOrigins BudgetRepositoryMockFindListExpectationOrigins
        results            *BudgetRepositoryMockFindListResults
        returnOrigin       string
        Counter            uint64
}

// BudgetRepositoryMockFindListParams contains parameters of the BudgetRepository.FindList
type BudgetRepositoryMockFindListParams struct {
        ctx         context.Context
        listOptions *mm_usecase.BudgetListOptions
        queryParams *uctypes.QueryGetListParams
}

// BudgetRepositoryMockFindListParamPtrs contains pointers to parameters of the BudgetRepository.FindList
type BudgetRepositoryMockFindListParamPtrs struct {
        ctx         *context.Context
        listOptions **mm_usecase.BudgetListOptions
        queryParams **uctypes.QueryGetListParams
}

// BudgetRepositoryMockFindListResults contains results of the BudgetRepository.FindList
type BudgetRepositoryMockFindListResults struct {
        items []*entity.Budget
        err   error
}

// BudgetRepositoryMockFindListOrigins contains origins of expectations of the BudgetRepository.FindList
type BudgetRepositoryMockFindListExpectationOrigins struct {
        origin            string
        originCtx         string
        originListOptions string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindList *mBudgetRepositoryMockFindList) Optional() *mBudgetRepositoryMockFindList <span class="cov0" title="0">{
        mmFindList.optional = true
        return mmFindList
}</span>

// Expect sets up expected params for BudgetRepository.FindList
func (mmFindList *mBudgetRepositoryMockFindList) Expect(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) *mBudgetRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("BudgetRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;BudgetRepositoryMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("BudgetRepositoryMock.FindList mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindList.defaultExpectation.params = &amp;BudgetRepositoryMockFindListParams{ctx, listOptions, queryParams}
        mmFindList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindList.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindList.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindList.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindList</span>
}

// ExpectCtxParam1 sets up expected param ctx for BudgetRepository.FindList
func (mmFindList *mBudgetRepositoryMockFindList) ExpectCtxParam1(ctx context.Context) *mBudgetRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("BudgetRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;BudgetRepositoryMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("BudgetRepositoryMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;BudgetRepositoryMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindList</span>
}

// ExpectListOptionsParam2 sets up expected param listOptions for BudgetRepository.FindList
func (mmFindList *mBudgetRepositoryMockFindList) ExpectListOptionsParam2(listOptions *mm_usecase.BudgetListOptions) *mBudgetRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("BudgetRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;BudgetRepositoryMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("BudgetRepositoryMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;BudgetRepositoryMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.listOptions = &amp;listOptions
        mmFindList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

        return mmFindList</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for BudgetRepository.FindList
func (mmFindList *mBudgetRepositoryMockFindList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mBudgetRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("BudgetRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;BudgetRepositoryMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("BudgetRepositoryMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;BudgetRepositoryMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindList</span>
}

// Inspect accepts an inspector function that has same arguments as the BudgetRepository.FindList
func (mmFindList *mBudgetRepositoryMockFindList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams)) *mBudgetRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.inspectFuncFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Inspect function is already set for BudgetRepositoryMock.FindList")
        }</span>

        <span class="cov0" title="0">mmFindList.mock.inspectFuncFindList = f

        return mmFindList</span>
}

// Return sets up results that will be returned by BudgetRepository.FindList
func (mmFindList *mBudgetRepositoryMockFindList) Return(items []*entity.Budget, err error) *BudgetRepositoryMock <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("BudgetRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;BudgetRepositoryMockFindListExpectation{mock: mmFindList.mock}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.results = &amp;BudgetRepositoryMockFindListResults{items, err}
        mmFindList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindList.mock</span>
}

// Set uses given function f to mock the BudgetRepository.FindList method
func (mmFindList *mBudgetRepositoryMockFindList) Set(f func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Budget, err error)) *BudgetRepositoryMock <span class="cov0" title="0">{
        if mmFindList.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Default expectation is already set for the BudgetRepository.FindList method")
        }</span>

        <span class="cov0" title="0">if len(mmFindList.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Some expectations are already set for the BudgetRepository.FindList method")
        }</span>

        <span class="cov0" title="0">mmFindList.mock.funcFindList = f
        mmFindList.mock.funcFindListOrigin = minimock.CallerInfo(1)
        return mmFindList.mock</span>
}

// When sets expectation for the BudgetRepository.FindList which will trigger the result defined by the following
// Then helper
func (mmFindList *mBudgetRepositoryMockFindList) When(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) *BudgetRepositoryMockFindListExpectation <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("BudgetRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;BudgetRepositoryMockFindListExpectation{
                mock:               mmFindList.mock,
                params:             &amp;BudgetRepositoryMockFindListParams{ctx, listOptions, queryParams},
                expectationOrigins: BudgetRepositoryMockFindListExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindList.expectations = append(mmFindList.expectations, expectation)
        return expectation</span>
}

// Then sets up BudgetRepository.FindList return parameters for the expectation previously defined by the When method
func (e *BudgetRepositoryMockFindListExpectation) Then(items []*entity.Budget, err error) *BudgetRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;BudgetRepositoryMockFindListResults{items, err}
        return e.mock
}</span>

// Times sets number of times BudgetRepository.FindList should be invoked
func (mmFindList *mBudgetRepositoryMockFindList) Times(n uint64) *mBudgetRepositoryMockFindList <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Times of BudgetRepositoryMock.FindList mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindList.expectedInvocations, n)
        mmFindList.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindList</span>
}

func (mmFindList *mBudgetRepositoryMockFindList) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindList.expectations) == 0 &amp;&amp; mmFindList.defaultExpectation == nil &amp;&amp; mmFindList.mock.funcFindList == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindList.mock.afterFindListCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindList.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindList implements mm_usecase.BudgetRepository
func (mmFindList *BudgetRepositoryMock) FindList(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Budget, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindList.beforeFindListCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindList.afterFindListCounter, 1)

        mmFindList.t.Helper()

        if mmFindList.inspectFuncFindList != nil </span><span class="cov0" title="0">{
                mmFindList.inspectFuncFindList(ctx, listOptions, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := BudgetRepositoryMockFindListParams{ctx, listOptions, queryParams}

        // Record call args
        mmFindList.FindListMock.mutex.Lock()
        mmFindList.FindListMock.callArgs = append(mmFindList.FindListMock.callArgs, &amp;mm_params)
        mmFindList.FindListMock.mutex.Unlock()

        for _, e := range mmFindList.FindListMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.items, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindList.FindListMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindList.FindListMock.defaultExpectation.Counter, 1)
                mm_want := mmFindList.FindListMock.defaultExpectation.params
                mm_want_ptrs := mmFindList.FindListMock.defaultExpectation.paramPtrs

                mm_got := BudgetRepositoryMockFindListParams{ctx, listOptions, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("BudgetRepositoryMock.FindList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.listOptions != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("BudgetRepositoryMock.FindList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("BudgetRepositoryMock.FindList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindList.t.Errorf("BudgetRepositoryMock.FindList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindList.FindListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindList.FindListMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindList.t.Fatal("No results are set for the BudgetRepositoryMock.FindList")
                }</span>
                <span class="cov0" title="0">return (*mm_results).items, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindList.funcFindList != nil </span><span class="cov0" title="0">{
                return mmFindList.funcFindList(ctx, listOptions, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindList.t.Fatalf("Unexpected call to BudgetRepositoryMock.FindList. %v %v %v", ctx, listOptions, queryParams)
        return</span>
}

// FindListAfterCounter returns a count of finished BudgetRepositoryMock.FindList invocations
func (mmFindList *BudgetRepositoryMock) FindListAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindList.afterFindListCounter)
}</span>

// FindListBeforeCounter returns a count of BudgetRepositoryMock.FindList invocations
func (mmFindList *BudgetRepositoryMock) FindListBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindList.beforeFindListCounter)
}</span>

// Calls returns a list of arguments used in each call to BudgetRepositoryMock.FindList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindList *mBudgetRepositoryMockFindList) Calls() []*BudgetRepositoryMockFindListParams <span class="cov0" title="0">{
        mmFindList.mutex.RLock()

        argCopy := make([]*BudgetRepositoryMockFindListParams, len(mmFindList.callArgs))
        copy(argCopy, mmFindList.callArgs)

        mmFindList.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindListDone returns true if the count of the FindList invocations corresponds
// the number of defined expectations
func (m *BudgetRepositoryMock) MinimockFindListDone() bool <span class="cov0" title="0">{
        if m.FindListMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindListMock.invocationsDone()</span>
}

// MinimockFindListInspect logs each unmet expectation
func (m *BudgetRepositoryMock) MinimockFindListInspect() <span class="cov0" title="0">{
        for _, e := range m.FindListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetRepositoryMock.FindList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindListCounter := mm_atomic.LoadUint64(&amp;m.afterFindListCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindListMock.defaultExpectation != nil &amp;&amp; afterFindListCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindListMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetRepositoryMock.FindList at\n%s", m.FindListMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to BudgetRepositoryMock.FindList at\n%s with params: %#v", m.FindListMock.defaultExpectation.expectationOrigins.origin, *m.FindListMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindList != nil &amp;&amp; afterFindListCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to BudgetRepositoryMock.FindList at\n%s", m.funcFindListOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindListMock.invocationsDone() &amp;&amp; afterFindListCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to BudgetRepositoryMock.FindList at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindListMock.expectedInvocations), m.FindListMock.expectedInvocationsOrigin, afterFindListCounter)
        }</span>
}

type mBudgetRepositoryMockFindOneByID struct {
        optional           bool
        mock               *BudgetRepositoryMock
        defaultExpectation *BudgetRepositoryMockFindOneByIDExpectation
        expectations       []*BudgetRepositoryMockFindOneByIDExpectation

        callArgs []*BudgetRepositoryMockFindOneByIDParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// BudgetRepositoryMockFindOneByIDExpectation specifies expectation struct of the BudgetRepository.FindOneByID
type BudgetRepositoryMockFindOneByIDExpectation struct {
        mock               *BudgetRepositoryMock
        params             *BudgetRepositoryMockFindOneByIDParams
        paramPtrs          *BudgetRepositoryMockFindOneByIDParamPtrs
        expectationOrigins BudgetRepositoryMockFindOneByIDExpectationOrigins
        results            *BudgetRepositoryMockFindOneByIDResults
        returnOrigin       string
        Counter            uint64
}

// BudgetRepositoryMockFindOneByIDParams contains parameters of the BudgetRepository.FindOneByID
type BudgetRepositoryMockFindOneByIDParams struct {
        ctx         context.Context
        id          uuid.UUID
        queryParams *uctypes.QueryGetOneParams
}

// BudgetRepositoryMockFindOneByIDParamPtrs contains pointers to parameters of the BudgetRepository.FindOneByID
type BudgetRepositoryMockFindOneByIDParamPtrs struct {
        ctx         *context.Context
        id          *uuid.UUID
        queryParams **uctypes.QueryGetOneParams
}

// BudgetRepositoryMockFindOneByIDResults contains results of the BudgetRepository.FindOneByID
type BudgetRepositoryMockFindOneByIDResults struct {
        budget *entity.Budget
        err    error
}

// BudgetRepositoryMockFindOneByIDOrigins contains origins of expectations of the BudgetRepository.FindOneByID
type BudgetRepositoryMockFindOneByIDExpectationOrigins struct {
        origin            string
        originCtx         string
        originId          string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindOneByID *mBudgetRepositoryMockFindOneByID) Optional() *mBudgetRepositoryMockFindOneByID <span class="cov0" title="0">{
        mmFindOneByID.optional = true
        return mmFindOneByID
}</span>

// Expect sets up expected params for BudgetRepository.FindOneByID
func (mmFindOneByID *mBudgetRepositoryMockFindOneByID) Expect(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *mBudgetRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("BudgetRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;BudgetRepositoryMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("BudgetRepositoryMock.FindOneByID mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.params = &amp;BudgetRepositoryMockFindOneByIDParams{ctx, id, queryParams}
        mmFindOneByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindOneByID.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindOneByID.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindOneByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindOneByID.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindOneByID</span>
}

// ExpectCtxParam1 sets up expected param ctx for BudgetRepository.FindOneByID
func (mmFindOneByID *mBudgetRepositoryMockFindOneByID) ExpectCtxParam1(ctx context.Context) *mBudgetRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("BudgetRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;BudgetRepositoryMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("BudgetRepositoryMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;BudgetRepositoryMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindOneByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// ExpectIdParam2 sets up expected param id for BudgetRepository.FindOneByID
func (mmFindOneByID *mBudgetRepositoryMockFindOneByID) ExpectIdParam2(id uuid.UUID) *mBudgetRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("BudgetRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;BudgetRepositoryMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("BudgetRepositoryMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;BudgetRepositoryMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.id = &amp;id
        mmFindOneByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for BudgetRepository.FindOneByID
func (mmFindOneByID *mBudgetRepositoryMockFindOneByID) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetOneParams) *mBudgetRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("BudgetRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;BudgetRepositoryMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("BudgetRepositoryMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;BudgetRepositoryMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindOneByID.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// Inspect accepts an inspector function that has same arguments as the BudgetRepository.FindOneByID
func (mmFindOneByID *mBudgetRepositoryMockFindOneByID) Inspect(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)) *mBudgetRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.inspectFuncFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Inspect function is already set for BudgetRepositoryMock.FindOneByID")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.mock.inspectFuncFindOneByID = f

        return mmFindOneByID</span>
}

// Return sets up results that will be returned by BudgetRepository.FindOneByID
func (mmFindOneByID *mBudgetRepositoryMockFindOneByID) Return(budget *entity.Budget, err error) *BudgetRepositoryMock <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("BudgetRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;BudgetRepositoryMockFindOneByIDExpectation{mock: mmFindOneByID.mock}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.results = &amp;BudgetRepositoryMockFindOneByIDResults{budget, err}
        mmFindOneByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindOneByID.mock</span>
}

// Set uses given function f to mock the BudgetRepository.FindOneByID method
func (mmFindOneByID *mBudgetRepositoryMockFindOneByID) Set(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (budget *entity.Budget, err error)) *BudgetRepositoryMock <span class="cov0" title="0">{
        if mmFindOneByID.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Default expectation is already set for the BudgetRepository.FindOneByID method")
        }</span>

        <span class="cov0" title="0">if len(mmFindOneByID.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Some expectations are already set for the BudgetRepository.FindOneByID method")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.mock.funcFindOneByID = f
        mmFindOneByID.mock.funcFindOneByIDOrigin = minimock.CallerInfo(1)
        return mmFindOneByID.mock</span>
}

// When sets expectation for the BudgetRepository.FindOneByID which will trigger the result defined by the following
// Then helper
func (mmFindOneByID *mBudgetRepositoryMockFindOneByID) When(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *BudgetRepositoryMockFindOneByIDExpectation <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("BudgetRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;BudgetRepositoryMockFindOneByIDExpectation{
                mock:               mmFindOneByID.mock,
                params:             &amp;BudgetRepositoryMockFindOneByIDParams{ctx, id, queryParams},
                expectationOrigins: BudgetRepositoryMockFindOneByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindOneByID.expectations = append(mmFindOneByID.expectations, expectation)
        return expectation</span>
}

// Then sets up BudgetRepository.FindOneByID return parameters for the expectation previously defined by the When method
func (e *BudgetRepositoryMockFindOneByIDExpectation) Then(budget *entity.Budget, err error) *BudgetRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;BudgetRepositoryMockFindOneByIDResults{budget, err}
        return e.mock
}</span>

// Times sets number of times BudgetRepository.FindOneByID should be invoked
func (mmFindOneByID *mBudgetRepositoryMockFindOneByID) Times(n uint64) *mBudgetRepositoryMockFindOneByID <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Times of BudgetRepositoryMock.FindOneByID mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindOneByID.expectedInvocations, n)
        mmFindOneByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindOneByID</span>
}

func (mmFindOneByID *mBudgetRepositoryMockFindOneByID) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindOneByID.expectations) == 0 &amp;&amp; mmFindOneByID.defaultExpectation == nil &amp;&amp; mmFindOneByID.mock.funcFindOneByID == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByID.mock.afterFindOneByIDCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByID.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindOneByID implements mm_usecase.BudgetRepository
func (mmFindOneByID *BudgetRepositoryMock) FindOneByID(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (budget *entity.Budget, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindOneByID.beforeFindOneByIDCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindOneByID.afterFindOneByIDCounter, 1)

        mmFindOneByID.t.Helper()

        if mmFindOneByID.inspectFuncFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.inspectFuncFindOneByID(ctx, id, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := BudgetRepositoryMockFindOneByIDParams{ctx, id, queryParams}

        // Record call args
        mmFindOneByID.FindOneByIDMock.mutex.Lock()
        mmFindOneByID.FindOneByIDMock.callArgs = append(mmFindOneByID.FindOneByIDMock.callArgs, &amp;mm_params)
        mmFindOneByID.FindOneByIDMock.mutex.Unlock()

        for _, e := range mmFindOneByID.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.budget, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindOneByID.FindOneByIDMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindOneByID.FindOneByIDMock.defaultExpectation.Counter, 1)
                mm_want := mmFindOneByID.FindOneByIDMock.defaultExpectation.params
                mm_want_ptrs := mmFindOneByID.FindOneByIDMock.defaultExpectation.paramPtrs

                mm_got := BudgetRepositoryMockFindOneByIDParams{ctx, id, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("BudgetRepositoryMock.FindOneByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("BudgetRepositoryMock.FindOneByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("BudgetRepositoryMock.FindOneByID got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindOneByID.t.Errorf("BudgetRepositoryMock.FindOneByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindOneByID.FindOneByIDMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindOneByID.t.Fatal("No results are set for the BudgetRepositoryMock.FindOneByID")
                }</span>
                <span class="cov0" title="0">return (*mm_results).budget, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindOneByID.funcFindOneByID != nil </span><span class="cov0" title="0">{
                return mmFindOneByID.funcFindOneByID(ctx, id, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindOneByID.t.Fatalf("Unexpected call to BudgetRepositoryMock.FindOneByID. %v %v %v", ctx, id, queryParams)
        return</span>
}

// FindOneByIDAfterCounter returns a count of finished BudgetRepositoryMock.FindOneByID invocations
func (mmFindOneByID *BudgetRepositoryMock) FindOneByIDAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByID.afterFindOneByIDCounter)
}</span>

// FindOneByIDBeforeCounter returns a count of BudgetRepositoryMock.FindOneByID invocations
func (mmFindOneByID *BudgetRepositoryMock) FindOneByIDBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByID.beforeFindOneByIDCounter)
}</span>

// Calls returns a list of arguments used in each call to BudgetRepositoryMock.FindOneByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindOneByID *mBudgetRepositoryMockFindOneByID) Calls() []*BudgetRepositoryMockFindOneByIDParams <span class="cov0" title="0">{
        mmFindOneByID.mutex.RLock()

        argCopy := make([]*BudgetRepositoryMockFindOneByIDParams, len(mmFindOneByID.callArgs))
        copy(argCopy, mmFindOneByID.callArgs)

        mmFindOneByID.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindOneByIDDone returns true if the count of the FindOneByID invocations corresponds
// the number of defined expectations
func (m *BudgetRepositoryMock) MinimockFindOneByIDDone() bool <span class="cov0" title="0">{
        if m.FindOneByIDMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindOneByIDMock.invocationsDone()</span>
}

// MinimockFindOneByIDInspect logs each unmet expectation
func (m *BudgetRepositoryMock) MinimockFindOneByIDInspect() <span class="cov0" title="0">{
        for _, e := range m.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetRepositoryMock.FindOneByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindOneByIDCounter := mm_atomic.LoadUint64(&amp;m.afterFindOneByIDCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindOneByIDMock.defaultExpectation != nil &amp;&amp; afterFindOneByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindOneByIDMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetRepositoryMock.FindOneByID at\n%s", m.FindOneByIDMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to BudgetRepositoryMock.FindOneByID at\n%s with params: %#v", m.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *m.FindOneByIDMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindOneByID != nil &amp;&amp; afterFindOneByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to BudgetRepositoryMock.FindOneByID at\n%s", m.funcFindOneByIDOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindOneByIDMock.invocationsDone() &amp;&amp; afterFindOneByIDCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to BudgetRepositoryMock.FindOneByID at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindOneByIDMock.expectedInvocations), m.FindOneByIDMock.expectedInvocationsOrigin, afterFindOneByIDCounter)
        }</span>
}

type mBudgetRepositoryMockFindPagedList struct {
        optional           bool
        mock               *BudgetRepositoryMock
        defaultExpectation *BudgetRepositoryMockFindPagedListExpectation
        expectations       []*BudgetRepositoryMockFindPagedListExpectation

        callArgs []*BudgetRepositoryMockFindPagedListParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// BudgetRepositoryMockFindPagedListExpectation specifies expectation struct of the BudgetRepository.FindPagedList
type BudgetRepositoryMockFindPagedListExpectation struct {
        mock               *BudgetRepositoryMock
        params             *BudgetRepositoryMockFindPagedListParams
        paramPtrs          *BudgetRepositoryMockFindPagedListParamPtrs
        expectationOrigins BudgetRepositoryMockFindPagedListExpectationOrigins
        results            *BudgetRepositoryMockFindPagedListResults
        returnOrigin       string
        Counter            uint64
}

// BudgetRepositoryMockFindPagedListParams contains parameters of the BudgetRepository.FindPagedList
type BudgetRepositoryMockFindPagedListParams struct {
        ctx         context.Context
        listOptions *mm_usecase.BudgetListOptions
        queryParams *uctypes.QueryGetListParams
}

// BudgetRepositoryMockFindPagedListParamPtrs contains pointers to parameters of the BudgetRepository.FindPagedList
type BudgetRepositoryMockFindPagedListParamPtrs struct {
        ctx         *context.Context
        listOptions **mm_usecase.BudgetListOptions
        queryParams **uctypes.QueryGetListParams
}

// BudgetRepositoryMockFindPagedListResults contains results of the BudgetRepository.FindPagedList
type BudgetRepositoryMockFindPagedListResults struct {
        items []*entity.Budget
        total uint64
        err   error
}

// BudgetRepositoryMockFindPagedListOrigins contains origins of expectations of the BudgetRepository.FindPagedList
type BudgetRepositoryMockFindPagedListExpectationOrigins struct {
        origin            string
        originCtx         string
        originListOptions string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindPagedList *mBudgetRepositoryMockFindPagedList) Optional() *mBudgetRepositoryMockFindPagedList <span class="cov0" title="0">{
        mmFindPagedList.optional = true
        return mmFindPagedList
}</span>

// Expect sets up expected params for BudgetRepository.FindPagedList
func (mmFindPagedList *mBudgetRepositoryMockFindPagedList) Expect(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) *mBudgetRepositoryMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("BudgetRepositoryMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;BudgetRepositoryMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("BudgetRepositoryMock.FindPagedList mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.params = &amp;BudgetRepositoryMockFindPagedListParams{ctx, listOptions, queryParams}
        mmFindPagedList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindPagedList.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindPagedList.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindPagedList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindPagedList.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindPagedList</span>
}

// ExpectCtxParam1 sets up expected param ctx for BudgetRepository.FindPagedList
func (mmFindPagedList *mBudgetRepositoryMockFindPagedList) ExpectCtxParam1(ctx context.Context) *mBudgetRepositoryMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("BudgetRepositoryMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;BudgetRepositoryMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("BudgetRepositoryMock.FindPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation.paramPtrs = &amp;BudgetRepositoryMockFindPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindPagedList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindPagedList</span>
}

// ExpectListOptionsParam2 sets up expected param listOptions for BudgetRepository.FindPagedList
func (mmFindPagedList *mBudgetRepositoryMockFindPagedList) ExpectListOptionsParam2(listOptions *mm_usecase.BudgetListOptions) *mBudgetRepositoryMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("BudgetRepositoryMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;BudgetRepositoryMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("BudgetRepositoryMock.FindPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation.paramPtrs = &amp;BudgetRepositoryMockFindPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.paramPtrs.listOptions = &amp;listOptions
        mmFindPagedList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

        return mmFindPagedList</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for BudgetRepository.FindPagedList
func (mmFindPagedList *mBudgetRepositoryMockFindPagedList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mBudgetRepositoryMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("BudgetRepositoryMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;BudgetRepositoryMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("BudgetRepositoryMock.FindPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation.paramPtrs = &amp;BudgetRepositoryMockFindPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindPagedList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindPagedList</span>
}

// Inspect accepts an inspector function that has same arguments as the BudgetRepository.FindPagedList
func (mmFindPagedList *mBudgetRepositoryMockFindPagedList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams)) *mBudgetRepositoryMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.inspectFuncFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Inspect function is already set for BudgetRepositoryMock.FindPagedList")
        }</span>

        <span class="cov0" title="0">mmFindPagedList.mock.inspectFuncFindPagedList = f

        return mmFindPagedList</span>
}

// Return sets up results that will be returned by BudgetRepository.FindPagedList
func (mmFindPagedList *mBudgetRepositoryMockFindPagedList) Return(items []*entity.Budget, total uint64, err error) *BudgetRepositoryMock <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("BudgetRepositoryMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;BudgetRepositoryMockFindPagedListExpectation{mock: mmFindPagedList.mock}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.results = &amp;BudgetRepositoryMockFindPagedListResults{items, total, err}
        mmFindPagedList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindPagedList.mock</span>
}

// Set uses given function f to mock the BudgetRepository.FindPagedList method
func (mmFindPagedList *mBudgetRepositoryMockFindPagedList) Set(f func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Budget, total uint64, err error)) *BudgetRepositoryMock <span class="cov0" title="0">{
        if mmFindPagedList.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Default expectation is already set for the BudgetRepository.FindPagedList method")
        }</span>

        <span class="cov0" title="0">if len(mmFindPagedList.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Some expectations are already set for the BudgetRepository.FindPagedList method")
        }</span>

        <span class="cov0" title="0">mmFindPagedList.mock.funcFindPagedList = f
        mmFindPagedList.mock.funcFindPagedListOrigin = minimock.CallerInfo(1)
        return mmFindPagedList.mock</span>
}

// When sets expectation for the BudgetRepository.FindPagedList which will trigger the result defined by the following
// Then helper
func (mmFindPagedList *mBudgetRepositoryMockFindPagedList) When(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) *BudgetRepositoryMockFindPagedListExpectation <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("BudgetRepositoryMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;BudgetRepositoryMockFindPagedListExpectation{
                mock:               mmFindPagedList.mock,
                params:             &amp;BudgetRepositoryMockFindPagedListParams{ctx, listOptions, queryParams},
                expectationOrigins: BudgetRepositoryMockFindPagedListExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindPagedList.expectations = append(mmFindPagedList.expectations, expectation)
        return expectation</span>
}

// Then sets up BudgetRepository.FindPagedList return parameters for the expectation previously defined by the When method
func (e *BudgetRepositoryMockFindPagedListExpectation) Then(items []*entity.Budget, total uint64, err error) *BudgetRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;BudgetRepositoryMockFindPagedListResults{items, total, err}
        return e.mock
}</span>

// Times sets number of times BudgetRepository.FindPagedList should be invoked
func (mmFindPagedList *mBudgetRepositoryMockFindPagedList) Times(n uint64) *mBudgetRepositoryMockFindPagedList <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Times of BudgetRepositoryMock.FindPagedList mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindPagedList.expectedInvocations, n)
        mmFindPagedList.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindPagedList</span>
}

func (mmFindPagedList *mBudgetRepositoryMockFindPagedList) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindPagedList.expectations) == 0 &amp;&amp; mmFindPagedList.defaultExpectation == nil &amp;&amp; mmFindPagedList.mock.funcFindPagedList == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindPagedList.mock.afterFindPagedListCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindPagedList.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindPagedList implements mm_usecase.BudgetRepository
func (mmFindPagedList *BudgetRepositoryMock) FindPagedList(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Budget, total uint64, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindPagedList.beforeFindPagedListCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindPagedList.afterFindPagedListCounter, 1)

        mmFindPagedList.t.Helper()

        if mmFindPagedList.inspectFuncFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.inspectFuncFindPagedList(ctx, listOptions, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := BudgetRepositoryMockFindPagedListParams{ctx, listOptions, queryParams}

        // Record call args
        mmFindPagedList.FindPagedListMock.mutex.Lock()
        mmFindPagedList.FindPagedListMock.callArgs = append(mmFindPagedList.FindPagedListMock.callArgs, &amp;mm_params)
        mmFindPagedList.FindPagedListMock.mutex.Unlock()

        for _, e := range mmFindPagedList.FindPagedListMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.items, e.results.total, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindPagedList.FindPagedListMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindPagedList.FindPagedListMock.defaultExpectation.Counter, 1)
                mm_want := mmFindPagedList.FindPagedListMock.defaultExpectation.params
                mm_want_ptrs := mmFindPagedList.FindPagedListMock.defaultExpectation.paramPtrs

                mm_got := BudgetRepositoryMockFindPagedListParams{ctx, listOptions, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindPagedList.t.Errorf("BudgetRepositoryMock.FindPagedList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.listOptions != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) </span><span class="cov0" title="0">{
                                mmFindPagedList.t.Errorf("BudgetRepositoryMock.FindPagedList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindPagedList.t.Errorf("BudgetRepositoryMock.FindPagedList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindPagedList.t.Errorf("BudgetRepositoryMock.FindPagedList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindPagedList.FindPagedListMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindPagedList.t.Fatal("No results are set for the BudgetRepositoryMock.FindPagedList")
                }</span>
                <span class="cov0" title="0">return (*mm_results).items, (*mm_results).total, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindPagedList.funcFindPagedList != nil </span><span class="cov0" title="0">{
                return mmFindPagedList.funcFindPagedList(ctx, listOptions, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindPagedList.t.Fatalf("Unexpected call to BudgetRepositoryMock.FindPagedList. %v %v %v", ctx, listOptions, queryParams)
        return</span>
}

// FindPagedListAfterCounter returns a count of finished BudgetRepositoryMock.FindPagedList invocations
func (mmFindPagedList *BudgetRepositoryMock) FindPagedListAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindPagedList.afterFindPagedListCounter)
}</span>

// FindPagedListBeforeCounter returns a count of BudgetRepositoryMock.FindPagedList invocations
func (mmFindPagedList *BudgetRepositoryMock) FindPagedListBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindPagedList.beforeFindPagedListCounter)
}</span>

// Calls returns a list of arguments used in each call to BudgetRepositoryMock.FindPagedList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindPagedList *mBudgetRepositoryMockFindPagedList) Calls() []*BudgetRepositoryMockFindPagedListParams <span class="cov0" title="0">{
        mmFindPagedList.mutex.RLock()

        argCopy := make([]*BudgetRepositoryMockFindPagedListParams, len(mmFindPagedList.callArgs))
        copy(argCopy, mmFindPagedList.callArgs)

        mmFindPagedList.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindPagedListDone returns true if the count of the FindPagedList invocations corresponds
// the number of defined expectations
func (m *BudgetRepositoryMock) MinimockFindPagedListDone() bool <span class="cov0" title="0">{
        if m.FindPagedListMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindPagedListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindPagedListMock.invocationsDone()</span>
}

// MinimockFindPagedListInspect logs each unmet expectation
func (m *BudgetRepositoryMock) MinimockFindPagedListInspect() <span class="cov0" title="0">{
        for _, e := range m.FindPagedListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetRepositoryMock.FindPagedList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindPagedListCounter := mm_atomic.LoadUint64(&amp;m.afterFindPagedListCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindPagedListMock.defaultExpectation != nil &amp;&amp; afterFindPagedListCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindPagedListMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetRepositoryMock.FindPagedList at\n%s", m.FindPagedListMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to BudgetRepositoryMock.FindPagedList at\n%s with params: %#v", m.FindPagedListMock.defaultExpectation.expectationOrigins.origin, *m.FindPagedListMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindPagedList != nil &amp;&amp; afterFindPagedListCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to BudgetRepositoryMock.FindPagedList at\n%s", m.funcFindPagedListOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindPagedListMock.invocationsDone() &amp;&amp; afterFindPagedListCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to BudgetRepositoryMock.FindPagedList at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindPagedListMock.expectedInvocations), m.FindPagedListMock.expectedInvocationsOrigin, afterFindPagedListCounter)
        }</span>
}

type mBudgetRepositoryMockUpdate struct {
        optional           bool
        mock               *BudgetRepositoryMock
        defaultExpectation *BudgetRepositoryMockUpdateExpectation
        expectations       []*BudgetRepositoryMockUpdateExpectation

        callArgs []*BudgetRepositoryMockUpdateParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// BudgetRepositoryMockUpdateExpectation specifies expectation struct of the BudgetRepository.Update
type BudgetRepositoryMockUpdateExpectation struct {
        mock               *BudgetRepositoryMock
        params             *BudgetRepositoryMockUpdateParams
        paramPtrs          *BudgetRepositoryMockUpdateParamPtrs
        expectationOrigins BudgetRepositoryMockUpdateExpectationOrigins
        results            *BudgetRepositoryMockUpdateResults
        returnOrigin       string
        Counter            uint64
}

// BudgetRepositoryMockUpdateParams contains parameters of the BudgetRepository.Update
type BudgetRepositoryMockUpdateParams struct {
        ctx  context.Context
        item *entity.Budget
}

// BudgetRepositoryMockUpdateParamPtrs contains pointers to parameters of the BudgetRepository.Update
type BudgetRepositoryMockUpdateParamPtrs struct {
        ctx  *context.Context
        item **entity.Budget
}

// BudgetRepositoryMockUpdateResults contains results of the BudgetRepository.Update
type BudgetRepositoryMockUpdateResults struct {
        err error
}

// BudgetRepositoryMockUpdateOrigins contains origins of expectations of the BudgetRepository.Update
type BudgetRepositoryMockUpdateExpectationOrigins struct {
        origin     string
        originCtx  string
        originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mBudgetRepositoryMockUpdate) Optional() *mBudgetRepositoryMockUpdate <span class="cov0" title="0">{
        mmUpdate.optional = true
        return mmUpdate
}</span>

// Expect sets up expected params for BudgetRepository.Update
func (mmUpdate *mBudgetRepositoryMockUpdate) Expect(ctx context.Context, item *entity.Budget) *mBudgetRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("BudgetRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;BudgetRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("BudgetRepositoryMock.Update mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmUpdate.defaultExpectation.params = &amp;BudgetRepositoryMockUpdateParams{ctx, item}
        mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmUpdate.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmUpdate</span>
}

// ExpectCtxParam1 sets up expected param ctx for BudgetRepository.Update
func (mmUpdate *mBudgetRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mBudgetRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("BudgetRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;BudgetRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("BudgetRepositoryMock.Update mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation.paramPtrs = &amp;BudgetRepositoryMockUpdateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmUpdate</span>
}

// ExpectItemParam2 sets up expected param item for BudgetRepository.Update
func (mmUpdate *mBudgetRepositoryMockUpdate) ExpectItemParam2(item *entity.Budget) *mBudgetRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("BudgetRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;BudgetRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("BudgetRepositoryMock.Update mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation.paramPtrs = &amp;BudgetRepositoryMockUpdateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.paramPtrs.item = &amp;item
        mmUpdate.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

        return mmUpdate</span>
}

// Inspect accepts an inspector function that has same arguments as the BudgetRepository.Update
func (mmUpdate *mBudgetRepositoryMockUpdate) Inspect(f func(ctx context.Context, item *entity.Budget)) *mBudgetRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.inspectFuncUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Inspect function is already set for BudgetRepositoryMock.Update")
        }</span>

        <span class="cov0" title="0">mmUpdate.mock.inspectFuncUpdate = f

        return mmUpdate</span>
}

// Return sets up results that will be returned by BudgetRepository.Update
func (mmUpdate *mBudgetRepositoryMockUpdate) Return(err error) *BudgetRepositoryMock <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("BudgetRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;BudgetRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.results = &amp;BudgetRepositoryMockUpdateResults{err}
        mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmUpdate.mock</span>
}

// Set uses given function f to mock the BudgetRepository.Update method
func (mmUpdate *mBudgetRepositoryMockUpdate) Set(f func(ctx context.Context, item *entity.Budget) (err error)) *BudgetRepositoryMock <span class="cov0" title="0">{
        if mmUpdate.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Default expectation is already set for the BudgetRepository.Update method")
        }</span>

        <span class="cov0" title="0">if len(mmUpdate.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Some expectations are already set for the BudgetRepository.Update method")
        }</span>

        <span class="cov0" title="0">mmUpdate.mock.funcUpdate = f
        mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
        return mmUpdate.mock</span>
}

// When sets expectation for the BudgetRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mBudgetRepositoryMockUpdate) When(ctx context.Context, item *entity.Budget) *BudgetRepositoryMockUpdateExpectation <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("BudgetRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;BudgetRepositoryMockUpdateExpectation{
                mock:               mmUpdate.mock,
                params:             &amp;BudgetRepositoryMockUpdateParams{ctx, item},
                expectationOrigins: BudgetRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmUpdate.expectations = append(mmUpdate.expectations, expectation)
        return expectation</span>
}

// Then sets up BudgetRepository.Update return parameters for the expectation previously defined by the When method
func (e *BudgetRepositoryMockUpdateExpectation) Then(err error) *BudgetRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;BudgetRepositoryMockUpdateResults{err}
        return e.mock
}</span>

// Times sets number of times BudgetRepository.Update should be invoked
func (mmUpdate *mBudgetRepositoryMockUpdate) Times(n uint64) *mBudgetRepositoryMockUpdate <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Times of BudgetRepositoryMock.Update mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmUpdate.expectedInvocations, n)
        mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmUpdate</span>
}

func (mmUpdate *mBudgetRepositoryMockUpdate) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmUpdate.expectations) == 0 &amp;&amp; mmUpdate.defaultExpectation == nil &amp;&amp; mmUpdate.mock.funcUpdate == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmUpdate.mock.afterUpdateCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmUpdate.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Update implements mm_usecase.BudgetRepository
func (mmUpdate *BudgetRepositoryMock) Update(ctx context.Context, item *entity.Budget) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmUpdate.beforeUpdateCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmUpdate.afterUpdateCounter, 1)

        mmUpdate.t.Helper()

        if mmUpdate.inspectFuncUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.inspectFuncUpdate(ctx, item)
        }</span>

        <span class="cov0" title="0">mm_params := BudgetRepositoryMockUpdateParams{ctx, item}

        // Record call args
        mmUpdate.UpdateMock.mutex.Lock()
        mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &amp;mm_params)
        mmUpdate.UpdateMock.mutex.Unlock()

        for _, e := range mmUpdate.UpdateMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmUpdate.UpdateMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
                mm_want := mmUpdate.UpdateMock.defaultExpectation.params
                mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

                mm_got := BudgetRepositoryMockUpdateParams{ctx, item}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmUpdate.t.Errorf("BudgetRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.item != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.item, mm_got.item) </span><span class="cov0" title="0">{
                                mmUpdate.t.Errorf("BudgetRepositoryMock.Update got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmUpdate.t.Errorf("BudgetRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmUpdate.UpdateMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmUpdate.t.Fatal("No results are set for the BudgetRepositoryMock.Update")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmUpdate.funcUpdate != nil </span><span class="cov0" title="0">{
                return mmUpdate.funcUpdate(ctx, item)
        }</span>
        <span class="cov0" title="0">mmUpdate.t.Fatalf("Unexpected call to BudgetRepositoryMock.Update. %v %v", ctx, item)
        return</span>
}

// UpdateAfterCounter returns a count of finished BudgetRepositoryMock.Update invocations
func (mmUpdate *BudgetRepositoryMock) UpdateAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdate.afterUpdateCounter)
}</span>

// UpdateBeforeCounter returns a count of BudgetRepositoryMock.Update invocations
func (mmUpdate *BudgetRepositoryMock) UpdateBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdate.beforeUpdateCounter)
}</span>

// Calls returns a list of arguments used in each call to BudgetRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mBudgetRepositoryMockUpdate) Calls() []*BudgetRepositoryMockUpdateParams <span class="cov0" title="0">{
        mmUpdate.mutex.RLock()

        argCopy := make([]*BudgetRepositoryMockUpdateParams, len(mmUpdate.callArgs))
        copy(argCopy, mmUpdate.callArgs)

        mmUpdate.mutex.RUnlock()

        return argCopy
}</span>

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *BudgetRepositoryMock) MinimockUpdateDone() bool <span class="cov0" title="0">{
        if m.UpdateMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.UpdateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.UpdateMock.invocationsDone()</span>
}

// MinimockUpdateInspect logs each unmet expectation
func (m *BudgetRepositoryMock) MinimockUpdateInspect() <span class="cov0" title="0">{
        for _, e := range m.UpdateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterUpdateCounter := mm_atomic.LoadUint64(&amp;m.afterUpdateCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.UpdateMock.defaultExpectation != nil &amp;&amp; afterUpdateCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.UpdateMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to BudgetRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcUpdate != nil &amp;&amp; afterUpdateCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to BudgetRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
        }</span>

        <span class="cov0" title="0">if !m.UpdateMock.invocationsDone() &amp;&amp; afterUpdateCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to BudgetRepositoryMock.Update at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *BudgetRepositoryMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockCreateInspect()

                        m.MinimockFindListInspect()

                        m.MinimockFindOneByIDInspect()

                        m.MinimockFindPagedListInspect()

                        m.MinimockUpdateInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *BudgetRepositoryMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *BudgetRepositoryMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockCreateDone() &amp;&amp;
                m.MinimockFindListDone() &amp;&amp;
                m.MinimockFindOneByIDDone() &amp;&amp;
                m.MinimockFindPagedListDone() &amp;&amp;
                m.MinimockUpdateDone()
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase.BudgetUsecase -o budget_usecase.go -n BudgetUsecaseMock -p mocks

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        mm_usecase "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
)

// BudgetUsecaseMock implements mm_usecase.BudgetUsecase
type BudgetUsecaseMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcCreateBudgetByDTO          func(ctx context.Context, in mm_usecase.CreateBudgetDataInput) (resBudgetDTO *mm_usecase.BudgetDTO, err error)
        funcCreateBudgetByDTOOrigin    string
        inspectFuncCreateBudgetByDTO   func(ctx context.Context, in mm_usecase.CreateBudgetDataInput)
        afterCreateBudgetByDTOCounter  uint64
        beforeCreateBudgetByDTOCounter uint64
        CreateBudgetByDTOMock          mBudgetUsecaseMockCreateBudgetByDTO

        funcDeleteBudgetByID          func(ctx context.Context, id uuid.UUID) (err error)
        funcDeleteBudgetByIDOrigin    string
        inspectFuncDeleteBudgetByID   func(ctx context.Context, id uuid.UUID)
        afterDeleteBudgetByIDCounter  uint64
        beforeDeleteBudgetByIDCounter uint64
        DeleteBudgetByIDMock          mBudgetUsecaseMockDeleteBudgetByID

        funcFindList          func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.BudgetDTO, cacheHit bool, err error)
        funcFindListOrigin    string
        inspectFuncFindList   func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams)
        afterFindListCounter  uint64
        beforeFindListCounter uint64
        FindListMock          mBudgetUsecaseMockFindList

        funcFindOneByID          func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (resItem *mm_usecase.BudgetDTO, cacheHit bool, err error)
        funcFindOneByIDOrigin    string
        inspectFuncFindOneByID   func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)
        afterFindOneByIDCounter  uint64
        beforeFindOneByIDCounter uint64
        FindOneByIDMock          mBudgetUsecaseMockFindOneByID

        funcFindPagedList          func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.BudgetDTO, total uint64, cacheHit bool, err error)
        funcFindPagedListOrigin    string
        inspectFuncFindPagedList   func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams)
        afterFindPagedListCounter  uint64
        beforeFindPagedListCounter uint64
        FindPagedListMock          mBudgetUsecaseMockFindPagedList

        funcPatchBudgetByDTO          func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchBudgetDataInput, skipVersionCheck bool) (err error)
        funcPatchBudgetByDTOOrigin    string
        inspectFuncPatchBudgetByDTO   func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchBudgetDataInput, skipVersionCheck bool)
        afterPatchBudgetByDTOCounter  uint64
        beforePatchBudgetByDTOCounter uint64
        PatchBudgetByDTOMock          mBudgetUsecaseMockPatchBudgetByDTO
}

// NewBudgetUsecaseMock returns a mock for mm_usecase.BudgetUsecase
func NewBudgetUsecaseMock(t minimock.Tester) *BudgetUsecaseMock <span class="cov0" title="0">{
        m := &amp;BudgetUsecaseMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.CreateBudgetByDTOMock = mBudgetUsecaseMockCreateBudgetByDTO{mock: m}
        m.CreateBudgetByDTOMock.callArgs = []*BudgetUsecaseMockCreateBudgetByDTOParams{}

        m.DeleteBudgetByIDMock = mBudgetUsecaseMockDeleteBudgetByID{mock: m}
        m.DeleteBudgetByIDMock.callArgs = []*BudgetUsecaseMockDeleteBudgetByIDParams{}

        m.FindListMock = mBudgetUsecaseMockFindList{mock: m}
        m.FindListMock.callArgs = []*BudgetUsecaseMockFindListParams{}

        m.FindOneByIDMock = mBudgetUsecaseMockFindOneByID{mock: m}
        m.FindOneByIDMock.callArgs = []*BudgetUsecaseMockFindOneByIDParams{}

        m.FindPagedListMock = mBudgetUsecaseMockFindPagedList{mock: m}
        m.FindPagedListMock.callArgs = []*BudgetUsecaseMockFindPagedListParams{}

        m.PatchBudgetByDTOMock = mBudgetUsecaseMockPatchBudgetByDTO{mock: m}
        m.PatchBudgetByDTOMock.callArgs = []*BudgetUsecaseMockPatchBudgetByDTOParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mBudgetUsecaseMockCreateBudgetByDTO struct {
        optional           bool
        mock               *BudgetUsecaseMock
        defaultExpectation *BudgetUsecaseMockCreateBudgetByDTOExpectation
        expectations       []*BudgetUsecaseMockCreateBudgetByDTOExpectation

        callArgs []*BudgetUsecaseMockCreateBudgetByDTOParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// BudgetUsecaseMockCreateBudgetByDTOExpectation specifies expectation struct of the BudgetUsecase.CreateBudgetByDTO
type BudgetUsecaseMockCreateBudgetByDTOExpectation struct {
        mock               *BudgetUsecaseMock
        params             *BudgetUsecaseMockCreateBudgetByDTOParams
        paramPtrs          *BudgetUsecaseMockCreateBudgetByDTOParamPtrs
        expectationOrigins BudgetUsecaseMockCreateBudgetByDTOExpectationOrigins
        results            *BudgetUsecaseMockCreateBudgetByDTOResults
        returnOrigin       string
        Counter            uint64
}

// BudgetUsecaseMockCreateBudgetByDTOParams contains parameters of the BudgetUsecase.CreateBudgetByDTO
type BudgetUsecaseMockCreateBudgetByDTOParams struct {
        ctx context.Context
        in  mm_usecase.CreateBudgetDataInput
}

// BudgetUsecaseMockCreateBudgetByDTOParamPtrs contains pointers to parameters of the BudgetUsecase.CreateBudgetByDTO
type BudgetUsecaseMockCreateBudgetByDTOParamPtrs struct {
        ctx *context.Context
        in  *mm_usecase.CreateBudgetDataInput
}

// BudgetUsecaseMockCreateBudgetByDTOResults contains results of the BudgetUsecase.CreateBudgetByDTO
type BudgetUsecaseMockCreateBudgetByDTOResults struct {
        resBudgetDTO *mm_usecase.BudgetDTO
        err          error
}

// BudgetUsecaseMockCreateBudgetByDTOOrigins contains origins of expectations of the BudgetUsecase.CreateBudgetByDTO
type BudgetUsecaseMockCreateBudgetByDTOExpectationOrigins struct {
        origin    string
        originCtx string
        originIn  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) Optional() *mBudgetUsecaseMockCreateBudgetByDTO <span class="cov0" title="0">{
        mmCreateBudgetByDTO.optional = true
        return mmCreateBudgetByDTO
}</span>

// Expect sets up expected params for BudgetUsecase.CreateBudgetByDTO
func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) Expect(ctx context.Context, in mm_usecase.CreateBudgetDataInput) *mBudgetUsecaseMockCreateBudgetByDTO <span class="cov0" title="0">{
        if mmCreateBudgetByDTO.mock.funcCreateBudgetByDTO != nil </span><span class="cov0" title="0">{
                mmCreateBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.CreateBudgetByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateBudgetByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateBudgetByDTO.defaultExpectation = &amp;BudgetUsecaseMockCreateBudgetByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateBudgetByDTO.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmCreateBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.CreateBudgetByDTO mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmCreateBudgetByDTO.defaultExpectation.params = &amp;BudgetUsecaseMockCreateBudgetByDTOParams{ctx, in}
        mmCreateBudgetByDTO.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmCreateBudgetByDTO.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmCreateBudgetByDTO.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmCreateBudgetByDTO.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateBudgetByDTO.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmCreateBudgetByDTO</span>
}

// ExpectCtxParam1 sets up expected param ctx for BudgetUsecase.CreateBudgetByDTO
func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) ExpectCtxParam1(ctx context.Context) *mBudgetUsecaseMockCreateBudgetByDTO <span class="cov0" title="0">{
        if mmCreateBudgetByDTO.mock.funcCreateBudgetByDTO != nil </span><span class="cov0" title="0">{
                mmCreateBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.CreateBudgetByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateBudgetByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateBudgetByDTO.defaultExpectation = &amp;BudgetUsecaseMockCreateBudgetByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateBudgetByDTO.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreateBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.CreateBudgetByDTO mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreateBudgetByDTO.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreateBudgetByDTO.defaultExpectation.paramPtrs = &amp;BudgetUsecaseMockCreateBudgetByDTOParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreateBudgetByDTO.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmCreateBudgetByDTO.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmCreateBudgetByDTO</span>
}

// ExpectInParam2 sets up expected param in for BudgetUsecase.CreateBudgetByDTO
func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) ExpectInParam2(in mm_usecase.CreateBudgetDataInput) *mBudgetUsecaseMockCreateBudgetByDTO <span class="cov0" title="0">{
        if mmCreateBudgetByDTO.mock.funcCreateBudgetByDTO != nil </span><span class="cov0" title="0">{
                mmCreateBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.CreateBudgetByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateBudgetByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateBudgetByDTO.defaultExpectation = &amp;BudgetUsecaseMockCreateBudgetByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateBudgetByDTO.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreateBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.CreateBudgetByDTO mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreateBudgetByDTO.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreateBudgetByDTO.defaultExpectation.paramPtrs = &amp;BudgetUsecaseMockCreateBudgetByDTOParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreateBudgetByDTO.defaultExpectation.paramPtrs.in = &amp;in
        mmCreateBudgetByDTO.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

        return mmCreateBudgetByDTO</span>
}

// Inspect accepts an inspector function that has same arguments as the BudgetUsecase.CreateBudgetByDTO
func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) Inspect(f func(ctx context.Context, in mm_usecase.CreateBudgetDataInput)) *mBudgetUsecaseMockCreateBudgetByDTO <span class="cov0" title="0">{
        if mmCreateBudgetByDTO.mock.inspectFuncCreateBudgetByDTO != nil </span><span class="cov0" title="0">{
                mmCreateBudgetByDTO.mock.t.Fatalf("Inspect function is already set for BudgetUsecaseMock.CreateBudgetByDTO")
        }</span>

        <span class="cov0" title="0">mmCreateBudgetByDTO.mock.inspectFuncCreateBudgetByDTO = f

        return mmCreateBudgetByDTO</span>
}

// Return sets up results that will be returned by BudgetUsecase.CreateBudgetByDTO
func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) Return(resBudgetDTO *mm_usecase.BudgetDTO, err error) *BudgetUsecaseMock <span class="cov0" title="0">{
        if mmCreateBudgetByDTO.mock.funcCreateBudgetByDTO != nil </span><span class="cov0" title="0">{
                mmCreateBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.CreateBudgetByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateBudgetByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateBudgetByDTO.defaultExpectation = &amp;BudgetUsecaseMockCreateBudgetByDTOExpectation{mock: mmCreateBudgetByDTO.mock}
        }</span>
        <span class="cov0" title="0">mmCreateBudgetByDTO.defaultExpectation.results = &amp;BudgetUsecaseMockCreateBudgetByDTOResults{resBudgetDTO, err}
        mmCreateBudgetByDTO.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmCreateBudgetByDTO.mock</span>
}

// Set uses given function f to mock the BudgetUsecase.CreateBudgetByDTO method
func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) Set(f func(ctx context.Context, in mm_usecase.CreateBudgetDataInput) (resBudgetDTO *mm_usecase.BudgetDTO, err error)) *BudgetUsecaseMock <span class="cov0" title="0">{
        if mmCreateBudgetByDTO.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmCreateBudgetByDTO.mock.t.Fatalf("Default expectation is already set for the BudgetUsecase.CreateBudgetByDTO method")
        }</span>

        <span class="cov0" title="0">if len(mmCreateBudgetByDTO.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmCreateBudgetByDTO.mock.t.Fatalf("Some expectations are already set for the BudgetUsecase.CreateBudgetByDTO method")
        }</span>

        <span class="cov0" title="0">mmCreateBudgetByDTO.mock.funcCreateBudgetByDTO = f
        mmCreateBudgetByDTO.mock.funcCreateBudgetByDTOOrigin = minimock.CallerInfo(1)
        return mmCreateBudgetByDTO.mock</span>
}

// When sets expectation for the BudgetUsecase.CreateBudgetByDTO which will trigger the result defined by the following
// Then helper
func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) When(ctx context.Context, in mm_usecase.CreateBudgetDataInput) *BudgetUsecaseMockCreateBudgetByDTOExpectation <span class="cov0" title="0">{
        if mmCreateBudgetByDTO.mock.funcCreateBudgetByDTO != nil </span><span class="cov0" title="0">{
                mmCreateBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.CreateBudgetByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;BudgetUsecaseMockCreateBudgetByDTOExpectation{
                mock:               mmCreateBudgetByDTO.mock,
                params:             &amp;BudgetUsecaseMockCreateBudgetByDTOParams{ctx, in},
                expectationOrigins: BudgetUsecaseMockCreateBudgetByDTOExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmCreateBudgetByDTO.expectations = append(mmCreateBudgetByDTO.expectations, expectation)
        return expectation</span>
}

// Then sets up BudgetUsecase.CreateBudgetByDTO return parameters for the expectation previously defined by the When method
func (e *BudgetUsecaseMockCreateBudgetByDTOExpectation) Then(resBudgetDTO *mm_usecase.BudgetDTO, err error) *BudgetUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;BudgetUsecaseMockCreateBudgetByDTOResults{resBudgetDTO, err}
        return e.mock
}</span>

// Times sets number of times BudgetUsecase.CreateBudgetByDTO should be invoked
func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) Times(n uint64) *mBudgetUsecaseMockCreateBudgetByDTO <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmCreateBudgetByDTO.mock.t.Fatalf("Times of BudgetUsecaseMock.CreateBudgetByDTO mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmCreateBudgetByDTO.expectedInvocations, n)
        mmCreateBudgetByDTO.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmCreateBudgetByDTO</span>
}

func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmCreateBudgetByDTO.expectations) == 0 &amp;&amp; mmCreateBudgetByDTO.defaultExpectation == nil &amp;&amp; mmCreateBudgetByDTO.mock.funcCreateBudgetByDTO == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmCreateBudgetByDTO.mock.afterCreateBudgetByDTOCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmCreateBudgetByDTO.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// CreateBudgetByDTO implements mm_usecase.BudgetUsecase
func (mmCreateBudgetByDTO *BudgetUsecaseMock) CreateBudgetByDTO(ctx context.Context, in mm_usecase.CreateBudgetDataInput) (resBudgetDTO *mm_usecase.BudgetDTO, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmCreateBudgetByDTO.beforeCreateBudgetByDTOCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmCreateBudgetByDTO.afterCreateBudgetByDTOCounter, 1)

        mmCreateBudgetByDTO.t.Helper()

        if mmCreateBudgetByDTO.inspectFuncCreateBudgetByDTO != nil </span><span class="cov0" title="0">{
                mmCreateBudgetByDTO.inspectFuncCreateBudgetByDTO(ctx, in)
        }</span>

        <span class="cov0" title="0">mm_params := BudgetUsecaseMockCreateBudgetByDTOParams{ctx, in}

        // Record call args
        mmCreateBudgetByDTO.CreateBudgetByDTOMock.mutex.Lock()
        mmCreateBudgetByDTO.CreateBudgetByDTOMock.callArgs = append(mmCreateBudgetByDTO.CreateBudgetByDTOMock.callArgs, &amp;mm_params)
        mmCreateBudgetByDTO.CreateBudgetByDTOMock.mutex.Unlock()

        for _, e := range mmCreateBudgetByDTO.CreateBudgetByDTOMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.resBudgetDTO, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmCreateBudgetByDTO.CreateBudgetByDTOMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmCreateBudgetByDTO.CreateBudgetByDTOMock.defaultExpectation.Counter, 1)
                mm_want := mmCreateBudgetByDTO.CreateBudgetByDTOMock.defaultExpectation.params
                mm_want_ptrs := mmCreateBudgetByDTO.CreateBudgetByDTOMock.defaultExpectation.paramPtrs

                mm_got := BudgetUsecaseMockCreateBudgetByDTOParams{ctx, in}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmCreateBudgetByDTO.t.Errorf("BudgetUsecaseMock.CreateBudgetByDTO got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCreateBudgetByDTO.CreateBudgetByDTOMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.in != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.in, mm_got.in) </span><span class="cov0" title="0">{
                                mmCreateBudgetByDTO.t.Errorf("BudgetUsecaseMock.CreateBudgetByDTO got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCreateBudgetByDTO.CreateBudgetByDTOMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmCreateBudgetByDTO.t.Errorf("BudgetUsecaseMock.CreateBudgetByDTO got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmCreateBudgetByDTO.CreateBudgetByDTOMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmCreateBudgetByDTO.CreateBudgetByDTOMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmCreateBudgetByDTO.t.Fatal("No results are set for the BudgetUsecaseMock.CreateBudgetByDTO")
                }</span>
                <span class="cov0" title="0">return (*mm_results).resBudgetDTO, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmCreateBudgetByDTO.funcCreateBudgetByDTO != nil </span><span class="cov0" title="0">{
                return mmCreateBudgetByDTO.funcCreateBudgetByDTO(ctx, in)
        }</span>
        <span class="cov0" title="0">mmCreateBudgetByDTO.t.Fatalf("Unexpected call to BudgetUsecaseMock.CreateBudgetByDTO. %v %v", ctx, in)
        return</span>
}

// CreateBudgetByDTOAfterCounter returns a count of finished BudgetUsecaseMock.CreateBudgetByDTO invocations
func (mmCreateBudgetByDTO *BudgetUsecaseMock) CreateBudgetByDTOAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreateBudgetByDTO.afterCreateBudgetByDTOCounter)
}</span>

// CreateBudgetByDTOBeforeCounter returns a count of BudgetUsecaseMock.CreateBudgetByDTO invocations
func (mmCreateBudgetByDTO *BudgetUsecaseMock) CreateBudgetByDTOBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreateBudgetByDTO.beforeCreateBudgetByDTOCounter)
}</span>

// Calls returns a list of arguments used in each call to BudgetUsecaseMock.CreateBudgetByDTO.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateBudgetByDTO *mBudgetUsecaseMockCreateBudgetByDTO) Calls() []*BudgetUsecaseMockCreateBudgetByDTOParams <span class="cov0" title="0">{
        mmCreateBudgetByDTO.mutex.RLock()

        argCopy := make([]*BudgetUsecaseMockCreateBudgetByDTOParams, len(mmCreateBudgetByDTO.callArgs))
        copy(argCopy, mmCreateBudgetByDTO.callArgs)

        mmCreateBudgetByDTO.mutex.RUnlock()

        return argCopy
}</span>

// MinimockCreateBudgetByDTODone returns true if the count of the CreateBudgetByDTO invocations corresponds
// the number of defined expectations
func (m *BudgetUsecaseMock) MinimockCreateBudgetByDTODone() bool <span class="cov0" title="0">{
        if m.CreateBudgetByDTOMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.CreateBudgetByDTOMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.CreateBudgetByDTOMock.invocationsDone()</span>
}

// MinimockCreateBudgetByDTOInspect logs each unmet expectation
func (m *BudgetUsecaseMock) MinimockCreateBudgetByDTOInspect() <span class="cov0" title="0">{
        for _, e := range m.CreateBudgetByDTOMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetUsecaseMock.CreateBudgetByDTO at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterCreateBudgetByDTOCounter := mm_atomic.LoadUint64(&amp;m.afterCreateBudgetByDTOCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.CreateBudgetByDTOMock.defaultExpectation != nil &amp;&amp; afterCreateBudgetByDTOCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.CreateBudgetByDTOMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetUsecaseMock.CreateBudgetByDTO at\n%s", m.CreateBudgetByDTOMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to BudgetUsecaseMock.CreateBudgetByDTO at\n%s with params: %#v", m.CreateBudgetByDTOMock.defaultExpectation.expectationOrigins.origin, *m.CreateBudgetByDTOMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcCreateBudgetByDTO != nil &amp;&amp; afterCreateBudgetByDTOCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to BudgetUsecaseMock.CreateBudgetByDTO at\n%s", m.funcCreateBudgetByDTOOrigin)
        }</span>

        <span class="cov0" title="0">if !m.CreateBudgetByDTOMock.invocationsDone() &amp;&amp; afterCreateBudgetByDTOCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to BudgetUsecaseMock.CreateBudgetByDTO at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.CreateBudgetByDTOMock.expectedInvocations), m.CreateBudgetByDTOMock.expectedInvocationsOrigin, afterCreateBudgetByDTOCounter)
        }</span>
}

type mBudgetUsecaseMockDeleteBudgetByID struct {
        optional           bool
        mock               *BudgetUsecaseMock
        defaultExpectation *BudgetUsecaseMockDeleteBudgetByIDExpectation
        expectations       []*BudgetUsecaseMockDeleteBudgetByIDExpectation

        callArgs []*BudgetUsecaseMockDeleteBudgetByIDParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// BudgetUsecaseMockDeleteBudgetByIDExpectation specifies expectation struct of the BudgetUsecase.DeleteBudgetByID
type BudgetUsecaseMockDeleteBudgetByIDExpectation struct {
        mock               *BudgetUsecaseMock
        params             *BudgetUsecaseMockDeleteBudgetByIDParams
        paramPtrs          *BudgetUsecaseMockDeleteBudgetByIDParamPtrs
        expectationOrigins BudgetUsecaseMockDeleteBudgetByIDExpectationOrigins
        results            *BudgetUsecaseMockDeleteBudgetByIDResults
        returnOrigin       string
        Counter            uint64
}

// BudgetUsecaseMockDeleteBudgetByIDParams contains parameters of the BudgetUsecase.DeleteBudgetByID
type BudgetUsecaseMockDeleteBudgetByIDParams struct {
        ctx context.Context
        id  uuid.UUID
}

// BudgetUsecaseMockDeleteBudgetByIDParamPtrs contains pointers to parameters of the BudgetUsecase.DeleteBudgetByID
type BudgetUsecaseMockDeleteBudgetByIDParamPtrs struct {
        ctx *context.Context
        id  *uuid.UUID
}

// BudgetUsecaseMockDeleteBudgetByIDResults contains results of the BudgetUsecase.DeleteBudgetByID
type BudgetUsecaseMockDeleteBudgetByIDResults struct {
        err error
}

// BudgetUsecaseMockDeleteBudgetByIDOrigins contains origins of expectations of the BudgetUsecase.DeleteBudgetByID
type BudgetUsecaseMockDeleteBudgetByIDExpectationOrigins struct {
        origin    string
        originCtx string
        originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) Optional() *mBudgetUsecaseMockDeleteBudgetByID <span class="cov0" title="0">{
        mmDeleteBudgetByID.optional = true
        return mmDeleteBudgetByID
}</span>

// Expect sets up expected params for BudgetUsecase.DeleteBudgetByID
func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) Expect(ctx context.Context, id uuid.UUID) *mBudgetUsecaseMockDeleteBudgetByID <span class="cov0" title="0">{
        if mmDeleteBudgetByID.mock.funcDeleteBudgetByID != nil </span><span class="cov0" title="0">{
                mmDeleteBudgetByID.mock.t.Fatalf("BudgetUsecaseMock.DeleteBudgetByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteBudgetByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteBudgetByID.defaultExpectation = &amp;BudgetUsecaseMockDeleteBudgetByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteBudgetByID.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmDeleteBudgetByID.mock.t.Fatalf("BudgetUsecaseMock.DeleteBudgetByID mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmDeleteBudgetByID.defaultExpectation.params = &amp;BudgetUsecaseMockDeleteBudgetByIDParams{ctx, id}
        mmDeleteBudgetByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmDeleteBudgetByID.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmDeleteBudgetByID.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmDeleteBudgetByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteBudgetByID.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmDeleteBudgetByID</span>
}

// ExpectCtxParam1 sets up expected param ctx for BudgetUsecase.DeleteBudgetByID
func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) ExpectCtxParam1(ctx context.Context) *mBudgetUsecaseMockDeleteBudgetByID <span class="cov0" title="0">{
        if mmDeleteBudgetByID.mock.funcDeleteBudgetByID != nil </span><span class="cov0" title="0">{
                mmDeleteBudgetByID.mock.t.Fatalf("BudgetUsecaseMock.DeleteBudgetByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteBudgetByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteBudgetByID.defaultExpectation = &amp;BudgetUsecaseMockDeleteBudgetByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteBudgetByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDeleteBudgetByID.mock.t.Fatalf("BudgetUsecaseMock.DeleteBudgetByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDeleteBudgetByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDeleteBudgetByID.defaultExpectation.paramPtrs = &amp;BudgetUsecaseMockDeleteBudgetByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDeleteBudgetByID.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmDeleteBudgetByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmDeleteBudgetByID</span>
}

// ExpectIdParam2 sets up expected param id for BudgetUsecase.DeleteBudgetByID
func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) ExpectIdParam2(id uuid.UUID) *mBudgetUsecaseMockDeleteBudgetByID <span class="cov0" title="0">{
        if mmDeleteBudgetByID.mock.funcDeleteBudgetByID != nil </span><span class="cov0" title="0">{
                mmDeleteBudgetByID.mock.t.Fatalf("BudgetUsecaseMock.DeleteBudgetByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteBudgetByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteBudgetByID.defaultExpectation = &amp;BudgetUsecaseMockDeleteBudgetByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteBudgetByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDeleteBudgetByID.mock.t.Fatalf("BudgetUsecaseMock.DeleteBudgetByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDeleteBudgetByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDeleteBudgetByID.defaultExpectation.paramPtrs = &amp;BudgetUsecaseMockDeleteBudgetByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDeleteBudgetByID.defaultExpectation.paramPtrs.id = &amp;id
        mmDeleteBudgetByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmDeleteBudgetByID</span>
}

// Inspect accepts an inspector function that has same arguments as the BudgetUsecase.DeleteBudgetByID
func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) Inspect(f func(ctx context.Context, id uuid.UUID)) *mBudgetUsecaseMockDeleteBudgetByID <span class="cov0" title="0">{
        if mmDeleteBudgetByID.mock.inspectFuncDeleteBudgetByID != nil </span><span class="cov0" title="0">{
                mmDeleteBudgetByID.mock.t.Fatalf("Inspect function is already set for BudgetUsecaseMock.DeleteBudgetByID")
        }</span>

        <span class="cov0" title="0">mmDeleteBudgetByID.mock.inspectFuncDeleteBudgetByID = f

        return mmDeleteBudgetByID</span>
}

// Return sets up results that will be returned by BudgetUsecase.DeleteBudgetByID
func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) Return(err error) *BudgetUsecaseMock <span class="cov0" title="0">{
        if mmDeleteBudgetByID.mock.funcDeleteBudgetByID != nil </span><span class="cov0" title="0">{
                mmDeleteBudgetByID.mock.t.Fatalf("BudgetUsecaseMock.DeleteBudgetByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteBudgetByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteBudgetByID.defaultExpectation = &amp;BudgetUsecaseMockDeleteBudgetByIDExpectation{mock: mmDeleteBudgetByID.mock}
        }</span>
        <span class="cov0" title="0">mmDeleteBudgetByID.defaultExpectation.results = &amp;BudgetUsecaseMockDeleteBudgetByIDResults{err}
        mmDeleteBudgetByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmDeleteBudgetByID.mock</span>
}

// Set uses given function f to mock the BudgetUsecase.DeleteBudgetByID method
func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *BudgetUsecaseMock <span class="cov0" title="0">{
        if mmDeleteBudgetByID.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmDeleteBudgetByID.mock.t.Fatalf("Default expectation is already set for the BudgetUsecase.DeleteBudgetByID method")
        }</span>

        <span class="cov0" title="0">if len(mmDeleteBudgetByID.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmDeleteBudgetByID.mock.t.Fatalf("Some expectations are already set for the BudgetUsecase.DeleteBudgetByID method")
        }</span>

        <span class="cov0" title="0">mmDeleteBudgetByID.mock.funcDeleteBudgetByID = f
        mmDeleteBudgetByID.mock.funcDeleteBudgetByIDOrigin = minimock.CallerInfo(1)
        return mmDeleteBudgetByID.mock</span>
}

// When sets expectation for the BudgetUsecase.DeleteBudgetByID which will trigger the result defined by the following
// Then helper
func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) When(ctx context.Context, id uuid.UUID) *BudgetUsecaseMockDeleteBudgetByIDExpectation <span class="cov0" title="0">{
        if mmDeleteBudgetByID.mock.funcDeleteBudgetByID != nil </span><span class="cov0" title="0">{
                mmDeleteBudgetByID.mock.t.Fatalf("BudgetUsecaseMock.DeleteBudgetByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;BudgetUsecaseMockDeleteBudgetByIDExpectation{
                mock:               mmDeleteBudgetByID.mock,
                params:             &amp;BudgetUsecaseMockDeleteBudgetByIDParams{ctx, id},
                expectationOrigins: BudgetUsecaseMockDeleteBudgetByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmDeleteBudgetByID.expectations = append(mmDeleteBudgetByID.expectations, expectation)
        return expectation</span>
}

// Then sets up BudgetUsecase.DeleteBudgetByID return parameters for the expectation previously defined by the When method
func (e *BudgetUsecaseMockDeleteBudgetByIDExpectation) Then(err error) *BudgetUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;BudgetUsecaseMockDeleteBudgetByIDResults{err}
        return e.mock
}</span>

// Times sets number of times BudgetUsecase.DeleteBudgetByID should be invoked
func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) Times(n uint64) *mBudgetUsecaseMockDeleteBudgetByID <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmDeleteBudgetByID.mock.t.Fatalf("Times of BudgetUsecaseMock.DeleteBudgetByID mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmDeleteBudgetByID.expectedInvocations, n)
        mmDeleteBudgetByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmDeleteBudgetByID</span>
}

func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmDeleteBudgetByID.expectations) == 0 &amp;&amp; mmDeleteBudgetByID.defaultExpectation == nil &amp;&amp; mmDeleteBudgetByID.mock.funcDeleteBudgetByID == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmDeleteBudgetByID.mock.afterDeleteBudgetByIDCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmDeleteBudgetByID.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// DeleteBudgetByID implements mm_usecase.BudgetUsecase
func (mmDeleteBudgetByID *BudgetUsecaseMock) DeleteBudgetByID(ctx context.Context, id uuid.UUID) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmDeleteBudgetByID.beforeDeleteBudgetByIDCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmDeleteBudgetByID.afterDeleteBudgetByIDCounter, 1)

        mmDeleteBudgetByID.t.Helper()

        if mmDeleteBudgetByID.inspectFuncDeleteBudgetByID != nil </span><span class="cov0" title="0">{
                mmDeleteBudgetByID.inspectFuncDeleteBudgetByID(ctx, id)
        }</span>

        <span class="cov0" title="0">mm_params := BudgetUsecaseMockDeleteBudgetByIDParams{ctx, id}

        // Record call args
        mmDeleteBudgetByID.DeleteBudgetByIDMock.mutex.Lock()
        mmDeleteBudgetByID.DeleteBudgetByIDMock.callArgs = append(mmDeleteBudgetByID.DeleteBudgetByIDMock.callArgs, &amp;mm_params)
        mmDeleteBudgetByID.DeleteBudgetByIDMock.mutex.Unlock()

        for _, e := range mmDeleteBudgetByID.DeleteBudgetByIDMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmDeleteBudgetByID.DeleteBudgetByIDMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmDeleteBudgetByID.DeleteBudgetByIDMock.defaultExpectation.Counter, 1)
                mm_want := mmDeleteBudgetByID.DeleteBudgetByIDMock.defaultExpectation.params
                mm_want_ptrs := mmDeleteBudgetByID.DeleteBudgetByIDMock.defaultExpectation.paramPtrs

                mm_got := BudgetUsecaseMockDeleteBudgetByIDParams{ctx, id}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmDeleteBudgetByID.t.Errorf("BudgetUsecaseMock.DeleteBudgetByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmDeleteBudgetByID.DeleteBudgetByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmDeleteBudgetByID.t.Errorf("BudgetUsecaseMock.DeleteBudgetByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmDeleteBudgetByID.DeleteBudgetByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmDeleteBudgetByID.t.Errorf("BudgetUsecaseMock.DeleteBudgetByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmDeleteBudgetByID.DeleteBudgetByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmDeleteBudgetByID.DeleteBudgetByIDMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmDeleteBudgetByID.t.Fatal("No results are set for the BudgetUsecaseMock.DeleteBudgetByID")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmDeleteBudgetByID.funcDeleteBudgetByID != nil </span><span class="cov0" title="0">{
                return mmDeleteBudgetByID.funcDeleteBudgetByID(ctx, id)
        }</span>
        <span class="cov0" title="0">mmDeleteBudgetByID.t.Fatalf("Unexpected call to BudgetUsecaseMock.DeleteBudgetByID. %v %v", ctx, id)
        return</span>
}

// DeleteBudgetByIDAfterCounter returns a count of finished BudgetUsecaseMock.DeleteBudgetByID invocations
func (mmDeleteBudgetByID *BudgetUsecaseMock) DeleteBudgetByIDAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDeleteBudgetByID.afterDeleteBudgetByIDCounter)
}</span>

// DeleteBudgetByIDBeforeCounter returns a count of BudgetUsecaseMock.DeleteBudgetByID invocations
func (mmDeleteBudgetByID *BudgetUsecaseMock) DeleteBudgetByIDBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDeleteBudgetByID.beforeDeleteBudgetByIDCounter)
}</span>

// Calls returns a list of arguments used in each call to BudgetUsecaseMock.DeleteBudgetByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteBudgetByID *mBudgetUsecaseMockDeleteBudgetByID) Calls() []*BudgetUsecaseMockDeleteBudgetByIDParams <span class="cov0" title="0">{
        mmDeleteBudgetByID.mutex.RLock()

        argCopy := make([]*BudgetUsecaseMockDeleteBudgetByIDParams, len(mmDeleteBudgetByID.callArgs))
        copy(argCopy, mmDeleteBudgetByID.callArgs)

        mmDeleteBudgetByID.mutex.RUnlock()

        return argCopy
}</span>

// MinimockDeleteBudgetByIDDone returns true if the count of the DeleteBudgetByID invocations corresponds
// the number of defined expectations
func (m *BudgetUsecaseMock) MinimockDeleteBudgetByIDDone() bool <span class="cov0" title="0">{
        if m.DeleteBudgetByIDMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.DeleteBudgetByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.DeleteBudgetByIDMock.invocationsDone()</span>
}

// MinimockDeleteBudgetByIDInspect logs each unmet expectation
func (m *BudgetUsecaseMock) MinimockDeleteBudgetByIDInspect() <span class="cov0" title="0">{
        for _, e := range m.DeleteBudgetByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetUsecaseMock.DeleteBudgetByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterDeleteBudgetByIDCounter := mm_atomic.LoadUint64(&amp;m.afterDeleteBudgetByIDCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.DeleteBudgetByIDMock.defaultExpectation != nil &amp;&amp; afterDeleteBudgetByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.DeleteBudgetByIDMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetUsecaseMock.DeleteBudgetByID at\n%s", m.DeleteBudgetByIDMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to BudgetUsecaseMock.DeleteBudgetByID at\n%s with params: %#v", m.DeleteBudgetByIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteBudgetByIDMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcDeleteBudgetByID != nil &amp;&amp; afterDeleteBudgetByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to BudgetUsecaseMock.DeleteBudgetByID at\n%s", m.funcDeleteBudgetByIDOrigin)
        }</span>

        <span class="cov0" title="0">if !m.DeleteBudgetByIDMock.invocationsDone() &amp;&amp; afterDeleteBudgetByIDCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to BudgetUsecaseMock.DeleteBudgetByID at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.DeleteBudgetByIDMock.expectedInvocations), m.DeleteBudgetByIDMock.expectedInvocationsOrigin, afterDeleteBudgetByIDCounter)
        }</span>
}

type mBudgetUsecaseMockFindList struct {
        optional           bool
        mock               *BudgetUsecaseMock
        defaultExpectation *BudgetUsecaseMockFindListExpectation
        expectations       []*BudgetUsecaseMockFindListExpectation

        callArgs []*BudgetUsecaseMockFindListParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// BudgetUsecaseMockFindListExpectation specifies expectation struct of the BudgetUsecase.FindList
type BudgetUsecaseMockFindListExpectation struct {
        mock               *BudgetUsecaseMock
        params             *BudgetUsecaseMockFindListParams
        paramPtrs          *BudgetUsecaseMockFindListParamPtrs
        expectationOrigins BudgetUsecaseMockFindListExpectationOrigins
        results            *BudgetUsecaseMockFindListResults
        returnOrigin       string
        Counter            uint64
}

// BudgetUsecaseMockFindListParams contains parameters of the BudgetUsecase.FindList
type BudgetUsecaseMockFindListParams struct {
        ctx         context.Context
        listOptions *mm_usecase.BudgetListOptions
        queryParams *uctypes.QueryGetListParams
}

// BudgetUsecaseMockFindListParamPtrs contains pointers to parameters of the BudgetUsecase.FindList
type BudgetUsecaseMockFindListParamPtrs struct {
        ctx         *context.Context
        listOptions **mm_usecase.BudgetListOptions
        queryParams **uctypes.QueryGetListParams
}

// BudgetUsecaseMockFindListResults contains results of the BudgetUsecase.FindList
type BudgetUsecaseMockFindListResults struct {
        resItems []*mm_usecase.BudgetDTO
        cacheHit bool
        err      error
}

// BudgetUsecaseMockFindListOrigins contains origins of expectations of the BudgetUsecase.FindList
type BudgetUsecaseMockFindListExpectationOrigins struct {
        origin            string
        originCtx         string
        originListOptions string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindList *mBudgetUsecaseMockFindList) Optional() *mBudgetUsecaseMockFindList <span class="cov0" title="0">{
        mmFindList.optional = true
        return mmFindList
}</span>

// Expect sets up expected params for BudgetUsecase.FindList
func (mmFindList *mBudgetUsecaseMockFindList) Expect(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) *mBudgetUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("BudgetUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;BudgetUsecaseMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("BudgetUsecaseMock.FindList mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindList.defaultExpectation.params = &amp;BudgetUsecaseMockFindListParams{ctx, listOptions, queryParams}
        mmFindList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindList.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindList.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindList.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindList</span>
}

// ExpectCtxParam1 sets up expected param ctx for BudgetUsecase.FindList
func (mmFindList *mBudgetUsecaseMockFindList) ExpectCtxParam1(ctx context.Context) *mBudgetUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("BudgetUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;BudgetUsecaseMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("BudgetUsecaseMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;BudgetUsecaseMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindList</span>
}

// ExpectListOptionsParam2 sets up expected param listOptions for BudgetUsecase.FindList
func (mmFindList *mBudgetUsecaseMockFindList) ExpectListOptionsParam2(listOptions *mm_usecase.BudgetListOptions) *mBudgetUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("BudgetUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;BudgetUsecaseMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("BudgetUsecaseMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;BudgetUsecaseMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.listOptions = &amp;listOptions
        mmFindList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

        return mmFindList</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for BudgetUsecase.FindList
func (mmFindList *mBudgetUsecaseMockFindList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mBudgetUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("BudgetUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;BudgetUsecaseMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("BudgetUsecaseMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;BudgetUsecaseMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindList</span>
}

// Inspect accepts an inspector function that has same arguments as the BudgetUsecase.FindList
func (mmFindList *mBudgetUsecaseMockFindList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams)) *mBudgetUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.inspectFuncFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Inspect function is already set for BudgetUsecaseMock.FindList")
        }</span>

        <span class="cov0" title="0">mmFindList.mock.inspectFuncFindList = f

        return mmFindList</span>
}

// Return sets up results that will be returned by BudgetUsecase.FindList
func (mmFindList *mBudgetUsecaseMockFindList) Return(resItems []*mm_usecase.BudgetDTO, cacheHit bool, err error) *BudgetUsecaseMock <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("BudgetUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;BudgetUsecaseMockFindListExpectation{mock: mmFindList.mock}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.results = &amp;BudgetUsecaseMockFindListResults{resItems, cacheHit, err}
        mmFindList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindList.mock</span>
}

// Set uses given function f to mock the BudgetUsecase.FindList method
func (mmFindList *mBudgetUsecaseMockFindList) Set(f func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.BudgetDTO, cacheHit bool, err error)) *BudgetUsecaseMock <span class="cov0" title="0">{
        if mmFindList.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Default expectation is already set for the BudgetUsecase.FindList method")
        }</span>

        <span class="cov0" title="0">if len(mmFindList.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Some expectations are already set for the BudgetUsecase.FindList method")
        }</span>

        <span class="cov0" title="0">mmFindList.mock.funcFindList = f
        mmFindList.mock.funcFindListOrigin = minimock.CallerInfo(1)
        return mmFindList.mock</span>
}

// When sets expectation for the BudgetUsecase.FindList which will trigger the result defined by the following
// Then helper
func (mmFindList *mBudgetUsecaseMockFindList) When(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) *BudgetUsecaseMockFindListExpectation <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("BudgetUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;BudgetUsecaseMockFindListExpectation{
                mock:               mmFindList.mock,
                params:             &amp;BudgetUsecaseMockFindListParams{ctx, listOptions, queryParams},
                expectationOrigins: BudgetUsecaseMockFindListExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindList.expectations = append(mmFindList.expectations, expectation)
        return expectation</span>
}

// Then sets up BudgetUsecase.FindList return parameters for the expectation previously defined by the When method
func (e *BudgetUsecaseMockFindListExpectation) Then(resItems []*mm_usecase.BudgetDTO, cacheHit bool, err error) *BudgetUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;BudgetUsecaseMockFindListResults{resItems, cacheHit, err}
        return e.mock
}</span>

// Times sets number of times BudgetUsecase.FindList should be invoked
func (mmFindList *mBudgetUsecaseMockFindList) Times(n uint64) *mBudgetUsecaseMockFindList <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Times of BudgetUsecaseMock.FindList mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindList.expectedInvocations, n)
        mmFindList.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindList</span>
}

func (mmFindList *mBudgetUsecaseMockFindList) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindList.expectations) == 0 &amp;&amp; mmFindList.defaultExpectation == nil &amp;&amp; mmFindList.mock.funcFindList == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindList.mock.afterFindListCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindList.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindList implements mm_usecase.BudgetUsecase
func (mmFindList *BudgetUsecaseMock) FindList(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.BudgetDTO, cacheHit bool, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindList.beforeFindListCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindList.afterFindListCounter, 1)

        mmFindList.t.Helper()

        if mmFindList.inspectFuncFindList != nil </span><span class="cov0" title="0">{
                mmFindList.inspectFuncFindList(ctx, listOptions, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := BudgetUsecaseMockFindListParams{ctx, listOptions, queryParams}

        // Record call args
        mmFindList.FindListMock.mutex.Lock()
        mmFindList.FindListMock.callArgs = append(mmFindList.FindListMock.callArgs, &amp;mm_params)
        mmFindList.FindListMock.mutex.Unlock()

        for _, e := range mmFindList.FindListMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.resItems, e.results.cacheHit, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindList.FindListMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindList.FindListMock.defaultExpectation.Counter, 1)
                mm_want := mmFindList.FindListMock.defaultExpectation.params
                mm_want_ptrs := mmFindList.FindListMock.defaultExpectation.paramPtrs

                mm_got := BudgetUsecaseMockFindListParams{ctx, listOptions, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("BudgetUsecaseMock.FindList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.listOptions != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("BudgetUsecaseMock.FindList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("BudgetUsecaseMock.FindList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindList.t.Errorf("BudgetUsecaseMock.FindList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindList.FindListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindList.FindListMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindList.t.Fatal("No results are set for the BudgetUsecaseMock.FindList")
                }</span>
                <span class="cov0" title="0">return (*mm_results).resItems, (*mm_results).cacheHit, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindList.funcFindList != nil </span><span class="cov0" title="0">{
                return mmFindList.funcFindList(ctx, listOptions, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindList.t.Fatalf("Unexpected call to BudgetUsecaseMock.FindList. %v %v %v", ctx, listOptions, queryParams)
        return</span>
}

// FindListAfterCounter returns a count of finished BudgetUsecaseMock.FindList invocations
func (mmFindList *BudgetUsecaseMock) FindListAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindList.afterFindListCounter)
}</span>

// FindListBeforeCounter returns a count of BudgetUsecaseMock.FindList invocations
func (mmFindList *BudgetUsecaseMock) FindListBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindList.beforeFindListCounter)
}</span>

// Calls returns a list of arguments used in each call to BudgetUsecaseMock.FindList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindList *mBudgetUsecaseMockFindList) Calls() []*BudgetUsecaseMockFindListParams <span class="cov0" title="0">{
        mmFindList.mutex.RLock()

        argCopy := make([]*BudgetUsecaseMockFindListParams, len(mmFindList.callArgs))
        copy(argCopy, mmFindList.callArgs)

        mmFindList.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindListDone returns true if the count of the FindList invocations corresponds
// the number of defined expectations
func (m *BudgetUsecaseMock) MinimockFindListDone() bool <span class="cov0" title="0">{
        if m.FindListMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindListMock.invocationsDone()</span>
}

// MinimockFindListInspect logs each unmet expectation
func (m *BudgetUsecaseMock) MinimockFindListInspect() <span class="cov0" title="0">{
        for _, e := range m.FindListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetUsecaseMock.FindList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindListCounter := mm_atomic.LoadUint64(&amp;m.afterFindListCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindListMock.defaultExpectation != nil &amp;&amp; afterFindListCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindListMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetUsecaseMock.FindList at\n%s", m.FindListMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to BudgetUsecaseMock.FindList at\n%s with params: %#v", m.FindListMock.defaultExpectation.expectationOrigins.origin, *m.FindListMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindList != nil &amp;&amp; afterFindListCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to BudgetUsecaseMock.FindList at\n%s", m.funcFindListOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindListMock.invocationsDone() &amp;&amp; afterFindListCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to BudgetUsecaseMock.FindList at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindListMock.expectedInvocations), m.FindListMock.expectedInvocationsOrigin, afterFindListCounter)
        }</span>
}

type mBudgetUsecaseMockFindOneByID struct {
        optional           bool
        mock               *BudgetUsecaseMock
        defaultExpectation *BudgetUsecaseMockFindOneByIDExpectation
        expectations       []*BudgetUsecaseMockFindOneByIDExpectation

        callArgs []*BudgetUsecaseMockFindOneByIDParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// BudgetUsecaseMockFindOneByIDExpectation specifies expectation struct of the BudgetUsecase.FindOneByID
type BudgetUsecaseMockFindOneByIDExpectation struct {
        mock               *BudgetUsecaseMock
        params             *BudgetUsecaseMockFindOneByIDParams
        paramPtrs          *BudgetUsecaseMockFindOneByIDParamPtrs
        expectationOrigins BudgetUsecaseMockFindOneByIDExpectationOrigins
        results            *BudgetUsecaseMockFindOneByIDResults
        returnOrigin       string
        Counter            uint64
}

// BudgetUsecaseMockFindOneByIDParams contains parameters of the BudgetUsecase.FindOneByID
type BudgetUsecaseMockFindOneByIDParams struct {
        ctx         context.Context
        id          uuid.UUID
        queryParams *uctypes.QueryGetOneParams
}

// BudgetUsecaseMockFindOneByIDParamPtrs contains pointers to parameters of the BudgetUsecase.FindOneByID
type BudgetUsecaseMockFindOneByIDParamPtrs struct {
        ctx         *context.Context
        id          *uuid.UUID
        queryParams **uctypes.QueryGetOneParams
}

// BudgetUsecaseMockFindOneByIDResults contains results of the BudgetUsecase.FindOneByID
type BudgetUsecaseMockFindOneByIDResults struct {
        resItem  *mm_usecase.BudgetDTO
        cacheHit bool
        err      error
}

// BudgetUsecaseMockFindOneByIDOrigins contains origins of expectations of the BudgetUsecase.FindOneByID
type BudgetUsecaseMockFindOneByIDExpectationOrigins struct {
        origin            string
        originCtx         string
        originId          string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) Optional() *mBudgetUsecaseMockFindOneByID <span class="cov0" title="0">{
        mmFindOneByID.optional = true
        return mmFindOneByID
}</span>

// Expect sets up expected params for BudgetUsecase.FindOneByID
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) Expect(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *mBudgetUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("BudgetUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;BudgetUsecaseMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("BudgetUsecaseMock.FindOneByID mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.params = &amp;BudgetUsecaseMockFindOneByIDParams{ctx, id, queryParams}
        mmFindOneByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindOneByID.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindOneByID.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindOneByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindOneByID.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindOneByID</span>
}

// ExpectCtxParam1 sets up expected param ctx for BudgetUsecase.FindOneByID
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) ExpectCtxParam1(ctx context.Context) *mBudgetUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("BudgetUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;BudgetUsecaseMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("BudgetUsecaseMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;BudgetUsecaseMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindOneByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// ExpectIdParam2 sets up expected param id for BudgetUsecase.FindOneByID
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) ExpectIdParam2(id uuid.UUID) *mBudgetUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("BudgetUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;BudgetUsecaseMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("BudgetUsecaseMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;BudgetUsecaseMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.id = &amp;id
        mmFindOneByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for BudgetUsecase.FindOneByID
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetOneParams) *mBudgetUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("BudgetUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;BudgetUsecaseMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("BudgetUsecaseMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;BudgetUsecaseMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindOneByID.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// Inspect accepts an inspector function that has same arguments as the BudgetUsecase.FindOneByID
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) Inspect(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)) *mBudgetUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.inspectFuncFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Inspect function is already set for BudgetUsecaseMock.FindOneByID")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.mock.inspectFuncFindOneByID = f

        return mmFindOneByID</span>
}

// Return sets up results that will be returned by BudgetUsecase.FindOneByID
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) Return(resItem *mm_usecase.BudgetDTO, cacheHit bool, err error) *BudgetUsecaseMock <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("BudgetUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;BudgetUsecaseMockFindOneByIDExpectation{mock: mmFindOneByID.mock}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.results = &amp;BudgetUsecaseMockFindOneByIDResults{resItem, cacheHit, err}
        mmFindOneByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindOneByID.mock</span>
}

// Set uses given function f to mock the BudgetUsecase.FindOneByID method
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) Set(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (resItem *mm_usecase.BudgetDTO, cacheHit bool, err error)) *BudgetUsecaseMock <span class="cov0" title="0">{
        if mmFindOneByID.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Default expectation is already set for the BudgetUsecase.FindOneByID method")
        }</span>

        <span class="cov0" title="0">if len(mmFindOneByID.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Some expectations are already set for the BudgetUsecase.FindOneByID method")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.mock.funcFindOneByID = f
        mmFindOneByID.mock.funcFindOneByIDOrigin = minimock.CallerInfo(1)
        return mmFindOneByID.mock</span>
}

// When sets expectation for the BudgetUsecase.FindOneByID which will trigger the result defined by the following
// Then helper
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) When(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *BudgetUsecaseMockFindOneByIDExpectation <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("BudgetUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;BudgetUsecaseMockFindOneByIDExpectation{
                mock:               mmFindOneByID.mock,
                params:             &amp;BudgetUsecaseMockFindOneByIDParams{ctx, id, queryParams},
                expectationOrigins: BudgetUsecaseMockFindOneByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindOneByID.expectations = append(mmFindOneByID.expectations, expectation)
        return expectation</span>
}

// Then sets up BudgetUsecase.FindOneByID return parameters for the expectation previously defined by the When method
func (e *BudgetUsecaseMockFindOneByIDExpectation) Then(resItem *mm_usecase.BudgetDTO, cacheHit bool, err error) *BudgetUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;BudgetUsecaseMockFindOneByIDResults{resItem, cacheHit, err}
        return e.mock
}</span>

// Times sets number of times BudgetUsecase.FindOneByID should be invoked
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) Times(n uint64) *mBudgetUsecaseMockFindOneByID <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Times of BudgetUsecaseMock.FindOneByID mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindOneByID.expectedInvocations, n)
        mmFindOneByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindOneByID</span>
}

func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindOneByID.expectations) == 0 &amp;&amp; mmFindOneByID.defaultExpectation == nil &amp;&amp; mmFindOneByID.mock.funcFindOneByID == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByID.mock.afterFindOneByIDCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByID.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindOneByID implements mm_usecase.BudgetUsecase
func (mmFindOneByID *BudgetUsecaseMock) FindOneByID(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (resItem *mm_usecase.BudgetDTO, cacheHit bool, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindOneByID.beforeFindOneByIDCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindOneByID.afterFindOneByIDCounter, 1)

        mmFindOneByID.t.Helper()

        if mmFindOneByID.inspectFuncFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.inspectFuncFindOneByID(ctx, id, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := BudgetUsecaseMockFindOneByIDParams{ctx, id, queryParams}

        // Record call args
        mmFindOneByID.FindOneByIDMock.mutex.Lock()
        mmFindOneByID.FindOneByIDMock.callArgs = append(mmFindOneByID.FindOneByIDMock.callArgs, &amp;mm_params)
        mmFindOneByID.FindOneByIDMock.mutex.Unlock()

        for _, e := range mmFindOneByID.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.resItem, e.results.cacheHit, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindOneByID.FindOneByIDMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindOneByID.FindOneByIDMock.defaultExpectation.Counter, 1)
                mm_want := mmFindOneByID.FindOneByIDMock.defaultExpectation.params
                mm_want_ptrs := mmFindOneByID.FindOneByIDMock.defaultExpectation.paramPtrs

                mm_got := BudgetUsecaseMockFindOneByIDParams{ctx, id, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("BudgetUsecaseMock.FindOneByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("BudgetUsecaseMock.FindOneByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("BudgetUsecaseMock.FindOneByID got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindOneByID.t.Errorf("BudgetUsecaseMock.FindOneByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindOneByID.FindOneByIDMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindOneByID.t.Fatal("No results are set for the BudgetUsecaseMock.FindOneByID")
                }</span>
                <span class="cov0" title="0">return (*mm_results).resItem, (*mm_results).cacheHit, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindOneByID.funcFindOneByID != nil </span><span class="cov0" title="0">{
                return mmFindOneByID.funcFindOneByID(ctx, id, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindOneByID.t.Fatalf("Unexpected call to BudgetUsecaseMock.FindOneByID. %v %v %v", ctx, id, queryParams)
        return</span>
}

// FindOneByIDAfterCounter returns a count of finished BudgetUsecaseMock.FindOneByID invocations
func (mmFindOneByID *BudgetUsecaseMock) FindOneByIDAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByID.afterFindOneByIDCounter)
}</span>

// FindOneByIDBeforeCounter returns a count of BudgetUsecaseMock.FindOneByID invocations
func (mmFindOneByID *BudgetUsecaseMock) FindOneByIDBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByID.beforeFindOneByIDCounter)
}</span>

// Calls returns a list of arguments used in each call to BudgetUsecaseMock.FindOneByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindOneByID *mBudgetUsecaseMockFindOneByID) Calls() []*BudgetUsecaseMockFindOneByIDParams <span class="cov0" title="0">{
        mmFindOneByID.mutex.RLock()

        argCopy := make([]*BudgetUsecaseMockFindOneByIDParams, len(mmFindOneByID.callArgs))
        copy(argCopy, mmFindOneByID.callArgs)

        mmFindOneByID.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindOneByIDDone returns true if the count of the FindOneByID invocations corresponds
// the number of defined expectations
func (m *BudgetUsecaseMock) MinimockFindOneByIDDone() bool <span class="cov0" title="0">{
        if m.FindOneByIDMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindOneByIDMock.invocationsDone()</span>
}

// MinimockFindOneByIDInspect logs each unmet expectation
func (m *BudgetUsecaseMock) MinimockFindOneByIDInspect() <span class="cov0" title="0">{
        for _, e := range m.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetUsecaseMock.FindOneByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindOneByIDCounter := mm_atomic.LoadUint64(&amp;m.afterFindOneByIDCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindOneByIDMock.defaultExpectation != nil &amp;&amp; afterFindOneByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindOneByIDMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetUsecaseMock.FindOneByID at\n%s", m.FindOneByIDMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to BudgetUsecaseMock.FindOneByID at\n%s with params: %#v", m.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *m.FindOneByIDMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindOneByID != nil &amp;&amp; afterFindOneByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to BudgetUsecaseMock.FindOneByID at\n%s", m.funcFindOneByIDOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindOneByIDMock.invocationsDone() &amp;&amp; afterFindOneByIDCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to BudgetUsecaseMock.FindOneByID at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindOneByIDMock.expectedInvocations), m.FindOneByIDMock.expectedInvocationsOrigin, afterFindOneByIDCounter)
        }</span>
}

type mBudgetUsecaseMockFindPagedList struct {
        optional           bool
        mock               *BudgetUsecaseMock
        defaultExpectation *BudgetUsecaseMockFindPagedListExpectation
        expectations       []*BudgetUsecaseMockFindPagedListExpectation

        callArgs []*BudgetUsecaseMockFindPagedListParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// BudgetUsecaseMockFindPagedListExpectation specifies expectation struct of the BudgetUsecase.FindPagedList
type BudgetUsecaseMockFindPagedListExpectation struct {
        mock               *BudgetUsecaseMock
        params             *BudgetUsecaseMockFindPagedListParams
        paramPtrs          *BudgetUsecaseMockFindPagedListParamPtrs
        expectationOrigins BudgetUsecaseMockFindPagedListExpectationOrigins
        results            *BudgetUsecaseMockFindPagedListResults
        returnOrigin       string
        Counter            uint64
}

// BudgetUsecaseMockFindPagedListParams contains parameters of the BudgetUsecase.FindPagedList
type BudgetUsecaseMockFindPagedListParams struct {
        ctx         context.Context
        listOptions *mm_usecase.BudgetListOptions
        queryParams *uctypes.QueryGetListParams
}

// BudgetUsecaseMockFindPagedListParamPtrs contains pointers to parameters of the BudgetUsecase.FindPagedList
type BudgetUsecaseMockFindPagedListParamPtrs struct {
        ctx         *context.Context
        listOptions **mm_usecase.BudgetListOptions
        queryParams **uctypes.QueryGetListParams
}

// BudgetUsecaseMockFindPagedListResults contains results of the BudgetUsecase.FindPagedList
type BudgetUsecaseMockFindPagedListResults struct {
        resItems []*mm_usecase.BudgetDTO
        total    uint64
        cacheHit bool
        err      error
}

// BudgetUsecaseMockFindPagedListOrigins contains origins of expectations of the BudgetUsecase.FindPagedList
type BudgetUsecaseMockFindPagedListExpectationOrigins struct {
        origin            string
        originCtx         string
        originListOptions string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) Optional() *mBudgetUsecaseMockFindPagedList <span class="cov0" title="0">{
        mmFindPagedList.optional = true
        return mmFindPagedList
}</span>

// Expect sets up expected params for BudgetUsecase.FindPagedList
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) Expect(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) *mBudgetUsecaseMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("BudgetUsecaseMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;BudgetUsecaseMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("BudgetUsecaseMock.FindPagedList mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.params = &amp;BudgetUsecaseMockFindPagedListParams{ctx, listOptions, queryParams}
        mmFindPagedList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindPagedList.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindPagedList.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindPagedList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindPagedList.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindPagedList</span>
}

// ExpectCtxParam1 sets up expected param ctx for BudgetUsecase.FindPagedList
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) ExpectCtxParam1(ctx context.Context) *mBudgetUsecaseMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("BudgetUsecaseMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;BudgetUsecaseMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("BudgetUsecaseMock.FindPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation.paramPtrs = &amp;BudgetUsecaseMockFindPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindPagedList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindPagedList</span>
}

// ExpectListOptionsParam2 sets up expected param listOptions for BudgetUsecase.FindPagedList
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) ExpectListOptionsParam2(listOptions *mm_usecase.BudgetListOptions) *mBudgetUsecaseMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("BudgetUsecaseMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;BudgetUsecaseMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("BudgetUsecaseMock.FindPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation.paramPtrs = &amp;BudgetUsecaseMockFindPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.paramPtrs.listOptions = &amp;listOptions
        mmFindPagedList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

        return mmFindPagedList</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for BudgetUsecase.FindPagedList
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mBudgetUsecaseMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("BudgetUsecaseMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;BudgetUsecaseMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("BudgetUsecaseMock.FindPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation.paramPtrs = &amp;BudgetUsecaseMockFindPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindPagedList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindPagedList</span>
}

// Inspect accepts an inspector function that has same arguments as the BudgetUsecase.FindPagedList
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams)) *mBudgetUsecaseMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.inspectFuncFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Inspect function is already set for BudgetUsecaseMock.FindPagedList")
        }</span>

        <span class="cov0" title="0">mmFindPagedList.mock.inspectFuncFindPagedList = f

        return mmFindPagedList</span>
}

// Return sets up results that will be returned by BudgetUsecase.FindPagedList
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) Return(resItems []*mm_usecase.BudgetDTO, total uint64, cacheHit bool, err error) *BudgetUsecaseMock <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("BudgetUsecaseMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;BudgetUsecaseMockFindPagedListExpectation{mock: mmFindPagedList.mock}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.results = &amp;BudgetUsecaseMockFindPagedListResults{resItems, total, cacheHit, err}
        mmFindPagedList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindPagedList.mock</span>
}

// Set uses given function f to mock the BudgetUsecase.FindPagedList method
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) Set(f func(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.BudgetDTO, total uint64, cacheHit bool, err error)) *BudgetUsecaseMock <span class="cov0" title="0">{
        if mmFindPagedList.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Default expectation is already set for the BudgetUsecase.FindPagedList method")
        }</span>

        <span class="cov0" title="0">if len(mmFindPagedList.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Some expectations are already set for the BudgetUsecase.FindPagedList method")
        }</span>

        <span class="cov0" title="0">mmFindPagedList.mock.funcFindPagedList = f
        mmFindPagedList.mock.funcFindPagedListOrigin = minimock.CallerInfo(1)
        return mmFindPagedList.mock</span>
}

// When sets expectation for the BudgetUsecase.FindPagedList which will trigger the result defined by the following
// Then helper
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) When(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) *BudgetUsecaseMockFindPagedListExpectation <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("BudgetUsecaseMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;BudgetUsecaseMockFindPagedListExpectation{
                mock:               mmFindPagedList.mock,
                params:             &amp;BudgetUsecaseMockFindPagedListParams{ctx, listOptions, queryParams},
                expectationOrigins: BudgetUsecaseMockFindPagedListExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindPagedList.expectations = append(mmFindPagedList.expectations, expectation)
        return expectation</span>
}

// Then sets up BudgetUsecase.FindPagedList return parameters for the expectation previously defined by the When method
func (e *BudgetUsecaseMockFindPagedListExpectation) Then(resItems []*mm_usecase.BudgetDTO, total uint64, cacheHit bool, err error) *BudgetUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;BudgetUsecaseMockFindPagedListResults{resItems, total, cacheHit, err}
        return e.mock
}</span>

// Times sets number of times BudgetUsecase.FindPagedList should be invoked
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) Times(n uint64) *mBudgetUsecaseMockFindPagedList <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Times of BudgetUsecaseMock.FindPagedList mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindPagedList.expectedInvocations, n)
        mmFindPagedList.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindPagedList</span>
}

func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindPagedList.expectations) == 0 &amp;&amp; mmFindPagedList.defaultExpectation == nil &amp;&amp; mmFindPagedList.mock.funcFindPagedList == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindPagedList.mock.afterFindPagedListCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindPagedList.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindPagedList implements mm_usecase.BudgetUsecase
func (mmFindPagedList *BudgetUsecaseMock) FindPagedList(ctx context.Context, listOptions *mm_usecase.BudgetListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.BudgetDTO, total uint64, cacheHit bool, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindPagedList.beforeFindPagedListCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindPagedList.afterFindPagedListCounter, 1)

        mmFindPagedList.t.Helper()

        if mmFindPagedList.inspectFuncFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.inspectFuncFindPagedList(ctx, listOptions, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := BudgetUsecaseMockFindPagedListParams{ctx, listOptions, queryParams}

        // Record call args
        mmFindPagedList.FindPagedListMock.mutex.Lock()
        mmFindPagedList.FindPagedListMock.callArgs = append(mmFindPagedList.FindPagedListMock.callArgs, &amp;mm_params)
        mmFindPagedList.FindPagedListMock.mutex.Unlock()

        for _, e := range mmFindPagedList.FindPagedListMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.resItems, e.results.total, e.results.cacheHit, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindPagedList.FindPagedListMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindPagedList.FindPagedListMock.defaultExpectation.Counter, 1)
                mm_want := mmFindPagedList.FindPagedListMock.defaultExpectation.params
                mm_want_ptrs := mmFindPagedList.FindPagedListMock.defaultExpectation.paramPtrs

                mm_got := BudgetUsecaseMockFindPagedListParams{ctx, listOptions, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindPagedList.t.Errorf("BudgetUsecaseMock.FindPagedList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.listOptions != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) </span><span class="cov0" title="0">{
                                mmFindPagedList.t.Errorf("BudgetUsecaseMock.FindPagedList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindPagedList.t.Errorf("BudgetUsecaseMock.FindPagedList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindPagedList.t.Errorf("BudgetUsecaseMock.FindPagedList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindPagedList.FindPagedListMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindPagedList.t.Fatal("No results are set for the BudgetUsecaseMock.FindPagedList")
                }</span>
                <span class="cov0" title="0">return (*mm_results).resItems, (*mm_results).total, (*mm_results).cacheHit, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindPagedList.funcFindPagedList != nil </span><span class="cov0" title="0">{
                return mmFindPagedList.funcFindPagedList(ctx, listOptions, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindPagedList.t.Fatalf("Unexpected call to BudgetUsecaseMock.FindPagedList. %v %v %v", ctx, listOptions, queryParams)
        return</span>
}

// FindPagedListAfterCounter returns a count of finished BudgetUsecaseMock.FindPagedList invocations
func (mmFindPagedList *BudgetUsecaseMock) FindPagedListAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindPagedList.afterFindPagedListCounter)
}</span>

// FindPagedListBeforeCounter returns a count of BudgetUsecaseMock.FindPagedList invocations
func (mmFindPagedList *BudgetUsecaseMock) FindPagedListBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindPagedList.beforeFindPagedListCounter)
}</span>

// Calls returns a list of arguments used in each call to BudgetUsecaseMock.FindPagedList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindPagedList *mBudgetUsecaseMockFindPagedList) Calls() []*BudgetUsecaseMockFindPagedListParams <span class="cov0" title="0">{
        mmFindPagedList.mutex.RLock()

        argCopy := make([]*BudgetUsecaseMockFindPagedListParams, len(mmFindPagedList.callArgs))
        copy(argCopy, mmFindPagedList.callArgs)

        mmFindPagedList.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindPagedListDone returns true if the count of the FindPagedList invocations corresponds
// the number of defined expectations
func (m *BudgetUsecaseMock) MinimockFindPagedListDone() bool <span class="cov0" title="0">{
        if m.FindPagedListMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindPagedListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindPagedListMock.invocationsDone()</span>
}

// MinimockFindPagedListInspect logs each unmet expectation
func (m *BudgetUsecaseMock) MinimockFindPagedListInspect() <span class="cov0" title="0">{
        for _, e := range m.FindPagedListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetUsecaseMock.FindPagedList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindPagedListCounter := mm_atomic.LoadUint64(&amp;m.afterFindPagedListCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindPagedListMock.defaultExpectation != nil &amp;&amp; afterFindPagedListCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindPagedListMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetUsecaseMock.FindPagedList at\n%s", m.FindPagedListMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to BudgetUsecaseMock.FindPagedList at\n%s with params: %#v", m.FindPagedListMock.defaultExpectation.expectationOrigins.origin, *m.FindPagedListMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindPagedList != nil &amp;&amp; afterFindPagedListCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to BudgetUsecaseMock.FindPagedList at\n%s", m.funcFindPagedListOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindPagedListMock.invocationsDone() &amp;&amp; afterFindPagedListCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to BudgetUsecaseMock.FindPagedList at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindPagedListMock.expectedInvocations), m.FindPagedListMock.expectedInvocationsOrigin, afterFindPagedListCounter)
        }</span>
}

type mBudgetUsecaseMockPatchBudgetByDTO struct {
        optional           bool
        mock               *BudgetUsecaseMock
        defaultExpectation *BudgetUsecaseMockPatchBudgetByDTOExpectation
        expectations       []*BudgetUsecaseMockPatchBudgetByDTOExpectation

        callArgs []*BudgetUsecaseMockPatchBudgetByDTOParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// BudgetUsecaseMockPatchBudgetByDTOExpectation specifies expectation struct of the BudgetUsecase.PatchBudgetByDTO
type BudgetUsecaseMockPatchBudgetByDTOExpectation struct {
        mock               *BudgetUsecaseMock
        params             *BudgetUsecaseMockPatchBudgetByDTOParams
        paramPtrs          *BudgetUsecaseMockPatchBudgetByDTOParamPtrs
        expectationOrigins BudgetUsecaseMockPatchBudgetByDTOExpectationOrigins
        results            *BudgetUsecaseMockPatchBudgetByDTOResults
        returnOrigin       string
        Counter            uint64
}

// BudgetUsecaseMockPatchBudgetByDTOParams contains parameters of the BudgetUsecase.PatchBudgetByDTO
type BudgetUsecaseMockPatchBudgetByDTOParams struct {
        ctx              context.Context
        id               uuid.UUID
        in               mm_usecase.PatchBudgetDataInput
        skipVersionCheck bool
}

// BudgetUsecaseMockPatchBudgetByDTOParamPtrs contains pointers to parameters of the BudgetUsecase.PatchBudgetByDTO
type BudgetUsecaseMockPatchBudgetByDTOParamPtrs struct {
        ctx              *context.Context
        id               *uuid.UUID
        in               *mm_usecase.PatchBudgetDataInput
        skipVersionCheck *bool
}

// BudgetUsecaseMockPatchBudgetByDTOResults contains results of the BudgetUsecase.PatchBudgetByDTO
type BudgetUsecaseMockPatchBudgetByDTOResults struct {
        err error
}

// BudgetUsecaseMockPatchBudgetByDTOOrigins contains origins of expectations of the BudgetUsecase.PatchBudgetByDTO
type BudgetUsecaseMockPatchBudgetByDTOExpectationOrigins struct {
        origin                 string
        originCtx              string
        originId               string
        originIn               string
        originSkipVersionCheck string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) Optional() *mBudgetUsecaseMockPatchBudgetByDTO <span class="cov0" title="0">{
        mmPatchBudgetByDTO.optional = true
        return mmPatchBudgetByDTO
}</span>

// Expect sets up expected params for BudgetUsecase.PatchBudgetByDTO
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) Expect(ctx context.Context, id uuid.UUID, in mm_usecase.PatchBudgetDataInput, skipVersionCheck bool) *mBudgetUsecaseMockPatchBudgetByDTO <span class="cov0" title="0">{
        if mmPatchBudgetByDTO.mock.funcPatchBudgetByDTO != nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmPatchBudgetByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.defaultExpectation = &amp;BudgetUsecaseMockPatchBudgetByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmPatchBudgetByDTO.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmPatchBudgetByDTO.defaultExpectation.params = &amp;BudgetUsecaseMockPatchBudgetByDTOParams{ctx, id, in, skipVersionCheck}
        mmPatchBudgetByDTO.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmPatchBudgetByDTO.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmPatchBudgetByDTO.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmPatchBudgetByDTO.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPatchBudgetByDTO.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmPatchBudgetByDTO</span>
}

// ExpectCtxParam1 sets up expected param ctx for BudgetUsecase.PatchBudgetByDTO
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) ExpectCtxParam1(ctx context.Context) *mBudgetUsecaseMockPatchBudgetByDTO <span class="cov0" title="0">{
        if mmPatchBudgetByDTO.mock.funcPatchBudgetByDTO != nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmPatchBudgetByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.defaultExpectation = &amp;BudgetUsecaseMockPatchBudgetByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmPatchBudgetByDTO.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmPatchBudgetByDTO.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.defaultExpectation.paramPtrs = &amp;BudgetUsecaseMockPatchBudgetByDTOParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmPatchBudgetByDTO.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmPatchBudgetByDTO.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmPatchBudgetByDTO</span>
}

// ExpectIdParam2 sets up expected param id for BudgetUsecase.PatchBudgetByDTO
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) ExpectIdParam2(id uuid.UUID) *mBudgetUsecaseMockPatchBudgetByDTO <span class="cov0" title="0">{
        if mmPatchBudgetByDTO.mock.funcPatchBudgetByDTO != nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmPatchBudgetByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.defaultExpectation = &amp;BudgetUsecaseMockPatchBudgetByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmPatchBudgetByDTO.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmPatchBudgetByDTO.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.defaultExpectation.paramPtrs = &amp;BudgetUsecaseMockPatchBudgetByDTOParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmPatchBudgetByDTO.defaultExpectation.paramPtrs.id = &amp;id
        mmPatchBudgetByDTO.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmPatchBudgetByDTO</span>
}

// ExpectInParam3 sets up expected param in for BudgetUsecase.PatchBudgetByDTO
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) ExpectInParam3(in mm_usecase.PatchBudgetDataInput) *mBudgetUsecaseMockPatchBudgetByDTO <span class="cov0" title="0">{
        if mmPatchBudgetByDTO.mock.funcPatchBudgetByDTO != nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmPatchBudgetByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.defaultExpectation = &amp;BudgetUsecaseMockPatchBudgetByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmPatchBudgetByDTO.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmPatchBudgetByDTO.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.defaultExpectation.paramPtrs = &amp;BudgetUsecaseMockPatchBudgetByDTOParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmPatchBudgetByDTO.defaultExpectation.paramPtrs.in = &amp;in
        mmPatchBudgetByDTO.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

        return mmPatchBudgetByDTO</span>
}

// ExpectSkipVersionCheckParam4 sets up expected param skipVersionCheck for BudgetUsecase.PatchBudgetByDTO
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) ExpectSkipVersionCheckParam4(skipVersionCheck bool) *mBudgetUsecaseMockPatchBudgetByDTO <span class="cov0" title="0">{
        if mmPatchBudgetByDTO.mock.funcPatchBudgetByDTO != nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmPatchBudgetByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.defaultExpectation = &amp;BudgetUsecaseMockPatchBudgetByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmPatchBudgetByDTO.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmPatchBudgetByDTO.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.defaultExpectation.paramPtrs = &amp;BudgetUsecaseMockPatchBudgetByDTOParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmPatchBudgetByDTO.defaultExpectation.paramPtrs.skipVersionCheck = &amp;skipVersionCheck
        mmPatchBudgetByDTO.defaultExpectation.expectationOrigins.originSkipVersionCheck = minimock.CallerInfo(1)

        return mmPatchBudgetByDTO</span>
}

// Inspect accepts an inspector function that has same arguments as the BudgetUsecase.PatchBudgetByDTO
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) Inspect(f func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchBudgetDataInput, skipVersionCheck bool)) *mBudgetUsecaseMockPatchBudgetByDTO <span class="cov0" title="0">{
        if mmPatchBudgetByDTO.mock.inspectFuncPatchBudgetByDTO != nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.mock.t.Fatalf("Inspect function is already set for BudgetUsecaseMock.PatchBudgetByDTO")
        }</span>

        <span class="cov0" title="0">mmPatchBudgetByDTO.mock.inspectFuncPatchBudgetByDTO = f

        return mmPatchBudgetByDTO</span>
}

// Return sets up results that will be returned by BudgetUsecase.PatchBudgetByDTO
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) Return(err error) *BudgetUsecaseMock <span class="cov0" title="0">{
        if mmPatchBudgetByDTO.mock.funcPatchBudgetByDTO != nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmPatchBudgetByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.defaultExpectation = &amp;BudgetUsecaseMockPatchBudgetByDTOExpectation{mock: mmPatchBudgetByDTO.mock}
        }</span>
        <span class="cov0" title="0">mmPatchBudgetByDTO.defaultExpectation.results = &amp;BudgetUsecaseMockPatchBudgetByDTOResults{err}
        mmPatchBudgetByDTO.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmPatchBudgetByDTO.mock</span>
}

// Set uses given function f to mock the BudgetUsecase.PatchBudgetByDTO method
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) Set(f func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchBudgetDataInput, skipVersionCheck bool) (err error)) *BudgetUsecaseMock <span class="cov0" title="0">{
        if mmPatchBudgetByDTO.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.mock.t.Fatalf("Default expectation is already set for the BudgetUsecase.PatchBudgetByDTO method")
        }</span>

        <span class="cov0" title="0">if len(mmPatchBudgetByDTO.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.mock.t.Fatalf("Some expectations are already set for the BudgetUsecase.PatchBudgetByDTO method")
        }</span>

        <span class="cov0" title="0">mmPatchBudgetByDTO.mock.funcPatchBudgetByDTO = f
        mmPatchBudgetByDTO.mock.funcPatchBudgetByDTOOrigin = minimock.CallerInfo(1)
        return mmPatchBudgetByDTO.mock</span>
}

// When sets expectation for the BudgetUsecase.PatchBudgetByDTO which will trigger the result defined by the following
// Then helper
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) When(ctx context.Context, id uuid.UUID, in mm_usecase.PatchBudgetDataInput, skipVersionCheck bool) *BudgetUsecaseMockPatchBudgetByDTOExpectation <span class="cov0" title="0">{
        if mmPatchBudgetByDTO.mock.funcPatchBudgetByDTO != nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.mock.t.Fatalf("BudgetUsecaseMock.PatchBudgetByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;BudgetUsecaseMockPatchBudgetByDTOExpectation{
                mock:               mmPatchBudgetByDTO.mock,
                params:             &amp;BudgetUsecaseMockPatchBudgetByDTOParams{ctx, id, in, skipVersionCheck},
                expectationOrigins: BudgetUsecaseMockPatchBudgetByDTOExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmPatchBudgetByDTO.expectations = append(mmPatchBudgetByDTO.expectations, expectation)
        return expectation</span>
}

// Then sets up BudgetUsecase.PatchBudgetByDTO return parameters for the expectation previously defined by the When method
func (e *BudgetUsecaseMockPatchBudgetByDTOExpectation) Then(err error) *BudgetUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;BudgetUsecaseMockPatchBudgetByDTOResults{err}
        return e.mock
}</span>

// Times sets number of times BudgetUsecase.PatchBudgetByDTO should be invoked
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) Times(n uint64) *mBudgetUsecaseMockPatchBudgetByDTO <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.mock.t.Fatalf("Times of BudgetUsecaseMock.PatchBudgetByDTO mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmPatchBudgetByDTO.expectedInvocations, n)
        mmPatchBudgetByDTO.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmPatchBudgetByDTO</span>
}

func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmPatchBudgetByDTO.expectations) == 0 &amp;&amp; mmPatchBudgetByDTO.defaultExpectation == nil &amp;&amp; mmPatchBudgetByDTO.mock.funcPatchBudgetByDTO == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmPatchBudgetByDTO.mock.afterPatchBudgetByDTOCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmPatchBudgetByDTO.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// PatchBudgetByDTO implements mm_usecase.BudgetUsecase
func (mmPatchBudgetByDTO *BudgetUsecaseMock) PatchBudgetByDTO(ctx context.Context, id uuid.UUID, in mm_usecase.PatchBudgetDataInput, skipVersionCheck bool) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmPatchBudgetByDTO.beforePatchBudgetByDTOCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmPatchBudgetByDTO.afterPatchBudgetByDTOCounter, 1)

        mmPatchBudgetByDTO.t.Helper()

        if mmPatchBudgetByDTO.inspectFuncPatchBudgetByDTO != nil </span><span class="cov0" title="0">{
                mmPatchBudgetByDTO.inspectFuncPatchBudgetByDTO(ctx, id, in, skipVersionCheck)
        }</span>

        <span class="cov0" title="0">mm_params := BudgetUsecaseMockPatchBudgetByDTOParams{ctx, id, in, skipVersionCheck}

        // Record call args
        mmPatchBudgetByDTO.PatchBudgetByDTOMock.mutex.Lock()
        mmPatchBudgetByDTO.PatchBudgetByDTOMock.callArgs = append(mmPatchBudgetByDTO.PatchBudgetByDTOMock.callArgs, &amp;mm_params)
        mmPatchBudgetByDTO.PatchBudgetByDTOMock.mutex.Unlock()

        for _, e := range mmPatchBudgetByDTO.PatchBudgetByDTOMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmPatchBudgetByDTO.PatchBudgetByDTOMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmPatchBudgetByDTO.PatchBudgetByDTOMock.defaultExpectation.Counter, 1)
                mm_want := mmPatchBudgetByDTO.PatchBudgetByDTOMock.defaultExpectation.params
                mm_want_ptrs := mmPatchBudgetByDTO.PatchBudgetByDTOMock.defaultExpectation.paramPtrs

                mm_got := BudgetUsecaseMockPatchBudgetByDTOParams{ctx, id, in, skipVersionCheck}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmPatchBudgetByDTO.t.Errorf("BudgetUsecaseMock.PatchBudgetByDTO got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmPatchBudgetByDTO.PatchBudgetByDTOMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmPatchBudgetByDTO.t.Errorf("BudgetUsecaseMock.PatchBudgetByDTO got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmPatchBudgetByDTO.PatchBudgetByDTOMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.in != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.in, mm_got.in) </span><span class="cov0" title="0">{
                                mmPatchBudgetByDTO.t.Errorf("BudgetUsecaseMock.PatchBudgetByDTO got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmPatchBudgetByDTO.PatchBudgetByDTOMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.skipVersionCheck != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.skipVersionCheck, mm_got.skipVersionCheck) </span><span class="cov0" title="0">{
                                mmPatchBudgetByDTO.t.Errorf("BudgetUsecaseMock.PatchBudgetByDTO got unexpected parameter skipVersionCheck, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmPatchBudgetByDTO.PatchBudgetByDTOMock.defaultExpectation.expectationOrigins.originSkipVersionCheck, *mm_want_ptrs.skipVersionCheck, mm_got.skipVersionCheck, minimock.Diff(*mm_want_ptrs.skipVersionCheck, mm_got.skipVersionCheck))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmPatchBudgetByDTO.t.Errorf("BudgetUsecaseMock.PatchBudgetByDTO got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmPatchBudgetByDTO.PatchBudgetByDTOMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmPatchBudgetByDTO.PatchBudgetByDTOMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmPatchBudgetByDTO.t.Fatal("No results are set for the BudgetUsecaseMock.PatchBudgetByDTO")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmPatchBudgetByDTO.funcPatchBudgetByDTO != nil </span><span class="cov0" title="0">{
                return mmPatchBudgetByDTO.funcPatchBudgetByDTO(ctx, id, in, skipVersionCheck)
        }</span>
        <span class="cov0" title="0">mmPatchBudgetByDTO.t.Fatalf("Unexpected call to BudgetUsecaseMock.PatchBudgetByDTO. %v %v %v %v", ctx, id, in, skipVersionCheck)
        return</span>
}

// PatchBudgetByDTOAfterCounter returns a count of finished BudgetUsecaseMock.PatchBudgetByDTO invocations
func (mmPatchBudgetByDTO *BudgetUsecaseMock) PatchBudgetByDTOAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmPatchBudgetByDTO.afterPatchBudgetByDTOCounter)
}</span>

// PatchBudgetByDTOBeforeCounter returns a count of BudgetUsecaseMock.PatchBudgetByDTO invocations
func (mmPatchBudgetByDTO *BudgetUsecaseMock) PatchBudgetByDTOBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmPatchBudgetByDTO.beforePatchBudgetByDTOCounter)
}</span>

// Calls returns a list of arguments used in each call to BudgetUsecaseMock.PatchBudgetByDTO.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPatchBudgetByDTO *mBudgetUsecaseMockPatchBudgetByDTO) Calls() []*BudgetUsecaseMockPatchBudgetByDTOParams <span class="cov0" title="0">{
        mmPatchBudgetByDTO.mutex.RLock()

        argCopy := make([]*BudgetUsecaseMockPatchBudgetByDTOParams, len(mmPatchBudgetByDTO.callArgs))
        copy(argCopy, mmPatchBudgetByDTO.callArgs)

        mmPatchBudgetByDTO.mutex.RUnlock()

        return argCopy
}</span>

// MinimockPatchBudgetByDTODone returns true if the count of the PatchBudgetByDTO invocations corresponds
// the number of defined expectations
func (m *BudgetUsecaseMock) MinimockPatchBudgetByDTODone() bool <span class="cov0" title="0">{
        if m.PatchBudgetByDTOMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.PatchBudgetByDTOMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.PatchBudgetByDTOMock.invocationsDone()</span>
}

// MinimockPatchBudgetByDTOInspect logs each unmet expectation
func (m *BudgetUsecaseMock) MinimockPatchBudgetByDTOInspect() <span class="cov0" title="0">{
        for _, e := range m.PatchBudgetByDTOMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetUsecaseMock.PatchBudgetByDTO at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterPatchBudgetByDTOCounter := mm_atomic.LoadUint64(&amp;m.afterPatchBudgetByDTOCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.PatchBudgetByDTOMock.defaultExpectation != nil &amp;&amp; afterPatchBudgetByDTOCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.PatchBudgetByDTOMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to BudgetUsecaseMock.PatchBudgetByDTO at\n%s", m.PatchBudgetByDTOMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to BudgetUsecaseMock.PatchBudgetByDTO at\n%s with params: %#v", m.PatchBudgetByDTOMock.defaultExpectation.expectationOrigins.origin, *m.PatchBudgetByDTOMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcPatchBudgetByDTO != nil &amp;&amp; afterPatchBudgetByDTOCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to BudgetUsecaseMock.PatchBudgetByDTO at\n%s", m.funcPatchBudgetByDTOOrigin)
        }</span>

        <span class="cov0" title="0">if !m.PatchBudgetByDTOMock.invocationsDone() &amp;&amp; afterPatchBudgetByDTOCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to BudgetUsecaseMock.PatchBudgetByDTO at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.PatchBudgetByDTOMock.expectedInvocations), m.PatchBudgetByDTOMock.expectedInvocationsOrigin, afterPatchBudgetByDTOCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *BudgetUsecaseMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockCreateBudgetByDTOInspect()

                        m.MinimockDeleteBudgetByIDInspect()

                        m.MinimockFindListInspect()

                        m.MinimockFindOneByIDInspect()

                        m.MinimockFindPagedListInspect()

                        m.MinimockPatchBudgetByDTOInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *BudgetUsecaseMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *BudgetUsecaseMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockCreateBudgetByDTODone() &amp;&amp;
                m.MinimockDeleteBudgetByIDDone() &amp;&amp;
                m.MinimockFindListDone() &amp;&amp;
                m.MinimockFindOneByIDDone() &amp;&amp;
                m.MinimockFindPagedListDone() &amp;&amp;
                m.MinimockPatchBudgetByDTODone()
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase.CategoryRepository -o category_repository.go -n CategoryRepositoryMock -p mocks

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        mm_usecase "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
)

// CategoryRepositoryMock implements mm_usecase.CategoryRepository
type CategoryRepositoryMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcFindList          func(ctx context.Context, listOptions *mm_usecase.CategoryListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Category, err error)
        funcFindListOrigin    string
        inspectFuncFindList   func(ctx context.Context, listOptions *mm_usecase.CategoryListOptions, queryParams *uctypes.QueryGetListParams)
        afterFindListCounter  uint64
        beforeFindListCounter uint64
        FindListMock          mCategoryRepositoryMockFindList

        funcFindOneByID          func(ctx context.Context, id uint64, queryParams *uctypes.QueryGetOneParams) (transaction *entity.Category, err error)
        funcFindOneByIDOrigin    string
        inspectFuncFindOneByID   func(ctx context.Context, id uint64, queryParams *uctypes.QueryGetOneParams)
        afterFindOneByIDCounter  uint64
        beforeFindOneByIDCounter uint64
        FindOneByIDMock          mCategoryRepositoryMockFindOneByID
}

// NewCategoryRepositoryMock returns a mock for mm_usecase.CategoryRepository
func NewCategoryRepositoryMock(t minimock.Tester) *CategoryRepositoryMock <span class="cov0" title="0">{
        m := &amp;CategoryRepositoryMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.FindListMock = mCategoryRepositoryMockFindList{mock: m}
        m.FindListMock.callArgs = []*CategoryRepositoryMockFindListParams{}

        m.FindOneByIDMock = mCategoryRepositoryMockFindOneByID{mock: m}
        m.FindOneByIDMock.callArgs = []*CategoryRepositoryMockFindOneByIDParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mCategoryRepositoryMockFindList struct {
        optional           bool
        mock               *CategoryRepositoryMock
        defaultExpectation *CategoryRepositoryMockFindListExpectation
        expectations       []*CategoryRepositoryMockFindListExpectation

        callArgs []*CategoryRepositoryMockFindListParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// CategoryRepositoryMockFindListExpectation specifies expectation struct of the CategoryRepository.FindList
type CategoryRepositoryMockFindListExpectation struct {
        mock               *CategoryRepositoryMock
        params             *CategoryRepositoryMockFindListParams
        paramPtrs          *CategoryRepositoryMockFindListParamPtrs
        expectationOrigins CategoryRepositoryMockFindListExpectationOrigins
        results            *CategoryRepositoryMockFindListResults
        returnOrigin       string
        Counter            uint64
}

// CategoryRepositoryMockFindListParams contains parameters of the CategoryRepository.FindList
type CategoryRepositoryMockFindListParams struct {
        ctx         context.Context
        listOptions *mm_usecase.CategoryListOptions
        queryParams *uctypes.QueryGetListParams
}

// CategoryRepositoryMockFindListParamPtrs contains pointers to parameters of the CategoryRepository.FindList
type CategoryRepositoryMockFindListParamPtrs struct {
        ctx         *context.Context
        listOptions **mm_usecase.CategoryListOptions
        queryParams **uctypes.QueryGetListParams
}

// CategoryRepositoryMockFindListResults contains results of the CategoryRepository.FindList
type CategoryRepositoryMockFindListResults struct {
        items []*entity.Category
        err   error
}

// CategoryRepositoryMockFindListOrigins contains origins of expectations of the CategoryRepository.FindList
type CategoryRepositoryMockFindListExpectationOrigins struct {
        origin            string
        originCtx         string
        originListOptions string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindList *mCategoryRepositoryMockFindList) Optional() *mCategoryRepositoryMockFindList <span class="cov0" title="0">{
        mmFindList.optional = true
        return mmFindList
}</span>

// Expect sets up expected params for CategoryRepository.FindList
func (mmFindList *mCategoryRepositoryMockFindList) Expect(ctx context.Context, listOptions *mm_usecase.CategoryListOptions, queryParams *uctypes.QueryGetListParams) *mCategoryRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("CategoryRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;CategoryRepositoryMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("CategoryRepositoryMock.FindList mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindList.defaultExpectation.params = &amp;CategoryRepositoryMockFindListParams{ctx, listOptions, queryParams}
        mmFindList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindList.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindList.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindList.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindList</span>
}

// ExpectCtxParam1 sets up expected param ctx for CategoryRepository.FindList
func (mmFindList *mCategoryRepositoryMockFindList) ExpectCtxParam1(ctx context.Context) *mCategoryRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("CategoryRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;CategoryRepositoryMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("CategoryRepositoryMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;CategoryRepositoryMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindList</span>
}

// ExpectListOptionsParam2 sets up expected param listOptions for CategoryRepository.FindList
func (mmFindList *mCategoryRepositoryMockFindList) ExpectListOptionsParam2(listOptions *mm_usecase.CategoryListOptions) *mCategoryRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("CategoryRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;CategoryRepositoryMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("CategoryRepositoryMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;CategoryRepositoryMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.listOptions = &amp;listOptions
        mmFindList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

        return mmFindList</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for CategoryRepository.FindList
func (mmFindList *mCategoryRepositoryMockFindList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mCategoryRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("CategoryRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;CategoryRepositoryMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("CategoryRepositoryMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;CategoryRepositoryMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindList</span>
}

// Inspect accepts an inspector function that has same arguments as the CategoryRepository.FindList
func (mmFindList *mCategoryRepositoryMockFindList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.CategoryListOptions, queryParams *uctypes.QueryGetListParams)) *mCategoryRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.inspectFuncFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Inspect function is already set for CategoryRepositoryMock.FindList")
        }</span>

        <span class="cov0" title="0">mmFindList.mock.inspectFuncFindList = f

        return mmFindList</span>
}

// Return sets up results that will be returned by CategoryRepository.FindList
func (mmFindList *mCategoryRepositoryMockFindList) Return(items []*entity.Category, err error) *CategoryRepositoryMock <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("CategoryRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;CategoryRepositoryMockFindListExpectation{mock: mmFindList.mock}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.results = &amp;CategoryRepositoryMockFindListResults{items, err}
        mmFindList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindList.mock</span>
}

// Set uses given function f to mock the CategoryRepository.FindList method
func (mmFindList *mCategoryRepositoryMockFindList) Set(f func(ctx context.Context, listOptions *mm_usecase.CategoryListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Category, err error)) *CategoryRepositoryMock <span class="cov0" title="0">{
        if mmFindList.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Default expectation is already set for the CategoryRepository.FindList method")
        }</span>

        <span class="cov0" title="0">if len(mmFindList.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Some expectations are already set for the CategoryRepository.FindList method")
        }</span>

        <span class="cov0" title="0">mmFindList.mock.funcFindList = f
        mmFindList.mock.funcFindListOrigin = minimock.CallerInfo(1)
        return mmFindList.mock</span>
}

// When sets expectation for the CategoryRepository.FindList which will trigger the result defined by the following
// Then helper
func (mmFindList *mCategoryRepositoryMockFindList) When(ctx context.Context, listOptions *mm_usecase.CategoryListOptions, queryParams *uctypes.QueryGetListParams) *CategoryRepositoryMockFindListExpectation <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("CategoryRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;CategoryRepositoryMockFindListExpectation{
                mock:               mmFindList.mock,
                params:             &amp;CategoryRepositoryMockFindListParams{ctx, listOptions, queryParams},
                expectationOrigins: CategoryRepositoryMockFindListExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindList.expectations = append(mmFindList.expectations, expectation)
        return expectation</span>
}

// Then sets up CategoryRepository.FindList return parameters for the expectation previously defined by the When method
func (e *CategoryRepositoryMockFindListExpectation) Then(items []*entity.Category, err error) *CategoryRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;CategoryRepositoryMockFindListResults{items, err}
        return e.mock
}</span>

// Times sets number of times CategoryRepository.FindList should be invoked
func (mmFindList *mCategoryRepositoryMockFindList) Times(n uint64) *mCategoryRepositoryMockFindList <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Times of CategoryRepositoryMock.FindList mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindList.expectedInvocations, n)
        mmFindList.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindList</span>
}

func (mmFindList *mCategoryRepositoryMockFindList) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindList.expectations) == 0 &amp;&amp; mmFindList.defaultExpectation == nil &amp;&amp; mmFindList.mock.funcFindList == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindList.mock.afterFindListCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindList.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindList implements mm_usecase.CategoryRepository
func (mmFindList *CategoryRepositoryMock) FindList(ctx context.Context, listOptions *mm_usecase.CategoryListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Category, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindList.beforeFindListCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindList.afterFindListCounter, 1)

        mmFindList.t.Helper()

        if mmFindList.inspectFuncFindList != nil </span><span class="cov0" title="0">{
                mmFindList.inspectFuncFindList(ctx, listOptions, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := CategoryRepositoryMockFindListParams{ctx, listOptions, queryParams}

        // Record call args
        mmFindList.FindListMock.mutex.Lock()
        mmFindList.FindListMock.callArgs = append(mmFindList.FindListMock.callArgs, &amp;mm_params)
        mmFindList.FindListMock.mutex.Unlock()

        for _, e := range mmFindList.FindListMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.items, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindList.FindListMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindList.FindListMock.defaultExpectation.Counter, 1)
                mm_want := mmFindList.FindListMock.defaultExpectation.params
                mm_want_ptrs := mmFindList.FindListMock.defaultExpectation.paramPtrs

                mm_got := CategoryRepositoryMockFindListParams{ctx, listOptions, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("CategoryRepositoryMock.FindList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.listOptions != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("CategoryRepositoryMock.FindList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("CategoryRepositoryMock.FindList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindList.t.Errorf("CategoryRepositoryMock.FindList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindList.FindListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindList.FindListMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindList.t.Fatal("No results are set for the CategoryRepositoryMock.FindList")
                }</span>
                <span class="cov0" title="0">return (*mm_results).items, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindList.funcFindList != nil </span><span class="cov0" title="0">{
                return mmFindList.funcFindList(ctx, listOptions, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindList.t.Fatalf("Unexpected call to CategoryRepositoryMock.FindList. %v %v %v", ctx, listOptions, queryParams)
        return</span>
}

// FindListAfterCounter returns a count of finished CategoryRepositoryMock.FindList invocations
func (mmFindList *CategoryRepositoryMock) FindListAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindList.afterFindListCounter)
}</span>

// FindListBeforeCounter returns a count of CategoryRepositoryMock.FindList invocations
func (mmFindList *CategoryRepositoryMock) FindListBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindList.beforeFindListCounter)
}</span>

// Calls returns a list of arguments used in each call to CategoryRepositoryMock.FindList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindList *mCategoryRepositoryMockFindList) Calls() []*CategoryRepositoryMockFindListParams <span class="cov0" title="0">{
        mmFindList.mutex.RLock()

        argCopy := make([]*CategoryRepositoryMockFindListParams, len(mmFindList.callArgs))
        copy(argCopy, mmFindList.callArgs)

        mmFindList.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindListDone returns true if the count of the FindList invocations corresponds
// the number of defined expectations
func (m *CategoryRepositoryMock) MinimockFindListDone() bool <span class="cov0" title="0">{
        if m.FindListMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindListMock.invocationsDone()</span>
}

// MinimockFindListInspect logs each unmet expectation
func (m *CategoryRepositoryMock) MinimockFindListInspect() <span class="cov0" title="0">{
        for _, e := range m.FindListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CategoryRepositoryMock.FindList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindListCounter := mm_atomic.LoadUint64(&amp;m.afterFindListCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindListMock.defaultExpectation != nil &amp;&amp; afterFindListCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindListMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CategoryRepositoryMock.FindList at\n%s", m.FindListMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to CategoryRepositoryMock.FindList at\n%s with params: %#v", m.FindListMock.defaultExpectation.expectationOrigins.origin, *m.FindListMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindList != nil &amp;&amp; afterFindListCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to CategoryRepositoryMock.FindList at\n%s", m.funcFindListOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindListMock.invocationsDone() &amp;&amp; afterFindListCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to CategoryRepositoryMock.FindList at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindListMock.expectedInvocations), m.FindListMock.expectedInvocationsOrigin, afterFindListCounter)
        }</span>
}

type mCategoryRepositoryMockFindOneByID struct {
        optional           bool
        mock               *CategoryRepositoryMock
        defaultExpectation *CategoryRepositoryMockFindOneByIDExpectation
        expectations       []*CategoryRepositoryMockFindOneByIDExpectation

        callArgs []*CategoryRepositoryMockFindOneByIDParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// CategoryRepositoryMockFindOneByIDExpectation specifies expectation struct of the CategoryRepository.FindOneByID
type CategoryRepositoryMockFindOneByIDExpectation struct {
        mock               *CategoryRepositoryMock
        params             *CategoryRepositoryMockFindOneByIDParams
        paramPtrs          *CategoryRepositoryMockFindOneByIDParamPtrs
        expectationOrigins CategoryRepositoryMockFindOneByIDExpectationOrigins
        results            *CategoryRepositoryMockFindOneByIDResults
        returnOrigin       string
        Counter            uint64
}

// CategoryRepositoryMockFindOneByIDParams contains parameters of the CategoryRepository.FindOneByID
type CategoryRepositoryMockFindOneByIDParams struct {
        ctx         context.Context
        id          uint64
        queryParams *uctypes.QueryGetOneParams
}

// CategoryRepositoryMockFindOneByIDParamPtrs contains pointers to parameters of the CategoryRepository.FindOneByID
type CategoryRepositoryMockFindOneByIDParamPtrs struct {
        ctx         *context.Context
        id          *uint64
        queryParams **uctypes.QueryGetOneParams
}

// CategoryRepositoryMockFindOneByIDResults contains results of the CategoryRepository.FindOneByID
type CategoryRepositoryMockFindOneByIDResults struct {
        transaction *entity.Category
        err         error
}

// CategoryRepositoryMockFindOneByIDOrigins contains origins of expectations of the CategoryRepository.FindOneByID
type CategoryRepositoryMockFindOneByIDExpectationOrigins struct {
        origin            string
        originCtx         string
        originId          string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindOneByID *mCategoryRepositoryMockFindOneByID) Optional() *mCategoryRepositoryMockFindOneByID <span class="cov0" title="0">{
        mmFindOneByID.optional = true
        return mmFindOneByID
}</span>

// Expect sets up expected params for CategoryRepository.FindOneByID
func (mmFindOneByID *mCategoryRepositoryMockFindOneByID) Expect(ctx context.Context, id uint64, queryParams *uctypes.QueryGetOneParams) *mCategoryRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("CategoryRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;CategoryRepositoryMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("CategoryRepositoryMock.FindOneByID mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.params = &amp;CategoryRepositoryMockFindOneByIDParams{ctx, id, queryParams}
        mmFindOneByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindOneByID.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindOneByID.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindOneByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindOneByID.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindOneByID</span>
}

// ExpectCtxParam1 sets up expected param ctx for CategoryRepository.FindOneByID
func (mmFindOneByID *mCategoryRepositoryMockFindOneByID) ExpectCtxParam1(ctx context.Context) *mCategoryRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("CategoryRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;CategoryRepositoryMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("CategoryRepositoryMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;CategoryRepositoryMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindOneByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// ExpectIdParam2 sets up expected param id for CategoryRepository.FindOneByID
func (mmFindOneByID *mCategoryRepositoryMockFindOneByID) ExpectIdParam2(id uint64) *mCategoryRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("CategoryRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;CategoryRepositoryMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("CategoryRepositoryMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;CategoryRepositoryMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.id = &amp;id
        mmFindOneByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for CategoryRepository.FindOneByID
func (mmFindOneByID *mCategoryRepositoryMockFindOneByID) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetOneParams) *mCategoryRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("CategoryRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;CategoryRepositoryMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("CategoryRepositoryMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;CategoryRepositoryMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindOneByID.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// Inspect accepts an inspector function that has same arguments as the CategoryRepository.FindOneByID
func (mmFindOneByID *mCategoryRepositoryMockFindOneByID) Inspect(f func(ctx context.Context, id uint64, queryParams *uctypes.QueryGetOneParams)) *mCategoryRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.inspectFuncFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Inspect function is already set for CategoryRepositoryMock.FindOneByID")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.mock.inspectFuncFindOneByID = f

        return mmFindOneByID</span>
}

// Return sets up results that will be returned by CategoryRepository.FindOneByID
func (mmFindOneByID *mCategoryRepositoryMockFindOneByID) Return(transaction *entity.Category, err error) *CategoryRepositoryMock <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("CategoryRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;CategoryRepositoryMockFindOneByIDExpectation{mock: mmFindOneByID.mock}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.results = &amp;CategoryRepositoryMockFindOneByIDResults{transaction, err}
        mmFindOneByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindOneByID.mock</span>
}

// Set uses given function f to mock the CategoryRepository.FindOneByID method
func (mmFindOneByID *mCategoryRepositoryMockFindOneByID) Set(f func(ctx context.Context, id uint64, queryParams *uctypes.QueryGetOneParams) (transaction *entity.Category, err error)) *CategoryRepositoryMock <span class="cov0" title="0">{
        if mmFindOneByID.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Default expectation is already set for the CategoryRepository.FindOneByID method")
        }</span>

        <span class="cov0" title="0">if len(mmFindOneByID.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Some expectations are already set for the CategoryRepository.FindOneByID method")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.mock.funcFindOneByID = f
        mmFindOneByID.mock.funcFindOneByIDOrigin = minimock.CallerInfo(1)
        return mmFindOneByID.mock</span>
}

// When sets expectation for the CategoryRepository.FindOneByID which will trigger the result defined by the following
// Then helper
func (mmFindOneByID *mCategoryRepositoryMockFindOneByID) When(ctx context.Context, id uint64, queryParams *uctypes.QueryGetOneParams) *CategoryRepositoryMockFindOneByIDExpectation <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("CategoryRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;CategoryRepositoryMockFindOneByIDExpectation{
                mock:               mmFindOneByID.mock,
                params:             &amp;CategoryRepositoryMockFindOneByIDParams{ctx, id, queryParams},
                expectationOrigins: CategoryRepositoryMockFindOneByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindOneByID.expectations = append(mmFindOneByID.expectations, expectation)
        return expectation</span>
}

// Then sets up CategoryRepository.FindOneByID return parameters for the expectation previously defined by the When method
func (e *CategoryRepositoryMockFindOneByIDExpectation) Then(transaction *entity.Category, err error) *CategoryRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;CategoryRepositoryMockFindOneByIDResults{transaction, err}
        return e.mock
}</span>

// Times sets number of times CategoryRepository.FindOneByID should be invoked
func (mmFindOneByID *mCategoryRepositoryMockFindOneByID) Times(n uint64) *mCategoryRepositoryMockFindOneByID <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Times of CategoryRepositoryMock.FindOneByID mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindOneByID.expectedInvocations, n)
        mmFindOneByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindOneByID</span>
}

func (mmFindOneByID *mCategoryRepositoryMockFindOneByID) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindOneByID.expectations) == 0 &amp;&amp; mmFindOneByID.defaultExpectation == nil &amp;&amp; mmFindOneByID.mock.funcFindOneByID == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByID.mock.afterFindOneByIDCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByID.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindOneByID implements mm_usecase.CategoryRepository
func (mmFindOneByID *CategoryRepositoryMock) FindOneByID(ctx context.Context, id uint64, queryParams *uctypes.QueryGetOneParams) (transaction *entity.Category, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindOneByID.beforeFindOneByIDCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindOneByID.afterFindOneByIDCounter, 1)

        mmFindOneByID.t.Helper()

        if mmFindOneByID.inspectFuncFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.inspectFuncFindOneByID(ctx, id, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := CategoryRepositoryMockFindOneByIDParams{ctx, id, queryParams}

        // Record call args
        mmFindOneByID.FindOneByIDMock.mutex.Lock()
        mmFindOneByID.FindOneByIDMock.callArgs = append(mmFindOneByID.FindOneByIDMock.callArgs, &amp;mm_params)
        mmFindOneByID.FindOneByIDMock.mutex.Unlock()

        for _, e := range mmFindOneByID.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.transaction, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindOneByID.FindOneByIDMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindOneByID.FindOneByIDMock.defaultExpectation.Counter, 1)
                mm_want := mmFindOneByID.FindOneByIDMock.defaultExpectation.params
                mm_want_ptrs := mmFindOneByID.FindOneByIDMock.defaultExpectation.paramPtrs

                mm_got := CategoryRepositoryMockFindOneByIDParams{ctx, id, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("CategoryRepositoryMock.FindOneByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("CategoryRepositoryMock.FindOneByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("CategoryRepositoryMock.FindOneByID got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindOneByID.t.Errorf("CategoryRepositoryMock.FindOneByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindOneByID.FindOneByIDMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindOneByID.t.Fatal("No results are set for the CategoryRepositoryMock.FindOneByID")
                }</span>
                <span class="cov0" title="0">return (*mm_results).transaction, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindOneByID.funcFindOneByID != nil </span><span class="cov0" title="0">{
                return mmFindOneByID.funcFindOneByID(ctx, id, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindOneByID.t.Fatalf("Unexpected call to CategoryRepositoryMock.FindOneByID. %v %v %v", ctx, id, queryParams)
        return</span>
}

// FindOneByIDAfterCounter returns a count of finished CategoryRepositoryMock.FindOneByID invocations
func (mmFindOneByID *CategoryRepositoryMock) FindOneByIDAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByID.afterFindOneByIDCounter)
}</span>

// FindOneByIDBeforeCounter returns a count of CategoryRepositoryMock.FindOneByID invocations
func (mmFindOneByID *CategoryRepositoryMock) FindOneByIDBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByID.beforeFindOneByIDCounter)
}</span>

// Calls returns a list of arguments used in each call to CategoryRepositoryMock.FindOneByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindOneByID *mCategoryRepositoryMockFindOneByID) Calls() []*CategoryRepositoryMockFindOneByIDParams <span class="cov0" title="0">{
        mmFindOneByID.mutex.RLock()

        argCopy := make([]*CategoryRepositoryMockFindOneByIDParams, len(mmFindOneByID.callArgs))
        copy(argCopy, mmFindOneByID.callArgs)

        mmFindOneByID.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindOneByIDDone returns true if the count of the FindOneByID invocations corresponds
// the number of defined expectations
func (m *CategoryRepositoryMock) MinimockFindOneByIDDone() bool <span class="cov0" title="0">{
        if m.FindOneByIDMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindOneByIDMock.invocationsDone()</span>
}

// MinimockFindOneByIDInspect logs each unmet expectation
func (m *CategoryRepositoryMock) MinimockFindOneByIDInspect() <span class="cov0" title="0">{
        for _, e := range m.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CategoryRepositoryMock.FindOneByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindOneByIDCounter := mm_atomic.LoadUint64(&amp;m.afterFindOneByIDCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindOneByIDMock.defaultExpectation != nil &amp;&amp; afterFindOneByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindOneByIDMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CategoryRepositoryMock.FindOneByID at\n%s", m.FindOneByIDMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to CategoryRepositoryMock.FindOneByID at\n%s with params: %#v", m.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *m.FindOneByIDMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindOneByID != nil &amp;&amp; afterFindOneByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to CategoryRepositoryMock.FindOneByID at\n%s", m.funcFindOneByIDOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindOneByIDMock.invocationsDone() &amp;&amp; afterFindOneByIDCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to CategoryRepositoryMock.FindOneByID at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindOneByIDMock.expectedInvocations), m.FindOneByIDMock.expectedInvocationsOrigin, afterFindOneByIDCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CategoryRepositoryMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockFindListInspect()

                        m.MinimockFindOneByIDInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CategoryRepositoryMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *CategoryRepositoryMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockFindListDone() &amp;&amp;
                m.MinimockFindOneByIDDone()
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase.CategoryUsecase -o category_usecase.go -n CategoryUsecaseMock -p mocks

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        mm_usecase "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
)

// CategoryUsecaseMock implements mm_usecase.CategoryUsecase
type CategoryUsecaseMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcFindList          func(ctx context.Context, listOptions *mm_usecase.CategoryListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.CategoryDTO, err error)
        funcFindListOrigin    string
        inspectFuncFindList   func(ctx context.Context, listOptions *mm_usecase.CategoryListOptions, queryParams *uctypes.QueryGetListParams)
        afterFindListCounter  uint64
        beforeFindListCounter uint64
        FindListMock          mCategoryUsecaseMockFindList

        funcFindOneByID          func(ctx context.Context, id uint64, queryParams *uctypes.QueryGetOneParams) (resItem *mm_usecase.CategoryDTO, err error)
        funcFindOneByIDOrigin    string
        inspectFuncFindOneByID   func(ctx context.Context, id uint64, queryParams *uctypes.QueryGetOneParams)
        afterFindOneByIDCounter  uint64
        beforeFindOneByIDCounter uint64
        FindOneByIDMock          mCategoryUsecaseMockFindOneByID
}

// NewCategoryUsecaseMock returns a mock for mm_usecase.CategoryUsecase
func NewCategoryUsecaseMock(t minimock.Tester) *CategoryUsecaseMock <span class="cov0" title="0">{
        m := &amp;CategoryUsecaseMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.FindListMock = mCategoryUsecaseMockFindList{mock: m}
        m.FindListMock.callArgs = []*CategoryUsecaseMockFindListParams{}

        m.FindOneByIDMock = mCategoryUsecaseMockFindOneByID{mock: m}
        m.FindOneByIDMock.callArgs = []*CategoryUsecaseMockFindOneByIDParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mCategoryUsecaseMockFindList struct {
        optional           bool
        mock               *CategoryUsecaseMock
        defaultExpectation *CategoryUsecaseMockFindListExpectation
        expectations       []*CategoryUsecaseMockFindListExpectation

        callArgs []*CategoryUsecaseMockFindListParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// CategoryUsecaseMockFindListExpectation specifies expectation struct of the CategoryUsecase.FindList
type CategoryUsecaseMockFindListExpectation struct {
        mock               *CategoryUsecaseMock
        params             *CategoryUsecaseMockFindListParams
        paramPtrs          *CategoryUsecaseMockFindListParamPtrs
        expectationOrigins CategoryUsecaseMockFindListExpectationOrigins
        results            *CategoryUsecaseMockFindListResults
        returnOrigin       string
        Counter            uint64
}

// CategoryUsecaseMockFindListParams contains parameters of the CategoryUsecase.FindList
type CategoryUsecaseMockFindListParams struct {
        ctx         context.Context
        listOptions *mm_usecase.CategoryListOptions
        queryParams *uctypes.QueryGetListParams
}

// CategoryUsecaseMockFindListParamPtrs contains pointers to parameters of the CategoryUsecase.FindList
type CategoryUsecaseMockFindListParamPtrs struct {
        ctx         *context.Context
        listOptions **mm_usecase.CategoryListOptions
        queryParams **uctypes.QueryGetListParams
}

// CategoryUsecaseMockFindListResults contains results of the CategoryUsecase.FindList
type CategoryUsecaseMockFindListResults struct {
        resItems []*mm_usecase.CategoryDTO
        err      error
}

// CategoryUsecaseMockFindListOrigins contains origins of expectations of the CategoryUsecase.FindList
type CategoryUsecaseMockFindListExpectationOrigins struct {
        origin            string
        originCtx         string
        originListOptions string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindList *mCategoryUsecaseMockFindList) Optional() *mCategoryUsecaseMockFindList <span class="cov0" title="0">{
        mmFindList.optional = true
        return mmFindList
}</span>

// Expect sets up expected params for CategoryUsecase.FindList
func (mmFindList *mCategoryUsecaseMockFindList) Expect(ctx context.Context, listOptions *mm_usecase.CategoryListOptions, queryParams *uctypes.QueryGetListParams) *mCategoryUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("CategoryUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;CategoryUsecaseMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("CategoryUsecaseMock.FindList mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindList.defaultExpectation.params = &amp;CategoryUsecaseMockFindListParams{ctx, listOptions, queryParams}
        mmFindList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindList.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindList.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindList.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindList</span>
}

// ExpectCtxParam1 sets up expected param ctx for CategoryUsecase.FindList
func (mmFindList *mCategoryUsecaseMockFindList) ExpectCtxParam1(ctx context.Context) *mCategoryUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("CategoryUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;CategoryUsecaseMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("CategoryUsecaseMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;CategoryUsecaseMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindList</span>
}

// ExpectListOptionsParam2 sets up expected param listOptions for CategoryUsecase.FindList
func (mmFindList *mCategoryUsecaseMockFindList) ExpectListOptionsParam2(listOptions *mm_usecase.CategoryListOptions) *mCategoryUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("CategoryUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;CategoryUsecaseMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("CategoryUsecaseMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;CategoryUsecaseMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.listOptions = &amp;listOptions
        mmFindList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

        return mmFindList</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for CategoryUsecase.FindList
func (mmFindList *mCategoryUsecaseMockFindList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mCategoryUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("CategoryUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;CategoryUsecaseMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("CategoryUsecaseMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;CategoryUsecaseMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindList</span>
}

// Inspect accepts an inspector function that has same arguments as the CategoryUsecase.FindList
func (mmFindList *mCategoryUsecaseMockFindList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.CategoryListOptions, queryParams *uctypes.QueryGetListParams)) *mCategoryUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.inspectFuncFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Inspect function is already set for CategoryUsecaseMock.FindList")
        }</span>

        <span class="cov0" title="0">mmFindList.mock.inspectFuncFindList = f

        return mmFindList</span>
}

// Return sets up results that will be returned by CategoryUsecase.FindList
func (mmFindList *mCategoryUsecaseMockFindList) Return(resItems []*mm_usecase.CategoryDTO, err error) *CategoryUsecaseMock <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("CategoryUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;CategoryUsecaseMockFindListExpectation{mock: mmFindList.mock}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.results = &amp;CategoryUsecaseMockFindListResults{resItems, err}
        mmFindList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindList.mock</span>
}

// Set uses given function f to mock the CategoryUsecase.FindList method
func (mmFindList *mCategoryUsecaseMockFindList) Set(f func(ctx context.Context, listOptions *mm_usecase.CategoryListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.CategoryDTO, err error)) *CategoryUsecaseMock <span class="cov0" title="0">{
        if mmFindList.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Default expectation is already set for the CategoryUsecase.FindList method")
        }</span>

        <span class="cov0" title="0">if len(mmFindList.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Some expectations are already set for the CategoryUsecase.FindList method")
        }</span>

        <span class="cov0" title="0">mmFindList.mock.funcFindList = f
        mmFindList.mock.funcFindListOrigin = minimock.CallerInfo(1)
        return mmFindList.mock</span>
}

// When sets expectation for the CategoryUsecase.FindList which will trigger the result defined by the following
// Then helper
func (mmFindList *mCategoryUsecaseMockFindList) When(ctx context.Context, listOptions *mm_usecase.CategoryListOptions, queryParams *uctypes.QueryGetListParams) *CategoryUsecaseMockFindListExpectation <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("CategoryUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;CategoryUsecaseMockFindListExpectation{
                mock:               mmFindList.mock,
                params:             &amp;CategoryUsecaseMockFindListParams{ctx, listOptions, queryParams},
                expectationOrigins: CategoryUsecaseMockFindListExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindList.expectations = append(mmFindList.expectations, expectation)
        return expectation</span>
}

// Then sets up CategoryUsecase.FindList return parameters for the expectation previously defined by the When method
func (e *CategoryUsecaseMockFindListExpectation) Then(resItems []*mm_usecase.CategoryDTO, err error) *CategoryUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;CategoryUsecaseMockFindListResults{resItems, err}
        return e.mock
}</span>

// Times sets number of times CategoryUsecase.FindList should be invoked
func (mmFindList *mCategoryUsecaseMockFindList) Times(n uint64) *mCategoryUsecaseMockFindList <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Times of CategoryUsecaseMock.FindList mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindList.expectedInvocations, n)
        mmFindList.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindList</span>
}

func (mmFindList *mCategoryUsecaseMockFindList) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindList.expectations) == 0 &amp;&amp; mmFindList.defaultExpectation == nil &amp;&amp; mmFindList.mock.funcFindList == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindList.mock.afterFindListCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindList.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindList implements mm_usecase.CategoryUsecase
func (mmFindList *CategoryUsecaseMock) FindList(ctx context.Context, listOptions *mm_usecase.CategoryListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.CategoryDTO, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindList.beforeFindListCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindList.afterFindListCounter, 1)

        mmFindList.t.Helper()

        if mmFindList.inspectFuncFindList != nil </span><span class="cov0" title="0">{
                mmFindList.inspectFuncFindList(ctx, listOptions, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := CategoryUsecaseMockFindListParams{ctx, listOptions, queryParams}

        // Record call args
        mmFindList.FindListMock.mutex.Lock()
        mmFindList.FindListMock.callArgs = append(mmFindList.FindListMock.callArgs, &amp;mm_params)
        mmFindList.FindListMock.mutex.Unlock()

        for _, e := range mmFindList.FindListMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.resItems, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindList.FindListMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindList.FindListMock.defaultExpectation.Counter, 1)
                mm_want := mmFindList.FindListMock.defaultExpectation.params
                mm_want_ptrs := mmFindList.FindListMock.defaultExpectation.paramPtrs

                mm_got := CategoryUsecaseMockFindListParams{ctx, listOptions, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("CategoryUsecaseMock.FindList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.listOptions != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("CategoryUsecaseMock.FindList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("CategoryUsecaseMock.FindList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindList.t.Errorf("CategoryUsecaseMock.FindList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindList.FindListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindList.FindListMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindList.t.Fatal("No results are set for the CategoryUsecaseMock.FindList")
                }</span>
                <span class="cov0" title="0">return (*mm_results).resItems, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindList.funcFindList != nil </span><span class="cov0" title="0">{
                return mmFindList.funcFindList(ctx, listOptions, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindList.t.Fatalf("Unexpected call to CategoryUsecaseMock.FindList. %v %v %v", ctx, listOptions, queryParams)
        return</span>
}

// FindListAfterCounter returns a count of finished CategoryUsecaseMock.FindList invocations
func (mmFindList *CategoryUsecaseMock) FindListAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindList.afterFindListCounter)
}</span>

// FindListBeforeCounter returns a count of CategoryUsecaseMock.FindList invocations
func (mmFindList *CategoryUsecaseMock) FindListBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindList.beforeFindListCounter)
}</span>

// Calls returns a list of arguments used in each call to CategoryUsecaseMock.FindList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindList *mCategoryUsecaseMockFindList) Calls() []*CategoryUsecaseMockFindListParams <span class="cov0" title="0">{
        mmFindList.mutex.RLock()

        argCopy := make([]*CategoryUsecaseMockFindListParams, len(mmFindList.callArgs))
        copy(argCopy, mmFindList.callArgs)

        mmFindList.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindListDone returns true if the count of the FindList invocations corresponds
// the number of defined expectations
func (m *CategoryUsecaseMock) MinimockFindListDone() bool <span class="cov0" title="0">{
        if m.FindListMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindListMock.invocationsDone()</span>
}

// MinimockFindListInspect logs each unmet expectation
func (m *CategoryUsecaseMock) MinimockFindListInspect() <span class="cov0" title="0">{
        for _, e := range m.FindListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CategoryUsecaseMock.FindList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindListCounter := mm_atomic.LoadUint64(&amp;m.afterFindListCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindListMock.defaultExpectation != nil &amp;&amp; afterFindListCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindListMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CategoryUsecaseMock.FindList at\n%s", m.FindListMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to CategoryUsecaseMock.FindList at\n%s with params: %#v", m.FindListMock.defaultExpectation.expectationOrigins.origin, *m.FindListMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindList != nil &amp;&amp; afterFindListCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to CategoryUsecaseMock.FindList at\n%s", m.funcFindListOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindListMock.invocationsDone() &amp;&amp; afterFindListCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to CategoryUsecaseMock.FindList at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindListMock.expectedInvocations), m.FindListMock.expectedInvocationsOrigin, afterFindListCounter)
        }</span>
}

type mCategoryUsecaseMockFindOneByID struct {
        optional           bool
        mock               *CategoryUsecaseMock
        defaultExpectation *CategoryUsecaseMockFindOneByIDExpectation
        expectations       []*CategoryUsecaseMockFindOneByIDExpectation

        callArgs []*CategoryUsecaseMockFindOneByIDParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// CategoryUsecaseMockFindOneByIDExpectation specifies expectation struct of the CategoryUsecase.FindOneByID
type CategoryUsecaseMockFindOneByIDExpectation struct {
        mock               *CategoryUsecaseMock
        params             *CategoryUsecaseMockFindOneByIDParams
        paramPtrs          *CategoryUsecaseMockFindOneByIDParamPtrs
        expectationOrigins CategoryUsecaseMockFindOneByIDExpectationOrigins
        results            *CategoryUsecaseMockFindOneByIDResults
        returnOrigin       string
        Counter            uint64
}

// CategoryUsecaseMockFindOneByIDParams contains parameters of the CategoryUsecase.FindOneByID
type CategoryUsecaseMockFindOneByIDParams struct {
        ctx         context.Context
        id          uint64
        queryParams *uctypes.QueryGetOneParams
}

// CategoryUsecaseMockFindOneByIDParamPtrs contains pointers to parameters of the CategoryUsecase.FindOneByID
type CategoryUsecaseMockFindOneByIDParamPtrs struct {
        ctx         *context.Context
        id          *uint64
        queryParams **uctypes.QueryGetOneParams
}

// CategoryUsecaseMockFindOneByIDResults contains results of the CategoryUsecase.FindOneByID
type CategoryUsecaseMockFindOneByIDResults struct {
        resItem *mm_usecase.CategoryDTO
        err     error
}

// CategoryUsecaseMockFindOneByIDOrigins contains origins of expectations of the CategoryUsecase.FindOneByID
type CategoryUsecaseMockFindOneByIDExpectationOrigins struct {
        origin            string
        originCtx         string
        originId          string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) Optional() *mCategoryUsecaseMockFindOneByID <span class="cov0" title="0">{
        mmFindOneByID.optional = true
        return mmFindOneByID
}</span>

// Expect sets up expected params for CategoryUsecase.FindOneByID
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) Expect(ctx context.Context, id uint64, queryParams *uctypes.QueryGetOneParams) *mCategoryUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("CategoryUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;CategoryUsecaseMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("CategoryUsecaseMock.FindOneByID mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.params = &amp;CategoryUsecaseMockFindOneByIDParams{ctx, id, queryParams}
        mmFindOneByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindOneByID.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindOneByID.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindOneByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindOneByID.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindOneByID</span>
}

// ExpectCtxParam1 sets up expected param ctx for CategoryUsecase.FindOneByID
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) ExpectCtxParam1(ctx context.Context) *mCategoryUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("CategoryUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;CategoryUsecaseMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("CategoryUsecaseMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;CategoryUsecaseMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindOneByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// ExpectIdParam2 sets up expected param id for CategoryUsecase.FindOneByID
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) ExpectIdParam2(id uint64) *mCategoryUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("CategoryUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;CategoryUsecaseMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("CategoryUsecaseMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;CategoryUsecaseMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.id = &amp;id
        mmFindOneByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for CategoryUsecase.FindOneByID
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetOneParams) *mCategoryUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("CategoryUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;CategoryUsecaseMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("CategoryUsecaseMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;CategoryUsecaseMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindOneByID.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// Inspect accepts an inspector function that has same arguments as the CategoryUsecase.FindOneByID
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) Inspect(f func(ctx context.Context, id uint64, queryParams *uctypes.QueryGetOneParams)) *mCategoryUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.inspectFuncFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Inspect function is already set for CategoryUsecaseMock.FindOneByID")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.mock.inspectFuncFindOneByID = f

        return mmFindOneByID</span>
}

// Return sets up results that will be returned by CategoryUsecase.FindOneByID
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) Return(resItem *mm_usecase.CategoryDTO, err error) *CategoryUsecaseMock <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("CategoryUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;CategoryUsecaseMockFindOneByIDExpectation{mock: mmFindOneByID.mock}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.results = &amp;CategoryUsecaseMockFindOneByIDResults{resItem, err}
        mmFindOneByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindOneByID.mock</span>
}

// Set uses given function f to mock the CategoryUsecase.FindOneByID method
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) Set(f func(ctx context.Context, id uint64, queryParams *uctypes.QueryGetOneParams) (resItem *mm_usecase.CategoryDTO, err error)) *CategoryUsecaseMock <span class="cov0" title="0">{
        if mmFindOneByID.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Default expectation is already set for the CategoryUsecase.FindOneByID method")
        }</span>

        <span class="cov0" title="0">if len(mmFindOneByID.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Some expectations are already set for the CategoryUsecase.FindOneByID method")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.mock.funcFindOneByID = f
        mmFindOneByID.mock.funcFindOneByIDOrigin = minimock.CallerInfo(1)
        return mmFindOneByID.mock</span>
}

// When sets expectation for the CategoryUsecase.FindOneByID which will trigger the result defined by the following
// Then helper
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) When(ctx context.Context, id uint64, queryParams *uctypes.QueryGetOneParams) *CategoryUsecaseMockFindOneByIDExpectation <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("CategoryUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;CategoryUsecaseMockFindOneByIDExpectation{
                mock:               mmFindOneByID.mock,
                params:             &amp;CategoryUsecaseMockFindOneByIDParams{ctx, id, queryParams},
                expectationOrigins: CategoryUsecaseMockFindOneByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindOneByID.expectations = append(mmFindOneByID.expectations, expectation)
        return expectation</span>
}

// Then sets up CategoryUsecase.FindOneByID return parameters for the expectation previously defined by the When method
func (e *CategoryUsecaseMockFindOneByIDExpectation) Then(resItem *mm_usecase.CategoryDTO, err error) *CategoryUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;CategoryUsecaseMockFindOneByIDResults{resItem, err}
        return e.mock
}</span>

// Times sets number of times CategoryUsecase.FindOneByID should be invoked
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) Times(n uint64) *mCategoryUsecaseMockFindOneByID <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Times of CategoryUsecaseMock.FindOneByID mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindOneByID.expectedInvocations, n)
        mmFindOneByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindOneByID</span>
}

func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindOneByID.expectations) == 0 &amp;&amp; mmFindOneByID.defaultExpectation == nil &amp;&amp; mmFindOneByID.mock.funcFindOneByID == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByID.mock.afterFindOneByIDCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByID.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindOneByID implements mm_usecase.CategoryUsecase
func (mmFindOneByID *CategoryUsecaseMock) FindOneByID(ctx context.Context, id uint64, queryParams *uctypes.QueryGetOneParams) (resItem *mm_usecase.CategoryDTO, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindOneByID.beforeFindOneByIDCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindOneByID.afterFindOneByIDCounter, 1)

        mmFindOneByID.t.Helper()

        if mmFindOneByID.inspectFuncFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.inspectFuncFindOneByID(ctx, id, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := CategoryUsecaseMockFindOneByIDParams{ctx, id, queryParams}

        // Record call args
        mmFindOneByID.FindOneByIDMock.mutex.Lock()
        mmFindOneByID.FindOneByIDMock.callArgs = append(mmFindOneByID.FindOneByIDMock.callArgs, &amp;mm_params)
        mmFindOneByID.FindOneByIDMock.mutex.Unlock()

        for _, e := range mmFindOneByID.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.resItem, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindOneByID.FindOneByIDMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindOneByID.FindOneByIDMock.defaultExpectation.Counter, 1)
                mm_want := mmFindOneByID.FindOneByIDMock.defaultExpectation.params
                mm_want_ptrs := mmFindOneByID.FindOneByIDMock.defaultExpectation.paramPtrs

                mm_got := CategoryUsecaseMockFindOneByIDParams{ctx, id, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("CategoryUsecaseMock.FindOneByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("CategoryUsecaseMock.FindOneByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("CategoryUsecaseMock.FindOneByID got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindOneByID.t.Errorf("CategoryUsecaseMock.FindOneByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindOneByID.FindOneByIDMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindOneByID.t.Fatal("No results are set for the CategoryUsecaseMock.FindOneByID")
                }</span>
                <span class="cov0" title="0">return (*mm_results).resItem, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindOneByID.funcFindOneByID != nil </span><span class="cov0" title="0">{
                return mmFindOneByID.funcFindOneByID(ctx, id, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindOneByID.t.Fatalf("Unexpected call to CategoryUsecaseMock.FindOneByID. %v %v %v", ctx, id, queryParams)
        return</span>
}

// FindOneByIDAfterCounter returns a count of finished CategoryUsecaseMock.FindOneByID invocations
func (mmFindOneByID *CategoryUsecaseMock) FindOneByIDAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByID.afterFindOneByIDCounter)
}</span>

// FindOneByIDBeforeCounter returns a count of CategoryUsecaseMock.FindOneByID invocations
func (mmFindOneByID *CategoryUsecaseMock) FindOneByIDBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByID.beforeFindOneByIDCounter)
}</span>

// Calls returns a list of arguments used in each call to CategoryUsecaseMock.FindOneByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindOneByID *mCategoryUsecaseMockFindOneByID) Calls() []*CategoryUsecaseMockFindOneByIDParams <span class="cov0" title="0">{
        mmFindOneByID.mutex.RLock()

        argCopy := make([]*CategoryUsecaseMockFindOneByIDParams, len(mmFindOneByID.callArgs))
        copy(argCopy, mmFindOneByID.callArgs)

        mmFindOneByID.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindOneByIDDone returns true if the count of the FindOneByID invocations corresponds
// the number of defined expectations
func (m *CategoryUsecaseMock) MinimockFindOneByIDDone() bool <span class="cov0" title="0">{
        if m.FindOneByIDMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindOneByIDMock.invocationsDone()</span>
}

// MinimockFindOneByIDInspect logs each unmet expectation
func (m *CategoryUsecaseMock) MinimockFindOneByIDInspect() <span class="cov0" title="0">{
        for _, e := range m.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CategoryUsecaseMock.FindOneByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindOneByIDCounter := mm_atomic.LoadUint64(&amp;m.afterFindOneByIDCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindOneByIDMock.defaultExpectation != nil &amp;&amp; afterFindOneByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindOneByIDMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CategoryUsecaseMock.FindOneByID at\n%s", m.FindOneByIDMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to CategoryUsecaseMock.FindOneByID at\n%s with params: %#v", m.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *m.FindOneByIDMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindOneByID != nil &amp;&amp; afterFindOneByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to CategoryUsecaseMock.FindOneByID at\n%s", m.funcFindOneByIDOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindOneByIDMock.invocationsDone() &amp;&amp; afterFindOneByIDCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to CategoryUsecaseMock.FindOneByID at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindOneByIDMock.expectedInvocations), m.FindOneByIDMock.expectedInvocationsOrigin, afterFindOneByIDCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CategoryUsecaseMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockFindListInspect()

                        m.MinimockFindOneByIDInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CategoryUsecaseMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *CategoryUsecaseMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockFindListDone() &amp;&amp;
                m.MinimockFindOneByIDDone()
}</span>
</pre>
		
		<pre class="file" id="file79" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase.TransactionCacheRepository -o transaction_cache_repository.go -n TransactionCacheRepositoryMock -p mocks

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        "time"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
)

// TransactionCacheRepositoryMock implements mm_usecase.TransactionCacheRepository
type TransactionCacheRepositoryMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcGetReports          func(ctx context.Context, key string) (items []*entity.ReportItem, err error)
        funcGetReportsOrigin    string
        inspectFuncGetReports   func(ctx context.Context, key string)
        afterGetReportsCounter  uint64
        beforeGetReportsCounter uint64
        GetReportsMock          mTransactionCacheRepositoryMockGetReports

        funcSaveReports          func(ctx context.Context, key string, items []*entity.ReportItem, ttl *time.Duration) (err error)
        funcSaveReportsOrigin    string
        inspectFuncSaveReports   func(ctx context.Context, key string, items []*entity.ReportItem, ttl *time.Duration)
        afterSaveReportsCounter  uint64
        beforeSaveReportsCounter uint64
        SaveReportsMock          mTransactionCacheRepositoryMockSaveReports
}

// NewTransactionCacheRepositoryMock returns a mock for mm_usecase.TransactionCacheRepository
func NewTransactionCacheRepositoryMock(t minimock.Tester) *TransactionCacheRepositoryMock <span class="cov0" title="0">{
        m := &amp;TransactionCacheRepositoryMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.GetReportsMock = mTransactionCacheRepositoryMockGetReports{mock: m}
        m.GetReportsMock.callArgs = []*TransactionCacheRepositoryMockGetReportsParams{}

        m.SaveReportsMock = mTransactionCacheRepositoryMockSaveReports{mock: m}
        m.SaveReportsMock.callArgs = []*TransactionCacheRepositoryMockSaveReportsParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mTransactionCacheRepositoryMockGetReports struct {
        optional           bool
        mock               *TransactionCacheRepositoryMock
        defaultExpectation *TransactionCacheRepositoryMockGetReportsExpectation
        expectations       []*TransactionCacheRepositoryMockGetReportsExpectation

        callArgs []*TransactionCacheRepositoryMockGetReportsParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TransactionCacheRepositoryMockGetReportsExpectation specifies expectation struct of the TransactionCacheRepository.GetReports
type TransactionCacheRepositoryMockGetReportsExpectation struct {
        mock               *TransactionCacheRepositoryMock
        params             *TransactionCacheRepositoryMockGetReportsParams
        paramPtrs          *TransactionCacheRepositoryMockGetReportsParamPtrs
        expectationOrigins TransactionCacheRepositoryMockGetReportsExpectationOrigins
        results            *TransactionCacheRepositoryMockGetReportsResults
        returnOrigin       string
        Counter            uint64
}

// TransactionCacheRepositoryMockGetReportsParams contains parameters of the TransactionCacheRepository.GetReports
type TransactionCacheRepositoryMockGetReportsParams struct {
        ctx context.Context
        key string
}

// TransactionCacheRepositoryMockGetReportsParamPtrs contains pointers to parameters of the TransactionCacheRepository.GetReports
type TransactionCacheRepositoryMockGetReportsParamPtrs struct {
        ctx *context.Context
        key *string
}

// TransactionCacheRepositoryMockGetReportsResults contains results of the TransactionCacheRepository.GetReports
type TransactionCacheRepositoryMockGetReportsResults struct {
        items []*entity.ReportItem
        err   error
}

// TransactionCacheRepositoryMockGetReportsOrigins contains origins of expectations of the TransactionCacheRepository.GetReports
type TransactionCacheRepositoryMockGetReportsExpectationOrigins struct {
        origin    string
        originCtx string
        originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReports *mTransactionCacheRepositoryMockGetReports) Optional() *mTransactionCacheRepositoryMockGetReports <span class="cov0" title="0">{
        mmGetReports.optional = true
        return mmGetReports
}</span>

// Expect sets up expected params for TransactionCacheRepository.GetReports
func (mmGetReports *mTransactionCacheRepositoryMockGetReports) Expect(ctx context.Context, key string) *mTransactionCacheRepositoryMockGetReports <span class="cov0" title="0">{
        if mmGetReports.mock.funcGetReports != nil </span><span class="cov0" title="0">{
                mmGetReports.mock.t.Fatalf("TransactionCacheRepositoryMock.GetReports mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetReports.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetReports.defaultExpectation = &amp;TransactionCacheRepositoryMockGetReportsExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetReports.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetReports.mock.t.Fatalf("TransactionCacheRepositoryMock.GetReports mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmGetReports.defaultExpectation.params = &amp;TransactionCacheRepositoryMockGetReportsParams{ctx, key}
        mmGetReports.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmGetReports.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetReports.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetReports.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReports.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmGetReports</span>
}

// ExpectCtxParam1 sets up expected param ctx for TransactionCacheRepository.GetReports
func (mmGetReports *mTransactionCacheRepositoryMockGetReports) ExpectCtxParam1(ctx context.Context) *mTransactionCacheRepositoryMockGetReports <span class="cov0" title="0">{
        if mmGetReports.mock.funcGetReports != nil </span><span class="cov0" title="0">{
                mmGetReports.mock.t.Fatalf("TransactionCacheRepositoryMock.GetReports mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetReports.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetReports.defaultExpectation = &amp;TransactionCacheRepositoryMockGetReportsExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetReports.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetReports.mock.t.Fatalf("TransactionCacheRepositoryMock.GetReports mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetReports.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetReports.defaultExpectation.paramPtrs = &amp;TransactionCacheRepositoryMockGetReportsParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetReports.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmGetReports.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmGetReports</span>
}

// ExpectKeyParam2 sets up expected param key for TransactionCacheRepository.GetReports
func (mmGetReports *mTransactionCacheRepositoryMockGetReports) ExpectKeyParam2(key string) *mTransactionCacheRepositoryMockGetReports <span class="cov0" title="0">{
        if mmGetReports.mock.funcGetReports != nil </span><span class="cov0" title="0">{
                mmGetReports.mock.t.Fatalf("TransactionCacheRepositoryMock.GetReports mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetReports.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetReports.defaultExpectation = &amp;TransactionCacheRepositoryMockGetReportsExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetReports.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetReports.mock.t.Fatalf("TransactionCacheRepositoryMock.GetReports mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetReports.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetReports.defaultExpectation.paramPtrs = &amp;TransactionCacheRepositoryMockGetReportsParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetReports.defaultExpectation.paramPtrs.key = &amp;key
        mmGetReports.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

        return mmGetReports</span>
}

// Inspect accepts an inspector function that has same arguments as the TransactionCacheRepository.GetReports
func (mmGetReports *mTransactionCacheRepositoryMockGetReports) Inspect(f func(ctx context.Context, key string)) *mTransactionCacheRepositoryMockGetReports <span class="cov0" title="0">{
        if mmGetReports.mock.inspectFuncGetReports != nil </span><span class="cov0" title="0">{
                mmGetReports.mock.t.Fatalf("Inspect function is already set for TransactionCacheRepositoryMock.GetReports")
        }</span>

        <span class="cov0" title="0">mmGetReports.mock.inspectFuncGetReports = f

        return mmGetReports</span>
}

// Return sets up results that will be returned by TransactionCacheRepository.GetReports
func (mmGetReports *mTransactionCacheRepositoryMockGetReports) Return(items []*entity.ReportItem, err error) *TransactionCacheRepositoryMock <span class="cov0" title="0">{
        if mmGetReports.mock.funcGetReports != nil </span><span class="cov0" title="0">{
                mmGetReports.mock.t.Fatalf("TransactionCacheRepositoryMock.GetReports mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetReports.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetReports.defaultExpectation = &amp;TransactionCacheRepositoryMockGetReportsExpectation{mock: mmGetReports.mock}
        }</span>
        <span class="cov0" title="0">mmGetReports.defaultExpectation.results = &amp;TransactionCacheRepositoryMockGetReportsResults{items, err}
        mmGetReports.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGetReports.mock</span>
}

// Set uses given function f to mock the TransactionCacheRepository.GetReports method
func (mmGetReports *mTransactionCacheRepositoryMockGetReports) Set(f func(ctx context.Context, key string) (items []*entity.ReportItem, err error)) *TransactionCacheRepositoryMock <span class="cov0" title="0">{
        if mmGetReports.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetReports.mock.t.Fatalf("Default expectation is already set for the TransactionCacheRepository.GetReports method")
        }</span>

        <span class="cov0" title="0">if len(mmGetReports.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetReports.mock.t.Fatalf("Some expectations are already set for the TransactionCacheRepository.GetReports method")
        }</span>

        <span class="cov0" title="0">mmGetReports.mock.funcGetReports = f
        mmGetReports.mock.funcGetReportsOrigin = minimock.CallerInfo(1)
        return mmGetReports.mock</span>
}

// When sets expectation for the TransactionCacheRepository.GetReports which will trigger the result defined by the following
// Then helper
func (mmGetReports *mTransactionCacheRepositoryMockGetReports) When(ctx context.Context, key string) *TransactionCacheRepositoryMockGetReportsExpectation <span class="cov0" title="0">{
        if mmGetReports.mock.funcGetReports != nil </span><span class="cov0" title="0">{
                mmGetReports.mock.t.Fatalf("TransactionCacheRepositoryMock.GetReports mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TransactionCacheRepositoryMockGetReportsExpectation{
                mock:               mmGetReports.mock,
                params:             &amp;TransactionCacheRepositoryMockGetReportsParams{ctx, key},
                expectationOrigins: TransactionCacheRepositoryMockGetReportsExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmGetReports.expectations = append(mmGetReports.expectations, expectation)
        return expectation</span>
}

// Then sets up TransactionCacheRepository.GetReports return parameters for the expectation previously defined by the When method
func (e *TransactionCacheRepositoryMockGetReportsExpectation) Then(items []*entity.ReportItem, err error) *TransactionCacheRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;TransactionCacheRepositoryMockGetReportsResults{items, err}
        return e.mock
}</span>

// Times sets number of times TransactionCacheRepository.GetReports should be invoked
func (mmGetReports *mTransactionCacheRepositoryMockGetReports) Times(n uint64) *mTransactionCacheRepositoryMockGetReports <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetReports.mock.t.Fatalf("Times of TransactionCacheRepositoryMock.GetReports mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetReports.expectedInvocations, n)
        mmGetReports.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGetReports</span>
}

func (mmGetReports *mTransactionCacheRepositoryMockGetReports) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmGetReports.expectations) == 0 &amp;&amp; mmGetReports.defaultExpectation == nil &amp;&amp; mmGetReports.mock.funcGetReports == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetReports.mock.afterGetReportsCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetReports.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetReports implements mm_usecase.TransactionCacheRepository
func (mmGetReports *TransactionCacheRepositoryMock) GetReports(ctx context.Context, key string) (items []*entity.ReportItem, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmGetReports.beforeGetReportsCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetReports.afterGetReportsCounter, 1)

        mmGetReports.t.Helper()

        if mmGetReports.inspectFuncGetReports != nil </span><span class="cov0" title="0">{
                mmGetReports.inspectFuncGetReports(ctx, key)
        }</span>

        <span class="cov0" title="0">mm_params := TransactionCacheRepositoryMockGetReportsParams{ctx, key}

        // Record call args
        mmGetReports.GetReportsMock.mutex.Lock()
        mmGetReports.GetReportsMock.callArgs = append(mmGetReports.GetReportsMock.callArgs, &amp;mm_params)
        mmGetReports.GetReportsMock.mutex.Unlock()

        for _, e := range mmGetReports.GetReportsMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.items, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmGetReports.GetReportsMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmGetReports.GetReportsMock.defaultExpectation.Counter, 1)
                mm_want := mmGetReports.GetReportsMock.defaultExpectation.params
                mm_want_ptrs := mmGetReports.GetReportsMock.defaultExpectation.paramPtrs

                mm_got := TransactionCacheRepositoryMockGetReportsParams{ctx, key}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmGetReports.t.Errorf("TransactionCacheRepositoryMock.GetReports got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetReports.GetReportsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.key != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.key, mm_got.key) </span><span class="cov0" title="0">{
                                mmGetReports.t.Errorf("TransactionCacheRepositoryMock.GetReports got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetReports.GetReportsMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetReports.t.Errorf("TransactionCacheRepositoryMock.GetReports got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmGetReports.GetReportsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmGetReports.GetReportsMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetReports.t.Fatal("No results are set for the TransactionCacheRepositoryMock.GetReports")
                }</span>
                <span class="cov0" title="0">return (*mm_results).items, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmGetReports.funcGetReports != nil </span><span class="cov0" title="0">{
                return mmGetReports.funcGetReports(ctx, key)
        }</span>
        <span class="cov0" title="0">mmGetReports.t.Fatalf("Unexpected call to TransactionCacheRepositoryMock.GetReports. %v %v", ctx, key)
        return</span>
}

// GetReportsAfterCounter returns a count of finished TransactionCacheRepositoryMock.GetReports invocations
func (mmGetReports *TransactionCacheRepositoryMock) GetReportsAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetReports.afterGetReportsCounter)
}</span>

// GetReportsBeforeCounter returns a count of TransactionCacheRepositoryMock.GetReports invocations
func (mmGetReports *TransactionCacheRepositoryMock) GetReportsBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetReports.beforeGetReportsCounter)
}</span>

// Calls returns a list of arguments used in each call to TransactionCacheRepositoryMock.GetReports.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReports *mTransactionCacheRepositoryMockGetReports) Calls() []*TransactionCacheRepositoryMockGetReportsParams <span class="cov0" title="0">{
        mmGetReports.mutex.RLock()

        argCopy := make([]*TransactionCacheRepositoryMockGetReportsParams, len(mmGetReports.callArgs))
        copy(argCopy, mmGetReports.callArgs)

        mmGetReports.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetReportsDone returns true if the count of the GetReports invocations corresponds
// the number of defined expectations
func (m *TransactionCacheRepositoryMock) MinimockGetReportsDone() bool <span class="cov0" title="0">{
        if m.GetReportsMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.GetReportsMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.GetReportsMock.invocationsDone()</span>
}

// MinimockGetReportsInspect logs each unmet expectation
func (m *TransactionCacheRepositoryMock) MinimockGetReportsInspect() <span class="cov0" title="0">{
        for _, e := range m.GetReportsMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionCacheRepositoryMock.GetReports at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetReportsCounter := mm_atomic.LoadUint64(&amp;m.afterGetReportsCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetReportsMock.defaultExpectation != nil &amp;&amp; afterGetReportsCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetReportsMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionCacheRepositoryMock.GetReports at\n%s", m.GetReportsMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TransactionCacheRepositoryMock.GetReports at\n%s with params: %#v", m.GetReportsMock.defaultExpectation.expectationOrigins.origin, *m.GetReportsMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetReports != nil &amp;&amp; afterGetReportsCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TransactionCacheRepositoryMock.GetReports at\n%s", m.funcGetReportsOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetReportsMock.invocationsDone() &amp;&amp; afterGetReportsCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TransactionCacheRepositoryMock.GetReports at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetReportsMock.expectedInvocations), m.GetReportsMock.expectedInvocationsOrigin, afterGetReportsCounter)
        }</span>
}

type mTransactionCacheRepositoryMockSaveReports struct {
        optional           bool
        mock               *TransactionCacheRepositoryMock
        defaultExpectation *TransactionCacheRepositoryMockSaveReportsExpectation
        expectations       []*TransactionCacheRepositoryMockSaveReportsExpectation

        callArgs []*TransactionCacheRepositoryMockSaveReportsParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TransactionCacheRepositoryMockSaveReportsExpectation specifies expectation struct of the TransactionCacheRepository.SaveReports
type TransactionCacheRepositoryMockSaveReportsExpectation struct {
        mock               *TransactionCacheRepositoryMock
        params             *TransactionCacheRepositoryMockSaveReportsParams
        paramPtrs          *TransactionCacheRepositoryMockSaveReportsParamPtrs
        expectationOrigins TransactionCacheRepositoryMockSaveReportsExpectationOrigins
        results            *TransactionCacheRepositoryMockSaveReportsResults
        returnOrigin       string
        Counter            uint64
}

// TransactionCacheRepositoryMockSaveReportsParams contains parameters of the TransactionCacheRepository.SaveReports
type TransactionCacheRepositoryMockSaveReportsParams struct {
        ctx   context.Context
        key   string
        items []*entity.ReportItem
        ttl   *time.Duration
}

// TransactionCacheRepositoryMockSaveReportsParamPtrs contains pointers to parameters of the TransactionCacheRepository.SaveReports
type TransactionCacheRepositoryMockSaveReportsParamPtrs struct {
        ctx   *context.Context
        key   *string
        items *[]*entity.ReportItem
        ttl   **time.Duration
}

// TransactionCacheRepositoryMockSaveReportsResults contains results of the TransactionCacheRepository.SaveReports
type TransactionCacheRepositoryMockSaveReportsResults struct {
        err error
}

// TransactionCacheRepositoryMockSaveReportsOrigins contains origins of expectations of the TransactionCacheRepository.SaveReports
type TransactionCacheRepositoryMockSaveReportsExpectationOrigins struct {
        origin      string
        originCtx   string
        originKey   string
        originItems string
        originTtl   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) Optional() *mTransactionCacheRepositoryMockSaveReports <span class="cov0" title="0">{
        mmSaveReports.optional = true
        return mmSaveReports
}</span>

// Expect sets up expected params for TransactionCacheRepository.SaveReports
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) Expect(ctx context.Context, key string, items []*entity.ReportItem, ttl *time.Duration) *mTransactionCacheRepositoryMockSaveReports <span class="cov0" title="0">{
        if mmSaveReports.mock.funcSaveReports != nil </span><span class="cov0" title="0">{
                mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveReports.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveReports.defaultExpectation = &amp;TransactionCacheRepositoryMockSaveReportsExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveReports.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmSaveReports.defaultExpectation.params = &amp;TransactionCacheRepositoryMockSaveReportsParams{ctx, key, items, ttl}
        mmSaveReports.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmSaveReports.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmSaveReports.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmSaveReports.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveReports.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmSaveReports</span>
}

// ExpectCtxParam1 sets up expected param ctx for TransactionCacheRepository.SaveReports
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) ExpectCtxParam1(ctx context.Context) *mTransactionCacheRepositoryMockSaveReports <span class="cov0" title="0">{
        if mmSaveReports.mock.funcSaveReports != nil </span><span class="cov0" title="0">{
                mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveReports.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveReports.defaultExpectation = &amp;TransactionCacheRepositoryMockSaveReportsExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveReports.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSaveReports.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSaveReports.defaultExpectation.paramPtrs = &amp;TransactionCacheRepositoryMockSaveReportsParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSaveReports.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmSaveReports.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmSaveReports</span>
}

// ExpectKeyParam2 sets up expected param key for TransactionCacheRepository.SaveReports
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) ExpectKeyParam2(key string) *mTransactionCacheRepositoryMockSaveReports <span class="cov0" title="0">{
        if mmSaveReports.mock.funcSaveReports != nil </span><span class="cov0" title="0">{
                mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveReports.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveReports.defaultExpectation = &amp;TransactionCacheRepositoryMockSaveReportsExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveReports.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSaveReports.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSaveReports.defaultExpectation.paramPtrs = &amp;TransactionCacheRepositoryMockSaveReportsParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSaveReports.defaultExpectation.paramPtrs.key = &amp;key
        mmSaveReports.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

        return mmSaveReports</span>
}

// ExpectItemsParam3 sets up expected param items for TransactionCacheRepository.SaveReports
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) ExpectItemsParam3(items []*entity.ReportItem) *mTransactionCacheRepositoryMockSaveReports <span class="cov0" title="0">{
        if mmSaveReports.mock.funcSaveReports != nil </span><span class="cov0" title="0">{
                mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveReports.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveReports.defaultExpectation = &amp;TransactionCacheRepositoryMockSaveReportsExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveReports.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSaveReports.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSaveReports.defaultExpectation.paramPtrs = &amp;TransactionCacheRepositoryMockSaveReportsParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSaveReports.defaultExpectation.paramPtrs.items = &amp;items
        mmSaveReports.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

        return mmSaveReports</span>
}

// ExpectTtlParam4 sets up expected param ttl for TransactionCacheRepository.SaveReports
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) ExpectTtlParam4(ttl *time.Duration) *mTransactionCacheRepositoryMockSaveReports <span class="cov0" title="0">{
        if mmSaveReports.mock.funcSaveReports != nil </span><span class="cov0" title="0">{
                mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveReports.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveReports.defaultExpectation = &amp;TransactionCacheRepositoryMockSaveReportsExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveReports.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSaveReports.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSaveReports.defaultExpectation.paramPtrs = &amp;TransactionCacheRepositoryMockSaveReportsParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSaveReports.defaultExpectation.paramPtrs.ttl = &amp;ttl
        mmSaveReports.defaultExpectation.expectationOrigins.originTtl = minimock.CallerInfo(1)

        return mmSaveReports</span>
}

// Inspect accepts an inspector function that has same arguments as the TransactionCacheRepository.SaveReports
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) Inspect(f func(ctx context.Context, key string, items []*entity.ReportItem, ttl *time.Duration)) *mTransactionCacheRepositoryMockSaveReports <span class="cov0" title="0">{
        if mmSaveReports.mock.inspectFuncSaveReports != nil </span><span class="cov0" title="0">{
                mmSaveReports.mock.t.Fatalf("Inspect function is already set for TransactionCacheRepositoryMock.SaveReports")
        }</span>

        <span class="cov0" title="0">mmSaveReports.mock.inspectFuncSaveReports = f

        return mmSaveReports</span>
}

// Return sets up results that will be returned by TransactionCacheRepository.SaveReports
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) Return(err error) *TransactionCacheRepositoryMock <span class="cov0" title="0">{
        if mmSaveReports.mock.funcSaveReports != nil </span><span class="cov0" title="0">{
                mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveReports.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveReports.defaultExpectation = &amp;TransactionCacheRepositoryMockSaveReportsExpectation{mock: mmSaveReports.mock}
        }</span>
        <span class="cov0" title="0">mmSaveReports.defaultExpectation.results = &amp;TransactionCacheRepositoryMockSaveReportsResults{err}
        mmSaveReports.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmSaveReports.mock</span>
}

// Set uses given function f to mock the TransactionCacheRepository.SaveReports method
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) Set(f func(ctx context.Context, key string, items []*entity.ReportItem, ttl *time.Duration) (err error)) *TransactionCacheRepositoryMock <span class="cov0" title="0">{
        if mmSaveReports.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmSaveReports.mock.t.Fatalf("Default expectation is already set for the TransactionCacheRepository.SaveReports method")
        }</span>

        <span class="cov0" title="0">if len(mmSaveReports.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmSaveReports.mock.t.Fatalf("Some expectations are already set for the TransactionCacheRepository.SaveReports method")
        }</span>

        <span class="cov0" title="0">mmSaveReports.mock.funcSaveReports = f
        mmSaveReports.mock.funcSaveReportsOrigin = minimock.CallerInfo(1)
        return mmSaveReports.mock</span>
}

// When sets expectation for the TransactionCacheRepository.SaveReports which will trigger the result defined by the following
// Then helper
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) When(ctx context.Context, key string, items []*entity.ReportItem, ttl *time.Duration) *TransactionCacheRepositoryMockSaveReportsExpectation <span class="cov0" title="0">{
        if mmSaveReports.mock.funcSaveReports != nil </span><span class="cov0" title="0">{
                mmSaveReports.mock.t.Fatalf("TransactionCacheRepositoryMock.SaveReports mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TransactionCacheRepositoryMockSaveReportsExpectation{
                mock:               mmSaveReports.mock,
                params:             &amp;TransactionCacheRepositoryMockSaveReportsParams{ctx, key, items, ttl},
                expectationOrigins: TransactionCacheRepositoryMockSaveReportsExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmSaveReports.expectations = append(mmSaveReports.expectations, expectation)
        return expectation</span>
}

// Then sets up TransactionCacheRepository.SaveReports return parameters for the expectation previously defined by the When method
func (e *TransactionCacheRepositoryMockSaveReportsExpectation) Then(err error) *TransactionCacheRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;TransactionCacheRepositoryMockSaveReportsResults{err}
        return e.mock
}</span>

// Times sets number of times TransactionCacheRepository.SaveReports should be invoked
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) Times(n uint64) *mTransactionCacheRepositoryMockSaveReports <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmSaveReports.mock.t.Fatalf("Times of TransactionCacheRepositoryMock.SaveReports mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmSaveReports.expectedInvocations, n)
        mmSaveReports.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmSaveReports</span>
}

func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmSaveReports.expectations) == 0 &amp;&amp; mmSaveReports.defaultExpectation == nil &amp;&amp; mmSaveReports.mock.funcSaveReports == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmSaveReports.mock.afterSaveReportsCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmSaveReports.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// SaveReports implements mm_usecase.TransactionCacheRepository
func (mmSaveReports *TransactionCacheRepositoryMock) SaveReports(ctx context.Context, key string, items []*entity.ReportItem, ttl *time.Duration) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmSaveReports.beforeSaveReportsCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmSaveReports.afterSaveReportsCounter, 1)

        mmSaveReports.t.Helper()

        if mmSaveReports.inspectFuncSaveReports != nil </span><span class="cov0" title="0">{
                mmSaveReports.inspectFuncSaveReports(ctx, key, items, ttl)
        }</span>

        <span class="cov0" title="0">mm_params := TransactionCacheRepositoryMockSaveReportsParams{ctx, key, items, ttl}

        // Record call args
        mmSaveReports.SaveReportsMock.mutex.Lock()
        mmSaveReports.SaveReportsMock.callArgs = append(mmSaveReports.SaveReportsMock.callArgs, &amp;mm_params)
        mmSaveReports.SaveReportsMock.mutex.Unlock()

        for _, e := range mmSaveReports.SaveReportsMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmSaveReports.SaveReportsMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmSaveReports.SaveReportsMock.defaultExpectation.Counter, 1)
                mm_want := mmSaveReports.SaveReportsMock.defaultExpectation.params
                mm_want_ptrs := mmSaveReports.SaveReportsMock.defaultExpectation.paramPtrs

                mm_got := TransactionCacheRepositoryMockSaveReportsParams{ctx, key, items, ttl}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmSaveReports.t.Errorf("TransactionCacheRepositoryMock.SaveReports got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmSaveReports.SaveReportsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.key != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.key, mm_got.key) </span><span class="cov0" title="0">{
                                mmSaveReports.t.Errorf("TransactionCacheRepositoryMock.SaveReports got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmSaveReports.SaveReportsMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.items != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.items, mm_got.items) </span><span class="cov0" title="0">{
                                mmSaveReports.t.Errorf("TransactionCacheRepositoryMock.SaveReports got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmSaveReports.SaveReportsMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.ttl != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ttl, mm_got.ttl) </span><span class="cov0" title="0">{
                                mmSaveReports.t.Errorf("TransactionCacheRepositoryMock.SaveReports got unexpected parameter ttl, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmSaveReports.SaveReportsMock.defaultExpectation.expectationOrigins.originTtl, *mm_want_ptrs.ttl, mm_got.ttl, minimock.Diff(*mm_want_ptrs.ttl, mm_got.ttl))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmSaveReports.t.Errorf("TransactionCacheRepositoryMock.SaveReports got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmSaveReports.SaveReportsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmSaveReports.SaveReportsMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmSaveReports.t.Fatal("No results are set for the TransactionCacheRepositoryMock.SaveReports")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmSaveReports.funcSaveReports != nil </span><span class="cov0" title="0">{
                return mmSaveReports.funcSaveReports(ctx, key, items, ttl)
        }</span>
        <span class="cov0" title="0">mmSaveReports.t.Fatalf("Unexpected call to TransactionCacheRepositoryMock.SaveReports. %v %v %v %v", ctx, key, items, ttl)
        return</span>
}

// SaveReportsAfterCounter returns a count of finished TransactionCacheRepositoryMock.SaveReports invocations
func (mmSaveReports *TransactionCacheRepositoryMock) SaveReportsAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmSaveReports.afterSaveReportsCounter)
}</span>

// SaveReportsBeforeCounter returns a count of TransactionCacheRepositoryMock.SaveReports invocations
func (mmSaveReports *TransactionCacheRepositoryMock) SaveReportsBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmSaveReports.beforeSaveReportsCounter)
}</span>

// Calls returns a list of arguments used in each call to TransactionCacheRepositoryMock.SaveReports.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveReports *mTransactionCacheRepositoryMockSaveReports) Calls() []*TransactionCacheRepositoryMockSaveReportsParams <span class="cov0" title="0">{
        mmSaveReports.mutex.RLock()

        argCopy := make([]*TransactionCacheRepositoryMockSaveReportsParams, len(mmSaveReports.callArgs))
        copy(argCopy, mmSaveReports.callArgs)

        mmSaveReports.mutex.RUnlock()

        return argCopy
}</span>

// MinimockSaveReportsDone returns true if the count of the SaveReports invocations corresponds
// the number of defined expectations
func (m *TransactionCacheRepositoryMock) MinimockSaveReportsDone() bool <span class="cov0" title="0">{
        if m.SaveReportsMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.SaveReportsMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.SaveReportsMock.invocationsDone()</span>
}

// MinimockSaveReportsInspect logs each unmet expectation
func (m *TransactionCacheRepositoryMock) MinimockSaveReportsInspect() <span class="cov0" title="0">{
        for _, e := range m.SaveReportsMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionCacheRepositoryMock.SaveReports at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterSaveReportsCounter := mm_atomic.LoadUint64(&amp;m.afterSaveReportsCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.SaveReportsMock.defaultExpectation != nil &amp;&amp; afterSaveReportsCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.SaveReportsMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionCacheRepositoryMock.SaveReports at\n%s", m.SaveReportsMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TransactionCacheRepositoryMock.SaveReports at\n%s with params: %#v", m.SaveReportsMock.defaultExpectation.expectationOrigins.origin, *m.SaveReportsMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcSaveReports != nil &amp;&amp; afterSaveReportsCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TransactionCacheRepositoryMock.SaveReports at\n%s", m.funcSaveReportsOrigin)
        }</span>

        <span class="cov0" title="0">if !m.SaveReportsMock.invocationsDone() &amp;&amp; afterSaveReportsCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TransactionCacheRepositoryMock.SaveReports at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.SaveReportsMock.expectedInvocations), m.SaveReportsMock.expectedInvocationsOrigin, afterSaveReportsCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TransactionCacheRepositoryMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockGetReportsInspect()

                        m.MinimockSaveReportsInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TransactionCacheRepositoryMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *TransactionCacheRepositoryMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockGetReportsDone() &amp;&amp;
                m.MinimockSaveReportsDone()
}</span>
</pre>
		
		<pre class="file" id="file80" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase.TransactionCSVRepository -o transaction_csv_repository.go -n TransactionCSVRepositoryMock -p mocks

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        mm_usecase "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
)

// TransactionCSVRepositoryMock implements mm_usecase.TransactionCSVRepository
type TransactionCSVRepositoryMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcItemsFromCSV          func(ctx context.Context, data []byte, accountID uuid.UUID) (items []*entity.Transaction, err error)
        funcItemsFromCSVOrigin    string
        inspectFuncItemsFromCSV   func(ctx context.Context, data []byte, accountID uuid.UUID)
        afterItemsFromCSVCounter  uint64
        beforeItemsFromCSVCounter uint64
        ItemsFromCSVMock          mTransactionCSVRepositoryMockItemsFromCSV

        funcItemsToCSV          func(ctx context.Context, items []*mm_usecase.TransactionDTO) (ba1 []byte, err error)
        funcItemsToCSVOrigin    string
        inspectFuncItemsToCSV   func(ctx context.Context, items []*mm_usecase.TransactionDTO)
        afterItemsToCSVCounter  uint64
        beforeItemsToCSVCounter uint64
        ItemsToCSVMock          mTransactionCSVRepositoryMockItemsToCSV
}

// NewTransactionCSVRepositoryMock returns a mock for mm_usecase.TransactionCSVRepository
func NewTransactionCSVRepositoryMock(t minimock.Tester) *TransactionCSVRepositoryMock <span class="cov0" title="0">{
        m := &amp;TransactionCSVRepositoryMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.ItemsFromCSVMock = mTransactionCSVRepositoryMockItemsFromCSV{mock: m}
        m.ItemsFromCSVMock.callArgs = []*TransactionCSVRepositoryMockItemsFromCSVParams{}

        m.ItemsToCSVMock = mTransactionCSVRepositoryMockItemsToCSV{mock: m}
        m.ItemsToCSVMock.callArgs = []*TransactionCSVRepositoryMockItemsToCSVParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mTransactionCSVRepositoryMockItemsFromCSV struct {
        optional           bool
        mock               *TransactionCSVRepositoryMock
        defaultExpectation *TransactionCSVRepositoryMockItemsFromCSVExpectation
        expectations       []*TransactionCSVRepositoryMockItemsFromCSVExpectation

        callArgs []*TransactionCSVRepositoryMockItemsFromCSVParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TransactionCSVRepositoryMockItemsFromCSVExpectation specifies expectation struct of the TransactionCSVRepository.ItemsFromCSV
type TransactionCSVRepositoryMockItemsFromCSVExpectation struct {
        mock               *TransactionCSVRepositoryMock
        params             *TransactionCSVRepositoryMockItemsFromCSVParams
        paramPtrs          *TransactionCSVRepositoryMockItemsFromCSVParamPtrs
        expectationOrigins TransactionCSVRepositoryMockItemsFromCSVExpectationOrigins
        results            *TransactionCSVRepositoryMockItemsFromCSVResults
        returnOrigin       string
        Counter            uint64
}

// TransactionCSVRepositoryMockItemsFromCSVParams contains parameters of the TransactionCSVRepository.ItemsFromCSV
type TransactionCSVRepositoryMockItemsFromCSVParams struct {
        ctx       context.Context
        data      []byte
        accountID uuid.UUID
}

// TransactionCSVRepositoryMockItemsFromCSVParamPtrs contains pointers to parameters of the TransactionCSVRepository.ItemsFromCSV
type TransactionCSVRepositoryMockItemsFromCSVParamPtrs struct {
        ctx       *context.Context
        data      *[]byte
        accountID *uuid.UUID
}

// TransactionCSVRepositoryMockItemsFromCSVResults contains results of the TransactionCSVRepository.ItemsFromCSV
type TransactionCSVRepositoryMockItemsFromCSVResults struct {
        items []*entity.Transaction
        err   error
}

// TransactionCSVRepositoryMockItemsFromCSVOrigins contains origins of expectations of the TransactionCSVRepository.ItemsFromCSV
type TransactionCSVRepositoryMockItemsFromCSVExpectationOrigins struct {
        origin          string
        originCtx       string
        originData      string
        originAccountID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) Optional() *mTransactionCSVRepositoryMockItemsFromCSV <span class="cov0" title="0">{
        mmItemsFromCSV.optional = true
        return mmItemsFromCSV
}</span>

// Expect sets up expected params for TransactionCSVRepository.ItemsFromCSV
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) Expect(ctx context.Context, data []byte, accountID uuid.UUID) *mTransactionCSVRepositoryMockItemsFromCSV <span class="cov0" title="0">{
        if mmItemsFromCSV.mock.funcItemsFromCSV != nil </span><span class="cov0" title="0">{
                mmItemsFromCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsFromCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmItemsFromCSV.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmItemsFromCSV.defaultExpectation = &amp;TransactionCSVRepositoryMockItemsFromCSVExpectation{}
        }</span>

        <span class="cov0" title="0">if mmItemsFromCSV.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmItemsFromCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsFromCSV mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmItemsFromCSV.defaultExpectation.params = &amp;TransactionCSVRepositoryMockItemsFromCSVParams{ctx, data, accountID}
        mmItemsFromCSV.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmItemsFromCSV.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmItemsFromCSV.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmItemsFromCSV.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmItemsFromCSV.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmItemsFromCSV</span>
}

// ExpectCtxParam1 sets up expected param ctx for TransactionCSVRepository.ItemsFromCSV
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) ExpectCtxParam1(ctx context.Context) *mTransactionCSVRepositoryMockItemsFromCSV <span class="cov0" title="0">{
        if mmItemsFromCSV.mock.funcItemsFromCSV != nil </span><span class="cov0" title="0">{
                mmItemsFromCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsFromCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmItemsFromCSV.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmItemsFromCSV.defaultExpectation = &amp;TransactionCSVRepositoryMockItemsFromCSVExpectation{}
        }</span>

        <span class="cov0" title="0">if mmItemsFromCSV.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmItemsFromCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsFromCSV mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmItemsFromCSV.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmItemsFromCSV.defaultExpectation.paramPtrs = &amp;TransactionCSVRepositoryMockItemsFromCSVParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmItemsFromCSV.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmItemsFromCSV.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmItemsFromCSV</span>
}

// ExpectDataParam2 sets up expected param data for TransactionCSVRepository.ItemsFromCSV
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) ExpectDataParam2(data []byte) *mTransactionCSVRepositoryMockItemsFromCSV <span class="cov0" title="0">{
        if mmItemsFromCSV.mock.funcItemsFromCSV != nil </span><span class="cov0" title="0">{
                mmItemsFromCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsFromCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmItemsFromCSV.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmItemsFromCSV.defaultExpectation = &amp;TransactionCSVRepositoryMockItemsFromCSVExpectation{}
        }</span>

        <span class="cov0" title="0">if mmItemsFromCSV.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmItemsFromCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsFromCSV mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmItemsFromCSV.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmItemsFromCSV.defaultExpectation.paramPtrs = &amp;TransactionCSVRepositoryMockItemsFromCSVParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmItemsFromCSV.defaultExpectation.paramPtrs.data = &amp;data
        mmItemsFromCSV.defaultExpectation.expectationOrigins.originData = minimock.CallerInfo(1)

        return mmItemsFromCSV</span>
}

// ExpectAccountIDParam3 sets up expected param accountID for TransactionCSVRepository.ItemsFromCSV
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) ExpectAccountIDParam3(accountID uuid.UUID) *mTransactionCSVRepositoryMockItemsFromCSV <span class="cov0" title="0">{
        if mmItemsFromCSV.mock.funcItemsFromCSV != nil </span><span class="cov0" title="0">{
                mmItemsFromCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsFromCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmItemsFromCSV.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmItemsFromCSV.defaultExpectation = &amp;TransactionCSVRepositoryMockItemsFromCSVExpectation{}
        }</span>

        <span class="cov0" title="0">if mmItemsFromCSV.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmItemsFromCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsFromCSV mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmItemsFromCSV.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmItemsFromCSV.defaultExpectation.paramPtrs = &amp;TransactionCSVRepositoryMockItemsFromCSVParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmItemsFromCSV.defaultExpectation.paramPtrs.accountID = &amp;accountID
        mmItemsFromCSV.defaultExpectation.expectationOrigins.originAccountID = minimock.CallerInfo(1)

        return mmItemsFromCSV</span>
}

// Inspect accepts an inspector function that has same arguments as the TransactionCSVRepository.ItemsFromCSV
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) Inspect(f func(ctx context.Context, data []byte, accountID uuid.UUID)) *mTransactionCSVRepositoryMockItemsFromCSV <span class="cov0" title="0">{
        if mmItemsFromCSV.mock.inspectFuncItemsFromCSV != nil </span><span class="cov0" title="0">{
                mmItemsFromCSV.mock.t.Fatalf("Inspect function is already set for TransactionCSVRepositoryMock.ItemsFromCSV")
        }</span>

        <span class="cov0" title="0">mmItemsFromCSV.mock.inspectFuncItemsFromCSV = f

        return mmItemsFromCSV</span>
}

// Return sets up results that will be returned by TransactionCSVRepository.ItemsFromCSV
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) Return(items []*entity.Transaction, err error) *TransactionCSVRepositoryMock <span class="cov0" title="0">{
        if mmItemsFromCSV.mock.funcItemsFromCSV != nil </span><span class="cov0" title="0">{
                mmItemsFromCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsFromCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmItemsFromCSV.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmItemsFromCSV.defaultExpectation = &amp;TransactionCSVRepositoryMockItemsFromCSVExpectation{mock: mmItemsFromCSV.mock}
        }</span>
        <span class="cov0" title="0">mmItemsFromCSV.defaultExpectation.results = &amp;TransactionCSVRepositoryMockItemsFromCSVResults{items, err}
        mmItemsFromCSV.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmItemsFromCSV.mock</span>
}

// Set uses given function f to mock the TransactionCSVRepository.ItemsFromCSV method
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) Set(f func(ctx context.Context, data []byte, accountID uuid.UUID) (items []*entity.Transaction, err error)) *TransactionCSVRepositoryMock <span class="cov0" title="0">{
        if mmItemsFromCSV.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmItemsFromCSV.mock.t.Fatalf("Default expectation is already set for the TransactionCSVRepository.ItemsFromCSV method")
        }</span>

        <span class="cov0" title="0">if len(mmItemsFromCSV.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmItemsFromCSV.mock.t.Fatalf("Some expectations are already set for the TransactionCSVRepository.ItemsFromCSV method")
        }</span>

        <span class="cov0" title="0">mmItemsFromCSV.mock.funcItemsFromCSV = f
        mmItemsFromCSV.mock.funcItemsFromCSVOrigin = minimock.CallerInfo(1)
        return mmItemsFromCSV.mock</span>
}

// When sets expectation for the TransactionCSVRepository.ItemsFromCSV which will trigger the result defined by the following
// Then helper
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) When(ctx context.Context, data []byte, accountID uuid.UUID) *TransactionCSVRepositoryMockItemsFromCSVExpectation <span class="cov0" title="0">{
        if mmItemsFromCSV.mock.funcItemsFromCSV != nil </span><span class="cov0" title="0">{
                mmItemsFromCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsFromCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TransactionCSVRepositoryMockItemsFromCSVExpectation{
                mock:               mmItemsFromCSV.mock,
                params:             &amp;TransactionCSVRepositoryMockItemsFromCSVParams{ctx, data, accountID},
                expectationOrigins: TransactionCSVRepositoryMockItemsFromCSVExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmItemsFromCSV.expectations = append(mmItemsFromCSV.expectations, expectation)
        return expectation</span>
}

// Then sets up TransactionCSVRepository.ItemsFromCSV return parameters for the expectation previously defined by the When method
func (e *TransactionCSVRepositoryMockItemsFromCSVExpectation) Then(items []*entity.Transaction, err error) *TransactionCSVRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;TransactionCSVRepositoryMockItemsFromCSVResults{items, err}
        return e.mock
}</span>

// Times sets number of times TransactionCSVRepository.ItemsFromCSV should be invoked
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) Times(n uint64) *mTransactionCSVRepositoryMockItemsFromCSV <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmItemsFromCSV.mock.t.Fatalf("Times of TransactionCSVRepositoryMock.ItemsFromCSV mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmItemsFromCSV.expectedInvocations, n)
        mmItemsFromCSV.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmItemsFromCSV</span>
}

func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmItemsFromCSV.expectations) == 0 &amp;&amp; mmItemsFromCSV.defaultExpectation == nil &amp;&amp; mmItemsFromCSV.mock.funcItemsFromCSV == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmItemsFromCSV.mock.afterItemsFromCSVCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmItemsFromCSV.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// ItemsFromCSV implements mm_usecase.TransactionCSVRepository
func (mmItemsFromCSV *TransactionCSVRepositoryMock) ItemsFromCSV(ctx context.Context, data []byte, accountID uuid.UUID) (items []*entity.Transaction, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmItemsFromCSV.beforeItemsFromCSVCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmItemsFromCSV.afterItemsFromCSVCounter, 1)

        mmItemsFromCSV.t.Helper()

        if mmItemsFromCSV.inspectFuncItemsFromCSV != nil </span><span class="cov0" title="0">{
                mmItemsFromCSV.inspectFuncItemsFromCSV(ctx, data, accountID)
        }</span>

        <span class="cov0" title="0">mm_params := TransactionCSVRepositoryMockItemsFromCSVParams{ctx, data, accountID}

        // Record call args
        mmItemsFromCSV.ItemsFromCSVMock.mutex.Lock()
        mmItemsFromCSV.ItemsFromCSVMock.callArgs = append(mmItemsFromCSV.ItemsFromCSVMock.callArgs, &amp;mm_params)
        mmItemsFromCSV.ItemsFromCSVMock.mutex.Unlock()

        for _, e := range mmItemsFromCSV.ItemsFromCSVMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.items, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmItemsFromCSV.ItemsFromCSVMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmItemsFromCSV.ItemsFromCSVMock.defaultExpectation.Counter, 1)
                mm_want := mmItemsFromCSV.ItemsFromCSVMock.defaultExpectation.params
                mm_want_ptrs := mmItemsFromCSV.ItemsFromCSVMock.defaultExpectation.paramPtrs

                mm_got := TransactionCSVRepositoryMockItemsFromCSVParams{ctx, data, accountID}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmItemsFromCSV.t.Errorf("TransactionCSVRepositoryMock.ItemsFromCSV got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmItemsFromCSV.ItemsFromCSVMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.data != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.data, mm_got.data) </span><span class="cov0" title="0">{
                                mmItemsFromCSV.t.Errorf("TransactionCSVRepositoryMock.ItemsFromCSV got unexpected parameter data, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmItemsFromCSV.ItemsFromCSVMock.defaultExpectation.expectationOrigins.originData, *mm_want_ptrs.data, mm_got.data, minimock.Diff(*mm_want_ptrs.data, mm_got.data))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.accountID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.accountID, mm_got.accountID) </span><span class="cov0" title="0">{
                                mmItemsFromCSV.t.Errorf("TransactionCSVRepositoryMock.ItemsFromCSV got unexpected parameter accountID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmItemsFromCSV.ItemsFromCSVMock.defaultExpectation.expectationOrigins.originAccountID, *mm_want_ptrs.accountID, mm_got.accountID, minimock.Diff(*mm_want_ptrs.accountID, mm_got.accountID))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmItemsFromCSV.t.Errorf("TransactionCSVRepositoryMock.ItemsFromCSV got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmItemsFromCSV.ItemsFromCSVMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmItemsFromCSV.ItemsFromCSVMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmItemsFromCSV.t.Fatal("No results are set for the TransactionCSVRepositoryMock.ItemsFromCSV")
                }</span>
                <span class="cov0" title="0">return (*mm_results).items, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmItemsFromCSV.funcItemsFromCSV != nil </span><span class="cov0" title="0">{
                return mmItemsFromCSV.funcItemsFromCSV(ctx, data, accountID)
        }</span>
        <span class="cov0" title="0">mmItemsFromCSV.t.Fatalf("Unexpected call to TransactionCSVRepositoryMock.ItemsFromCSV. %v %v %v", ctx, data, accountID)
        return</span>
}

// ItemsFromCSVAfterCounter returns a count of finished TransactionCSVRepositoryMock.ItemsFromCSV invocations
func (mmItemsFromCSV *TransactionCSVRepositoryMock) ItemsFromCSVAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmItemsFromCSV.afterItemsFromCSVCounter)
}</span>

// ItemsFromCSVBeforeCounter returns a count of TransactionCSVRepositoryMock.ItemsFromCSV invocations
func (mmItemsFromCSV *TransactionCSVRepositoryMock) ItemsFromCSVBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmItemsFromCSV.beforeItemsFromCSVCounter)
}</span>

// Calls returns a list of arguments used in each call to TransactionCSVRepositoryMock.ItemsFromCSV.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmItemsFromCSV *mTransactionCSVRepositoryMockItemsFromCSV) Calls() []*TransactionCSVRepositoryMockItemsFromCSVParams <span class="cov0" title="0">{
        mmItemsFromCSV.mutex.RLock()

        argCopy := make([]*TransactionCSVRepositoryMockItemsFromCSVParams, len(mmItemsFromCSV.callArgs))
        copy(argCopy, mmItemsFromCSV.callArgs)

        mmItemsFromCSV.mutex.RUnlock()

        return argCopy
}</span>

// MinimockItemsFromCSVDone returns true if the count of the ItemsFromCSV invocations corresponds
// the number of defined expectations
func (m *TransactionCSVRepositoryMock) MinimockItemsFromCSVDone() bool <span class="cov0" title="0">{
        if m.ItemsFromCSVMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.ItemsFromCSVMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.ItemsFromCSVMock.invocationsDone()</span>
}

// MinimockItemsFromCSVInspect logs each unmet expectation
func (m *TransactionCSVRepositoryMock) MinimockItemsFromCSVInspect() <span class="cov0" title="0">{
        for _, e := range m.ItemsFromCSVMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionCSVRepositoryMock.ItemsFromCSV at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterItemsFromCSVCounter := mm_atomic.LoadUint64(&amp;m.afterItemsFromCSVCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.ItemsFromCSVMock.defaultExpectation != nil &amp;&amp; afterItemsFromCSVCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.ItemsFromCSVMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionCSVRepositoryMock.ItemsFromCSV at\n%s", m.ItemsFromCSVMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TransactionCSVRepositoryMock.ItemsFromCSV at\n%s with params: %#v", m.ItemsFromCSVMock.defaultExpectation.expectationOrigins.origin, *m.ItemsFromCSVMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcItemsFromCSV != nil &amp;&amp; afterItemsFromCSVCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TransactionCSVRepositoryMock.ItemsFromCSV at\n%s", m.funcItemsFromCSVOrigin)
        }</span>

        <span class="cov0" title="0">if !m.ItemsFromCSVMock.invocationsDone() &amp;&amp; afterItemsFromCSVCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TransactionCSVRepositoryMock.ItemsFromCSV at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.ItemsFromCSVMock.expectedInvocations), m.ItemsFromCSVMock.expectedInvocationsOrigin, afterItemsFromCSVCounter)
        }</span>
}

type mTransactionCSVRepositoryMockItemsToCSV struct {
        optional           bool
        mock               *TransactionCSVRepositoryMock
        defaultExpectation *TransactionCSVRepositoryMockItemsToCSVExpectation
        expectations       []*TransactionCSVRepositoryMockItemsToCSVExpectation

        callArgs []*TransactionCSVRepositoryMockItemsToCSVParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TransactionCSVRepositoryMockItemsToCSVExpectation specifies expectation struct of the TransactionCSVRepository.ItemsToCSV
type TransactionCSVRepositoryMockItemsToCSVExpectation struct {
        mock               *TransactionCSVRepositoryMock
        params             *TransactionCSVRepositoryMockItemsToCSVParams
        paramPtrs          *TransactionCSVRepositoryMockItemsToCSVParamPtrs
        expectationOrigins TransactionCSVRepositoryMockItemsToCSVExpectationOrigins
        results            *TransactionCSVRepositoryMockItemsToCSVResults
        returnOrigin       string
        Counter            uint64
}

// TransactionCSVRepositoryMockItemsToCSVParams contains parameters of the TransactionCSVRepository.ItemsToCSV
type TransactionCSVRepositoryMockItemsToCSVParams struct {
        ctx   context.Context
        items []*mm_usecase.TransactionDTO
}

// TransactionCSVRepositoryMockItemsToCSVParamPtrs contains pointers to parameters of the TransactionCSVRepository.ItemsToCSV
type TransactionCSVRepositoryMockItemsToCSVParamPtrs struct {
        ctx   *context.Context
        items *[]*mm_usecase.TransactionDTO
}

// TransactionCSVRepositoryMockItemsToCSVResults contains results of the TransactionCSVRepository.ItemsToCSV
type TransactionCSVRepositoryMockItemsToCSVResults struct {
        ba1 []byte
        err error
}

// TransactionCSVRepositoryMockItemsToCSVOrigins contains origins of expectations of the TransactionCSVRepository.ItemsToCSV
type TransactionCSVRepositoryMockItemsToCSVExpectationOrigins struct {
        origin      string
        originCtx   string
        originItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) Optional() *mTransactionCSVRepositoryMockItemsToCSV <span class="cov0" title="0">{
        mmItemsToCSV.optional = true
        return mmItemsToCSV
}</span>

// Expect sets up expected params for TransactionCSVRepository.ItemsToCSV
func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) Expect(ctx context.Context, items []*mm_usecase.TransactionDTO) *mTransactionCSVRepositoryMockItemsToCSV <span class="cov0" title="0">{
        if mmItemsToCSV.mock.funcItemsToCSV != nil </span><span class="cov0" title="0">{
                mmItemsToCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsToCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmItemsToCSV.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmItemsToCSV.defaultExpectation = &amp;TransactionCSVRepositoryMockItemsToCSVExpectation{}
        }</span>

        <span class="cov0" title="0">if mmItemsToCSV.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmItemsToCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsToCSV mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmItemsToCSV.defaultExpectation.params = &amp;TransactionCSVRepositoryMockItemsToCSVParams{ctx, items}
        mmItemsToCSV.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmItemsToCSV.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmItemsToCSV.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmItemsToCSV.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmItemsToCSV.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmItemsToCSV</span>
}

// ExpectCtxParam1 sets up expected param ctx for TransactionCSVRepository.ItemsToCSV
func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) ExpectCtxParam1(ctx context.Context) *mTransactionCSVRepositoryMockItemsToCSV <span class="cov0" title="0">{
        if mmItemsToCSV.mock.funcItemsToCSV != nil </span><span class="cov0" title="0">{
                mmItemsToCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsToCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmItemsToCSV.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmItemsToCSV.defaultExpectation = &amp;TransactionCSVRepositoryMockItemsToCSVExpectation{}
        }</span>

        <span class="cov0" title="0">if mmItemsToCSV.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmItemsToCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsToCSV mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmItemsToCSV.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmItemsToCSV.defaultExpectation.paramPtrs = &amp;TransactionCSVRepositoryMockItemsToCSVParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmItemsToCSV.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmItemsToCSV.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmItemsToCSV</span>
}

// ExpectItemsParam2 sets up expected param items for TransactionCSVRepository.ItemsToCSV
func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) ExpectItemsParam2(items []*mm_usecase.TransactionDTO) *mTransactionCSVRepositoryMockItemsToCSV <span class="cov0" title="0">{
        if mmItemsToCSV.mock.funcItemsToCSV != nil </span><span class="cov0" title="0">{
                mmItemsToCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsToCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmItemsToCSV.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmItemsToCSV.defaultExpectation = &amp;TransactionCSVRepositoryMockItemsToCSVExpectation{}
        }</span>

        <span class="cov0" title="0">if mmItemsToCSV.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmItemsToCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsToCSV mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmItemsToCSV.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmItemsToCSV.defaultExpectation.paramPtrs = &amp;TransactionCSVRepositoryMockItemsToCSVParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmItemsToCSV.defaultExpectation.paramPtrs.items = &amp;items
        mmItemsToCSV.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

        return mmItemsToCSV</span>
}

// Inspect accepts an inspector function that has same arguments as the TransactionCSVRepository.ItemsToCSV
func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) Inspect(f func(ctx context.Context, items []*mm_usecase.TransactionDTO)) *mTransactionCSVRepositoryMockItemsToCSV <span class="cov0" title="0">{
        if mmItemsToCSV.mock.inspectFuncItemsToCSV != nil </span><span class="cov0" title="0">{
                mmItemsToCSV.mock.t.Fatalf("Inspect function is already set for TransactionCSVRepositoryMock.ItemsToCSV")
        }</span>

        <span class="cov0" title="0">mmItemsToCSV.mock.inspectFuncItemsToCSV = f

        return mmItemsToCSV</span>
}

// Return sets up results that will be returned by TransactionCSVRepository.ItemsToCSV
func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) Return(ba1 []byte, err error) *TransactionCSVRepositoryMock <span class="cov0" title="0">{
        if mmItemsToCSV.mock.funcItemsToCSV != nil </span><span class="cov0" title="0">{
                mmItemsToCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsToCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmItemsToCSV.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmItemsToCSV.defaultExpectation = &amp;TransactionCSVRepositoryMockItemsToCSVExpectation{mock: mmItemsToCSV.mock}
        }</span>
        <span class="cov0" title="0">mmItemsToCSV.defaultExpectation.results = &amp;TransactionCSVRepositoryMockItemsToCSVResults{ba1, err}
        mmItemsToCSV.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmItemsToCSV.mock</span>
}

// Set uses given function f to mock the TransactionCSVRepository.ItemsToCSV method
func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) Set(f func(ctx context.Context, items []*mm_usecase.TransactionDTO) (ba1 []byte, err error)) *TransactionCSVRepositoryMock <span class="cov0" title="0">{
        if mmItemsToCSV.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmItemsToCSV.mock.t.Fatalf("Default expectation is already set for the TransactionCSVRepository.ItemsToCSV method")
        }</span>

        <span class="cov0" title="0">if len(mmItemsToCSV.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmItemsToCSV.mock.t.Fatalf("Some expectations are already set for the TransactionCSVRepository.ItemsToCSV method")
        }</span>

        <span class="cov0" title="0">mmItemsToCSV.mock.funcItemsToCSV = f
        mmItemsToCSV.mock.funcItemsToCSVOrigin = minimock.CallerInfo(1)
        return mmItemsToCSV.mock</span>
}

// When sets expectation for the TransactionCSVRepository.ItemsToCSV which will trigger the result defined by the following
// Then helper
func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) When(ctx context.Context, items []*mm_usecase.TransactionDTO) *TransactionCSVRepositoryMockItemsToCSVExpectation <span class="cov0" title="0">{
        if mmItemsToCSV.mock.funcItemsToCSV != nil </span><span class="cov0" title="0">{
                mmItemsToCSV.mock.t.Fatalf("TransactionCSVRepositoryMock.ItemsToCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TransactionCSVRepositoryMockItemsToCSVExpectation{
                mock:               mmItemsToCSV.mock,
                params:             &amp;TransactionCSVRepositoryMockItemsToCSVParams{ctx, items},
                expectationOrigins: TransactionCSVRepositoryMockItemsToCSVExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmItemsToCSV.expectations = append(mmItemsToCSV.expectations, expectation)
        return expectation</span>
}

// Then sets up TransactionCSVRepository.ItemsToCSV return parameters for the expectation previously defined by the When method
func (e *TransactionCSVRepositoryMockItemsToCSVExpectation) Then(ba1 []byte, err error) *TransactionCSVRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;TransactionCSVRepositoryMockItemsToCSVResults{ba1, err}
        return e.mock
}</span>

// Times sets number of times TransactionCSVRepository.ItemsToCSV should be invoked
func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) Times(n uint64) *mTransactionCSVRepositoryMockItemsToCSV <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmItemsToCSV.mock.t.Fatalf("Times of TransactionCSVRepositoryMock.ItemsToCSV mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmItemsToCSV.expectedInvocations, n)
        mmItemsToCSV.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmItemsToCSV</span>
}

func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmItemsToCSV.expectations) == 0 &amp;&amp; mmItemsToCSV.defaultExpectation == nil &amp;&amp; mmItemsToCSV.mock.funcItemsToCSV == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmItemsToCSV.mock.afterItemsToCSVCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmItemsToCSV.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// ItemsToCSV implements mm_usecase.TransactionCSVRepository
func (mmItemsToCSV *TransactionCSVRepositoryMock) ItemsToCSV(ctx context.Context, items []*mm_usecase.TransactionDTO) (ba1 []byte, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmItemsToCSV.beforeItemsToCSVCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmItemsToCSV.afterItemsToCSVCounter, 1)

        mmItemsToCSV.t.Helper()

        if mmItemsToCSV.inspectFuncItemsToCSV != nil </span><span class="cov0" title="0">{
                mmItemsToCSV.inspectFuncItemsToCSV(ctx, items)
        }</span>

        <span class="cov0" title="0">mm_params := TransactionCSVRepositoryMockItemsToCSVParams{ctx, items}

        // Record call args
        mmItemsToCSV.ItemsToCSVMock.mutex.Lock()
        mmItemsToCSV.ItemsToCSVMock.callArgs = append(mmItemsToCSV.ItemsToCSVMock.callArgs, &amp;mm_params)
        mmItemsToCSV.ItemsToCSVMock.mutex.Unlock()

        for _, e := range mmItemsToCSV.ItemsToCSVMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.ba1, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmItemsToCSV.ItemsToCSVMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmItemsToCSV.ItemsToCSVMock.defaultExpectation.Counter, 1)
                mm_want := mmItemsToCSV.ItemsToCSVMock.defaultExpectation.params
                mm_want_ptrs := mmItemsToCSV.ItemsToCSVMock.defaultExpectation.paramPtrs

                mm_got := TransactionCSVRepositoryMockItemsToCSVParams{ctx, items}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmItemsToCSV.t.Errorf("TransactionCSVRepositoryMock.ItemsToCSV got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmItemsToCSV.ItemsToCSVMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.items != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.items, mm_got.items) </span><span class="cov0" title="0">{
                                mmItemsToCSV.t.Errorf("TransactionCSVRepositoryMock.ItemsToCSV got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmItemsToCSV.ItemsToCSVMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmItemsToCSV.t.Errorf("TransactionCSVRepositoryMock.ItemsToCSV got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmItemsToCSV.ItemsToCSVMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmItemsToCSV.ItemsToCSVMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmItemsToCSV.t.Fatal("No results are set for the TransactionCSVRepositoryMock.ItemsToCSV")
                }</span>
                <span class="cov0" title="0">return (*mm_results).ba1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmItemsToCSV.funcItemsToCSV != nil </span><span class="cov0" title="0">{
                return mmItemsToCSV.funcItemsToCSV(ctx, items)
        }</span>
        <span class="cov0" title="0">mmItemsToCSV.t.Fatalf("Unexpected call to TransactionCSVRepositoryMock.ItemsToCSV. %v %v", ctx, items)
        return</span>
}

// ItemsToCSVAfterCounter returns a count of finished TransactionCSVRepositoryMock.ItemsToCSV invocations
func (mmItemsToCSV *TransactionCSVRepositoryMock) ItemsToCSVAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmItemsToCSV.afterItemsToCSVCounter)
}</span>

// ItemsToCSVBeforeCounter returns a count of TransactionCSVRepositoryMock.ItemsToCSV invocations
func (mmItemsToCSV *TransactionCSVRepositoryMock) ItemsToCSVBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmItemsToCSV.beforeItemsToCSVCounter)
}</span>

// Calls returns a list of arguments used in each call to TransactionCSVRepositoryMock.ItemsToCSV.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmItemsToCSV *mTransactionCSVRepositoryMockItemsToCSV) Calls() []*TransactionCSVRepositoryMockItemsToCSVParams <span class="cov0" title="0">{
        mmItemsToCSV.mutex.RLock()

        argCopy := make([]*TransactionCSVRepositoryMockItemsToCSVParams, len(mmItemsToCSV.callArgs))
        copy(argCopy, mmItemsToCSV.callArgs)

        mmItemsToCSV.mutex.RUnlock()

        return argCopy
}</span>

// MinimockItemsToCSVDone returns true if the count of the ItemsToCSV invocations corresponds
// the number of defined expectations
func (m *TransactionCSVRepositoryMock) MinimockItemsToCSVDone() bool <span class="cov0" title="0">{
        if m.ItemsToCSVMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.ItemsToCSVMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.ItemsToCSVMock.invocationsDone()</span>
}

// MinimockItemsToCSVInspect logs each unmet expectation
func (m *TransactionCSVRepositoryMock) MinimockItemsToCSVInspect() <span class="cov0" title="0">{
        for _, e := range m.ItemsToCSVMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionCSVRepositoryMock.ItemsToCSV at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterItemsToCSVCounter := mm_atomic.LoadUint64(&amp;m.afterItemsToCSVCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.ItemsToCSVMock.defaultExpectation != nil &amp;&amp; afterItemsToCSVCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.ItemsToCSVMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionCSVRepositoryMock.ItemsToCSV at\n%s", m.ItemsToCSVMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TransactionCSVRepositoryMock.ItemsToCSV at\n%s with params: %#v", m.ItemsToCSVMock.defaultExpectation.expectationOrigins.origin, *m.ItemsToCSVMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcItemsToCSV != nil &amp;&amp; afterItemsToCSVCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TransactionCSVRepositoryMock.ItemsToCSV at\n%s", m.funcItemsToCSVOrigin)
        }</span>

        <span class="cov0" title="0">if !m.ItemsToCSVMock.invocationsDone() &amp;&amp; afterItemsToCSVCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TransactionCSVRepositoryMock.ItemsToCSV at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.ItemsToCSVMock.expectedInvocations), m.ItemsToCSVMock.expectedInvocationsOrigin, afterItemsToCSVCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TransactionCSVRepositoryMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockItemsFromCSVInspect()

                        m.MinimockItemsToCSVInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TransactionCSVRepositoryMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *TransactionCSVRepositoryMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockItemsFromCSVDone() &amp;&amp;
                m.MinimockItemsToCSVDone()
}</span>
</pre>
		
		<pre class="file" id="file81" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase.TransactionRepository -o transaction_repository.go -n TransactionRepositoryMock -p mocks

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        mm_usecase "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
)

// TransactionRepositoryMock implements mm_usecase.TransactionRepository
type TransactionRepositoryMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcCountReportItems          func(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter) (items []*entity.AccountTransactionReportItem, err error)
        funcCountReportItemsOrigin    string
        inspectFuncCountReportItems   func(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter)
        afterCountReportItemsCounter  uint64
        beforeCountReportItemsCounter uint64
        CountReportItemsMock          mTransactionRepositoryMockCountReportItems

        funcCreate          func(ctx context.Context, item *entity.Transaction) (err error)
        funcCreateOrigin    string
        inspectFuncCreate   func(ctx context.Context, item *entity.Transaction)
        afterCreateCounter  uint64
        beforeCreateCounter uint64
        CreateMock          mTransactionRepositoryMockCreate

        funcFindList          func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Transaction, err error)
        funcFindListOrigin    string
        inspectFuncFindList   func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)
        afterFindListCounter  uint64
        beforeFindListCounter uint64
        FindListMock          mTransactionRepositoryMockFindList

        funcFindOneByID          func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (transaction *entity.Transaction, err error)
        funcFindOneByIDOrigin    string
        inspectFuncFindOneByID   func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)
        afterFindOneByIDCounter  uint64
        beforeFindOneByIDCounter uint64
        FindOneByIDMock          mTransactionRepositoryMockFindOneByID

        funcFindPagedList          func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Transaction, total uint64, err error)
        funcFindPagedListOrigin    string
        inspectFuncFindPagedList   func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)
        afterFindPagedListCounter  uint64
        beforeFindPagedListCounter uint64
        FindPagedListMock          mTransactionRepositoryMockFindPagedList

        funcUpdate          func(ctx context.Context, item *entity.Transaction) (err error)
        funcUpdateOrigin    string
        inspectFuncUpdate   func(ctx context.Context, item *entity.Transaction)
        afterUpdateCounter  uint64
        beforeUpdateCounter uint64
        UpdateMock          mTransactionRepositoryMockUpdate
}

// NewTransactionRepositoryMock returns a mock for mm_usecase.TransactionRepository
func NewTransactionRepositoryMock(t minimock.Tester) *TransactionRepositoryMock <span class="cov0" title="0">{
        m := &amp;TransactionRepositoryMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.CountReportItemsMock = mTransactionRepositoryMockCountReportItems{mock: m}
        m.CountReportItemsMock.callArgs = []*TransactionRepositoryMockCountReportItemsParams{}

        m.CreateMock = mTransactionRepositoryMockCreate{mock: m}
        m.CreateMock.callArgs = []*TransactionRepositoryMockCreateParams{}

        m.FindListMock = mTransactionRepositoryMockFindList{mock: m}
        m.FindListMock.callArgs = []*TransactionRepositoryMockFindListParams{}

        m.FindOneByIDMock = mTransactionRepositoryMockFindOneByID{mock: m}
        m.FindOneByIDMock.callArgs = []*TransactionRepositoryMockFindOneByIDParams{}

        m.FindPagedListMock = mTransactionRepositoryMockFindPagedList{mock: m}
        m.FindPagedListMock.callArgs = []*TransactionRepositoryMockFindPagedListParams{}

        m.UpdateMock = mTransactionRepositoryMockUpdate{mock: m}
        m.UpdateMock.callArgs = []*TransactionRepositoryMockUpdateParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mTransactionRepositoryMockCountReportItems struct {
        optional           bool
        mock               *TransactionRepositoryMock
        defaultExpectation *TransactionRepositoryMockCountReportItemsExpectation
        expectations       []*TransactionRepositoryMockCountReportItemsExpectation

        callArgs []*TransactionRepositoryMockCountReportItemsParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TransactionRepositoryMockCountReportItemsExpectation specifies expectation struct of the TransactionRepository.CountReportItems
type TransactionRepositoryMockCountReportItemsExpectation struct {
        mock               *TransactionRepositoryMock
        params             *TransactionRepositoryMockCountReportItemsParams
        paramPtrs          *TransactionRepositoryMockCountReportItemsParamPtrs
        expectationOrigins TransactionRepositoryMockCountReportItemsExpectationOrigins
        results            *TransactionRepositoryMockCountReportItemsResults
        returnOrigin       string
        Counter            uint64
}

// TransactionRepositoryMockCountReportItemsParams contains parameters of the TransactionRepository.CountReportItems
type TransactionRepositoryMockCountReportItemsParams struct {
        ctx         context.Context
        queryFilter mm_usecase.CountReportItemsQueryFilter
}

// TransactionRepositoryMockCountReportItemsParamPtrs contains pointers to parameters of the TransactionRepository.CountReportItems
type TransactionRepositoryMockCountReportItemsParamPtrs struct {
        ctx         *context.Context
        queryFilter *mm_usecase.CountReportItemsQueryFilter
}

// TransactionRepositoryMockCountReportItemsResults contains results of the TransactionRepository.CountReportItems
type TransactionRepositoryMockCountReportItemsResults struct {
        items []*entity.AccountTransactionReportItem
        err   error
}

// TransactionRepositoryMockCountReportItemsOrigins contains origins of expectations of the TransactionRepository.CountReportItems
type TransactionRepositoryMockCountReportItemsExpectationOrigins struct {
        origin            string
        originCtx         string
        originQueryFilter string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) Optional() *mTransactionRepositoryMockCountReportItems <span class="cov0" title="0">{
        mmCountReportItems.optional = true
        return mmCountReportItems
}</span>

// Expect sets up expected params for TransactionRepository.CountReportItems
func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) Expect(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter) *mTransactionRepositoryMockCountReportItems <span class="cov0" title="0">{
        if mmCountReportItems.mock.funcCountReportItems != nil </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("TransactionRepositoryMock.CountReportItems mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCountReportItems.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCountReportItems.defaultExpectation = &amp;TransactionRepositoryMockCountReportItemsExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCountReportItems.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("TransactionRepositoryMock.CountReportItems mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmCountReportItems.defaultExpectation.params = &amp;TransactionRepositoryMockCountReportItemsParams{ctx, queryFilter}
        mmCountReportItems.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmCountReportItems.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmCountReportItems.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmCountReportItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCountReportItems.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmCountReportItems</span>
}

// ExpectCtxParam1 sets up expected param ctx for TransactionRepository.CountReportItems
func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) ExpectCtxParam1(ctx context.Context) *mTransactionRepositoryMockCountReportItems <span class="cov0" title="0">{
        if mmCountReportItems.mock.funcCountReportItems != nil </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("TransactionRepositoryMock.CountReportItems mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCountReportItems.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCountReportItems.defaultExpectation = &amp;TransactionRepositoryMockCountReportItemsExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCountReportItems.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("TransactionRepositoryMock.CountReportItems mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCountReportItems.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCountReportItems.defaultExpectation.paramPtrs = &amp;TransactionRepositoryMockCountReportItemsParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCountReportItems.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmCountReportItems.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmCountReportItems</span>
}

// ExpectQueryFilterParam2 sets up expected param queryFilter for TransactionRepository.CountReportItems
func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) ExpectQueryFilterParam2(queryFilter mm_usecase.CountReportItemsQueryFilter) *mTransactionRepositoryMockCountReportItems <span class="cov0" title="0">{
        if mmCountReportItems.mock.funcCountReportItems != nil </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("TransactionRepositoryMock.CountReportItems mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCountReportItems.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCountReportItems.defaultExpectation = &amp;TransactionRepositoryMockCountReportItemsExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCountReportItems.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("TransactionRepositoryMock.CountReportItems mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCountReportItems.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCountReportItems.defaultExpectation.paramPtrs = &amp;TransactionRepositoryMockCountReportItemsParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCountReportItems.defaultExpectation.paramPtrs.queryFilter = &amp;queryFilter
        mmCountReportItems.defaultExpectation.expectationOrigins.originQueryFilter = minimock.CallerInfo(1)

        return mmCountReportItems</span>
}

// Inspect accepts an inspector function that has same arguments as the TransactionRepository.CountReportItems
func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) Inspect(f func(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter)) *mTransactionRepositoryMockCountReportItems <span class="cov0" title="0">{
        if mmCountReportItems.mock.inspectFuncCountReportItems != nil </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("Inspect function is already set for TransactionRepositoryMock.CountReportItems")
        }</span>

        <span class="cov0" title="0">mmCountReportItems.mock.inspectFuncCountReportItems = f

        return mmCountReportItems</span>
}

// Return sets up results that will be returned by TransactionRepository.CountReportItems
func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) Return(items []*entity.AccountTransactionReportItem, err error) *TransactionRepositoryMock <span class="cov0" title="0">{
        if mmCountReportItems.mock.funcCountReportItems != nil </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("TransactionRepositoryMock.CountReportItems mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCountReportItems.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCountReportItems.defaultExpectation = &amp;TransactionRepositoryMockCountReportItemsExpectation{mock: mmCountReportItems.mock}
        }</span>
        <span class="cov0" title="0">mmCountReportItems.defaultExpectation.results = &amp;TransactionRepositoryMockCountReportItemsResults{items, err}
        mmCountReportItems.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmCountReportItems.mock</span>
}

// Set uses given function f to mock the TransactionRepository.CountReportItems method
func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) Set(f func(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter) (items []*entity.AccountTransactionReportItem, err error)) *TransactionRepositoryMock <span class="cov0" title="0">{
        if mmCountReportItems.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("Default expectation is already set for the TransactionRepository.CountReportItems method")
        }</span>

        <span class="cov0" title="0">if len(mmCountReportItems.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("Some expectations are already set for the TransactionRepository.CountReportItems method")
        }</span>

        <span class="cov0" title="0">mmCountReportItems.mock.funcCountReportItems = f
        mmCountReportItems.mock.funcCountReportItemsOrigin = minimock.CallerInfo(1)
        return mmCountReportItems.mock</span>
}

// When sets expectation for the TransactionRepository.CountReportItems which will trigger the result defined by the following
// Then helper
func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) When(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter) *TransactionRepositoryMockCountReportItemsExpectation <span class="cov0" title="0">{
        if mmCountReportItems.mock.funcCountReportItems != nil </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("TransactionRepositoryMock.CountReportItems mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TransactionRepositoryMockCountReportItemsExpectation{
                mock:               mmCountReportItems.mock,
                params:             &amp;TransactionRepositoryMockCountReportItemsParams{ctx, queryFilter},
                expectationOrigins: TransactionRepositoryMockCountReportItemsExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmCountReportItems.expectations = append(mmCountReportItems.expectations, expectation)
        return expectation</span>
}

// Then sets up TransactionRepository.CountReportItems return parameters for the expectation previously defined by the When method
func (e *TransactionRepositoryMockCountReportItemsExpectation) Then(items []*entity.AccountTransactionReportItem, err error) *TransactionRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;TransactionRepositoryMockCountReportItemsResults{items, err}
        return e.mock
}</span>

// Times sets number of times TransactionRepository.CountReportItems should be invoked
func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) Times(n uint64) *mTransactionRepositoryMockCountReportItems <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("Times of TransactionRepositoryMock.CountReportItems mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmCountReportItems.expectedInvocations, n)
        mmCountReportItems.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmCountReportItems</span>
}

func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmCountReportItems.expectations) == 0 &amp;&amp; mmCountReportItems.defaultExpectation == nil &amp;&amp; mmCountReportItems.mock.funcCountReportItems == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmCountReportItems.mock.afterCountReportItemsCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmCountReportItems.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// CountReportItems implements mm_usecase.TransactionRepository
func (mmCountReportItems *TransactionRepositoryMock) CountReportItems(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter) (items []*entity.AccountTransactionReportItem, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmCountReportItems.beforeCountReportItemsCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmCountReportItems.afterCountReportItemsCounter, 1)

        mmCountReportItems.t.Helper()

        if mmCountReportItems.inspectFuncCountReportItems != nil </span><span class="cov0" title="0">{
                mmCountReportItems.inspectFuncCountReportItems(ctx, queryFilter)
        }</span>

        <span class="cov0" title="0">mm_params := TransactionRepositoryMockCountReportItemsParams{ctx, queryFilter}

        // Record call args
        mmCountReportItems.CountReportItemsMock.mutex.Lock()
        mmCountReportItems.CountReportItemsMock.callArgs = append(mmCountReportItems.CountReportItemsMock.callArgs, &amp;mm_params)
        mmCountReportItems.CountReportItemsMock.mutex.Unlock()

        for _, e := range mmCountReportItems.CountReportItemsMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.items, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmCountReportItems.CountReportItemsMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmCountReportItems.CountReportItemsMock.defaultExpectation.Counter, 1)
                mm_want := mmCountReportItems.CountReportItemsMock.defaultExpectation.params
                mm_want_ptrs := mmCountReportItems.CountReportItemsMock.defaultExpectation.paramPtrs

                mm_got := TransactionRepositoryMockCountReportItemsParams{ctx, queryFilter}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmCountReportItems.t.Errorf("TransactionRepositoryMock.CountReportItems got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCountReportItems.CountReportItemsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryFilter != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryFilter, mm_got.queryFilter) </span><span class="cov0" title="0">{
                                mmCountReportItems.t.Errorf("TransactionRepositoryMock.CountReportItems got unexpected parameter queryFilter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCountReportItems.CountReportItemsMock.defaultExpectation.expectationOrigins.originQueryFilter, *mm_want_ptrs.queryFilter, mm_got.queryFilter, minimock.Diff(*mm_want_ptrs.queryFilter, mm_got.queryFilter))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmCountReportItems.t.Errorf("TransactionRepositoryMock.CountReportItems got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmCountReportItems.CountReportItemsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmCountReportItems.CountReportItemsMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmCountReportItems.t.Fatal("No results are set for the TransactionRepositoryMock.CountReportItems")
                }</span>
                <span class="cov0" title="0">return (*mm_results).items, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmCountReportItems.funcCountReportItems != nil </span><span class="cov0" title="0">{
                return mmCountReportItems.funcCountReportItems(ctx, queryFilter)
        }</span>
        <span class="cov0" title="0">mmCountReportItems.t.Fatalf("Unexpected call to TransactionRepositoryMock.CountReportItems. %v %v", ctx, queryFilter)
        return</span>
}

// CountReportItemsAfterCounter returns a count of finished TransactionRepositoryMock.CountReportItems invocations
func (mmCountReportItems *TransactionRepositoryMock) CountReportItemsAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCountReportItems.afterCountReportItemsCounter)
}</span>

// CountReportItemsBeforeCounter returns a count of TransactionRepositoryMock.CountReportItems invocations
func (mmCountReportItems *TransactionRepositoryMock) CountReportItemsBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCountReportItems.beforeCountReportItemsCounter)
}</span>

// Calls returns a list of arguments used in each call to TransactionRepositoryMock.CountReportItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCountReportItems *mTransactionRepositoryMockCountReportItems) Calls() []*TransactionRepositoryMockCountReportItemsParams <span class="cov0" title="0">{
        mmCountReportItems.mutex.RLock()

        argCopy := make([]*TransactionRepositoryMockCountReportItemsParams, len(mmCountReportItems.callArgs))
        copy(argCopy, mmCountReportItems.callArgs)

        mmCountReportItems.mutex.RUnlock()

        return argCopy
}</span>

// MinimockCountReportItemsDone returns true if the count of the CountReportItems invocations corresponds
// the number of defined expectations
func (m *TransactionRepositoryMock) MinimockCountReportItemsDone() bool <span class="cov0" title="0">{
        if m.CountReportItemsMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.CountReportItemsMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.CountReportItemsMock.invocationsDone()</span>
}

// MinimockCountReportItemsInspect logs each unmet expectation
func (m *TransactionRepositoryMock) MinimockCountReportItemsInspect() <span class="cov0" title="0">{
        for _, e := range m.CountReportItemsMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionRepositoryMock.CountReportItems at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterCountReportItemsCounter := mm_atomic.LoadUint64(&amp;m.afterCountReportItemsCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.CountReportItemsMock.defaultExpectation != nil &amp;&amp; afterCountReportItemsCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.CountReportItemsMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionRepositoryMock.CountReportItems at\n%s", m.CountReportItemsMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TransactionRepositoryMock.CountReportItems at\n%s with params: %#v", m.CountReportItemsMock.defaultExpectation.expectationOrigins.origin, *m.CountReportItemsMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcCountReportItems != nil &amp;&amp; afterCountReportItemsCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TransactionRepositoryMock.CountReportItems at\n%s", m.funcCountReportItemsOrigin)
        }</span>

        <span class="cov0" title="0">if !m.CountReportItemsMock.invocationsDone() &amp;&amp; afterCountReportItemsCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TransactionRepositoryMock.CountReportItems at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.CountReportItemsMock.expectedInvocations), m.CountReportItemsMock.expectedInvocationsOrigin, afterCountReportItemsCounter)
        }</span>
}

type mTransactionRepositoryMockCreate struct {
        optional           bool
        mock               *TransactionRepositoryMock
        defaultExpectation *TransactionRepositoryMockCreateExpectation
        expectations       []*TransactionRepositoryMockCreateExpectation

        callArgs []*TransactionRepositoryMockCreateParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TransactionRepositoryMockCreateExpectation specifies expectation struct of the TransactionRepository.Create
type TransactionRepositoryMockCreateExpectation struct {
        mock               *TransactionRepositoryMock
        params             *TransactionRepositoryMockCreateParams
        paramPtrs          *TransactionRepositoryMockCreateParamPtrs
        expectationOrigins TransactionRepositoryMockCreateExpectationOrigins
        results            *TransactionRepositoryMockCreateResults
        returnOrigin       string
        Counter            uint64
}

// TransactionRepositoryMockCreateParams contains parameters of the TransactionRepository.Create
type TransactionRepositoryMockCreateParams struct {
        ctx  context.Context
        item *entity.Transaction
}

// TransactionRepositoryMockCreateParamPtrs contains pointers to parameters of the TransactionRepository.Create
type TransactionRepositoryMockCreateParamPtrs struct {
        ctx  *context.Context
        item **entity.Transaction
}

// TransactionRepositoryMockCreateResults contains results of the TransactionRepository.Create
type TransactionRepositoryMockCreateResults struct {
        err error
}

// TransactionRepositoryMockCreateOrigins contains origins of expectations of the TransactionRepository.Create
type TransactionRepositoryMockCreateExpectationOrigins struct {
        origin     string
        originCtx  string
        originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mTransactionRepositoryMockCreate) Optional() *mTransactionRepositoryMockCreate <span class="cov0" title="0">{
        mmCreate.optional = true
        return mmCreate
}</span>

// Expect sets up expected params for TransactionRepository.Create
func (mmCreate *mTransactionRepositoryMockCreate) Expect(ctx context.Context, item *entity.Transaction) *mTransactionRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("TransactionRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;TransactionRepositoryMockCreateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("TransactionRepositoryMock.Create mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmCreate.defaultExpectation.params = &amp;TransactionRepositoryMockCreateParams{ctx, item}
        mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmCreate.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmCreate.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmCreate</span>
}

// ExpectCtxParam1 sets up expected param ctx for TransactionRepository.Create
func (mmCreate *mTransactionRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mTransactionRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("TransactionRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;TransactionRepositoryMockCreateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("TransactionRepositoryMock.Create mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation.paramPtrs = &amp;TransactionRepositoryMockCreateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreate.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmCreate</span>
}

// ExpectItemParam2 sets up expected param item for TransactionRepository.Create
func (mmCreate *mTransactionRepositoryMockCreate) ExpectItemParam2(item *entity.Transaction) *mTransactionRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("TransactionRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;TransactionRepositoryMockCreateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("TransactionRepositoryMock.Create mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation.paramPtrs = &amp;TransactionRepositoryMockCreateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreate.defaultExpectation.paramPtrs.item = &amp;item
        mmCreate.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

        return mmCreate</span>
}

// Inspect accepts an inspector function that has same arguments as the TransactionRepository.Create
func (mmCreate *mTransactionRepositoryMockCreate) Inspect(f func(ctx context.Context, item *entity.Transaction)) *mTransactionRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.inspectFuncCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Inspect function is already set for TransactionRepositoryMock.Create")
        }</span>

        <span class="cov0" title="0">mmCreate.mock.inspectFuncCreate = f

        return mmCreate</span>
}

// Return sets up results that will be returned by TransactionRepository.Create
func (mmCreate *mTransactionRepositoryMockCreate) Return(err error) *TransactionRepositoryMock <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("TransactionRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;TransactionRepositoryMockCreateExpectation{mock: mmCreate.mock}
        }</span>
        <span class="cov0" title="0">mmCreate.defaultExpectation.results = &amp;TransactionRepositoryMockCreateResults{err}
        mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmCreate.mock</span>
}

// Set uses given function f to mock the TransactionRepository.Create method
func (mmCreate *mTransactionRepositoryMockCreate) Set(f func(ctx context.Context, item *entity.Transaction) (err error)) *TransactionRepositoryMock <span class="cov0" title="0">{
        if mmCreate.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Default expectation is already set for the TransactionRepository.Create method")
        }</span>

        <span class="cov0" title="0">if len(mmCreate.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Some expectations are already set for the TransactionRepository.Create method")
        }</span>

        <span class="cov0" title="0">mmCreate.mock.funcCreate = f
        mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
        return mmCreate.mock</span>
}

// When sets expectation for the TransactionRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mTransactionRepositoryMockCreate) When(ctx context.Context, item *entity.Transaction) *TransactionRepositoryMockCreateExpectation <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("TransactionRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TransactionRepositoryMockCreateExpectation{
                mock:               mmCreate.mock,
                params:             &amp;TransactionRepositoryMockCreateParams{ctx, item},
                expectationOrigins: TransactionRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmCreate.expectations = append(mmCreate.expectations, expectation)
        return expectation</span>
}

// Then sets up TransactionRepository.Create return parameters for the expectation previously defined by the When method
func (e *TransactionRepositoryMockCreateExpectation) Then(err error) *TransactionRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;TransactionRepositoryMockCreateResults{err}
        return e.mock
}</span>

// Times sets number of times TransactionRepository.Create should be invoked
func (mmCreate *mTransactionRepositoryMockCreate) Times(n uint64) *mTransactionRepositoryMockCreate <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Times of TransactionRepositoryMock.Create mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmCreate.expectedInvocations, n)
        mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmCreate</span>
}

func (mmCreate *mTransactionRepositoryMockCreate) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmCreate.expectations) == 0 &amp;&amp; mmCreate.defaultExpectation == nil &amp;&amp; mmCreate.mock.funcCreate == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmCreate.mock.afterCreateCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmCreate.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Create implements mm_usecase.TransactionRepository
func (mmCreate *TransactionRepositoryMock) Create(ctx context.Context, item *entity.Transaction) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmCreate.beforeCreateCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmCreate.afterCreateCounter, 1)

        mmCreate.t.Helper()

        if mmCreate.inspectFuncCreate != nil </span><span class="cov0" title="0">{
                mmCreate.inspectFuncCreate(ctx, item)
        }</span>

        <span class="cov0" title="0">mm_params := TransactionRepositoryMockCreateParams{ctx, item}

        // Record call args
        mmCreate.CreateMock.mutex.Lock()
        mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &amp;mm_params)
        mmCreate.CreateMock.mutex.Unlock()

        for _, e := range mmCreate.CreateMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmCreate.CreateMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmCreate.CreateMock.defaultExpectation.Counter, 1)
                mm_want := mmCreate.CreateMock.defaultExpectation.params
                mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

                mm_got := TransactionRepositoryMockCreateParams{ctx, item}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmCreate.t.Errorf("TransactionRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.item != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.item, mm_got.item) </span><span class="cov0" title="0">{
                                mmCreate.t.Errorf("TransactionRepositoryMock.Create got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCreate.CreateMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmCreate.t.Errorf("TransactionRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmCreate.CreateMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmCreate.t.Fatal("No results are set for the TransactionRepositoryMock.Create")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmCreate.funcCreate != nil </span><span class="cov0" title="0">{
                return mmCreate.funcCreate(ctx, item)
        }</span>
        <span class="cov0" title="0">mmCreate.t.Fatalf("Unexpected call to TransactionRepositoryMock.Create. %v %v", ctx, item)
        return</span>
}

// CreateAfterCounter returns a count of finished TransactionRepositoryMock.Create invocations
func (mmCreate *TransactionRepositoryMock) CreateAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreate.afterCreateCounter)
}</span>

// CreateBeforeCounter returns a count of TransactionRepositoryMock.Create invocations
func (mmCreate *TransactionRepositoryMock) CreateBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreate.beforeCreateCounter)
}</span>

// Calls returns a list of arguments used in each call to TransactionRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mTransactionRepositoryMockCreate) Calls() []*TransactionRepositoryMockCreateParams <span class="cov0" title="0">{
        mmCreate.mutex.RLock()

        argCopy := make([]*TransactionRepositoryMockCreateParams, len(mmCreate.callArgs))
        copy(argCopy, mmCreate.callArgs)

        mmCreate.mutex.RUnlock()

        return argCopy
}</span>

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *TransactionRepositoryMock) MinimockCreateDone() bool <span class="cov0" title="0">{
        if m.CreateMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.CreateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.CreateMock.invocationsDone()</span>
}

// MinimockCreateInspect logs each unmet expectation
func (m *TransactionRepositoryMock) MinimockCreateInspect() <span class="cov0" title="0">{
        for _, e := range m.CreateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterCreateCounter := mm_atomic.LoadUint64(&amp;m.afterCreateCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.CreateMock.defaultExpectation != nil &amp;&amp; afterCreateCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.CreateMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TransactionRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcCreate != nil &amp;&amp; afterCreateCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TransactionRepositoryMock.Create at\n%s", m.funcCreateOrigin)
        }</span>

        <span class="cov0" title="0">if !m.CreateMock.invocationsDone() &amp;&amp; afterCreateCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TransactionRepositoryMock.Create at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
        }</span>
}

type mTransactionRepositoryMockFindList struct {
        optional           bool
        mock               *TransactionRepositoryMock
        defaultExpectation *TransactionRepositoryMockFindListExpectation
        expectations       []*TransactionRepositoryMockFindListExpectation

        callArgs []*TransactionRepositoryMockFindListParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TransactionRepositoryMockFindListExpectation specifies expectation struct of the TransactionRepository.FindList
type TransactionRepositoryMockFindListExpectation struct {
        mock               *TransactionRepositoryMock
        params             *TransactionRepositoryMockFindListParams
        paramPtrs          *TransactionRepositoryMockFindListParamPtrs
        expectationOrigins TransactionRepositoryMockFindListExpectationOrigins
        results            *TransactionRepositoryMockFindListResults
        returnOrigin       string
        Counter            uint64
}

// TransactionRepositoryMockFindListParams contains parameters of the TransactionRepository.FindList
type TransactionRepositoryMockFindListParams struct {
        ctx         context.Context
        listOptions *mm_usecase.TransactionListOptions
        queryParams *uctypes.QueryGetListParams
}

// TransactionRepositoryMockFindListParamPtrs contains pointers to parameters of the TransactionRepository.FindList
type TransactionRepositoryMockFindListParamPtrs struct {
        ctx         *context.Context
        listOptions **mm_usecase.TransactionListOptions
        queryParams **uctypes.QueryGetListParams
}

// TransactionRepositoryMockFindListResults contains results of the TransactionRepository.FindList
type TransactionRepositoryMockFindListResults struct {
        items []*entity.Transaction
        err   error
}

// TransactionRepositoryMockFindListOrigins contains origins of expectations of the TransactionRepository.FindList
type TransactionRepositoryMockFindListExpectationOrigins struct {
        origin            string
        originCtx         string
        originListOptions string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindList *mTransactionRepositoryMockFindList) Optional() *mTransactionRepositoryMockFindList <span class="cov0" title="0">{
        mmFindList.optional = true
        return mmFindList
}</span>

// Expect sets up expected params for TransactionRepository.FindList
func (mmFindList *mTransactionRepositoryMockFindList) Expect(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *mTransactionRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("TransactionRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;TransactionRepositoryMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("TransactionRepositoryMock.FindList mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindList.defaultExpectation.params = &amp;TransactionRepositoryMockFindListParams{ctx, listOptions, queryParams}
        mmFindList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindList.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindList.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindList.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindList</span>
}

// ExpectCtxParam1 sets up expected param ctx for TransactionRepository.FindList
func (mmFindList *mTransactionRepositoryMockFindList) ExpectCtxParam1(ctx context.Context) *mTransactionRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("TransactionRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;TransactionRepositoryMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("TransactionRepositoryMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;TransactionRepositoryMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindList</span>
}

// ExpectListOptionsParam2 sets up expected param listOptions for TransactionRepository.FindList
func (mmFindList *mTransactionRepositoryMockFindList) ExpectListOptionsParam2(listOptions *mm_usecase.TransactionListOptions) *mTransactionRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("TransactionRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;TransactionRepositoryMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("TransactionRepositoryMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;TransactionRepositoryMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.listOptions = &amp;listOptions
        mmFindList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

        return mmFindList</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for TransactionRepository.FindList
func (mmFindList *mTransactionRepositoryMockFindList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mTransactionRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("TransactionRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;TransactionRepositoryMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("TransactionRepositoryMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;TransactionRepositoryMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindList</span>
}

// Inspect accepts an inspector function that has same arguments as the TransactionRepository.FindList
func (mmFindList *mTransactionRepositoryMockFindList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)) *mTransactionRepositoryMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.inspectFuncFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Inspect function is already set for TransactionRepositoryMock.FindList")
        }</span>

        <span class="cov0" title="0">mmFindList.mock.inspectFuncFindList = f

        return mmFindList</span>
}

// Return sets up results that will be returned by TransactionRepository.FindList
func (mmFindList *mTransactionRepositoryMockFindList) Return(items []*entity.Transaction, err error) *TransactionRepositoryMock <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("TransactionRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;TransactionRepositoryMockFindListExpectation{mock: mmFindList.mock}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.results = &amp;TransactionRepositoryMockFindListResults{items, err}
        mmFindList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindList.mock</span>
}

// Set uses given function f to mock the TransactionRepository.FindList method
func (mmFindList *mTransactionRepositoryMockFindList) Set(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Transaction, err error)) *TransactionRepositoryMock <span class="cov0" title="0">{
        if mmFindList.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Default expectation is already set for the TransactionRepository.FindList method")
        }</span>

        <span class="cov0" title="0">if len(mmFindList.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Some expectations are already set for the TransactionRepository.FindList method")
        }</span>

        <span class="cov0" title="0">mmFindList.mock.funcFindList = f
        mmFindList.mock.funcFindListOrigin = minimock.CallerInfo(1)
        return mmFindList.mock</span>
}

// When sets expectation for the TransactionRepository.FindList which will trigger the result defined by the following
// Then helper
func (mmFindList *mTransactionRepositoryMockFindList) When(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *TransactionRepositoryMockFindListExpectation <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("TransactionRepositoryMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TransactionRepositoryMockFindListExpectation{
                mock:               mmFindList.mock,
                params:             &amp;TransactionRepositoryMockFindListParams{ctx, listOptions, queryParams},
                expectationOrigins: TransactionRepositoryMockFindListExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindList.expectations = append(mmFindList.expectations, expectation)
        return expectation</span>
}

// Then sets up TransactionRepository.FindList return parameters for the expectation previously defined by the When method
func (e *TransactionRepositoryMockFindListExpectation) Then(items []*entity.Transaction, err error) *TransactionRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;TransactionRepositoryMockFindListResults{items, err}
        return e.mock
}</span>

// Times sets number of times TransactionRepository.FindList should be invoked
func (mmFindList *mTransactionRepositoryMockFindList) Times(n uint64) *mTransactionRepositoryMockFindList <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Times of TransactionRepositoryMock.FindList mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindList.expectedInvocations, n)
        mmFindList.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindList</span>
}

func (mmFindList *mTransactionRepositoryMockFindList) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindList.expectations) == 0 &amp;&amp; mmFindList.defaultExpectation == nil &amp;&amp; mmFindList.mock.funcFindList == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindList.mock.afterFindListCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindList.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindList implements mm_usecase.TransactionRepository
func (mmFindList *TransactionRepositoryMock) FindList(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Transaction, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindList.beforeFindListCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindList.afterFindListCounter, 1)

        mmFindList.t.Helper()

        if mmFindList.inspectFuncFindList != nil </span><span class="cov0" title="0">{
                mmFindList.inspectFuncFindList(ctx, listOptions, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := TransactionRepositoryMockFindListParams{ctx, listOptions, queryParams}

        // Record call args
        mmFindList.FindListMock.mutex.Lock()
        mmFindList.FindListMock.callArgs = append(mmFindList.FindListMock.callArgs, &amp;mm_params)
        mmFindList.FindListMock.mutex.Unlock()

        for _, e := range mmFindList.FindListMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.items, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindList.FindListMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindList.FindListMock.defaultExpectation.Counter, 1)
                mm_want := mmFindList.FindListMock.defaultExpectation.params
                mm_want_ptrs := mmFindList.FindListMock.defaultExpectation.paramPtrs

                mm_got := TransactionRepositoryMockFindListParams{ctx, listOptions, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("TransactionRepositoryMock.FindList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.listOptions != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("TransactionRepositoryMock.FindList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("TransactionRepositoryMock.FindList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindList.t.Errorf("TransactionRepositoryMock.FindList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindList.FindListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindList.FindListMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindList.t.Fatal("No results are set for the TransactionRepositoryMock.FindList")
                }</span>
                <span class="cov0" title="0">return (*mm_results).items, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindList.funcFindList != nil </span><span class="cov0" title="0">{
                return mmFindList.funcFindList(ctx, listOptions, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindList.t.Fatalf("Unexpected call to TransactionRepositoryMock.FindList. %v %v %v", ctx, listOptions, queryParams)
        return</span>
}

// FindListAfterCounter returns a count of finished TransactionRepositoryMock.FindList invocations
func (mmFindList *TransactionRepositoryMock) FindListAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindList.afterFindListCounter)
}</span>

// FindListBeforeCounter returns a count of TransactionRepositoryMock.FindList invocations
func (mmFindList *TransactionRepositoryMock) FindListBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindList.beforeFindListCounter)
}</span>

// Calls returns a list of arguments used in each call to TransactionRepositoryMock.FindList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindList *mTransactionRepositoryMockFindList) Calls() []*TransactionRepositoryMockFindListParams <span class="cov0" title="0">{
        mmFindList.mutex.RLock()

        argCopy := make([]*TransactionRepositoryMockFindListParams, len(mmFindList.callArgs))
        copy(argCopy, mmFindList.callArgs)

        mmFindList.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindListDone returns true if the count of the FindList invocations corresponds
// the number of defined expectations
func (m *TransactionRepositoryMock) MinimockFindListDone() bool <span class="cov0" title="0">{
        if m.FindListMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindListMock.invocationsDone()</span>
}

// MinimockFindListInspect logs each unmet expectation
func (m *TransactionRepositoryMock) MinimockFindListInspect() <span class="cov0" title="0">{
        for _, e := range m.FindListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionRepositoryMock.FindList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindListCounter := mm_atomic.LoadUint64(&amp;m.afterFindListCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindListMock.defaultExpectation != nil &amp;&amp; afterFindListCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindListMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionRepositoryMock.FindList at\n%s", m.FindListMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TransactionRepositoryMock.FindList at\n%s with params: %#v", m.FindListMock.defaultExpectation.expectationOrigins.origin, *m.FindListMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindList != nil &amp;&amp; afterFindListCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TransactionRepositoryMock.FindList at\n%s", m.funcFindListOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindListMock.invocationsDone() &amp;&amp; afterFindListCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TransactionRepositoryMock.FindList at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindListMock.expectedInvocations), m.FindListMock.expectedInvocationsOrigin, afterFindListCounter)
        }</span>
}

type mTransactionRepositoryMockFindOneByID struct {
        optional           bool
        mock               *TransactionRepositoryMock
        defaultExpectation *TransactionRepositoryMockFindOneByIDExpectation
        expectations       []*TransactionRepositoryMockFindOneByIDExpectation

        callArgs []*TransactionRepositoryMockFindOneByIDParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TransactionRepositoryMockFindOneByIDExpectation specifies expectation struct of the TransactionRepository.FindOneByID
type TransactionRepositoryMockFindOneByIDExpectation struct {
        mock               *TransactionRepositoryMock
        params             *TransactionRepositoryMockFindOneByIDParams
        paramPtrs          *TransactionRepositoryMockFindOneByIDParamPtrs
        expectationOrigins TransactionRepositoryMockFindOneByIDExpectationOrigins
        results            *TransactionRepositoryMockFindOneByIDResults
        returnOrigin       string
        Counter            uint64
}

// TransactionRepositoryMockFindOneByIDParams contains parameters of the TransactionRepository.FindOneByID
type TransactionRepositoryMockFindOneByIDParams struct {
        ctx         context.Context
        id          uuid.UUID
        queryParams *uctypes.QueryGetOneParams
}

// TransactionRepositoryMockFindOneByIDParamPtrs contains pointers to parameters of the TransactionRepository.FindOneByID
type TransactionRepositoryMockFindOneByIDParamPtrs struct {
        ctx         *context.Context
        id          *uuid.UUID
        queryParams **uctypes.QueryGetOneParams
}

// TransactionRepositoryMockFindOneByIDResults contains results of the TransactionRepository.FindOneByID
type TransactionRepositoryMockFindOneByIDResults struct {
        transaction *entity.Transaction
        err         error
}

// TransactionRepositoryMockFindOneByIDOrigins contains origins of expectations of the TransactionRepository.FindOneByID
type TransactionRepositoryMockFindOneByIDExpectationOrigins struct {
        origin            string
        originCtx         string
        originId          string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) Optional() *mTransactionRepositoryMockFindOneByID <span class="cov0" title="0">{
        mmFindOneByID.optional = true
        return mmFindOneByID
}</span>

// Expect sets up expected params for TransactionRepository.FindOneByID
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) Expect(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *mTransactionRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("TransactionRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;TransactionRepositoryMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("TransactionRepositoryMock.FindOneByID mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.params = &amp;TransactionRepositoryMockFindOneByIDParams{ctx, id, queryParams}
        mmFindOneByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindOneByID.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindOneByID.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindOneByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindOneByID.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindOneByID</span>
}

// ExpectCtxParam1 sets up expected param ctx for TransactionRepository.FindOneByID
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) ExpectCtxParam1(ctx context.Context) *mTransactionRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("TransactionRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;TransactionRepositoryMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("TransactionRepositoryMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;TransactionRepositoryMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindOneByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// ExpectIdParam2 sets up expected param id for TransactionRepository.FindOneByID
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) ExpectIdParam2(id uuid.UUID) *mTransactionRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("TransactionRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;TransactionRepositoryMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("TransactionRepositoryMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;TransactionRepositoryMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.id = &amp;id
        mmFindOneByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for TransactionRepository.FindOneByID
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetOneParams) *mTransactionRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("TransactionRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;TransactionRepositoryMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("TransactionRepositoryMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;TransactionRepositoryMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindOneByID.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// Inspect accepts an inspector function that has same arguments as the TransactionRepository.FindOneByID
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) Inspect(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)) *mTransactionRepositoryMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.inspectFuncFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Inspect function is already set for TransactionRepositoryMock.FindOneByID")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.mock.inspectFuncFindOneByID = f

        return mmFindOneByID</span>
}

// Return sets up results that will be returned by TransactionRepository.FindOneByID
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) Return(transaction *entity.Transaction, err error) *TransactionRepositoryMock <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("TransactionRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;TransactionRepositoryMockFindOneByIDExpectation{mock: mmFindOneByID.mock}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.results = &amp;TransactionRepositoryMockFindOneByIDResults{transaction, err}
        mmFindOneByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindOneByID.mock</span>
}

// Set uses given function f to mock the TransactionRepository.FindOneByID method
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) Set(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (transaction *entity.Transaction, err error)) *TransactionRepositoryMock <span class="cov0" title="0">{
        if mmFindOneByID.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Default expectation is already set for the TransactionRepository.FindOneByID method")
        }</span>

        <span class="cov0" title="0">if len(mmFindOneByID.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Some expectations are already set for the TransactionRepository.FindOneByID method")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.mock.funcFindOneByID = f
        mmFindOneByID.mock.funcFindOneByIDOrigin = minimock.CallerInfo(1)
        return mmFindOneByID.mock</span>
}

// When sets expectation for the TransactionRepository.FindOneByID which will trigger the result defined by the following
// Then helper
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) When(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *TransactionRepositoryMockFindOneByIDExpectation <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("TransactionRepositoryMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TransactionRepositoryMockFindOneByIDExpectation{
                mock:               mmFindOneByID.mock,
                params:             &amp;TransactionRepositoryMockFindOneByIDParams{ctx, id, queryParams},
                expectationOrigins: TransactionRepositoryMockFindOneByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindOneByID.expectations = append(mmFindOneByID.expectations, expectation)
        return expectation</span>
}

// Then sets up TransactionRepository.FindOneByID return parameters for the expectation previously defined by the When method
func (e *TransactionRepositoryMockFindOneByIDExpectation) Then(transaction *entity.Transaction, err error) *TransactionRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;TransactionRepositoryMockFindOneByIDResults{transaction, err}
        return e.mock
}</span>

// Times sets number of times TransactionRepository.FindOneByID should be invoked
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) Times(n uint64) *mTransactionRepositoryMockFindOneByID <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Times of TransactionRepositoryMock.FindOneByID mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindOneByID.expectedInvocations, n)
        mmFindOneByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindOneByID</span>
}

func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindOneByID.expectations) == 0 &amp;&amp; mmFindOneByID.defaultExpectation == nil &amp;&amp; mmFindOneByID.mock.funcFindOneByID == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByID.mock.afterFindOneByIDCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByID.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindOneByID implements mm_usecase.TransactionRepository
func (mmFindOneByID *TransactionRepositoryMock) FindOneByID(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (transaction *entity.Transaction, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindOneByID.beforeFindOneByIDCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindOneByID.afterFindOneByIDCounter, 1)

        mmFindOneByID.t.Helper()

        if mmFindOneByID.inspectFuncFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.inspectFuncFindOneByID(ctx, id, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := TransactionRepositoryMockFindOneByIDParams{ctx, id, queryParams}

        // Record call args
        mmFindOneByID.FindOneByIDMock.mutex.Lock()
        mmFindOneByID.FindOneByIDMock.callArgs = append(mmFindOneByID.FindOneByIDMock.callArgs, &amp;mm_params)
        mmFindOneByID.FindOneByIDMock.mutex.Unlock()

        for _, e := range mmFindOneByID.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.transaction, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindOneByID.FindOneByIDMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindOneByID.FindOneByIDMock.defaultExpectation.Counter, 1)
                mm_want := mmFindOneByID.FindOneByIDMock.defaultExpectation.params
                mm_want_ptrs := mmFindOneByID.FindOneByIDMock.defaultExpectation.paramPtrs

                mm_got := TransactionRepositoryMockFindOneByIDParams{ctx, id, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("TransactionRepositoryMock.FindOneByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("TransactionRepositoryMock.FindOneByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("TransactionRepositoryMock.FindOneByID got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindOneByID.t.Errorf("TransactionRepositoryMock.FindOneByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindOneByID.FindOneByIDMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindOneByID.t.Fatal("No results are set for the TransactionRepositoryMock.FindOneByID")
                }</span>
                <span class="cov0" title="0">return (*mm_results).transaction, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindOneByID.funcFindOneByID != nil </span><span class="cov0" title="0">{
                return mmFindOneByID.funcFindOneByID(ctx, id, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindOneByID.t.Fatalf("Unexpected call to TransactionRepositoryMock.FindOneByID. %v %v %v", ctx, id, queryParams)
        return</span>
}

// FindOneByIDAfterCounter returns a count of finished TransactionRepositoryMock.FindOneByID invocations
func (mmFindOneByID *TransactionRepositoryMock) FindOneByIDAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByID.afterFindOneByIDCounter)
}</span>

// FindOneByIDBeforeCounter returns a count of TransactionRepositoryMock.FindOneByID invocations
func (mmFindOneByID *TransactionRepositoryMock) FindOneByIDBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByID.beforeFindOneByIDCounter)
}</span>

// Calls returns a list of arguments used in each call to TransactionRepositoryMock.FindOneByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindOneByID *mTransactionRepositoryMockFindOneByID) Calls() []*TransactionRepositoryMockFindOneByIDParams <span class="cov0" title="0">{
        mmFindOneByID.mutex.RLock()

        argCopy := make([]*TransactionRepositoryMockFindOneByIDParams, len(mmFindOneByID.callArgs))
        copy(argCopy, mmFindOneByID.callArgs)

        mmFindOneByID.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindOneByIDDone returns true if the count of the FindOneByID invocations corresponds
// the number of defined expectations
func (m *TransactionRepositoryMock) MinimockFindOneByIDDone() bool <span class="cov0" title="0">{
        if m.FindOneByIDMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindOneByIDMock.invocationsDone()</span>
}

// MinimockFindOneByIDInspect logs each unmet expectation
func (m *TransactionRepositoryMock) MinimockFindOneByIDInspect() <span class="cov0" title="0">{
        for _, e := range m.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionRepositoryMock.FindOneByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindOneByIDCounter := mm_atomic.LoadUint64(&amp;m.afterFindOneByIDCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindOneByIDMock.defaultExpectation != nil &amp;&amp; afterFindOneByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindOneByIDMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionRepositoryMock.FindOneByID at\n%s", m.FindOneByIDMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TransactionRepositoryMock.FindOneByID at\n%s with params: %#v", m.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *m.FindOneByIDMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindOneByID != nil &amp;&amp; afterFindOneByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TransactionRepositoryMock.FindOneByID at\n%s", m.funcFindOneByIDOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindOneByIDMock.invocationsDone() &amp;&amp; afterFindOneByIDCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TransactionRepositoryMock.FindOneByID at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindOneByIDMock.expectedInvocations), m.FindOneByIDMock.expectedInvocationsOrigin, afterFindOneByIDCounter)
        }</span>
}

type mTransactionRepositoryMockFindPagedList struct {
        optional           bool
        mock               *TransactionRepositoryMock
        defaultExpectation *TransactionRepositoryMockFindPagedListExpectation
        expectations       []*TransactionRepositoryMockFindPagedListExpectation

        callArgs []*TransactionRepositoryMockFindPagedListParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TransactionRepositoryMockFindPagedListExpectation specifies expectation struct of the TransactionRepository.FindPagedList
type TransactionRepositoryMockFindPagedListExpectation struct {
        mock               *TransactionRepositoryMock
        params             *TransactionRepositoryMockFindPagedListParams
        paramPtrs          *TransactionRepositoryMockFindPagedListParamPtrs
        expectationOrigins TransactionRepositoryMockFindPagedListExpectationOrigins
        results            *TransactionRepositoryMockFindPagedListResults
        returnOrigin       string
        Counter            uint64
}

// TransactionRepositoryMockFindPagedListParams contains parameters of the TransactionRepository.FindPagedList
type TransactionRepositoryMockFindPagedListParams struct {
        ctx         context.Context
        listOptions *mm_usecase.TransactionListOptions
        queryParams *uctypes.QueryGetListParams
}

// TransactionRepositoryMockFindPagedListParamPtrs contains pointers to parameters of the TransactionRepository.FindPagedList
type TransactionRepositoryMockFindPagedListParamPtrs struct {
        ctx         *context.Context
        listOptions **mm_usecase.TransactionListOptions
        queryParams **uctypes.QueryGetListParams
}

// TransactionRepositoryMockFindPagedListResults contains results of the TransactionRepository.FindPagedList
type TransactionRepositoryMockFindPagedListResults struct {
        items []*entity.Transaction
        total uint64
        err   error
}

// TransactionRepositoryMockFindPagedListOrigins contains origins of expectations of the TransactionRepository.FindPagedList
type TransactionRepositoryMockFindPagedListExpectationOrigins struct {
        origin            string
        originCtx         string
        originListOptions string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) Optional() *mTransactionRepositoryMockFindPagedList <span class="cov0" title="0">{
        mmFindPagedList.optional = true
        return mmFindPagedList
}</span>

// Expect sets up expected params for TransactionRepository.FindPagedList
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) Expect(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *mTransactionRepositoryMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("TransactionRepositoryMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;TransactionRepositoryMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("TransactionRepositoryMock.FindPagedList mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.params = &amp;TransactionRepositoryMockFindPagedListParams{ctx, listOptions, queryParams}
        mmFindPagedList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindPagedList.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindPagedList.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindPagedList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindPagedList.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindPagedList</span>
}

// ExpectCtxParam1 sets up expected param ctx for TransactionRepository.FindPagedList
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) ExpectCtxParam1(ctx context.Context) *mTransactionRepositoryMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("TransactionRepositoryMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;TransactionRepositoryMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("TransactionRepositoryMock.FindPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation.paramPtrs = &amp;TransactionRepositoryMockFindPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindPagedList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindPagedList</span>
}

// ExpectListOptionsParam2 sets up expected param listOptions for TransactionRepository.FindPagedList
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) ExpectListOptionsParam2(listOptions *mm_usecase.TransactionListOptions) *mTransactionRepositoryMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("TransactionRepositoryMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;TransactionRepositoryMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("TransactionRepositoryMock.FindPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation.paramPtrs = &amp;TransactionRepositoryMockFindPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.paramPtrs.listOptions = &amp;listOptions
        mmFindPagedList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

        return mmFindPagedList</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for TransactionRepository.FindPagedList
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mTransactionRepositoryMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("TransactionRepositoryMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;TransactionRepositoryMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("TransactionRepositoryMock.FindPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation.paramPtrs = &amp;TransactionRepositoryMockFindPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindPagedList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindPagedList</span>
}

// Inspect accepts an inspector function that has same arguments as the TransactionRepository.FindPagedList
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)) *mTransactionRepositoryMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.inspectFuncFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Inspect function is already set for TransactionRepositoryMock.FindPagedList")
        }</span>

        <span class="cov0" title="0">mmFindPagedList.mock.inspectFuncFindPagedList = f

        return mmFindPagedList</span>
}

// Return sets up results that will be returned by TransactionRepository.FindPagedList
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) Return(items []*entity.Transaction, total uint64, err error) *TransactionRepositoryMock <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("TransactionRepositoryMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;TransactionRepositoryMockFindPagedListExpectation{mock: mmFindPagedList.mock}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.results = &amp;TransactionRepositoryMockFindPagedListResults{items, total, err}
        mmFindPagedList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindPagedList.mock</span>
}

// Set uses given function f to mock the TransactionRepository.FindPagedList method
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) Set(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Transaction, total uint64, err error)) *TransactionRepositoryMock <span class="cov0" title="0">{
        if mmFindPagedList.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Default expectation is already set for the TransactionRepository.FindPagedList method")
        }</span>

        <span class="cov0" title="0">if len(mmFindPagedList.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Some expectations are already set for the TransactionRepository.FindPagedList method")
        }</span>

        <span class="cov0" title="0">mmFindPagedList.mock.funcFindPagedList = f
        mmFindPagedList.mock.funcFindPagedListOrigin = minimock.CallerInfo(1)
        return mmFindPagedList.mock</span>
}

// When sets expectation for the TransactionRepository.FindPagedList which will trigger the result defined by the following
// Then helper
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) When(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *TransactionRepositoryMockFindPagedListExpectation <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("TransactionRepositoryMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TransactionRepositoryMockFindPagedListExpectation{
                mock:               mmFindPagedList.mock,
                params:             &amp;TransactionRepositoryMockFindPagedListParams{ctx, listOptions, queryParams},
                expectationOrigins: TransactionRepositoryMockFindPagedListExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindPagedList.expectations = append(mmFindPagedList.expectations, expectation)
        return expectation</span>
}

// Then sets up TransactionRepository.FindPagedList return parameters for the expectation previously defined by the When method
func (e *TransactionRepositoryMockFindPagedListExpectation) Then(items []*entity.Transaction, total uint64, err error) *TransactionRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;TransactionRepositoryMockFindPagedListResults{items, total, err}
        return e.mock
}</span>

// Times sets number of times TransactionRepository.FindPagedList should be invoked
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) Times(n uint64) *mTransactionRepositoryMockFindPagedList <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Times of TransactionRepositoryMock.FindPagedList mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindPagedList.expectedInvocations, n)
        mmFindPagedList.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindPagedList</span>
}

func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindPagedList.expectations) == 0 &amp;&amp; mmFindPagedList.defaultExpectation == nil &amp;&amp; mmFindPagedList.mock.funcFindPagedList == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindPagedList.mock.afterFindPagedListCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindPagedList.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindPagedList implements mm_usecase.TransactionRepository
func (mmFindPagedList *TransactionRepositoryMock) FindPagedList(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (items []*entity.Transaction, total uint64, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindPagedList.beforeFindPagedListCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindPagedList.afterFindPagedListCounter, 1)

        mmFindPagedList.t.Helper()

        if mmFindPagedList.inspectFuncFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.inspectFuncFindPagedList(ctx, listOptions, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := TransactionRepositoryMockFindPagedListParams{ctx, listOptions, queryParams}

        // Record call args
        mmFindPagedList.FindPagedListMock.mutex.Lock()
        mmFindPagedList.FindPagedListMock.callArgs = append(mmFindPagedList.FindPagedListMock.callArgs, &amp;mm_params)
        mmFindPagedList.FindPagedListMock.mutex.Unlock()

        for _, e := range mmFindPagedList.FindPagedListMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.items, e.results.total, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindPagedList.FindPagedListMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindPagedList.FindPagedListMock.defaultExpectation.Counter, 1)
                mm_want := mmFindPagedList.FindPagedListMock.defaultExpectation.params
                mm_want_ptrs := mmFindPagedList.FindPagedListMock.defaultExpectation.paramPtrs

                mm_got := TransactionRepositoryMockFindPagedListParams{ctx, listOptions, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindPagedList.t.Errorf("TransactionRepositoryMock.FindPagedList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.listOptions != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) </span><span class="cov0" title="0">{
                                mmFindPagedList.t.Errorf("TransactionRepositoryMock.FindPagedList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindPagedList.t.Errorf("TransactionRepositoryMock.FindPagedList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindPagedList.t.Errorf("TransactionRepositoryMock.FindPagedList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindPagedList.FindPagedListMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindPagedList.t.Fatal("No results are set for the TransactionRepositoryMock.FindPagedList")
                }</span>
                <span class="cov0" title="0">return (*mm_results).items, (*mm_results).total, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindPagedList.funcFindPagedList != nil </span><span class="cov0" title="0">{
                return mmFindPagedList.funcFindPagedList(ctx, listOptions, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindPagedList.t.Fatalf("Unexpected call to TransactionRepositoryMock.FindPagedList. %v %v %v", ctx, listOptions, queryParams)
        return</span>
}

// FindPagedListAfterCounter returns a count of finished TransactionRepositoryMock.FindPagedList invocations
func (mmFindPagedList *TransactionRepositoryMock) FindPagedListAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindPagedList.afterFindPagedListCounter)
}</span>

// FindPagedListBeforeCounter returns a count of TransactionRepositoryMock.FindPagedList invocations
func (mmFindPagedList *TransactionRepositoryMock) FindPagedListBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindPagedList.beforeFindPagedListCounter)
}</span>

// Calls returns a list of arguments used in each call to TransactionRepositoryMock.FindPagedList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindPagedList *mTransactionRepositoryMockFindPagedList) Calls() []*TransactionRepositoryMockFindPagedListParams <span class="cov0" title="0">{
        mmFindPagedList.mutex.RLock()

        argCopy := make([]*TransactionRepositoryMockFindPagedListParams, len(mmFindPagedList.callArgs))
        copy(argCopy, mmFindPagedList.callArgs)

        mmFindPagedList.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindPagedListDone returns true if the count of the FindPagedList invocations corresponds
// the number of defined expectations
func (m *TransactionRepositoryMock) MinimockFindPagedListDone() bool <span class="cov0" title="0">{
        if m.FindPagedListMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindPagedListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindPagedListMock.invocationsDone()</span>
}

// MinimockFindPagedListInspect logs each unmet expectation
func (m *TransactionRepositoryMock) MinimockFindPagedListInspect() <span class="cov0" title="0">{
        for _, e := range m.FindPagedListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionRepositoryMock.FindPagedList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindPagedListCounter := mm_atomic.LoadUint64(&amp;m.afterFindPagedListCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindPagedListMock.defaultExpectation != nil &amp;&amp; afterFindPagedListCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindPagedListMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionRepositoryMock.FindPagedList at\n%s", m.FindPagedListMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TransactionRepositoryMock.FindPagedList at\n%s with params: %#v", m.FindPagedListMock.defaultExpectation.expectationOrigins.origin, *m.FindPagedListMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindPagedList != nil &amp;&amp; afterFindPagedListCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TransactionRepositoryMock.FindPagedList at\n%s", m.funcFindPagedListOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindPagedListMock.invocationsDone() &amp;&amp; afterFindPagedListCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TransactionRepositoryMock.FindPagedList at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindPagedListMock.expectedInvocations), m.FindPagedListMock.expectedInvocationsOrigin, afterFindPagedListCounter)
        }</span>
}

type mTransactionRepositoryMockUpdate struct {
        optional           bool
        mock               *TransactionRepositoryMock
        defaultExpectation *TransactionRepositoryMockUpdateExpectation
        expectations       []*TransactionRepositoryMockUpdateExpectation

        callArgs []*TransactionRepositoryMockUpdateParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TransactionRepositoryMockUpdateExpectation specifies expectation struct of the TransactionRepository.Update
type TransactionRepositoryMockUpdateExpectation struct {
        mock               *TransactionRepositoryMock
        params             *TransactionRepositoryMockUpdateParams
        paramPtrs          *TransactionRepositoryMockUpdateParamPtrs
        expectationOrigins TransactionRepositoryMockUpdateExpectationOrigins
        results            *TransactionRepositoryMockUpdateResults
        returnOrigin       string
        Counter            uint64
}

// TransactionRepositoryMockUpdateParams contains parameters of the TransactionRepository.Update
type TransactionRepositoryMockUpdateParams struct {
        ctx  context.Context
        item *entity.Transaction
}

// TransactionRepositoryMockUpdateParamPtrs contains pointers to parameters of the TransactionRepository.Update
type TransactionRepositoryMockUpdateParamPtrs struct {
        ctx  *context.Context
        item **entity.Transaction
}

// TransactionRepositoryMockUpdateResults contains results of the TransactionRepository.Update
type TransactionRepositoryMockUpdateResults struct {
        err error
}

// TransactionRepositoryMockUpdateOrigins contains origins of expectations of the TransactionRepository.Update
type TransactionRepositoryMockUpdateExpectationOrigins struct {
        origin     string
        originCtx  string
        originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mTransactionRepositoryMockUpdate) Optional() *mTransactionRepositoryMockUpdate <span class="cov0" title="0">{
        mmUpdate.optional = true
        return mmUpdate
}</span>

// Expect sets up expected params for TransactionRepository.Update
func (mmUpdate *mTransactionRepositoryMockUpdate) Expect(ctx context.Context, item *entity.Transaction) *mTransactionRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("TransactionRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;TransactionRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("TransactionRepositoryMock.Update mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmUpdate.defaultExpectation.params = &amp;TransactionRepositoryMockUpdateParams{ctx, item}
        mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmUpdate.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmUpdate</span>
}

// ExpectCtxParam1 sets up expected param ctx for TransactionRepository.Update
func (mmUpdate *mTransactionRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mTransactionRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("TransactionRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;TransactionRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("TransactionRepositoryMock.Update mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation.paramPtrs = &amp;TransactionRepositoryMockUpdateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmUpdate</span>
}

// ExpectItemParam2 sets up expected param item for TransactionRepository.Update
func (mmUpdate *mTransactionRepositoryMockUpdate) ExpectItemParam2(item *entity.Transaction) *mTransactionRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("TransactionRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;TransactionRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("TransactionRepositoryMock.Update mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation.paramPtrs = &amp;TransactionRepositoryMockUpdateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.paramPtrs.item = &amp;item
        mmUpdate.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

        return mmUpdate</span>
}

// Inspect accepts an inspector function that has same arguments as the TransactionRepository.Update
func (mmUpdate *mTransactionRepositoryMockUpdate) Inspect(f func(ctx context.Context, item *entity.Transaction)) *mTransactionRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.inspectFuncUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Inspect function is already set for TransactionRepositoryMock.Update")
        }</span>

        <span class="cov0" title="0">mmUpdate.mock.inspectFuncUpdate = f

        return mmUpdate</span>
}

// Return sets up results that will be returned by TransactionRepository.Update
func (mmUpdate *mTransactionRepositoryMockUpdate) Return(err error) *TransactionRepositoryMock <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("TransactionRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;TransactionRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.results = &amp;TransactionRepositoryMockUpdateResults{err}
        mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmUpdate.mock</span>
}

// Set uses given function f to mock the TransactionRepository.Update method
func (mmUpdate *mTransactionRepositoryMockUpdate) Set(f func(ctx context.Context, item *entity.Transaction) (err error)) *TransactionRepositoryMock <span class="cov0" title="0">{
        if mmUpdate.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Default expectation is already set for the TransactionRepository.Update method")
        }</span>

        <span class="cov0" title="0">if len(mmUpdate.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Some expectations are already set for the TransactionRepository.Update method")
        }</span>

        <span class="cov0" title="0">mmUpdate.mock.funcUpdate = f
        mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
        return mmUpdate.mock</span>
}

// When sets expectation for the TransactionRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mTransactionRepositoryMockUpdate) When(ctx context.Context, item *entity.Transaction) *TransactionRepositoryMockUpdateExpectation <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("TransactionRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TransactionRepositoryMockUpdateExpectation{
                mock:               mmUpdate.mock,
                params:             &amp;TransactionRepositoryMockUpdateParams{ctx, item},
                expectationOrigins: TransactionRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmUpdate.expectations = append(mmUpdate.expectations, expectation)
        return expectation</span>
}

// Then sets up TransactionRepository.Update return parameters for the expectation previously defined by the When method
func (e *TransactionRepositoryMockUpdateExpectation) Then(err error) *TransactionRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;TransactionRepositoryMockUpdateResults{err}
        return e.mock
}</span>

// Times sets number of times TransactionRepository.Update should be invoked
func (mmUpdate *mTransactionRepositoryMockUpdate) Times(n uint64) *mTransactionRepositoryMockUpdate <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Times of TransactionRepositoryMock.Update mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmUpdate.expectedInvocations, n)
        mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmUpdate</span>
}

func (mmUpdate *mTransactionRepositoryMockUpdate) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmUpdate.expectations) == 0 &amp;&amp; mmUpdate.defaultExpectation == nil &amp;&amp; mmUpdate.mock.funcUpdate == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmUpdate.mock.afterUpdateCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmUpdate.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Update implements mm_usecase.TransactionRepository
func (mmUpdate *TransactionRepositoryMock) Update(ctx context.Context, item *entity.Transaction) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmUpdate.beforeUpdateCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmUpdate.afterUpdateCounter, 1)

        mmUpdate.t.Helper()

        if mmUpdate.inspectFuncUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.inspectFuncUpdate(ctx, item)
        }</span>

        <span class="cov0" title="0">mm_params := TransactionRepositoryMockUpdateParams{ctx, item}

        // Record call args
        mmUpdate.UpdateMock.mutex.Lock()
        mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &amp;mm_params)
        mmUpdate.UpdateMock.mutex.Unlock()

        for _, e := range mmUpdate.UpdateMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmUpdate.UpdateMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
                mm_want := mmUpdate.UpdateMock.defaultExpectation.params
                mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

                mm_got := TransactionRepositoryMockUpdateParams{ctx, item}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmUpdate.t.Errorf("TransactionRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.item != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.item, mm_got.item) </span><span class="cov0" title="0">{
                                mmUpdate.t.Errorf("TransactionRepositoryMock.Update got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmUpdate.t.Errorf("TransactionRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmUpdate.UpdateMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmUpdate.t.Fatal("No results are set for the TransactionRepositoryMock.Update")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmUpdate.funcUpdate != nil </span><span class="cov0" title="0">{
                return mmUpdate.funcUpdate(ctx, item)
        }</span>
        <span class="cov0" title="0">mmUpdate.t.Fatalf("Unexpected call to TransactionRepositoryMock.Update. %v %v", ctx, item)
        return</span>
}

// UpdateAfterCounter returns a count of finished TransactionRepositoryMock.Update invocations
func (mmUpdate *TransactionRepositoryMock) UpdateAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdate.afterUpdateCounter)
}</span>

// UpdateBeforeCounter returns a count of TransactionRepositoryMock.Update invocations
func (mmUpdate *TransactionRepositoryMock) UpdateBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdate.beforeUpdateCounter)
}</span>

// Calls returns a list of arguments used in each call to TransactionRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mTransactionRepositoryMockUpdate) Calls() []*TransactionRepositoryMockUpdateParams <span class="cov0" title="0">{
        mmUpdate.mutex.RLock()

        argCopy := make([]*TransactionRepositoryMockUpdateParams, len(mmUpdate.callArgs))
        copy(argCopy, mmUpdate.callArgs)

        mmUpdate.mutex.RUnlock()

        return argCopy
}</span>

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *TransactionRepositoryMock) MinimockUpdateDone() bool <span class="cov0" title="0">{
        if m.UpdateMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.UpdateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.UpdateMock.invocationsDone()</span>
}

// MinimockUpdateInspect logs each unmet expectation
func (m *TransactionRepositoryMock) MinimockUpdateInspect() <span class="cov0" title="0">{
        for _, e := range m.UpdateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterUpdateCounter := mm_atomic.LoadUint64(&amp;m.afterUpdateCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.UpdateMock.defaultExpectation != nil &amp;&amp; afterUpdateCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.UpdateMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TransactionRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcUpdate != nil &amp;&amp; afterUpdateCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TransactionRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
        }</span>

        <span class="cov0" title="0">if !m.UpdateMock.invocationsDone() &amp;&amp; afterUpdateCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TransactionRepositoryMock.Update at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TransactionRepositoryMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockCountReportItemsInspect()

                        m.MinimockCreateInspect()

                        m.MinimockFindListInspect()

                        m.MinimockFindOneByIDInspect()

                        m.MinimockFindPagedListInspect()

                        m.MinimockUpdateInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TransactionRepositoryMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *TransactionRepositoryMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockCountReportItemsDone() &amp;&amp;
                m.MinimockCreateDone() &amp;&amp;
                m.MinimockFindListDone() &amp;&amp;
                m.MinimockFindOneByIDDone() &amp;&amp;
                m.MinimockFindPagedListDone() &amp;&amp;
                m.MinimockUpdateDone()
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase.TransactionUsecase -o transaction_usecase.go -n TransactionUsecaseMock -p mocks

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        mm_usecase "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
)

// TransactionUsecaseMock implements mm_usecase.TransactionUsecase
type TransactionUsecaseMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcCountReportItems          func(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter) (items []*entity.ReportItem, cacheHit bool, err error)
        funcCountReportItemsOrigin    string
        inspectFuncCountReportItems   func(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter)
        afterCountReportItemsCounter  uint64
        beforeCountReportItemsCounter uint64
        CountReportItemsMock          mTransactionUsecaseMockCountReportItems

        funcCreateTransactionByDTO          func(ctx context.Context, in mm_usecase.CreateTransactionDataInput) (resTransactionDTO *mm_usecase.TransactionDTO, err error)
        funcCreateTransactionByDTOOrigin    string
        inspectFuncCreateTransactionByDTO   func(ctx context.Context, in mm_usecase.CreateTransactionDataInput)
        afterCreateTransactionByDTOCounter  uint64
        beforeCreateTransactionByDTOCounter uint64
        CreateTransactionByDTOMock          mTransactionUsecaseMockCreateTransactionByDTO

        funcDeleteTransactionByID          func(ctx context.Context, id uuid.UUID) (err error)
        funcDeleteTransactionByIDOrigin    string
        inspectFuncDeleteTransactionByID   func(ctx context.Context, id uuid.UUID)
        afterDeleteTransactionByIDCounter  uint64
        beforeDeleteTransactionByIDCounter uint64
        DeleteTransactionByIDMock          mTransactionUsecaseMockDeleteTransactionByID

        funcFindList          func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.TransactionDTO, err error)
        funcFindListOrigin    string
        inspectFuncFindList   func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)
        afterFindListCounter  uint64
        beforeFindListCounter uint64
        FindListMock          mTransactionUsecaseMockFindList

        funcFindListInMap          func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (resItems map[uuid.UUID]*mm_usecase.TransactionDTO, err error)
        funcFindListInMapOrigin    string
        inspectFuncFindListInMap   func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)
        afterFindListInMapCounter  uint64
        beforeFindListInMapCounter uint64
        FindListInMapMock          mTransactionUsecaseMockFindListInMap

        funcFindOneByID          func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (resItem *mm_usecase.TransactionDTO, err error)
        funcFindOneByIDOrigin    string
        inspectFuncFindOneByID   func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)
        afterFindOneByIDCounter  uint64
        beforeFindOneByIDCounter uint64
        FindOneByIDMock          mTransactionUsecaseMockFindOneByID

        funcFindPagedList          func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.TransactionDTO, total uint64, err error)
        funcFindPagedListOrigin    string
        inspectFuncFindPagedList   func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)
        afterFindPagedListCounter  uint64
        beforeFindPagedListCounter uint64
        FindPagedListMock          mTransactionUsecaseMockFindPagedList

        funcFindPagedListAsCSV          func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (res []byte, total uint64, err error)
        funcFindPagedListAsCSVOrigin    string
        inspectFuncFindPagedListAsCSV   func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)
        afterFindPagedListAsCSVCounter  uint64
        beforeFindPagedListAsCSVCounter uint64
        FindPagedListAsCSVMock          mTransactionUsecaseMockFindPagedListAsCSV

        funcImportTransactionsFromCSV          func(ctx context.Context, data []byte, accountID uuid.UUID) (err error)
        funcImportTransactionsFromCSVOrigin    string
        inspectFuncImportTransactionsFromCSV   func(ctx context.Context, data []byte, accountID uuid.UUID)
        afterImportTransactionsFromCSVCounter  uint64
        beforeImportTransactionsFromCSVCounter uint64
        ImportTransactionsFromCSVMock          mTransactionUsecaseMockImportTransactionsFromCSV

        funcPatchTransactionByDTO          func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchTransactionDataInput, skipVersionCheck bool) (err error)
        funcPatchTransactionByDTOOrigin    string
        inspectFuncPatchTransactionByDTO   func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchTransactionDataInput, skipVersionCheck bool)
        afterPatchTransactionByDTOCounter  uint64
        beforePatchTransactionByDTOCounter uint64
        PatchTransactionByDTOMock          mTransactionUsecaseMockPatchTransactionByDTO
}

// NewTransactionUsecaseMock returns a mock for mm_usecase.TransactionUsecase
func NewTransactionUsecaseMock(t minimock.Tester) *TransactionUsecaseMock <span class="cov0" title="0">{
        m := &amp;TransactionUsecaseMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.CountReportItemsMock = mTransactionUsecaseMockCountReportItems{mock: m}
        m.CountReportItemsMock.callArgs = []*TransactionUsecaseMockCountReportItemsParams{}

        m.CreateTransactionByDTOMock = mTransactionUsecaseMockCreateTransactionByDTO{mock: m}
        m.CreateTransactionByDTOMock.callArgs = []*TransactionUsecaseMockCreateTransactionByDTOParams{}

        m.DeleteTransactionByIDMock = mTransactionUsecaseMockDeleteTransactionByID{mock: m}
        m.DeleteTransactionByIDMock.callArgs = []*TransactionUsecaseMockDeleteTransactionByIDParams{}

        m.FindListMock = mTransactionUsecaseMockFindList{mock: m}
        m.FindListMock.callArgs = []*TransactionUsecaseMockFindListParams{}

        m.FindListInMapMock = mTransactionUsecaseMockFindListInMap{mock: m}
        m.FindListInMapMock.callArgs = []*TransactionUsecaseMockFindListInMapParams{}

        m.FindOneByIDMock = mTransactionUsecaseMockFindOneByID{mock: m}
        m.FindOneByIDMock.callArgs = []*TransactionUsecaseMockFindOneByIDParams{}

        m.FindPagedListMock = mTransactionUsecaseMockFindPagedList{mock: m}
        m.FindPagedListMock.callArgs = []*TransactionUsecaseMockFindPagedListParams{}

        m.FindPagedListAsCSVMock = mTransactionUsecaseMockFindPagedListAsCSV{mock: m}
        m.FindPagedListAsCSVMock.callArgs = []*TransactionUsecaseMockFindPagedListAsCSVParams{}

        m.ImportTransactionsFromCSVMock = mTransactionUsecaseMockImportTransactionsFromCSV{mock: m}
        m.ImportTransactionsFromCSVMock.callArgs = []*TransactionUsecaseMockImportTransactionsFromCSVParams{}

        m.PatchTransactionByDTOMock = mTransactionUsecaseMockPatchTransactionByDTO{mock: m}
        m.PatchTransactionByDTOMock.callArgs = []*TransactionUsecaseMockPatchTransactionByDTOParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mTransactionUsecaseMockCountReportItems struct {
        optional           bool
        mock               *TransactionUsecaseMock
        defaultExpectation *TransactionUsecaseMockCountReportItemsExpectation
        expectations       []*TransactionUsecaseMockCountReportItemsExpectation

        callArgs []*TransactionUsecaseMockCountReportItemsParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TransactionUsecaseMockCountReportItemsExpectation specifies expectation struct of the TransactionUsecase.CountReportItems
type TransactionUsecaseMockCountReportItemsExpectation struct {
        mock               *TransactionUsecaseMock
        params             *TransactionUsecaseMockCountReportItemsParams
        paramPtrs          *TransactionUsecaseMockCountReportItemsParamPtrs
        expectationOrigins TransactionUsecaseMockCountReportItemsExpectationOrigins
        results            *TransactionUsecaseMockCountReportItemsResults
        returnOrigin       string
        Counter            uint64
}

// TransactionUsecaseMockCountReportItemsParams contains parameters of the TransactionUsecase.CountReportItems
type TransactionUsecaseMockCountReportItemsParams struct {
        ctx         context.Context
        queryFilter mm_usecase.CountReportItemsQueryFilter
}

// TransactionUsecaseMockCountReportItemsParamPtrs contains pointers to parameters of the TransactionUsecase.CountReportItems
type TransactionUsecaseMockCountReportItemsParamPtrs struct {
        ctx         *context.Context
        queryFilter *mm_usecase.CountReportItemsQueryFilter
}

// TransactionUsecaseMockCountReportItemsResults contains results of the TransactionUsecase.CountReportItems
type TransactionUsecaseMockCountReportItemsResults struct {
        items    []*entity.ReportItem
        cacheHit bool
        err      error
}

// TransactionUsecaseMockCountReportItemsOrigins contains origins of expectations of the TransactionUsecase.CountReportItems
type TransactionUsecaseMockCountReportItemsExpectationOrigins struct {
        origin            string
        originCtx         string
        originQueryFilter string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) Optional() *mTransactionUsecaseMockCountReportItems <span class="cov0" title="0">{
        mmCountReportItems.optional = true
        return mmCountReportItems
}</span>

// Expect sets up expected params for TransactionUsecase.CountReportItems
func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) Expect(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter) *mTransactionUsecaseMockCountReportItems <span class="cov0" title="0">{
        if mmCountReportItems.mock.funcCountReportItems != nil </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("TransactionUsecaseMock.CountReportItems mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCountReportItems.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCountReportItems.defaultExpectation = &amp;TransactionUsecaseMockCountReportItemsExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCountReportItems.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("TransactionUsecaseMock.CountReportItems mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmCountReportItems.defaultExpectation.params = &amp;TransactionUsecaseMockCountReportItemsParams{ctx, queryFilter}
        mmCountReportItems.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmCountReportItems.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmCountReportItems.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmCountReportItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCountReportItems.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmCountReportItems</span>
}

// ExpectCtxParam1 sets up expected param ctx for TransactionUsecase.CountReportItems
func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) ExpectCtxParam1(ctx context.Context) *mTransactionUsecaseMockCountReportItems <span class="cov0" title="0">{
        if mmCountReportItems.mock.funcCountReportItems != nil </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("TransactionUsecaseMock.CountReportItems mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCountReportItems.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCountReportItems.defaultExpectation = &amp;TransactionUsecaseMockCountReportItemsExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCountReportItems.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("TransactionUsecaseMock.CountReportItems mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCountReportItems.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCountReportItems.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockCountReportItemsParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCountReportItems.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmCountReportItems.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmCountReportItems</span>
}

// ExpectQueryFilterParam2 sets up expected param queryFilter for TransactionUsecase.CountReportItems
func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) ExpectQueryFilterParam2(queryFilter mm_usecase.CountReportItemsQueryFilter) *mTransactionUsecaseMockCountReportItems <span class="cov0" title="0">{
        if mmCountReportItems.mock.funcCountReportItems != nil </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("TransactionUsecaseMock.CountReportItems mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCountReportItems.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCountReportItems.defaultExpectation = &amp;TransactionUsecaseMockCountReportItemsExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCountReportItems.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("TransactionUsecaseMock.CountReportItems mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCountReportItems.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCountReportItems.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockCountReportItemsParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCountReportItems.defaultExpectation.paramPtrs.queryFilter = &amp;queryFilter
        mmCountReportItems.defaultExpectation.expectationOrigins.originQueryFilter = minimock.CallerInfo(1)

        return mmCountReportItems</span>
}

// Inspect accepts an inspector function that has same arguments as the TransactionUsecase.CountReportItems
func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) Inspect(f func(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter)) *mTransactionUsecaseMockCountReportItems <span class="cov0" title="0">{
        if mmCountReportItems.mock.inspectFuncCountReportItems != nil </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("Inspect function is already set for TransactionUsecaseMock.CountReportItems")
        }</span>

        <span class="cov0" title="0">mmCountReportItems.mock.inspectFuncCountReportItems = f

        return mmCountReportItems</span>
}

// Return sets up results that will be returned by TransactionUsecase.CountReportItems
func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) Return(items []*entity.ReportItem, cacheHit bool, err error) *TransactionUsecaseMock <span class="cov0" title="0">{
        if mmCountReportItems.mock.funcCountReportItems != nil </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("TransactionUsecaseMock.CountReportItems mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCountReportItems.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCountReportItems.defaultExpectation = &amp;TransactionUsecaseMockCountReportItemsExpectation{mock: mmCountReportItems.mock}
        }</span>
        <span class="cov0" title="0">mmCountReportItems.defaultExpectation.results = &amp;TransactionUsecaseMockCountReportItemsResults{items, cacheHit, err}
        mmCountReportItems.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmCountReportItems.mock</span>
}

// Set uses given function f to mock the TransactionUsecase.CountReportItems method
func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) Set(f func(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter) (items []*entity.ReportItem, cacheHit bool, err error)) *TransactionUsecaseMock <span class="cov0" title="0">{
        if mmCountReportItems.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("Default expectation is already set for the TransactionUsecase.CountReportItems method")
        }</span>

        <span class="cov0" title="0">if len(mmCountReportItems.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("Some expectations are already set for the TransactionUsecase.CountReportItems method")
        }</span>

        <span class="cov0" title="0">mmCountReportItems.mock.funcCountReportItems = f
        mmCountReportItems.mock.funcCountReportItemsOrigin = minimock.CallerInfo(1)
        return mmCountReportItems.mock</span>
}

// When sets expectation for the TransactionUsecase.CountReportItems which will trigger the result defined by the following
// Then helper
func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) When(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter) *TransactionUsecaseMockCountReportItemsExpectation <span class="cov0" title="0">{
        if mmCountReportItems.mock.funcCountReportItems != nil </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("TransactionUsecaseMock.CountReportItems mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TransactionUsecaseMockCountReportItemsExpectation{
                mock:               mmCountReportItems.mock,
                params:             &amp;TransactionUsecaseMockCountReportItemsParams{ctx, queryFilter},
                expectationOrigins: TransactionUsecaseMockCountReportItemsExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmCountReportItems.expectations = append(mmCountReportItems.expectations, expectation)
        return expectation</span>
}

// Then sets up TransactionUsecase.CountReportItems return parameters for the expectation previously defined by the When method
func (e *TransactionUsecaseMockCountReportItemsExpectation) Then(items []*entity.ReportItem, cacheHit bool, err error) *TransactionUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;TransactionUsecaseMockCountReportItemsResults{items, cacheHit, err}
        return e.mock
}</span>

// Times sets number of times TransactionUsecase.CountReportItems should be invoked
func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) Times(n uint64) *mTransactionUsecaseMockCountReportItems <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmCountReportItems.mock.t.Fatalf("Times of TransactionUsecaseMock.CountReportItems mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmCountReportItems.expectedInvocations, n)
        mmCountReportItems.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmCountReportItems</span>
}

func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmCountReportItems.expectations) == 0 &amp;&amp; mmCountReportItems.defaultExpectation == nil &amp;&amp; mmCountReportItems.mock.funcCountReportItems == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmCountReportItems.mock.afterCountReportItemsCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmCountReportItems.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// CountReportItems implements mm_usecase.TransactionUsecase
func (mmCountReportItems *TransactionUsecaseMock) CountReportItems(ctx context.Context, queryFilter mm_usecase.CountReportItemsQueryFilter) (items []*entity.ReportItem, cacheHit bool, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmCountReportItems.beforeCountReportItemsCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmCountReportItems.afterCountReportItemsCounter, 1)

        mmCountReportItems.t.Helper()

        if mmCountReportItems.inspectFuncCountReportItems != nil </span><span class="cov0" title="0">{
                mmCountReportItems.inspectFuncCountReportItems(ctx, queryFilter)
        }</span>

        <span class="cov0" title="0">mm_params := TransactionUsecaseMockCountReportItemsParams{ctx, queryFilter}

        // Record call args
        mmCountReportItems.CountReportItemsMock.mutex.Lock()
        mmCountReportItems.CountReportItemsMock.callArgs = append(mmCountReportItems.CountReportItemsMock.callArgs, &amp;mm_params)
        mmCountReportItems.CountReportItemsMock.mutex.Unlock()

        for _, e := range mmCountReportItems.CountReportItemsMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.items, e.results.cacheHit, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmCountReportItems.CountReportItemsMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmCountReportItems.CountReportItemsMock.defaultExpectation.Counter, 1)
                mm_want := mmCountReportItems.CountReportItemsMock.defaultExpectation.params
                mm_want_ptrs := mmCountReportItems.CountReportItemsMock.defaultExpectation.paramPtrs

                mm_got := TransactionUsecaseMockCountReportItemsParams{ctx, queryFilter}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmCountReportItems.t.Errorf("TransactionUsecaseMock.CountReportItems got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCountReportItems.CountReportItemsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryFilter != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryFilter, mm_got.queryFilter) </span><span class="cov0" title="0">{
                                mmCountReportItems.t.Errorf("TransactionUsecaseMock.CountReportItems got unexpected parameter queryFilter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCountReportItems.CountReportItemsMock.defaultExpectation.expectationOrigins.originQueryFilter, *mm_want_ptrs.queryFilter, mm_got.queryFilter, minimock.Diff(*mm_want_ptrs.queryFilter, mm_got.queryFilter))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmCountReportItems.t.Errorf("TransactionUsecaseMock.CountReportItems got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmCountReportItems.CountReportItemsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmCountReportItems.CountReportItemsMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmCountReportItems.t.Fatal("No results are set for the TransactionUsecaseMock.CountReportItems")
                }</span>
                <span class="cov0" title="0">return (*mm_results).items, (*mm_results).cacheHit, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmCountReportItems.funcCountReportItems != nil </span><span class="cov0" title="0">{
                return mmCountReportItems.funcCountReportItems(ctx, queryFilter)
        }</span>
        <span class="cov0" title="0">mmCountReportItems.t.Fatalf("Unexpected call to TransactionUsecaseMock.CountReportItems. %v %v", ctx, queryFilter)
        return</span>
}

// CountReportItemsAfterCounter returns a count of finished TransactionUsecaseMock.CountReportItems invocations
func (mmCountReportItems *TransactionUsecaseMock) CountReportItemsAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCountReportItems.afterCountReportItemsCounter)
}</span>

// CountReportItemsBeforeCounter returns a count of TransactionUsecaseMock.CountReportItems invocations
func (mmCountReportItems *TransactionUsecaseMock) CountReportItemsBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCountReportItems.beforeCountReportItemsCounter)
}</span>

// Calls returns a list of arguments used in each call to TransactionUsecaseMock.CountReportItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCountReportItems *mTransactionUsecaseMockCountReportItems) Calls() []*TransactionUsecaseMockCountReportItemsParams <span class="cov0" title="0">{
        mmCountReportItems.mutex.RLock()

        argCopy := make([]*TransactionUsecaseMockCountReportItemsParams, len(mmCountReportItems.callArgs))
        copy(argCopy, mmCountReportItems.callArgs)

        mmCountReportItems.mutex.RUnlock()

        return argCopy
}</span>

// MinimockCountReportItemsDone returns true if the count of the CountReportItems invocations corresponds
// the number of defined expectations
func (m *TransactionUsecaseMock) MinimockCountReportItemsDone() bool <span class="cov0" title="0">{
        if m.CountReportItemsMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.CountReportItemsMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.CountReportItemsMock.invocationsDone()</span>
}

// MinimockCountReportItemsInspect logs each unmet expectation
func (m *TransactionUsecaseMock) MinimockCountReportItemsInspect() <span class="cov0" title="0">{
        for _, e := range m.CountReportItemsMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionUsecaseMock.CountReportItems at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterCountReportItemsCounter := mm_atomic.LoadUint64(&amp;m.afterCountReportItemsCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.CountReportItemsMock.defaultExpectation != nil &amp;&amp; afterCountReportItemsCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.CountReportItemsMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionUsecaseMock.CountReportItems at\n%s", m.CountReportItemsMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TransactionUsecaseMock.CountReportItems at\n%s with params: %#v", m.CountReportItemsMock.defaultExpectation.expectationOrigins.origin, *m.CountReportItemsMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcCountReportItems != nil &amp;&amp; afterCountReportItemsCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TransactionUsecaseMock.CountReportItems at\n%s", m.funcCountReportItemsOrigin)
        }</span>

        <span class="cov0" title="0">if !m.CountReportItemsMock.invocationsDone() &amp;&amp; afterCountReportItemsCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TransactionUsecaseMock.CountReportItems at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.CountReportItemsMock.expectedInvocations), m.CountReportItemsMock.expectedInvocationsOrigin, afterCountReportItemsCounter)
        }</span>
}

type mTransactionUsecaseMockCreateTransactionByDTO struct {
        optional           bool
        mock               *TransactionUsecaseMock
        defaultExpectation *TransactionUsecaseMockCreateTransactionByDTOExpectation
        expectations       []*TransactionUsecaseMockCreateTransactionByDTOExpectation

        callArgs []*TransactionUsecaseMockCreateTransactionByDTOParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TransactionUsecaseMockCreateTransactionByDTOExpectation specifies expectation struct of the TransactionUsecase.CreateTransactionByDTO
type TransactionUsecaseMockCreateTransactionByDTOExpectation struct {
        mock               *TransactionUsecaseMock
        params             *TransactionUsecaseMockCreateTransactionByDTOParams
        paramPtrs          *TransactionUsecaseMockCreateTransactionByDTOParamPtrs
        expectationOrigins TransactionUsecaseMockCreateTransactionByDTOExpectationOrigins
        results            *TransactionUsecaseMockCreateTransactionByDTOResults
        returnOrigin       string
        Counter            uint64
}

// TransactionUsecaseMockCreateTransactionByDTOParams contains parameters of the TransactionUsecase.CreateTransactionByDTO
type TransactionUsecaseMockCreateTransactionByDTOParams struct {
        ctx context.Context
        in  mm_usecase.CreateTransactionDataInput
}

// TransactionUsecaseMockCreateTransactionByDTOParamPtrs contains pointers to parameters of the TransactionUsecase.CreateTransactionByDTO
type TransactionUsecaseMockCreateTransactionByDTOParamPtrs struct {
        ctx *context.Context
        in  *mm_usecase.CreateTransactionDataInput
}

// TransactionUsecaseMockCreateTransactionByDTOResults contains results of the TransactionUsecase.CreateTransactionByDTO
type TransactionUsecaseMockCreateTransactionByDTOResults struct {
        resTransactionDTO *mm_usecase.TransactionDTO
        err               error
}

// TransactionUsecaseMockCreateTransactionByDTOOrigins contains origins of expectations of the TransactionUsecase.CreateTransactionByDTO
type TransactionUsecaseMockCreateTransactionByDTOExpectationOrigins struct {
        origin    string
        originCtx string
        originIn  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) Optional() *mTransactionUsecaseMockCreateTransactionByDTO <span class="cov0" title="0">{
        mmCreateTransactionByDTO.optional = true
        return mmCreateTransactionByDTO
}</span>

// Expect sets up expected params for TransactionUsecase.CreateTransactionByDTO
func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) Expect(ctx context.Context, in mm_usecase.CreateTransactionDataInput) *mTransactionUsecaseMockCreateTransactionByDTO <span class="cov0" title="0">{
        if mmCreateTransactionByDTO.mock.funcCreateTransactionByDTO != nil </span><span class="cov0" title="0">{
                mmCreateTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.CreateTransactionByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateTransactionByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateTransactionByDTO.defaultExpectation = &amp;TransactionUsecaseMockCreateTransactionByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateTransactionByDTO.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmCreateTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.CreateTransactionByDTO mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmCreateTransactionByDTO.defaultExpectation.params = &amp;TransactionUsecaseMockCreateTransactionByDTOParams{ctx, in}
        mmCreateTransactionByDTO.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmCreateTransactionByDTO.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmCreateTransactionByDTO.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmCreateTransactionByDTO.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateTransactionByDTO.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmCreateTransactionByDTO</span>
}

// ExpectCtxParam1 sets up expected param ctx for TransactionUsecase.CreateTransactionByDTO
func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) ExpectCtxParam1(ctx context.Context) *mTransactionUsecaseMockCreateTransactionByDTO <span class="cov0" title="0">{
        if mmCreateTransactionByDTO.mock.funcCreateTransactionByDTO != nil </span><span class="cov0" title="0">{
                mmCreateTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.CreateTransactionByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateTransactionByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateTransactionByDTO.defaultExpectation = &amp;TransactionUsecaseMockCreateTransactionByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateTransactionByDTO.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreateTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.CreateTransactionByDTO mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreateTransactionByDTO.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreateTransactionByDTO.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockCreateTransactionByDTOParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreateTransactionByDTO.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmCreateTransactionByDTO.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmCreateTransactionByDTO</span>
}

// ExpectInParam2 sets up expected param in for TransactionUsecase.CreateTransactionByDTO
func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) ExpectInParam2(in mm_usecase.CreateTransactionDataInput) *mTransactionUsecaseMockCreateTransactionByDTO <span class="cov0" title="0">{
        if mmCreateTransactionByDTO.mock.funcCreateTransactionByDTO != nil </span><span class="cov0" title="0">{
                mmCreateTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.CreateTransactionByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateTransactionByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateTransactionByDTO.defaultExpectation = &amp;TransactionUsecaseMockCreateTransactionByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateTransactionByDTO.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreateTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.CreateTransactionByDTO mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreateTransactionByDTO.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreateTransactionByDTO.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockCreateTransactionByDTOParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreateTransactionByDTO.defaultExpectation.paramPtrs.in = &amp;in
        mmCreateTransactionByDTO.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

        return mmCreateTransactionByDTO</span>
}

// Inspect accepts an inspector function that has same arguments as the TransactionUsecase.CreateTransactionByDTO
func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) Inspect(f func(ctx context.Context, in mm_usecase.CreateTransactionDataInput)) *mTransactionUsecaseMockCreateTransactionByDTO <span class="cov0" title="0">{
        if mmCreateTransactionByDTO.mock.inspectFuncCreateTransactionByDTO != nil </span><span class="cov0" title="0">{
                mmCreateTransactionByDTO.mock.t.Fatalf("Inspect function is already set for TransactionUsecaseMock.CreateTransactionByDTO")
        }</span>

        <span class="cov0" title="0">mmCreateTransactionByDTO.mock.inspectFuncCreateTransactionByDTO = f

        return mmCreateTransactionByDTO</span>
}

// Return sets up results that will be returned by TransactionUsecase.CreateTransactionByDTO
func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) Return(resTransactionDTO *mm_usecase.TransactionDTO, err error) *TransactionUsecaseMock <span class="cov0" title="0">{
        if mmCreateTransactionByDTO.mock.funcCreateTransactionByDTO != nil </span><span class="cov0" title="0">{
                mmCreateTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.CreateTransactionByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateTransactionByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateTransactionByDTO.defaultExpectation = &amp;TransactionUsecaseMockCreateTransactionByDTOExpectation{mock: mmCreateTransactionByDTO.mock}
        }</span>
        <span class="cov0" title="0">mmCreateTransactionByDTO.defaultExpectation.results = &amp;TransactionUsecaseMockCreateTransactionByDTOResults{resTransactionDTO, err}
        mmCreateTransactionByDTO.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmCreateTransactionByDTO.mock</span>
}

// Set uses given function f to mock the TransactionUsecase.CreateTransactionByDTO method
func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) Set(f func(ctx context.Context, in mm_usecase.CreateTransactionDataInput) (resTransactionDTO *mm_usecase.TransactionDTO, err error)) *TransactionUsecaseMock <span class="cov0" title="0">{
        if mmCreateTransactionByDTO.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmCreateTransactionByDTO.mock.t.Fatalf("Default expectation is already set for the TransactionUsecase.CreateTransactionByDTO method")
        }</span>

        <span class="cov0" title="0">if len(mmCreateTransactionByDTO.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmCreateTransactionByDTO.mock.t.Fatalf("Some expectations are already set for the TransactionUsecase.CreateTransactionByDTO method")
        }</span>

        <span class="cov0" title="0">mmCreateTransactionByDTO.mock.funcCreateTransactionByDTO = f
        mmCreateTransactionByDTO.mock.funcCreateTransactionByDTOOrigin = minimock.CallerInfo(1)
        return mmCreateTransactionByDTO.mock</span>
}

// When sets expectation for the TransactionUsecase.CreateTransactionByDTO which will trigger the result defined by the following
// Then helper
func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) When(ctx context.Context, in mm_usecase.CreateTransactionDataInput) *TransactionUsecaseMockCreateTransactionByDTOExpectation <span class="cov0" title="0">{
        if mmCreateTransactionByDTO.mock.funcCreateTransactionByDTO != nil </span><span class="cov0" title="0">{
                mmCreateTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.CreateTransactionByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TransactionUsecaseMockCreateTransactionByDTOExpectation{
                mock:               mmCreateTransactionByDTO.mock,
                params:             &amp;TransactionUsecaseMockCreateTransactionByDTOParams{ctx, in},
                expectationOrigins: TransactionUsecaseMockCreateTransactionByDTOExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmCreateTransactionByDTO.expectations = append(mmCreateTransactionByDTO.expectations, expectation)
        return expectation</span>
}

// Then sets up TransactionUsecase.CreateTransactionByDTO return parameters for the expectation previously defined by the When method
func (e *TransactionUsecaseMockCreateTransactionByDTOExpectation) Then(resTransactionDTO *mm_usecase.TransactionDTO, err error) *TransactionUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;TransactionUsecaseMockCreateTransactionByDTOResults{resTransactionDTO, err}
        return e.mock
}</span>

// Times sets number of times TransactionUsecase.CreateTransactionByDTO should be invoked
func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) Times(n uint64) *mTransactionUsecaseMockCreateTransactionByDTO <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmCreateTransactionByDTO.mock.t.Fatalf("Times of TransactionUsecaseMock.CreateTransactionByDTO mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmCreateTransactionByDTO.expectedInvocations, n)
        mmCreateTransactionByDTO.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmCreateTransactionByDTO</span>
}

func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmCreateTransactionByDTO.expectations) == 0 &amp;&amp; mmCreateTransactionByDTO.defaultExpectation == nil &amp;&amp; mmCreateTransactionByDTO.mock.funcCreateTransactionByDTO == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmCreateTransactionByDTO.mock.afterCreateTransactionByDTOCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmCreateTransactionByDTO.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// CreateTransactionByDTO implements mm_usecase.TransactionUsecase
func (mmCreateTransactionByDTO *TransactionUsecaseMock) CreateTransactionByDTO(ctx context.Context, in mm_usecase.CreateTransactionDataInput) (resTransactionDTO *mm_usecase.TransactionDTO, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmCreateTransactionByDTO.beforeCreateTransactionByDTOCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmCreateTransactionByDTO.afterCreateTransactionByDTOCounter, 1)

        mmCreateTransactionByDTO.t.Helper()

        if mmCreateTransactionByDTO.inspectFuncCreateTransactionByDTO != nil </span><span class="cov0" title="0">{
                mmCreateTransactionByDTO.inspectFuncCreateTransactionByDTO(ctx, in)
        }</span>

        <span class="cov0" title="0">mm_params := TransactionUsecaseMockCreateTransactionByDTOParams{ctx, in}

        // Record call args
        mmCreateTransactionByDTO.CreateTransactionByDTOMock.mutex.Lock()
        mmCreateTransactionByDTO.CreateTransactionByDTOMock.callArgs = append(mmCreateTransactionByDTO.CreateTransactionByDTOMock.callArgs, &amp;mm_params)
        mmCreateTransactionByDTO.CreateTransactionByDTOMock.mutex.Unlock()

        for _, e := range mmCreateTransactionByDTO.CreateTransactionByDTOMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.resTransactionDTO, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmCreateTransactionByDTO.CreateTransactionByDTOMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmCreateTransactionByDTO.CreateTransactionByDTOMock.defaultExpectation.Counter, 1)
                mm_want := mmCreateTransactionByDTO.CreateTransactionByDTOMock.defaultExpectation.params
                mm_want_ptrs := mmCreateTransactionByDTO.CreateTransactionByDTOMock.defaultExpectation.paramPtrs

                mm_got := TransactionUsecaseMockCreateTransactionByDTOParams{ctx, in}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmCreateTransactionByDTO.t.Errorf("TransactionUsecaseMock.CreateTransactionByDTO got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCreateTransactionByDTO.CreateTransactionByDTOMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.in != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.in, mm_got.in) </span><span class="cov0" title="0">{
                                mmCreateTransactionByDTO.t.Errorf("TransactionUsecaseMock.CreateTransactionByDTO got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCreateTransactionByDTO.CreateTransactionByDTOMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmCreateTransactionByDTO.t.Errorf("TransactionUsecaseMock.CreateTransactionByDTO got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmCreateTransactionByDTO.CreateTransactionByDTOMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmCreateTransactionByDTO.CreateTransactionByDTOMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmCreateTransactionByDTO.t.Fatal("No results are set for the TransactionUsecaseMock.CreateTransactionByDTO")
                }</span>
                <span class="cov0" title="0">return (*mm_results).resTransactionDTO, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmCreateTransactionByDTO.funcCreateTransactionByDTO != nil </span><span class="cov0" title="0">{
                return mmCreateTransactionByDTO.funcCreateTransactionByDTO(ctx, in)
        }</span>
        <span class="cov0" title="0">mmCreateTransactionByDTO.t.Fatalf("Unexpected call to TransactionUsecaseMock.CreateTransactionByDTO. %v %v", ctx, in)
        return</span>
}

// CreateTransactionByDTOAfterCounter returns a count of finished TransactionUsecaseMock.CreateTransactionByDTO invocations
func (mmCreateTransactionByDTO *TransactionUsecaseMock) CreateTransactionByDTOAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreateTransactionByDTO.afterCreateTransactionByDTOCounter)
}</span>

// CreateTransactionByDTOBeforeCounter returns a count of TransactionUsecaseMock.CreateTransactionByDTO invocations
func (mmCreateTransactionByDTO *TransactionUsecaseMock) CreateTransactionByDTOBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreateTransactionByDTO.beforeCreateTransactionByDTOCounter)
}</span>

// Calls returns a list of arguments used in each call to TransactionUsecaseMock.CreateTransactionByDTO.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateTransactionByDTO *mTransactionUsecaseMockCreateTransactionByDTO) Calls() []*TransactionUsecaseMockCreateTransactionByDTOParams <span class="cov0" title="0">{
        mmCreateTransactionByDTO.mutex.RLock()

        argCopy := make([]*TransactionUsecaseMockCreateTransactionByDTOParams, len(mmCreateTransactionByDTO.callArgs))
        copy(argCopy, mmCreateTransactionByDTO.callArgs)

        mmCreateTransactionByDTO.mutex.RUnlock()

        return argCopy
}</span>

// MinimockCreateTransactionByDTODone returns true if the count of the CreateTransactionByDTO invocations corresponds
// the number of defined expectations
func (m *TransactionUsecaseMock) MinimockCreateTransactionByDTODone() bool <span class="cov0" title="0">{
        if m.CreateTransactionByDTOMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.CreateTransactionByDTOMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.CreateTransactionByDTOMock.invocationsDone()</span>
}

// MinimockCreateTransactionByDTOInspect logs each unmet expectation
func (m *TransactionUsecaseMock) MinimockCreateTransactionByDTOInspect() <span class="cov0" title="0">{
        for _, e := range m.CreateTransactionByDTOMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionUsecaseMock.CreateTransactionByDTO at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterCreateTransactionByDTOCounter := mm_atomic.LoadUint64(&amp;m.afterCreateTransactionByDTOCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.CreateTransactionByDTOMock.defaultExpectation != nil &amp;&amp; afterCreateTransactionByDTOCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.CreateTransactionByDTOMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionUsecaseMock.CreateTransactionByDTO at\n%s", m.CreateTransactionByDTOMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TransactionUsecaseMock.CreateTransactionByDTO at\n%s with params: %#v", m.CreateTransactionByDTOMock.defaultExpectation.expectationOrigins.origin, *m.CreateTransactionByDTOMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcCreateTransactionByDTO != nil &amp;&amp; afterCreateTransactionByDTOCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TransactionUsecaseMock.CreateTransactionByDTO at\n%s", m.funcCreateTransactionByDTOOrigin)
        }</span>

        <span class="cov0" title="0">if !m.CreateTransactionByDTOMock.invocationsDone() &amp;&amp; afterCreateTransactionByDTOCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TransactionUsecaseMock.CreateTransactionByDTO at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.CreateTransactionByDTOMock.expectedInvocations), m.CreateTransactionByDTOMock.expectedInvocationsOrigin, afterCreateTransactionByDTOCounter)
        }</span>
}

type mTransactionUsecaseMockDeleteTransactionByID struct {
        optional           bool
        mock               *TransactionUsecaseMock
        defaultExpectation *TransactionUsecaseMockDeleteTransactionByIDExpectation
        expectations       []*TransactionUsecaseMockDeleteTransactionByIDExpectation

        callArgs []*TransactionUsecaseMockDeleteTransactionByIDParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TransactionUsecaseMockDeleteTransactionByIDExpectation specifies expectation struct of the TransactionUsecase.DeleteTransactionByID
type TransactionUsecaseMockDeleteTransactionByIDExpectation struct {
        mock               *TransactionUsecaseMock
        params             *TransactionUsecaseMockDeleteTransactionByIDParams
        paramPtrs          *TransactionUsecaseMockDeleteTransactionByIDParamPtrs
        expectationOrigins TransactionUsecaseMockDeleteTransactionByIDExpectationOrigins
        results            *TransactionUsecaseMockDeleteTransactionByIDResults
        returnOrigin       string
        Counter            uint64
}

// TransactionUsecaseMockDeleteTransactionByIDParams contains parameters of the TransactionUsecase.DeleteTransactionByID
type TransactionUsecaseMockDeleteTransactionByIDParams struct {
        ctx context.Context
        id  uuid.UUID
}

// TransactionUsecaseMockDeleteTransactionByIDParamPtrs contains pointers to parameters of the TransactionUsecase.DeleteTransactionByID
type TransactionUsecaseMockDeleteTransactionByIDParamPtrs struct {
        ctx *context.Context
        id  *uuid.UUID
}

// TransactionUsecaseMockDeleteTransactionByIDResults contains results of the TransactionUsecase.DeleteTransactionByID
type TransactionUsecaseMockDeleteTransactionByIDResults struct {
        err error
}

// TransactionUsecaseMockDeleteTransactionByIDOrigins contains origins of expectations of the TransactionUsecase.DeleteTransactionByID
type TransactionUsecaseMockDeleteTransactionByIDExpectationOrigins struct {
        origin    string
        originCtx string
        originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) Optional() *mTransactionUsecaseMockDeleteTransactionByID <span class="cov0" title="0">{
        mmDeleteTransactionByID.optional = true
        return mmDeleteTransactionByID
}</span>

// Expect sets up expected params for TransactionUsecase.DeleteTransactionByID
func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) Expect(ctx context.Context, id uuid.UUID) *mTransactionUsecaseMockDeleteTransactionByID <span class="cov0" title="0">{
        if mmDeleteTransactionByID.mock.funcDeleteTransactionByID != nil </span><span class="cov0" title="0">{
                mmDeleteTransactionByID.mock.t.Fatalf("TransactionUsecaseMock.DeleteTransactionByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteTransactionByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteTransactionByID.defaultExpectation = &amp;TransactionUsecaseMockDeleteTransactionByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteTransactionByID.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmDeleteTransactionByID.mock.t.Fatalf("TransactionUsecaseMock.DeleteTransactionByID mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmDeleteTransactionByID.defaultExpectation.params = &amp;TransactionUsecaseMockDeleteTransactionByIDParams{ctx, id}
        mmDeleteTransactionByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmDeleteTransactionByID.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmDeleteTransactionByID.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmDeleteTransactionByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteTransactionByID.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmDeleteTransactionByID</span>
}

// ExpectCtxParam1 sets up expected param ctx for TransactionUsecase.DeleteTransactionByID
func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) ExpectCtxParam1(ctx context.Context) *mTransactionUsecaseMockDeleteTransactionByID <span class="cov0" title="0">{
        if mmDeleteTransactionByID.mock.funcDeleteTransactionByID != nil </span><span class="cov0" title="0">{
                mmDeleteTransactionByID.mock.t.Fatalf("TransactionUsecaseMock.DeleteTransactionByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteTransactionByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteTransactionByID.defaultExpectation = &amp;TransactionUsecaseMockDeleteTransactionByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteTransactionByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDeleteTransactionByID.mock.t.Fatalf("TransactionUsecaseMock.DeleteTransactionByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDeleteTransactionByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDeleteTransactionByID.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockDeleteTransactionByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDeleteTransactionByID.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmDeleteTransactionByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmDeleteTransactionByID</span>
}

// ExpectIdParam2 sets up expected param id for TransactionUsecase.DeleteTransactionByID
func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) ExpectIdParam2(id uuid.UUID) *mTransactionUsecaseMockDeleteTransactionByID <span class="cov0" title="0">{
        if mmDeleteTransactionByID.mock.funcDeleteTransactionByID != nil </span><span class="cov0" title="0">{
                mmDeleteTransactionByID.mock.t.Fatalf("TransactionUsecaseMock.DeleteTransactionByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteTransactionByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteTransactionByID.defaultExpectation = &amp;TransactionUsecaseMockDeleteTransactionByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteTransactionByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDeleteTransactionByID.mock.t.Fatalf("TransactionUsecaseMock.DeleteTransactionByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDeleteTransactionByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDeleteTransactionByID.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockDeleteTransactionByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDeleteTransactionByID.defaultExpectation.paramPtrs.id = &amp;id
        mmDeleteTransactionByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmDeleteTransactionByID</span>
}

// Inspect accepts an inspector function that has same arguments as the TransactionUsecase.DeleteTransactionByID
func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) Inspect(f func(ctx context.Context, id uuid.UUID)) *mTransactionUsecaseMockDeleteTransactionByID <span class="cov0" title="0">{
        if mmDeleteTransactionByID.mock.inspectFuncDeleteTransactionByID != nil </span><span class="cov0" title="0">{
                mmDeleteTransactionByID.mock.t.Fatalf("Inspect function is already set for TransactionUsecaseMock.DeleteTransactionByID")
        }</span>

        <span class="cov0" title="0">mmDeleteTransactionByID.mock.inspectFuncDeleteTransactionByID = f

        return mmDeleteTransactionByID</span>
}

// Return sets up results that will be returned by TransactionUsecase.DeleteTransactionByID
func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) Return(err error) *TransactionUsecaseMock <span class="cov0" title="0">{
        if mmDeleteTransactionByID.mock.funcDeleteTransactionByID != nil </span><span class="cov0" title="0">{
                mmDeleteTransactionByID.mock.t.Fatalf("TransactionUsecaseMock.DeleteTransactionByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteTransactionByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteTransactionByID.defaultExpectation = &amp;TransactionUsecaseMockDeleteTransactionByIDExpectation{mock: mmDeleteTransactionByID.mock}
        }</span>
        <span class="cov0" title="0">mmDeleteTransactionByID.defaultExpectation.results = &amp;TransactionUsecaseMockDeleteTransactionByIDResults{err}
        mmDeleteTransactionByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmDeleteTransactionByID.mock</span>
}

// Set uses given function f to mock the TransactionUsecase.DeleteTransactionByID method
func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *TransactionUsecaseMock <span class="cov0" title="0">{
        if mmDeleteTransactionByID.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmDeleteTransactionByID.mock.t.Fatalf("Default expectation is already set for the TransactionUsecase.DeleteTransactionByID method")
        }</span>

        <span class="cov0" title="0">if len(mmDeleteTransactionByID.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmDeleteTransactionByID.mock.t.Fatalf("Some expectations are already set for the TransactionUsecase.DeleteTransactionByID method")
        }</span>

        <span class="cov0" title="0">mmDeleteTransactionByID.mock.funcDeleteTransactionByID = f
        mmDeleteTransactionByID.mock.funcDeleteTransactionByIDOrigin = minimock.CallerInfo(1)
        return mmDeleteTransactionByID.mock</span>
}

// When sets expectation for the TransactionUsecase.DeleteTransactionByID which will trigger the result defined by the following
// Then helper
func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) When(ctx context.Context, id uuid.UUID) *TransactionUsecaseMockDeleteTransactionByIDExpectation <span class="cov0" title="0">{
        if mmDeleteTransactionByID.mock.funcDeleteTransactionByID != nil </span><span class="cov0" title="0">{
                mmDeleteTransactionByID.mock.t.Fatalf("TransactionUsecaseMock.DeleteTransactionByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TransactionUsecaseMockDeleteTransactionByIDExpectation{
                mock:               mmDeleteTransactionByID.mock,
                params:             &amp;TransactionUsecaseMockDeleteTransactionByIDParams{ctx, id},
                expectationOrigins: TransactionUsecaseMockDeleteTransactionByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmDeleteTransactionByID.expectations = append(mmDeleteTransactionByID.expectations, expectation)
        return expectation</span>
}

// Then sets up TransactionUsecase.DeleteTransactionByID return parameters for the expectation previously defined by the When method
func (e *TransactionUsecaseMockDeleteTransactionByIDExpectation) Then(err error) *TransactionUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;TransactionUsecaseMockDeleteTransactionByIDResults{err}
        return e.mock
}</span>

// Times sets number of times TransactionUsecase.DeleteTransactionByID should be invoked
func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) Times(n uint64) *mTransactionUsecaseMockDeleteTransactionByID <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmDeleteTransactionByID.mock.t.Fatalf("Times of TransactionUsecaseMock.DeleteTransactionByID mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmDeleteTransactionByID.expectedInvocations, n)
        mmDeleteTransactionByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmDeleteTransactionByID</span>
}

func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmDeleteTransactionByID.expectations) == 0 &amp;&amp; mmDeleteTransactionByID.defaultExpectation == nil &amp;&amp; mmDeleteTransactionByID.mock.funcDeleteTransactionByID == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmDeleteTransactionByID.mock.afterDeleteTransactionByIDCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmDeleteTransactionByID.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// DeleteTransactionByID implements mm_usecase.TransactionUsecase
func (mmDeleteTransactionByID *TransactionUsecaseMock) DeleteTransactionByID(ctx context.Context, id uuid.UUID) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmDeleteTransactionByID.beforeDeleteTransactionByIDCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmDeleteTransactionByID.afterDeleteTransactionByIDCounter, 1)

        mmDeleteTransactionByID.t.Helper()

        if mmDeleteTransactionByID.inspectFuncDeleteTransactionByID != nil </span><span class="cov0" title="0">{
                mmDeleteTransactionByID.inspectFuncDeleteTransactionByID(ctx, id)
        }</span>

        <span class="cov0" title="0">mm_params := TransactionUsecaseMockDeleteTransactionByIDParams{ctx, id}

        // Record call args
        mmDeleteTransactionByID.DeleteTransactionByIDMock.mutex.Lock()
        mmDeleteTransactionByID.DeleteTransactionByIDMock.callArgs = append(mmDeleteTransactionByID.DeleteTransactionByIDMock.callArgs, &amp;mm_params)
        mmDeleteTransactionByID.DeleteTransactionByIDMock.mutex.Unlock()

        for _, e := range mmDeleteTransactionByID.DeleteTransactionByIDMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmDeleteTransactionByID.DeleteTransactionByIDMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmDeleteTransactionByID.DeleteTransactionByIDMock.defaultExpectation.Counter, 1)
                mm_want := mmDeleteTransactionByID.DeleteTransactionByIDMock.defaultExpectation.params
                mm_want_ptrs := mmDeleteTransactionByID.DeleteTransactionByIDMock.defaultExpectation.paramPtrs

                mm_got := TransactionUsecaseMockDeleteTransactionByIDParams{ctx, id}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmDeleteTransactionByID.t.Errorf("TransactionUsecaseMock.DeleteTransactionByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmDeleteTransactionByID.DeleteTransactionByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmDeleteTransactionByID.t.Errorf("TransactionUsecaseMock.DeleteTransactionByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmDeleteTransactionByID.DeleteTransactionByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmDeleteTransactionByID.t.Errorf("TransactionUsecaseMock.DeleteTransactionByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmDeleteTransactionByID.DeleteTransactionByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmDeleteTransactionByID.DeleteTransactionByIDMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmDeleteTransactionByID.t.Fatal("No results are set for the TransactionUsecaseMock.DeleteTransactionByID")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmDeleteTransactionByID.funcDeleteTransactionByID != nil </span><span class="cov0" title="0">{
                return mmDeleteTransactionByID.funcDeleteTransactionByID(ctx, id)
        }</span>
        <span class="cov0" title="0">mmDeleteTransactionByID.t.Fatalf("Unexpected call to TransactionUsecaseMock.DeleteTransactionByID. %v %v", ctx, id)
        return</span>
}

// DeleteTransactionByIDAfterCounter returns a count of finished TransactionUsecaseMock.DeleteTransactionByID invocations
func (mmDeleteTransactionByID *TransactionUsecaseMock) DeleteTransactionByIDAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDeleteTransactionByID.afterDeleteTransactionByIDCounter)
}</span>

// DeleteTransactionByIDBeforeCounter returns a count of TransactionUsecaseMock.DeleteTransactionByID invocations
func (mmDeleteTransactionByID *TransactionUsecaseMock) DeleteTransactionByIDBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDeleteTransactionByID.beforeDeleteTransactionByIDCounter)
}</span>

// Calls returns a list of arguments used in each call to TransactionUsecaseMock.DeleteTransactionByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteTransactionByID *mTransactionUsecaseMockDeleteTransactionByID) Calls() []*TransactionUsecaseMockDeleteTransactionByIDParams <span class="cov0" title="0">{
        mmDeleteTransactionByID.mutex.RLock()

        argCopy := make([]*TransactionUsecaseMockDeleteTransactionByIDParams, len(mmDeleteTransactionByID.callArgs))
        copy(argCopy, mmDeleteTransactionByID.callArgs)

        mmDeleteTransactionByID.mutex.RUnlock()

        return argCopy
}</span>

// MinimockDeleteTransactionByIDDone returns true if the count of the DeleteTransactionByID invocations corresponds
// the number of defined expectations
func (m *TransactionUsecaseMock) MinimockDeleteTransactionByIDDone() bool <span class="cov0" title="0">{
        if m.DeleteTransactionByIDMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.DeleteTransactionByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.DeleteTransactionByIDMock.invocationsDone()</span>
}

// MinimockDeleteTransactionByIDInspect logs each unmet expectation
func (m *TransactionUsecaseMock) MinimockDeleteTransactionByIDInspect() <span class="cov0" title="0">{
        for _, e := range m.DeleteTransactionByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionUsecaseMock.DeleteTransactionByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterDeleteTransactionByIDCounter := mm_atomic.LoadUint64(&amp;m.afterDeleteTransactionByIDCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.DeleteTransactionByIDMock.defaultExpectation != nil &amp;&amp; afterDeleteTransactionByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.DeleteTransactionByIDMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionUsecaseMock.DeleteTransactionByID at\n%s", m.DeleteTransactionByIDMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TransactionUsecaseMock.DeleteTransactionByID at\n%s with params: %#v", m.DeleteTransactionByIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteTransactionByIDMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcDeleteTransactionByID != nil &amp;&amp; afterDeleteTransactionByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TransactionUsecaseMock.DeleteTransactionByID at\n%s", m.funcDeleteTransactionByIDOrigin)
        }</span>

        <span class="cov0" title="0">if !m.DeleteTransactionByIDMock.invocationsDone() &amp;&amp; afterDeleteTransactionByIDCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TransactionUsecaseMock.DeleteTransactionByID at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.DeleteTransactionByIDMock.expectedInvocations), m.DeleteTransactionByIDMock.expectedInvocationsOrigin, afterDeleteTransactionByIDCounter)
        }</span>
}

type mTransactionUsecaseMockFindList struct {
        optional           bool
        mock               *TransactionUsecaseMock
        defaultExpectation *TransactionUsecaseMockFindListExpectation
        expectations       []*TransactionUsecaseMockFindListExpectation

        callArgs []*TransactionUsecaseMockFindListParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TransactionUsecaseMockFindListExpectation specifies expectation struct of the TransactionUsecase.FindList
type TransactionUsecaseMockFindListExpectation struct {
        mock               *TransactionUsecaseMock
        params             *TransactionUsecaseMockFindListParams
        paramPtrs          *TransactionUsecaseMockFindListParamPtrs
        expectationOrigins TransactionUsecaseMockFindListExpectationOrigins
        results            *TransactionUsecaseMockFindListResults
        returnOrigin       string
        Counter            uint64
}

// TransactionUsecaseMockFindListParams contains parameters of the TransactionUsecase.FindList
type TransactionUsecaseMockFindListParams struct {
        ctx         context.Context
        listOptions *mm_usecase.TransactionListOptions
        queryParams *uctypes.QueryGetListParams
}

// TransactionUsecaseMockFindListParamPtrs contains pointers to parameters of the TransactionUsecase.FindList
type TransactionUsecaseMockFindListParamPtrs struct {
        ctx         *context.Context
        listOptions **mm_usecase.TransactionListOptions
        queryParams **uctypes.QueryGetListParams
}

// TransactionUsecaseMockFindListResults contains results of the TransactionUsecase.FindList
type TransactionUsecaseMockFindListResults struct {
        resItems []*mm_usecase.TransactionDTO
        err      error
}

// TransactionUsecaseMockFindListOrigins contains origins of expectations of the TransactionUsecase.FindList
type TransactionUsecaseMockFindListExpectationOrigins struct {
        origin            string
        originCtx         string
        originListOptions string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindList *mTransactionUsecaseMockFindList) Optional() *mTransactionUsecaseMockFindList <span class="cov0" title="0">{
        mmFindList.optional = true
        return mmFindList
}</span>

// Expect sets up expected params for TransactionUsecase.FindList
func (mmFindList *mTransactionUsecaseMockFindList) Expect(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *mTransactionUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("TransactionUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;TransactionUsecaseMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("TransactionUsecaseMock.FindList mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindList.defaultExpectation.params = &amp;TransactionUsecaseMockFindListParams{ctx, listOptions, queryParams}
        mmFindList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindList.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindList.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindList.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindList</span>
}

// ExpectCtxParam1 sets up expected param ctx for TransactionUsecase.FindList
func (mmFindList *mTransactionUsecaseMockFindList) ExpectCtxParam1(ctx context.Context) *mTransactionUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("TransactionUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;TransactionUsecaseMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("TransactionUsecaseMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindList</span>
}

// ExpectListOptionsParam2 sets up expected param listOptions for TransactionUsecase.FindList
func (mmFindList *mTransactionUsecaseMockFindList) ExpectListOptionsParam2(listOptions *mm_usecase.TransactionListOptions) *mTransactionUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("TransactionUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;TransactionUsecaseMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("TransactionUsecaseMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.listOptions = &amp;listOptions
        mmFindList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

        return mmFindList</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for TransactionUsecase.FindList
func (mmFindList *mTransactionUsecaseMockFindList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mTransactionUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("TransactionUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;TransactionUsecaseMockFindListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("TransactionUsecaseMock.FindList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockFindListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindList</span>
}

// Inspect accepts an inspector function that has same arguments as the TransactionUsecase.FindList
func (mmFindList *mTransactionUsecaseMockFindList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)) *mTransactionUsecaseMockFindList <span class="cov0" title="0">{
        if mmFindList.mock.inspectFuncFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Inspect function is already set for TransactionUsecaseMock.FindList")
        }</span>

        <span class="cov0" title="0">mmFindList.mock.inspectFuncFindList = f

        return mmFindList</span>
}

// Return sets up results that will be returned by TransactionUsecase.FindList
func (mmFindList *mTransactionUsecaseMockFindList) Return(resItems []*mm_usecase.TransactionDTO, err error) *TransactionUsecaseMock <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("TransactionUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindList.defaultExpectation = &amp;TransactionUsecaseMockFindListExpectation{mock: mmFindList.mock}
        }</span>
        <span class="cov0" title="0">mmFindList.defaultExpectation.results = &amp;TransactionUsecaseMockFindListResults{resItems, err}
        mmFindList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindList.mock</span>
}

// Set uses given function f to mock the TransactionUsecase.FindList method
func (mmFindList *mTransactionUsecaseMockFindList) Set(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.TransactionDTO, err error)) *TransactionUsecaseMock <span class="cov0" title="0">{
        if mmFindList.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Default expectation is already set for the TransactionUsecase.FindList method")
        }</span>

        <span class="cov0" title="0">if len(mmFindList.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Some expectations are already set for the TransactionUsecase.FindList method")
        }</span>

        <span class="cov0" title="0">mmFindList.mock.funcFindList = f
        mmFindList.mock.funcFindListOrigin = minimock.CallerInfo(1)
        return mmFindList.mock</span>
}

// When sets expectation for the TransactionUsecase.FindList which will trigger the result defined by the following
// Then helper
func (mmFindList *mTransactionUsecaseMockFindList) When(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *TransactionUsecaseMockFindListExpectation <span class="cov0" title="0">{
        if mmFindList.mock.funcFindList != nil </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("TransactionUsecaseMock.FindList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TransactionUsecaseMockFindListExpectation{
                mock:               mmFindList.mock,
                params:             &amp;TransactionUsecaseMockFindListParams{ctx, listOptions, queryParams},
                expectationOrigins: TransactionUsecaseMockFindListExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindList.expectations = append(mmFindList.expectations, expectation)
        return expectation</span>
}

// Then sets up TransactionUsecase.FindList return parameters for the expectation previously defined by the When method
func (e *TransactionUsecaseMockFindListExpectation) Then(resItems []*mm_usecase.TransactionDTO, err error) *TransactionUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;TransactionUsecaseMockFindListResults{resItems, err}
        return e.mock
}</span>

// Times sets number of times TransactionUsecase.FindList should be invoked
func (mmFindList *mTransactionUsecaseMockFindList) Times(n uint64) *mTransactionUsecaseMockFindList <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindList.mock.t.Fatalf("Times of TransactionUsecaseMock.FindList mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindList.expectedInvocations, n)
        mmFindList.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindList</span>
}

func (mmFindList *mTransactionUsecaseMockFindList) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindList.expectations) == 0 &amp;&amp; mmFindList.defaultExpectation == nil &amp;&amp; mmFindList.mock.funcFindList == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindList.mock.afterFindListCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindList.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindList implements mm_usecase.TransactionUsecase
func (mmFindList *TransactionUsecaseMock) FindList(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.TransactionDTO, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindList.beforeFindListCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindList.afterFindListCounter, 1)

        mmFindList.t.Helper()

        if mmFindList.inspectFuncFindList != nil </span><span class="cov0" title="0">{
                mmFindList.inspectFuncFindList(ctx, listOptions, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := TransactionUsecaseMockFindListParams{ctx, listOptions, queryParams}

        // Record call args
        mmFindList.FindListMock.mutex.Lock()
        mmFindList.FindListMock.callArgs = append(mmFindList.FindListMock.callArgs, &amp;mm_params)
        mmFindList.FindListMock.mutex.Unlock()

        for _, e := range mmFindList.FindListMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.resItems, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindList.FindListMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindList.FindListMock.defaultExpectation.Counter, 1)
                mm_want := mmFindList.FindListMock.defaultExpectation.params
                mm_want_ptrs := mmFindList.FindListMock.defaultExpectation.paramPtrs

                mm_got := TransactionUsecaseMockFindListParams{ctx, listOptions, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("TransactionUsecaseMock.FindList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.listOptions != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("TransactionUsecaseMock.FindList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindList.t.Errorf("TransactionUsecaseMock.FindList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindList.FindListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindList.t.Errorf("TransactionUsecaseMock.FindList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindList.FindListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindList.FindListMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindList.t.Fatal("No results are set for the TransactionUsecaseMock.FindList")
                }</span>
                <span class="cov0" title="0">return (*mm_results).resItems, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindList.funcFindList != nil </span><span class="cov0" title="0">{
                return mmFindList.funcFindList(ctx, listOptions, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindList.t.Fatalf("Unexpected call to TransactionUsecaseMock.FindList. %v %v %v", ctx, listOptions, queryParams)
        return</span>
}

// FindListAfterCounter returns a count of finished TransactionUsecaseMock.FindList invocations
func (mmFindList *TransactionUsecaseMock) FindListAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindList.afterFindListCounter)
}</span>

// FindListBeforeCounter returns a count of TransactionUsecaseMock.FindList invocations
func (mmFindList *TransactionUsecaseMock) FindListBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindList.beforeFindListCounter)
}</span>

// Calls returns a list of arguments used in each call to TransactionUsecaseMock.FindList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindList *mTransactionUsecaseMockFindList) Calls() []*TransactionUsecaseMockFindListParams <span class="cov0" title="0">{
        mmFindList.mutex.RLock()

        argCopy := make([]*TransactionUsecaseMockFindListParams, len(mmFindList.callArgs))
        copy(argCopy, mmFindList.callArgs)

        mmFindList.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindListDone returns true if the count of the FindList invocations corresponds
// the number of defined expectations
func (m *TransactionUsecaseMock) MinimockFindListDone() bool <span class="cov0" title="0">{
        if m.FindListMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindListMock.invocationsDone()</span>
}

// MinimockFindListInspect logs each unmet expectation
func (m *TransactionUsecaseMock) MinimockFindListInspect() <span class="cov0" title="0">{
        for _, e := range m.FindListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionUsecaseMock.FindList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindListCounter := mm_atomic.LoadUint64(&amp;m.afterFindListCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindListMock.defaultExpectation != nil &amp;&amp; afterFindListCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindListMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionUsecaseMock.FindList at\n%s", m.FindListMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TransactionUsecaseMock.FindList at\n%s with params: %#v", m.FindListMock.defaultExpectation.expectationOrigins.origin, *m.FindListMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindList != nil &amp;&amp; afterFindListCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TransactionUsecaseMock.FindList at\n%s", m.funcFindListOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindListMock.invocationsDone() &amp;&amp; afterFindListCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TransactionUsecaseMock.FindList at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindListMock.expectedInvocations), m.FindListMock.expectedInvocationsOrigin, afterFindListCounter)
        }</span>
}

type mTransactionUsecaseMockFindListInMap struct {
        optional           bool
        mock               *TransactionUsecaseMock
        defaultExpectation *TransactionUsecaseMockFindListInMapExpectation
        expectations       []*TransactionUsecaseMockFindListInMapExpectation

        callArgs []*TransactionUsecaseMockFindListInMapParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TransactionUsecaseMockFindListInMapExpectation specifies expectation struct of the TransactionUsecase.FindListInMap
type TransactionUsecaseMockFindListInMapExpectation struct {
        mock               *TransactionUsecaseMock
        params             *TransactionUsecaseMockFindListInMapParams
        paramPtrs          *TransactionUsecaseMockFindListInMapParamPtrs
        expectationOrigins TransactionUsecaseMockFindListInMapExpectationOrigins
        results            *TransactionUsecaseMockFindListInMapResults
        returnOrigin       string
        Counter            uint64
}

// TransactionUsecaseMockFindListInMapParams contains parameters of the TransactionUsecase.FindListInMap
type TransactionUsecaseMockFindListInMapParams struct {
        ctx         context.Context
        listOptions *mm_usecase.TransactionListOptions
        queryParams *uctypes.QueryGetListParams
}

// TransactionUsecaseMockFindListInMapParamPtrs contains pointers to parameters of the TransactionUsecase.FindListInMap
type TransactionUsecaseMockFindListInMapParamPtrs struct {
        ctx         *context.Context
        listOptions **mm_usecase.TransactionListOptions
        queryParams **uctypes.QueryGetListParams
}

// TransactionUsecaseMockFindListInMapResults contains results of the TransactionUsecase.FindListInMap
type TransactionUsecaseMockFindListInMapResults struct {
        resItems map[uuid.UUID]*mm_usecase.TransactionDTO
        err      error
}

// TransactionUsecaseMockFindListInMapOrigins contains origins of expectations of the TransactionUsecase.FindListInMap
type TransactionUsecaseMockFindListInMapExpectationOrigins struct {
        origin            string
        originCtx         string
        originListOptions string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) Optional() *mTransactionUsecaseMockFindListInMap <span class="cov0" title="0">{
        mmFindListInMap.optional = true
        return mmFindListInMap
}</span>

// Expect sets up expected params for TransactionUsecase.FindListInMap
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) Expect(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *mTransactionUsecaseMockFindListInMap <span class="cov0" title="0">{
        if mmFindListInMap.mock.funcFindListInMap != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("TransactionUsecaseMock.FindListInMap mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindListInMap.defaultExpectation = &amp;TransactionUsecaseMockFindListInMapExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("TransactionUsecaseMock.FindListInMap mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindListInMap.defaultExpectation.params = &amp;TransactionUsecaseMockFindListInMapParams{ctx, listOptions, queryParams}
        mmFindListInMap.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindListInMap.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindListInMap.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindListInMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindListInMap.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindListInMap</span>
}

// ExpectCtxParam1 sets up expected param ctx for TransactionUsecase.FindListInMap
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) ExpectCtxParam1(ctx context.Context) *mTransactionUsecaseMockFindListInMap <span class="cov0" title="0">{
        if mmFindListInMap.mock.funcFindListInMap != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("TransactionUsecaseMock.FindListInMap mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindListInMap.defaultExpectation = &amp;TransactionUsecaseMockFindListInMapExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("TransactionUsecaseMock.FindListInMap mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindListInMap.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockFindListInMapParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindListInMap.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindListInMap.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindListInMap</span>
}

// ExpectListOptionsParam2 sets up expected param listOptions for TransactionUsecase.FindListInMap
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) ExpectListOptionsParam2(listOptions *mm_usecase.TransactionListOptions) *mTransactionUsecaseMockFindListInMap <span class="cov0" title="0">{
        if mmFindListInMap.mock.funcFindListInMap != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("TransactionUsecaseMock.FindListInMap mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindListInMap.defaultExpectation = &amp;TransactionUsecaseMockFindListInMapExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("TransactionUsecaseMock.FindListInMap mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindListInMap.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockFindListInMapParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindListInMap.defaultExpectation.paramPtrs.listOptions = &amp;listOptions
        mmFindListInMap.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

        return mmFindListInMap</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for TransactionUsecase.FindListInMap
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mTransactionUsecaseMockFindListInMap <span class="cov0" title="0">{
        if mmFindListInMap.mock.funcFindListInMap != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("TransactionUsecaseMock.FindListInMap mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindListInMap.defaultExpectation = &amp;TransactionUsecaseMockFindListInMapExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("TransactionUsecaseMock.FindListInMap mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindListInMap.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockFindListInMapParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindListInMap.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindListInMap.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindListInMap</span>
}

// Inspect accepts an inspector function that has same arguments as the TransactionUsecase.FindListInMap
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) Inspect(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)) *mTransactionUsecaseMockFindListInMap <span class="cov0" title="0">{
        if mmFindListInMap.mock.inspectFuncFindListInMap != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("Inspect function is already set for TransactionUsecaseMock.FindListInMap")
        }</span>

        <span class="cov0" title="0">mmFindListInMap.mock.inspectFuncFindListInMap = f

        return mmFindListInMap</span>
}

// Return sets up results that will be returned by TransactionUsecase.FindListInMap
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) Return(resItems map[uuid.UUID]*mm_usecase.TransactionDTO, err error) *TransactionUsecaseMock <span class="cov0" title="0">{
        if mmFindListInMap.mock.funcFindListInMap != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("TransactionUsecaseMock.FindListInMap mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindListInMap.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindListInMap.defaultExpectation = &amp;TransactionUsecaseMockFindListInMapExpectation{mock: mmFindListInMap.mock}
        }</span>
        <span class="cov0" title="0">mmFindListInMap.defaultExpectation.results = &amp;TransactionUsecaseMockFindListInMapResults{resItems, err}
        mmFindListInMap.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindListInMap.mock</span>
}

// Set uses given function f to mock the TransactionUsecase.FindListInMap method
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) Set(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (resItems map[uuid.UUID]*mm_usecase.TransactionDTO, err error)) *TransactionUsecaseMock <span class="cov0" title="0">{
        if mmFindListInMap.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("Default expectation is already set for the TransactionUsecase.FindListInMap method")
        }</span>

        <span class="cov0" title="0">if len(mmFindListInMap.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("Some expectations are already set for the TransactionUsecase.FindListInMap method")
        }</span>

        <span class="cov0" title="0">mmFindListInMap.mock.funcFindListInMap = f
        mmFindListInMap.mock.funcFindListInMapOrigin = minimock.CallerInfo(1)
        return mmFindListInMap.mock</span>
}

// When sets expectation for the TransactionUsecase.FindListInMap which will trigger the result defined by the following
// Then helper
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) When(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *TransactionUsecaseMockFindListInMapExpectation <span class="cov0" title="0">{
        if mmFindListInMap.mock.funcFindListInMap != nil </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("TransactionUsecaseMock.FindListInMap mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TransactionUsecaseMockFindListInMapExpectation{
                mock:               mmFindListInMap.mock,
                params:             &amp;TransactionUsecaseMockFindListInMapParams{ctx, listOptions, queryParams},
                expectationOrigins: TransactionUsecaseMockFindListInMapExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindListInMap.expectations = append(mmFindListInMap.expectations, expectation)
        return expectation</span>
}

// Then sets up TransactionUsecase.FindListInMap return parameters for the expectation previously defined by the When method
func (e *TransactionUsecaseMockFindListInMapExpectation) Then(resItems map[uuid.UUID]*mm_usecase.TransactionDTO, err error) *TransactionUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;TransactionUsecaseMockFindListInMapResults{resItems, err}
        return e.mock
}</span>

// Times sets number of times TransactionUsecase.FindListInMap should be invoked
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) Times(n uint64) *mTransactionUsecaseMockFindListInMap <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindListInMap.mock.t.Fatalf("Times of TransactionUsecaseMock.FindListInMap mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindListInMap.expectedInvocations, n)
        mmFindListInMap.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindListInMap</span>
}

func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindListInMap.expectations) == 0 &amp;&amp; mmFindListInMap.defaultExpectation == nil &amp;&amp; mmFindListInMap.mock.funcFindListInMap == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindListInMap.mock.afterFindListInMapCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindListInMap.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindListInMap implements mm_usecase.TransactionUsecase
func (mmFindListInMap *TransactionUsecaseMock) FindListInMap(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (resItems map[uuid.UUID]*mm_usecase.TransactionDTO, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindListInMap.beforeFindListInMapCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindListInMap.afterFindListInMapCounter, 1)

        mmFindListInMap.t.Helper()

        if mmFindListInMap.inspectFuncFindListInMap != nil </span><span class="cov0" title="0">{
                mmFindListInMap.inspectFuncFindListInMap(ctx, listOptions, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := TransactionUsecaseMockFindListInMapParams{ctx, listOptions, queryParams}

        // Record call args
        mmFindListInMap.FindListInMapMock.mutex.Lock()
        mmFindListInMap.FindListInMapMock.callArgs = append(mmFindListInMap.FindListInMapMock.callArgs, &amp;mm_params)
        mmFindListInMap.FindListInMapMock.mutex.Unlock()

        for _, e := range mmFindListInMap.FindListInMapMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.resItems, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindListInMap.FindListInMapMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindListInMap.FindListInMapMock.defaultExpectation.Counter, 1)
                mm_want := mmFindListInMap.FindListInMapMock.defaultExpectation.params
                mm_want_ptrs := mmFindListInMap.FindListInMapMock.defaultExpectation.paramPtrs

                mm_got := TransactionUsecaseMockFindListInMapParams{ctx, listOptions, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindListInMap.t.Errorf("TransactionUsecaseMock.FindListInMap got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindListInMap.FindListInMapMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.listOptions != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) </span><span class="cov0" title="0">{
                                mmFindListInMap.t.Errorf("TransactionUsecaseMock.FindListInMap got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindListInMap.FindListInMapMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindListInMap.t.Errorf("TransactionUsecaseMock.FindListInMap got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindListInMap.FindListInMapMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindListInMap.t.Errorf("TransactionUsecaseMock.FindListInMap got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindListInMap.FindListInMapMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindListInMap.FindListInMapMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindListInMap.t.Fatal("No results are set for the TransactionUsecaseMock.FindListInMap")
                }</span>
                <span class="cov0" title="0">return (*mm_results).resItems, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindListInMap.funcFindListInMap != nil </span><span class="cov0" title="0">{
                return mmFindListInMap.funcFindListInMap(ctx, listOptions, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindListInMap.t.Fatalf("Unexpected call to TransactionUsecaseMock.FindListInMap. %v %v %v", ctx, listOptions, queryParams)
        return</span>
}

// FindListInMapAfterCounter returns a count of finished TransactionUsecaseMock.FindListInMap invocations
func (mmFindListInMap *TransactionUsecaseMock) FindListInMapAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindListInMap.afterFindListInMapCounter)
}</span>

// FindListInMapBeforeCounter returns a count of TransactionUsecaseMock.FindListInMap invocations
func (mmFindListInMap *TransactionUsecaseMock) FindListInMapBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindListInMap.beforeFindListInMapCounter)
}</span>

// Calls returns a list of arguments used in each call to TransactionUsecaseMock.FindListInMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindListInMap *mTransactionUsecaseMockFindListInMap) Calls() []*TransactionUsecaseMockFindListInMapParams <span class="cov0" title="0">{
        mmFindListInMap.mutex.RLock()

        argCopy := make([]*TransactionUsecaseMockFindListInMapParams, len(mmFindListInMap.callArgs))
        copy(argCopy, mmFindListInMap.callArgs)

        mmFindListInMap.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindListInMapDone returns true if the count of the FindListInMap invocations corresponds
// the number of defined expectations
func (m *TransactionUsecaseMock) MinimockFindListInMapDone() bool <span class="cov0" title="0">{
        if m.FindListInMapMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindListInMapMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindListInMapMock.invocationsDone()</span>
}

// MinimockFindListInMapInspect logs each unmet expectation
func (m *TransactionUsecaseMock) MinimockFindListInMapInspect() <span class="cov0" title="0">{
        for _, e := range m.FindListInMapMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionUsecaseMock.FindListInMap at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindListInMapCounter := mm_atomic.LoadUint64(&amp;m.afterFindListInMapCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindListInMapMock.defaultExpectation != nil &amp;&amp; afterFindListInMapCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindListInMapMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionUsecaseMock.FindListInMap at\n%s", m.FindListInMapMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TransactionUsecaseMock.FindListInMap at\n%s with params: %#v", m.FindListInMapMock.defaultExpectation.expectationOrigins.origin, *m.FindListInMapMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindListInMap != nil &amp;&amp; afterFindListInMapCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TransactionUsecaseMock.FindListInMap at\n%s", m.funcFindListInMapOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindListInMapMock.invocationsDone() &amp;&amp; afterFindListInMapCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TransactionUsecaseMock.FindListInMap at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindListInMapMock.expectedInvocations), m.FindListInMapMock.expectedInvocationsOrigin, afterFindListInMapCounter)
        }</span>
}

type mTransactionUsecaseMockFindOneByID struct {
        optional           bool
        mock               *TransactionUsecaseMock
        defaultExpectation *TransactionUsecaseMockFindOneByIDExpectation
        expectations       []*TransactionUsecaseMockFindOneByIDExpectation

        callArgs []*TransactionUsecaseMockFindOneByIDParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TransactionUsecaseMockFindOneByIDExpectation specifies expectation struct of the TransactionUsecase.FindOneByID
type TransactionUsecaseMockFindOneByIDExpectation struct {
        mock               *TransactionUsecaseMock
        params             *TransactionUsecaseMockFindOneByIDParams
        paramPtrs          *TransactionUsecaseMockFindOneByIDParamPtrs
        expectationOrigins TransactionUsecaseMockFindOneByIDExpectationOrigins
        results            *TransactionUsecaseMockFindOneByIDResults
        returnOrigin       string
        Counter            uint64
}

// TransactionUsecaseMockFindOneByIDParams contains parameters of the TransactionUsecase.FindOneByID
type TransactionUsecaseMockFindOneByIDParams struct {
        ctx         context.Context
        id          uuid.UUID
        queryParams *uctypes.QueryGetOneParams
}

// TransactionUsecaseMockFindOneByIDParamPtrs contains pointers to parameters of the TransactionUsecase.FindOneByID
type TransactionUsecaseMockFindOneByIDParamPtrs struct {
        ctx         *context.Context
        id          *uuid.UUID
        queryParams **uctypes.QueryGetOneParams
}

// TransactionUsecaseMockFindOneByIDResults contains results of the TransactionUsecase.FindOneByID
type TransactionUsecaseMockFindOneByIDResults struct {
        resItem *mm_usecase.TransactionDTO
        err     error
}

// TransactionUsecaseMockFindOneByIDOrigins contains origins of expectations of the TransactionUsecase.FindOneByID
type TransactionUsecaseMockFindOneByIDExpectationOrigins struct {
        origin            string
        originCtx         string
        originId          string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) Optional() *mTransactionUsecaseMockFindOneByID <span class="cov0" title="0">{
        mmFindOneByID.optional = true
        return mmFindOneByID
}</span>

// Expect sets up expected params for TransactionUsecase.FindOneByID
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) Expect(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *mTransactionUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("TransactionUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;TransactionUsecaseMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("TransactionUsecaseMock.FindOneByID mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.params = &amp;TransactionUsecaseMockFindOneByIDParams{ctx, id, queryParams}
        mmFindOneByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindOneByID.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindOneByID.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindOneByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindOneByID.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindOneByID</span>
}

// ExpectCtxParam1 sets up expected param ctx for TransactionUsecase.FindOneByID
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) ExpectCtxParam1(ctx context.Context) *mTransactionUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("TransactionUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;TransactionUsecaseMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("TransactionUsecaseMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindOneByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// ExpectIdParam2 sets up expected param id for TransactionUsecase.FindOneByID
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) ExpectIdParam2(id uuid.UUID) *mTransactionUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("TransactionUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;TransactionUsecaseMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("TransactionUsecaseMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.id = &amp;id
        mmFindOneByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for TransactionUsecase.FindOneByID
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetOneParams) *mTransactionUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("TransactionUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;TransactionUsecaseMockFindOneByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("TransactionUsecaseMock.FindOneByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockFindOneByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindOneByID.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindOneByID</span>
}

// Inspect accepts an inspector function that has same arguments as the TransactionUsecase.FindOneByID
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) Inspect(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams)) *mTransactionUsecaseMockFindOneByID <span class="cov0" title="0">{
        if mmFindOneByID.mock.inspectFuncFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Inspect function is already set for TransactionUsecaseMock.FindOneByID")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.mock.inspectFuncFindOneByID = f

        return mmFindOneByID</span>
}

// Return sets up results that will be returned by TransactionUsecase.FindOneByID
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) Return(resItem *mm_usecase.TransactionDTO, err error) *TransactionUsecaseMock <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("TransactionUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindOneByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindOneByID.defaultExpectation = &amp;TransactionUsecaseMockFindOneByIDExpectation{mock: mmFindOneByID.mock}
        }</span>
        <span class="cov0" title="0">mmFindOneByID.defaultExpectation.results = &amp;TransactionUsecaseMockFindOneByIDResults{resItem, err}
        mmFindOneByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindOneByID.mock</span>
}

// Set uses given function f to mock the TransactionUsecase.FindOneByID method
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) Set(f func(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (resItem *mm_usecase.TransactionDTO, err error)) *TransactionUsecaseMock <span class="cov0" title="0">{
        if mmFindOneByID.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Default expectation is already set for the TransactionUsecase.FindOneByID method")
        }</span>

        <span class="cov0" title="0">if len(mmFindOneByID.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Some expectations are already set for the TransactionUsecase.FindOneByID method")
        }</span>

        <span class="cov0" title="0">mmFindOneByID.mock.funcFindOneByID = f
        mmFindOneByID.mock.funcFindOneByIDOrigin = minimock.CallerInfo(1)
        return mmFindOneByID.mock</span>
}

// When sets expectation for the TransactionUsecase.FindOneByID which will trigger the result defined by the following
// Then helper
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) When(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) *TransactionUsecaseMockFindOneByIDExpectation <span class="cov0" title="0">{
        if mmFindOneByID.mock.funcFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("TransactionUsecaseMock.FindOneByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TransactionUsecaseMockFindOneByIDExpectation{
                mock:               mmFindOneByID.mock,
                params:             &amp;TransactionUsecaseMockFindOneByIDParams{ctx, id, queryParams},
                expectationOrigins: TransactionUsecaseMockFindOneByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindOneByID.expectations = append(mmFindOneByID.expectations, expectation)
        return expectation</span>
}

// Then sets up TransactionUsecase.FindOneByID return parameters for the expectation previously defined by the When method
func (e *TransactionUsecaseMockFindOneByIDExpectation) Then(resItem *mm_usecase.TransactionDTO, err error) *TransactionUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;TransactionUsecaseMockFindOneByIDResults{resItem, err}
        return e.mock
}</span>

// Times sets number of times TransactionUsecase.FindOneByID should be invoked
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) Times(n uint64) *mTransactionUsecaseMockFindOneByID <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindOneByID.mock.t.Fatalf("Times of TransactionUsecaseMock.FindOneByID mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindOneByID.expectedInvocations, n)
        mmFindOneByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindOneByID</span>
}

func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindOneByID.expectations) == 0 &amp;&amp; mmFindOneByID.defaultExpectation == nil &amp;&amp; mmFindOneByID.mock.funcFindOneByID == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByID.mock.afterFindOneByIDCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindOneByID.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindOneByID implements mm_usecase.TransactionUsecase
func (mmFindOneByID *TransactionUsecaseMock) FindOneByID(ctx context.Context, id uuid.UUID, queryParams *uctypes.QueryGetOneParams) (resItem *mm_usecase.TransactionDTO, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindOneByID.beforeFindOneByIDCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindOneByID.afterFindOneByIDCounter, 1)

        mmFindOneByID.t.Helper()

        if mmFindOneByID.inspectFuncFindOneByID != nil </span><span class="cov0" title="0">{
                mmFindOneByID.inspectFuncFindOneByID(ctx, id, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := TransactionUsecaseMockFindOneByIDParams{ctx, id, queryParams}

        // Record call args
        mmFindOneByID.FindOneByIDMock.mutex.Lock()
        mmFindOneByID.FindOneByIDMock.callArgs = append(mmFindOneByID.FindOneByIDMock.callArgs, &amp;mm_params)
        mmFindOneByID.FindOneByIDMock.mutex.Unlock()

        for _, e := range mmFindOneByID.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.resItem, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindOneByID.FindOneByIDMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindOneByID.FindOneByIDMock.defaultExpectation.Counter, 1)
                mm_want := mmFindOneByID.FindOneByIDMock.defaultExpectation.params
                mm_want_ptrs := mmFindOneByID.FindOneByIDMock.defaultExpectation.paramPtrs

                mm_got := TransactionUsecaseMockFindOneByIDParams{ctx, id, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("TransactionUsecaseMock.FindOneByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("TransactionUsecaseMock.FindOneByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindOneByID.t.Errorf("TransactionUsecaseMock.FindOneByID got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindOneByID.t.Errorf("TransactionUsecaseMock.FindOneByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindOneByID.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindOneByID.FindOneByIDMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindOneByID.t.Fatal("No results are set for the TransactionUsecaseMock.FindOneByID")
                }</span>
                <span class="cov0" title="0">return (*mm_results).resItem, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindOneByID.funcFindOneByID != nil </span><span class="cov0" title="0">{
                return mmFindOneByID.funcFindOneByID(ctx, id, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindOneByID.t.Fatalf("Unexpected call to TransactionUsecaseMock.FindOneByID. %v %v %v", ctx, id, queryParams)
        return</span>
}

// FindOneByIDAfterCounter returns a count of finished TransactionUsecaseMock.FindOneByID invocations
func (mmFindOneByID *TransactionUsecaseMock) FindOneByIDAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByID.afterFindOneByIDCounter)
}</span>

// FindOneByIDBeforeCounter returns a count of TransactionUsecaseMock.FindOneByID invocations
func (mmFindOneByID *TransactionUsecaseMock) FindOneByIDBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindOneByID.beforeFindOneByIDCounter)
}</span>

// Calls returns a list of arguments used in each call to TransactionUsecaseMock.FindOneByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindOneByID *mTransactionUsecaseMockFindOneByID) Calls() []*TransactionUsecaseMockFindOneByIDParams <span class="cov0" title="0">{
        mmFindOneByID.mutex.RLock()

        argCopy := make([]*TransactionUsecaseMockFindOneByIDParams, len(mmFindOneByID.callArgs))
        copy(argCopy, mmFindOneByID.callArgs)

        mmFindOneByID.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindOneByIDDone returns true if the count of the FindOneByID invocations corresponds
// the number of defined expectations
func (m *TransactionUsecaseMock) MinimockFindOneByIDDone() bool <span class="cov0" title="0">{
        if m.FindOneByIDMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindOneByIDMock.invocationsDone()</span>
}

// MinimockFindOneByIDInspect logs each unmet expectation
func (m *TransactionUsecaseMock) MinimockFindOneByIDInspect() <span class="cov0" title="0">{
        for _, e := range m.FindOneByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionUsecaseMock.FindOneByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindOneByIDCounter := mm_atomic.LoadUint64(&amp;m.afterFindOneByIDCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindOneByIDMock.defaultExpectation != nil &amp;&amp; afterFindOneByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindOneByIDMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionUsecaseMock.FindOneByID at\n%s", m.FindOneByIDMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TransactionUsecaseMock.FindOneByID at\n%s with params: %#v", m.FindOneByIDMock.defaultExpectation.expectationOrigins.origin, *m.FindOneByIDMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindOneByID != nil &amp;&amp; afterFindOneByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TransactionUsecaseMock.FindOneByID at\n%s", m.funcFindOneByIDOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindOneByIDMock.invocationsDone() &amp;&amp; afterFindOneByIDCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TransactionUsecaseMock.FindOneByID at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindOneByIDMock.expectedInvocations), m.FindOneByIDMock.expectedInvocationsOrigin, afterFindOneByIDCounter)
        }</span>
}

type mTransactionUsecaseMockFindPagedList struct {
        optional           bool
        mock               *TransactionUsecaseMock
        defaultExpectation *TransactionUsecaseMockFindPagedListExpectation
        expectations       []*TransactionUsecaseMockFindPagedListExpectation

        callArgs []*TransactionUsecaseMockFindPagedListParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TransactionUsecaseMockFindPagedListExpectation specifies expectation struct of the TransactionUsecase.FindPagedList
type TransactionUsecaseMockFindPagedListExpectation struct {
        mock               *TransactionUsecaseMock
        params             *TransactionUsecaseMockFindPagedListParams
        paramPtrs          *TransactionUsecaseMockFindPagedListParamPtrs
        expectationOrigins TransactionUsecaseMockFindPagedListExpectationOrigins
        results            *TransactionUsecaseMockFindPagedListResults
        returnOrigin       string
        Counter            uint64
}

// TransactionUsecaseMockFindPagedListParams contains parameters of the TransactionUsecase.FindPagedList
type TransactionUsecaseMockFindPagedListParams struct {
        ctx         context.Context
        listOptions *mm_usecase.TransactionListOptions
        queryParams *uctypes.QueryGetListParams
}

// TransactionUsecaseMockFindPagedListParamPtrs contains pointers to parameters of the TransactionUsecase.FindPagedList
type TransactionUsecaseMockFindPagedListParamPtrs struct {
        ctx         *context.Context
        listOptions **mm_usecase.TransactionListOptions
        queryParams **uctypes.QueryGetListParams
}

// TransactionUsecaseMockFindPagedListResults contains results of the TransactionUsecase.FindPagedList
type TransactionUsecaseMockFindPagedListResults struct {
        resItems []*mm_usecase.TransactionDTO
        total    uint64
        err      error
}

// TransactionUsecaseMockFindPagedListOrigins contains origins of expectations of the TransactionUsecase.FindPagedList
type TransactionUsecaseMockFindPagedListExpectationOrigins struct {
        origin            string
        originCtx         string
        originListOptions string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) Optional() *mTransactionUsecaseMockFindPagedList <span class="cov0" title="0">{
        mmFindPagedList.optional = true
        return mmFindPagedList
}</span>

// Expect sets up expected params for TransactionUsecase.FindPagedList
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) Expect(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *mTransactionUsecaseMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("TransactionUsecaseMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;TransactionUsecaseMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("TransactionUsecaseMock.FindPagedList mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.params = &amp;TransactionUsecaseMockFindPagedListParams{ctx, listOptions, queryParams}
        mmFindPagedList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindPagedList.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindPagedList.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindPagedList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindPagedList.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindPagedList</span>
}

// ExpectCtxParam1 sets up expected param ctx for TransactionUsecase.FindPagedList
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) ExpectCtxParam1(ctx context.Context) *mTransactionUsecaseMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("TransactionUsecaseMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;TransactionUsecaseMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("TransactionUsecaseMock.FindPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockFindPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindPagedList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindPagedList</span>
}

// ExpectListOptionsParam2 sets up expected param listOptions for TransactionUsecase.FindPagedList
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) ExpectListOptionsParam2(listOptions *mm_usecase.TransactionListOptions) *mTransactionUsecaseMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("TransactionUsecaseMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;TransactionUsecaseMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("TransactionUsecaseMock.FindPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockFindPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.paramPtrs.listOptions = &amp;listOptions
        mmFindPagedList.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

        return mmFindPagedList</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for TransactionUsecase.FindPagedList
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mTransactionUsecaseMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("TransactionUsecaseMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;TransactionUsecaseMockFindPagedListExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("TransactionUsecaseMock.FindPagedList mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockFindPagedListParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindPagedList.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindPagedList</span>
}

// Inspect accepts an inspector function that has same arguments as the TransactionUsecase.FindPagedList
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) Inspect(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)) *mTransactionUsecaseMockFindPagedList <span class="cov0" title="0">{
        if mmFindPagedList.mock.inspectFuncFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Inspect function is already set for TransactionUsecaseMock.FindPagedList")
        }</span>

        <span class="cov0" title="0">mmFindPagedList.mock.inspectFuncFindPagedList = f

        return mmFindPagedList</span>
}

// Return sets up results that will be returned by TransactionUsecase.FindPagedList
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) Return(resItems []*mm_usecase.TransactionDTO, total uint64, err error) *TransactionUsecaseMock <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("TransactionUsecaseMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedList.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedList.defaultExpectation = &amp;TransactionUsecaseMockFindPagedListExpectation{mock: mmFindPagedList.mock}
        }</span>
        <span class="cov0" title="0">mmFindPagedList.defaultExpectation.results = &amp;TransactionUsecaseMockFindPagedListResults{resItems, total, err}
        mmFindPagedList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindPagedList.mock</span>
}

// Set uses given function f to mock the TransactionUsecase.FindPagedList method
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) Set(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.TransactionDTO, total uint64, err error)) *TransactionUsecaseMock <span class="cov0" title="0">{
        if mmFindPagedList.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Default expectation is already set for the TransactionUsecase.FindPagedList method")
        }</span>

        <span class="cov0" title="0">if len(mmFindPagedList.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Some expectations are already set for the TransactionUsecase.FindPagedList method")
        }</span>

        <span class="cov0" title="0">mmFindPagedList.mock.funcFindPagedList = f
        mmFindPagedList.mock.funcFindPagedListOrigin = minimock.CallerInfo(1)
        return mmFindPagedList.mock</span>
}

// When sets expectation for the TransactionUsecase.FindPagedList which will trigger the result defined by the following
// Then helper
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) When(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *TransactionUsecaseMockFindPagedListExpectation <span class="cov0" title="0">{
        if mmFindPagedList.mock.funcFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("TransactionUsecaseMock.FindPagedList mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TransactionUsecaseMockFindPagedListExpectation{
                mock:               mmFindPagedList.mock,
                params:             &amp;TransactionUsecaseMockFindPagedListParams{ctx, listOptions, queryParams},
                expectationOrigins: TransactionUsecaseMockFindPagedListExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindPagedList.expectations = append(mmFindPagedList.expectations, expectation)
        return expectation</span>
}

// Then sets up TransactionUsecase.FindPagedList return parameters for the expectation previously defined by the When method
func (e *TransactionUsecaseMockFindPagedListExpectation) Then(resItems []*mm_usecase.TransactionDTO, total uint64, err error) *TransactionUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;TransactionUsecaseMockFindPagedListResults{resItems, total, err}
        return e.mock
}</span>

// Times sets number of times TransactionUsecase.FindPagedList should be invoked
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) Times(n uint64) *mTransactionUsecaseMockFindPagedList <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindPagedList.mock.t.Fatalf("Times of TransactionUsecaseMock.FindPagedList mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindPagedList.expectedInvocations, n)
        mmFindPagedList.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindPagedList</span>
}

func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindPagedList.expectations) == 0 &amp;&amp; mmFindPagedList.defaultExpectation == nil &amp;&amp; mmFindPagedList.mock.funcFindPagedList == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindPagedList.mock.afterFindPagedListCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindPagedList.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindPagedList implements mm_usecase.TransactionUsecase
func (mmFindPagedList *TransactionUsecaseMock) FindPagedList(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (resItems []*mm_usecase.TransactionDTO, total uint64, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindPagedList.beforeFindPagedListCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindPagedList.afterFindPagedListCounter, 1)

        mmFindPagedList.t.Helper()

        if mmFindPagedList.inspectFuncFindPagedList != nil </span><span class="cov0" title="0">{
                mmFindPagedList.inspectFuncFindPagedList(ctx, listOptions, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := TransactionUsecaseMockFindPagedListParams{ctx, listOptions, queryParams}

        // Record call args
        mmFindPagedList.FindPagedListMock.mutex.Lock()
        mmFindPagedList.FindPagedListMock.callArgs = append(mmFindPagedList.FindPagedListMock.callArgs, &amp;mm_params)
        mmFindPagedList.FindPagedListMock.mutex.Unlock()

        for _, e := range mmFindPagedList.FindPagedListMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.resItems, e.results.total, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindPagedList.FindPagedListMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindPagedList.FindPagedListMock.defaultExpectation.Counter, 1)
                mm_want := mmFindPagedList.FindPagedListMock.defaultExpectation.params
                mm_want_ptrs := mmFindPagedList.FindPagedListMock.defaultExpectation.paramPtrs

                mm_got := TransactionUsecaseMockFindPagedListParams{ctx, listOptions, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindPagedList.t.Errorf("TransactionUsecaseMock.FindPagedList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.listOptions != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) </span><span class="cov0" title="0">{
                                mmFindPagedList.t.Errorf("TransactionUsecaseMock.FindPagedList got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindPagedList.t.Errorf("TransactionUsecaseMock.FindPagedList got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindPagedList.t.Errorf("TransactionUsecaseMock.FindPagedList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindPagedList.FindPagedListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindPagedList.FindPagedListMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindPagedList.t.Fatal("No results are set for the TransactionUsecaseMock.FindPagedList")
                }</span>
                <span class="cov0" title="0">return (*mm_results).resItems, (*mm_results).total, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindPagedList.funcFindPagedList != nil </span><span class="cov0" title="0">{
                return mmFindPagedList.funcFindPagedList(ctx, listOptions, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindPagedList.t.Fatalf("Unexpected call to TransactionUsecaseMock.FindPagedList. %v %v %v", ctx, listOptions, queryParams)
        return</span>
}

// FindPagedListAfterCounter returns a count of finished TransactionUsecaseMock.FindPagedList invocations
func (mmFindPagedList *TransactionUsecaseMock) FindPagedListAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindPagedList.afterFindPagedListCounter)
}</span>

// FindPagedListBeforeCounter returns a count of TransactionUsecaseMock.FindPagedList invocations
func (mmFindPagedList *TransactionUsecaseMock) FindPagedListBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindPagedList.beforeFindPagedListCounter)
}</span>

// Calls returns a list of arguments used in each call to TransactionUsecaseMock.FindPagedList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindPagedList *mTransactionUsecaseMockFindPagedList) Calls() []*TransactionUsecaseMockFindPagedListParams <span class="cov0" title="0">{
        mmFindPagedList.mutex.RLock()

        argCopy := make([]*TransactionUsecaseMockFindPagedListParams, len(mmFindPagedList.callArgs))
        copy(argCopy, mmFindPagedList.callArgs)

        mmFindPagedList.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindPagedListDone returns true if the count of the FindPagedList invocations corresponds
// the number of defined expectations
func (m *TransactionUsecaseMock) MinimockFindPagedListDone() bool <span class="cov0" title="0">{
        if m.FindPagedListMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindPagedListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindPagedListMock.invocationsDone()</span>
}

// MinimockFindPagedListInspect logs each unmet expectation
func (m *TransactionUsecaseMock) MinimockFindPagedListInspect() <span class="cov0" title="0">{
        for _, e := range m.FindPagedListMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionUsecaseMock.FindPagedList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindPagedListCounter := mm_atomic.LoadUint64(&amp;m.afterFindPagedListCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindPagedListMock.defaultExpectation != nil &amp;&amp; afterFindPagedListCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindPagedListMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionUsecaseMock.FindPagedList at\n%s", m.FindPagedListMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TransactionUsecaseMock.FindPagedList at\n%s with params: %#v", m.FindPagedListMock.defaultExpectation.expectationOrigins.origin, *m.FindPagedListMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindPagedList != nil &amp;&amp; afterFindPagedListCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TransactionUsecaseMock.FindPagedList at\n%s", m.funcFindPagedListOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindPagedListMock.invocationsDone() &amp;&amp; afterFindPagedListCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TransactionUsecaseMock.FindPagedList at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindPagedListMock.expectedInvocations), m.FindPagedListMock.expectedInvocationsOrigin, afterFindPagedListCounter)
        }</span>
}

type mTransactionUsecaseMockFindPagedListAsCSV struct {
        optional           bool
        mock               *TransactionUsecaseMock
        defaultExpectation *TransactionUsecaseMockFindPagedListAsCSVExpectation
        expectations       []*TransactionUsecaseMockFindPagedListAsCSVExpectation

        callArgs []*TransactionUsecaseMockFindPagedListAsCSVParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TransactionUsecaseMockFindPagedListAsCSVExpectation specifies expectation struct of the TransactionUsecase.FindPagedListAsCSV
type TransactionUsecaseMockFindPagedListAsCSVExpectation struct {
        mock               *TransactionUsecaseMock
        params             *TransactionUsecaseMockFindPagedListAsCSVParams
        paramPtrs          *TransactionUsecaseMockFindPagedListAsCSVParamPtrs
        expectationOrigins TransactionUsecaseMockFindPagedListAsCSVExpectationOrigins
        results            *TransactionUsecaseMockFindPagedListAsCSVResults
        returnOrigin       string
        Counter            uint64
}

// TransactionUsecaseMockFindPagedListAsCSVParams contains parameters of the TransactionUsecase.FindPagedListAsCSV
type TransactionUsecaseMockFindPagedListAsCSVParams struct {
        ctx         context.Context
        listOptions *mm_usecase.TransactionListOptions
        queryParams *uctypes.QueryGetListParams
}

// TransactionUsecaseMockFindPagedListAsCSVParamPtrs contains pointers to parameters of the TransactionUsecase.FindPagedListAsCSV
type TransactionUsecaseMockFindPagedListAsCSVParamPtrs struct {
        ctx         *context.Context
        listOptions **mm_usecase.TransactionListOptions
        queryParams **uctypes.QueryGetListParams
}

// TransactionUsecaseMockFindPagedListAsCSVResults contains results of the TransactionUsecase.FindPagedListAsCSV
type TransactionUsecaseMockFindPagedListAsCSVResults struct {
        res   []byte
        total uint64
        err   error
}

// TransactionUsecaseMockFindPagedListAsCSVOrigins contains origins of expectations of the TransactionUsecase.FindPagedListAsCSV
type TransactionUsecaseMockFindPagedListAsCSVExpectationOrigins struct {
        origin            string
        originCtx         string
        originListOptions string
        originQueryParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) Optional() *mTransactionUsecaseMockFindPagedListAsCSV <span class="cov0" title="0">{
        mmFindPagedListAsCSV.optional = true
        return mmFindPagedListAsCSV
}</span>

// Expect sets up expected params for TransactionUsecase.FindPagedListAsCSV
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) Expect(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *mTransactionUsecaseMockFindPagedListAsCSV <span class="cov0" title="0">{
        if mmFindPagedListAsCSV.mock.funcFindPagedListAsCSV != nil </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.mock.t.Fatalf("TransactionUsecaseMock.FindPagedListAsCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedListAsCSV.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.defaultExpectation = &amp;TransactionUsecaseMockFindPagedListAsCSVExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedListAsCSV.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.mock.t.Fatalf("TransactionUsecaseMock.FindPagedListAsCSV mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmFindPagedListAsCSV.defaultExpectation.params = &amp;TransactionUsecaseMockFindPagedListAsCSVParams{ctx, listOptions, queryParams}
        mmFindPagedListAsCSV.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmFindPagedListAsCSV.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmFindPagedListAsCSV.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmFindPagedListAsCSV.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindPagedListAsCSV.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmFindPagedListAsCSV</span>
}

// ExpectCtxParam1 sets up expected param ctx for TransactionUsecase.FindPagedListAsCSV
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) ExpectCtxParam1(ctx context.Context) *mTransactionUsecaseMockFindPagedListAsCSV <span class="cov0" title="0">{
        if mmFindPagedListAsCSV.mock.funcFindPagedListAsCSV != nil </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.mock.t.Fatalf("TransactionUsecaseMock.FindPagedListAsCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedListAsCSV.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.defaultExpectation = &amp;TransactionUsecaseMockFindPagedListAsCSVExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedListAsCSV.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.mock.t.Fatalf("TransactionUsecaseMock.FindPagedListAsCSV mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindPagedListAsCSV.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockFindPagedListAsCSVParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindPagedListAsCSV.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmFindPagedListAsCSV.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmFindPagedListAsCSV</span>
}

// ExpectListOptionsParam2 sets up expected param listOptions for TransactionUsecase.FindPagedListAsCSV
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) ExpectListOptionsParam2(listOptions *mm_usecase.TransactionListOptions) *mTransactionUsecaseMockFindPagedListAsCSV <span class="cov0" title="0">{
        if mmFindPagedListAsCSV.mock.funcFindPagedListAsCSV != nil </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.mock.t.Fatalf("TransactionUsecaseMock.FindPagedListAsCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedListAsCSV.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.defaultExpectation = &amp;TransactionUsecaseMockFindPagedListAsCSVExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedListAsCSV.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.mock.t.Fatalf("TransactionUsecaseMock.FindPagedListAsCSV mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindPagedListAsCSV.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockFindPagedListAsCSVParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindPagedListAsCSV.defaultExpectation.paramPtrs.listOptions = &amp;listOptions
        mmFindPagedListAsCSV.defaultExpectation.expectationOrigins.originListOptions = minimock.CallerInfo(1)

        return mmFindPagedListAsCSV</span>
}

// ExpectQueryParamsParam3 sets up expected param queryParams for TransactionUsecase.FindPagedListAsCSV
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) ExpectQueryParamsParam3(queryParams *uctypes.QueryGetListParams) *mTransactionUsecaseMockFindPagedListAsCSV <span class="cov0" title="0">{
        if mmFindPagedListAsCSV.mock.funcFindPagedListAsCSV != nil </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.mock.t.Fatalf("TransactionUsecaseMock.FindPagedListAsCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedListAsCSV.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.defaultExpectation = &amp;TransactionUsecaseMockFindPagedListAsCSVExpectation{}
        }</span>

        <span class="cov0" title="0">if mmFindPagedListAsCSV.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.mock.t.Fatalf("TransactionUsecaseMock.FindPagedListAsCSV mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmFindPagedListAsCSV.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockFindPagedListAsCSVParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmFindPagedListAsCSV.defaultExpectation.paramPtrs.queryParams = &amp;queryParams
        mmFindPagedListAsCSV.defaultExpectation.expectationOrigins.originQueryParams = minimock.CallerInfo(1)

        return mmFindPagedListAsCSV</span>
}

// Inspect accepts an inspector function that has same arguments as the TransactionUsecase.FindPagedListAsCSV
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) Inspect(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams)) *mTransactionUsecaseMockFindPagedListAsCSV <span class="cov0" title="0">{
        if mmFindPagedListAsCSV.mock.inspectFuncFindPagedListAsCSV != nil </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.mock.t.Fatalf("Inspect function is already set for TransactionUsecaseMock.FindPagedListAsCSV")
        }</span>

        <span class="cov0" title="0">mmFindPagedListAsCSV.mock.inspectFuncFindPagedListAsCSV = f

        return mmFindPagedListAsCSV</span>
}

// Return sets up results that will be returned by TransactionUsecase.FindPagedListAsCSV
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) Return(res []byte, total uint64, err error) *TransactionUsecaseMock <span class="cov0" title="0">{
        if mmFindPagedListAsCSV.mock.funcFindPagedListAsCSV != nil </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.mock.t.Fatalf("TransactionUsecaseMock.FindPagedListAsCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFindPagedListAsCSV.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.defaultExpectation = &amp;TransactionUsecaseMockFindPagedListAsCSVExpectation{mock: mmFindPagedListAsCSV.mock}
        }</span>
        <span class="cov0" title="0">mmFindPagedListAsCSV.defaultExpectation.results = &amp;TransactionUsecaseMockFindPagedListAsCSVResults{res, total, err}
        mmFindPagedListAsCSV.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFindPagedListAsCSV.mock</span>
}

// Set uses given function f to mock the TransactionUsecase.FindPagedListAsCSV method
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) Set(f func(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (res []byte, total uint64, err error)) *TransactionUsecaseMock <span class="cov0" title="0">{
        if mmFindPagedListAsCSV.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.mock.t.Fatalf("Default expectation is already set for the TransactionUsecase.FindPagedListAsCSV method")
        }</span>

        <span class="cov0" title="0">if len(mmFindPagedListAsCSV.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.mock.t.Fatalf("Some expectations are already set for the TransactionUsecase.FindPagedListAsCSV method")
        }</span>

        <span class="cov0" title="0">mmFindPagedListAsCSV.mock.funcFindPagedListAsCSV = f
        mmFindPagedListAsCSV.mock.funcFindPagedListAsCSVOrigin = minimock.CallerInfo(1)
        return mmFindPagedListAsCSV.mock</span>
}

// When sets expectation for the TransactionUsecase.FindPagedListAsCSV which will trigger the result defined by the following
// Then helper
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) When(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) *TransactionUsecaseMockFindPagedListAsCSVExpectation <span class="cov0" title="0">{
        if mmFindPagedListAsCSV.mock.funcFindPagedListAsCSV != nil </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.mock.t.Fatalf("TransactionUsecaseMock.FindPagedListAsCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TransactionUsecaseMockFindPagedListAsCSVExpectation{
                mock:               mmFindPagedListAsCSV.mock,
                params:             &amp;TransactionUsecaseMockFindPagedListAsCSVParams{ctx, listOptions, queryParams},
                expectationOrigins: TransactionUsecaseMockFindPagedListAsCSVExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmFindPagedListAsCSV.expectations = append(mmFindPagedListAsCSV.expectations, expectation)
        return expectation</span>
}

// Then sets up TransactionUsecase.FindPagedListAsCSV return parameters for the expectation previously defined by the When method
func (e *TransactionUsecaseMockFindPagedListAsCSVExpectation) Then(res []byte, total uint64, err error) *TransactionUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;TransactionUsecaseMockFindPagedListAsCSVResults{res, total, err}
        return e.mock
}</span>

// Times sets number of times TransactionUsecase.FindPagedListAsCSV should be invoked
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) Times(n uint64) *mTransactionUsecaseMockFindPagedListAsCSV <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.mock.t.Fatalf("Times of TransactionUsecaseMock.FindPagedListAsCSV mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFindPagedListAsCSV.expectedInvocations, n)
        mmFindPagedListAsCSV.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFindPagedListAsCSV</span>
}

func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFindPagedListAsCSV.expectations) == 0 &amp;&amp; mmFindPagedListAsCSV.defaultExpectation == nil &amp;&amp; mmFindPagedListAsCSV.mock.funcFindPagedListAsCSV == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFindPagedListAsCSV.mock.afterFindPagedListAsCSVCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFindPagedListAsCSV.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// FindPagedListAsCSV implements mm_usecase.TransactionUsecase
func (mmFindPagedListAsCSV *TransactionUsecaseMock) FindPagedListAsCSV(ctx context.Context, listOptions *mm_usecase.TransactionListOptions, queryParams *uctypes.QueryGetListParams) (res []byte, total uint64, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFindPagedListAsCSV.beforeFindPagedListAsCSVCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFindPagedListAsCSV.afterFindPagedListAsCSVCounter, 1)

        mmFindPagedListAsCSV.t.Helper()

        if mmFindPagedListAsCSV.inspectFuncFindPagedListAsCSV != nil </span><span class="cov0" title="0">{
                mmFindPagedListAsCSV.inspectFuncFindPagedListAsCSV(ctx, listOptions, queryParams)
        }</span>

        <span class="cov0" title="0">mm_params := TransactionUsecaseMockFindPagedListAsCSVParams{ctx, listOptions, queryParams}

        // Record call args
        mmFindPagedListAsCSV.FindPagedListAsCSVMock.mutex.Lock()
        mmFindPagedListAsCSV.FindPagedListAsCSVMock.callArgs = append(mmFindPagedListAsCSV.FindPagedListAsCSVMock.callArgs, &amp;mm_params)
        mmFindPagedListAsCSV.FindPagedListAsCSVMock.mutex.Unlock()

        for _, e := range mmFindPagedListAsCSV.FindPagedListAsCSVMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.res, e.results.total, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmFindPagedListAsCSV.FindPagedListAsCSVMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFindPagedListAsCSV.FindPagedListAsCSVMock.defaultExpectation.Counter, 1)
                mm_want := mmFindPagedListAsCSV.FindPagedListAsCSVMock.defaultExpectation.params
                mm_want_ptrs := mmFindPagedListAsCSV.FindPagedListAsCSVMock.defaultExpectation.paramPtrs

                mm_got := TransactionUsecaseMockFindPagedListAsCSVParams{ctx, listOptions, queryParams}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmFindPagedListAsCSV.t.Errorf("TransactionUsecaseMock.FindPagedListAsCSV got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindPagedListAsCSV.FindPagedListAsCSVMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.listOptions != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.listOptions, mm_got.listOptions) </span><span class="cov0" title="0">{
                                mmFindPagedListAsCSV.t.Errorf("TransactionUsecaseMock.FindPagedListAsCSV got unexpected parameter listOptions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindPagedListAsCSV.FindPagedListAsCSVMock.defaultExpectation.expectationOrigins.originListOptions, *mm_want_ptrs.listOptions, mm_got.listOptions, minimock.Diff(*mm_want_ptrs.listOptions, mm_got.listOptions))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.queryParams != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.queryParams, mm_got.queryParams) </span><span class="cov0" title="0">{
                                mmFindPagedListAsCSV.t.Errorf("TransactionUsecaseMock.FindPagedListAsCSV got unexpected parameter queryParams, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmFindPagedListAsCSV.FindPagedListAsCSVMock.defaultExpectation.expectationOrigins.originQueryParams, *mm_want_ptrs.queryParams, mm_got.queryParams, minimock.Diff(*mm_want_ptrs.queryParams, mm_got.queryParams))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmFindPagedListAsCSV.t.Errorf("TransactionUsecaseMock.FindPagedListAsCSV got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmFindPagedListAsCSV.FindPagedListAsCSVMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmFindPagedListAsCSV.FindPagedListAsCSVMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFindPagedListAsCSV.t.Fatal("No results are set for the TransactionUsecaseMock.FindPagedListAsCSV")
                }</span>
                <span class="cov0" title="0">return (*mm_results).res, (*mm_results).total, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmFindPagedListAsCSV.funcFindPagedListAsCSV != nil </span><span class="cov0" title="0">{
                return mmFindPagedListAsCSV.funcFindPagedListAsCSV(ctx, listOptions, queryParams)
        }</span>
        <span class="cov0" title="0">mmFindPagedListAsCSV.t.Fatalf("Unexpected call to TransactionUsecaseMock.FindPagedListAsCSV. %v %v %v", ctx, listOptions, queryParams)
        return</span>
}

// FindPagedListAsCSVAfterCounter returns a count of finished TransactionUsecaseMock.FindPagedListAsCSV invocations
func (mmFindPagedListAsCSV *TransactionUsecaseMock) FindPagedListAsCSVAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindPagedListAsCSV.afterFindPagedListAsCSVCounter)
}</span>

// FindPagedListAsCSVBeforeCounter returns a count of TransactionUsecaseMock.FindPagedListAsCSV invocations
func (mmFindPagedListAsCSV *TransactionUsecaseMock) FindPagedListAsCSVBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFindPagedListAsCSV.beforeFindPagedListAsCSVCounter)
}</span>

// Calls returns a list of arguments used in each call to TransactionUsecaseMock.FindPagedListAsCSV.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindPagedListAsCSV *mTransactionUsecaseMockFindPagedListAsCSV) Calls() []*TransactionUsecaseMockFindPagedListAsCSVParams <span class="cov0" title="0">{
        mmFindPagedListAsCSV.mutex.RLock()

        argCopy := make([]*TransactionUsecaseMockFindPagedListAsCSVParams, len(mmFindPagedListAsCSV.callArgs))
        copy(argCopy, mmFindPagedListAsCSV.callArgs)

        mmFindPagedListAsCSV.mutex.RUnlock()

        return argCopy
}</span>

// MinimockFindPagedListAsCSVDone returns true if the count of the FindPagedListAsCSV invocations corresponds
// the number of defined expectations
func (m *TransactionUsecaseMock) MinimockFindPagedListAsCSVDone() bool <span class="cov0" title="0">{
        if m.FindPagedListAsCSVMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FindPagedListAsCSVMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FindPagedListAsCSVMock.invocationsDone()</span>
}

// MinimockFindPagedListAsCSVInspect logs each unmet expectation
func (m *TransactionUsecaseMock) MinimockFindPagedListAsCSVInspect() <span class="cov0" title="0">{
        for _, e := range m.FindPagedListAsCSVMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionUsecaseMock.FindPagedListAsCSV at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterFindPagedListAsCSVCounter := mm_atomic.LoadUint64(&amp;m.afterFindPagedListAsCSVCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FindPagedListAsCSVMock.defaultExpectation != nil &amp;&amp; afterFindPagedListAsCSVCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.FindPagedListAsCSVMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionUsecaseMock.FindPagedListAsCSV at\n%s", m.FindPagedListAsCSVMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TransactionUsecaseMock.FindPagedListAsCSV at\n%s with params: %#v", m.FindPagedListAsCSVMock.defaultExpectation.expectationOrigins.origin, *m.FindPagedListAsCSVMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFindPagedListAsCSV != nil &amp;&amp; afterFindPagedListAsCSVCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TransactionUsecaseMock.FindPagedListAsCSV at\n%s", m.funcFindPagedListAsCSVOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FindPagedListAsCSVMock.invocationsDone() &amp;&amp; afterFindPagedListAsCSVCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TransactionUsecaseMock.FindPagedListAsCSV at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FindPagedListAsCSVMock.expectedInvocations), m.FindPagedListAsCSVMock.expectedInvocationsOrigin, afterFindPagedListAsCSVCounter)
        }</span>
}

type mTransactionUsecaseMockImportTransactionsFromCSV struct {
        optional           bool
        mock               *TransactionUsecaseMock
        defaultExpectation *TransactionUsecaseMockImportTransactionsFromCSVExpectation
        expectations       []*TransactionUsecaseMockImportTransactionsFromCSVExpectation

        callArgs []*TransactionUsecaseMockImportTransactionsFromCSVParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TransactionUsecaseMockImportTransactionsFromCSVExpectation specifies expectation struct of the TransactionUsecase.ImportTransactionsFromCSV
type TransactionUsecaseMockImportTransactionsFromCSVExpectation struct {
        mock               *TransactionUsecaseMock
        params             *TransactionUsecaseMockImportTransactionsFromCSVParams
        paramPtrs          *TransactionUsecaseMockImportTransactionsFromCSVParamPtrs
        expectationOrigins TransactionUsecaseMockImportTransactionsFromCSVExpectationOrigins
        results            *TransactionUsecaseMockImportTransactionsFromCSVResults
        returnOrigin       string
        Counter            uint64
}

// TransactionUsecaseMockImportTransactionsFromCSVParams contains parameters of the TransactionUsecase.ImportTransactionsFromCSV
type TransactionUsecaseMockImportTransactionsFromCSVParams struct {
        ctx       context.Context
        data      []byte
        accountID uuid.UUID
}

// TransactionUsecaseMockImportTransactionsFromCSVParamPtrs contains pointers to parameters of the TransactionUsecase.ImportTransactionsFromCSV
type TransactionUsecaseMockImportTransactionsFromCSVParamPtrs struct {
        ctx       *context.Context
        data      *[]byte
        accountID *uuid.UUID
}

// TransactionUsecaseMockImportTransactionsFromCSVResults contains results of the TransactionUsecase.ImportTransactionsFromCSV
type TransactionUsecaseMockImportTransactionsFromCSVResults struct {
        err error
}

// TransactionUsecaseMockImportTransactionsFromCSVOrigins contains origins of expectations of the TransactionUsecase.ImportTransactionsFromCSV
type TransactionUsecaseMockImportTransactionsFromCSVExpectationOrigins struct {
        origin          string
        originCtx       string
        originData      string
        originAccountID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) Optional() *mTransactionUsecaseMockImportTransactionsFromCSV <span class="cov0" title="0">{
        mmImportTransactionsFromCSV.optional = true
        return mmImportTransactionsFromCSV
}</span>

// Expect sets up expected params for TransactionUsecase.ImportTransactionsFromCSV
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) Expect(ctx context.Context, data []byte, accountID uuid.UUID) *mTransactionUsecaseMockImportTransactionsFromCSV <span class="cov0" title="0">{
        if mmImportTransactionsFromCSV.mock.funcImportTransactionsFromCSV != nil </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.mock.t.Fatalf("TransactionUsecaseMock.ImportTransactionsFromCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmImportTransactionsFromCSV.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.defaultExpectation = &amp;TransactionUsecaseMockImportTransactionsFromCSVExpectation{}
        }</span>

        <span class="cov0" title="0">if mmImportTransactionsFromCSV.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.mock.t.Fatalf("TransactionUsecaseMock.ImportTransactionsFromCSV mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmImportTransactionsFromCSV.defaultExpectation.params = &amp;TransactionUsecaseMockImportTransactionsFromCSVParams{ctx, data, accountID}
        mmImportTransactionsFromCSV.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmImportTransactionsFromCSV.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmImportTransactionsFromCSV.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmImportTransactionsFromCSV.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmImportTransactionsFromCSV.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmImportTransactionsFromCSV</span>
}

// ExpectCtxParam1 sets up expected param ctx for TransactionUsecase.ImportTransactionsFromCSV
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) ExpectCtxParam1(ctx context.Context) *mTransactionUsecaseMockImportTransactionsFromCSV <span class="cov0" title="0">{
        if mmImportTransactionsFromCSV.mock.funcImportTransactionsFromCSV != nil </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.mock.t.Fatalf("TransactionUsecaseMock.ImportTransactionsFromCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmImportTransactionsFromCSV.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.defaultExpectation = &amp;TransactionUsecaseMockImportTransactionsFromCSVExpectation{}
        }</span>

        <span class="cov0" title="0">if mmImportTransactionsFromCSV.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.mock.t.Fatalf("TransactionUsecaseMock.ImportTransactionsFromCSV mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmImportTransactionsFromCSV.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockImportTransactionsFromCSVParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmImportTransactionsFromCSV.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmImportTransactionsFromCSV.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmImportTransactionsFromCSV</span>
}

// ExpectDataParam2 sets up expected param data for TransactionUsecase.ImportTransactionsFromCSV
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) ExpectDataParam2(data []byte) *mTransactionUsecaseMockImportTransactionsFromCSV <span class="cov0" title="0">{
        if mmImportTransactionsFromCSV.mock.funcImportTransactionsFromCSV != nil </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.mock.t.Fatalf("TransactionUsecaseMock.ImportTransactionsFromCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmImportTransactionsFromCSV.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.defaultExpectation = &amp;TransactionUsecaseMockImportTransactionsFromCSVExpectation{}
        }</span>

        <span class="cov0" title="0">if mmImportTransactionsFromCSV.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.mock.t.Fatalf("TransactionUsecaseMock.ImportTransactionsFromCSV mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmImportTransactionsFromCSV.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockImportTransactionsFromCSVParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmImportTransactionsFromCSV.defaultExpectation.paramPtrs.data = &amp;data
        mmImportTransactionsFromCSV.defaultExpectation.expectationOrigins.originData = minimock.CallerInfo(1)

        return mmImportTransactionsFromCSV</span>
}

// ExpectAccountIDParam3 sets up expected param accountID for TransactionUsecase.ImportTransactionsFromCSV
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) ExpectAccountIDParam3(accountID uuid.UUID) *mTransactionUsecaseMockImportTransactionsFromCSV <span class="cov0" title="0">{
        if mmImportTransactionsFromCSV.mock.funcImportTransactionsFromCSV != nil </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.mock.t.Fatalf("TransactionUsecaseMock.ImportTransactionsFromCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmImportTransactionsFromCSV.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.defaultExpectation = &amp;TransactionUsecaseMockImportTransactionsFromCSVExpectation{}
        }</span>

        <span class="cov0" title="0">if mmImportTransactionsFromCSV.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.mock.t.Fatalf("TransactionUsecaseMock.ImportTransactionsFromCSV mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmImportTransactionsFromCSV.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockImportTransactionsFromCSVParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmImportTransactionsFromCSV.defaultExpectation.paramPtrs.accountID = &amp;accountID
        mmImportTransactionsFromCSV.defaultExpectation.expectationOrigins.originAccountID = minimock.CallerInfo(1)

        return mmImportTransactionsFromCSV</span>
}

// Inspect accepts an inspector function that has same arguments as the TransactionUsecase.ImportTransactionsFromCSV
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) Inspect(f func(ctx context.Context, data []byte, accountID uuid.UUID)) *mTransactionUsecaseMockImportTransactionsFromCSV <span class="cov0" title="0">{
        if mmImportTransactionsFromCSV.mock.inspectFuncImportTransactionsFromCSV != nil </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.mock.t.Fatalf("Inspect function is already set for TransactionUsecaseMock.ImportTransactionsFromCSV")
        }</span>

        <span class="cov0" title="0">mmImportTransactionsFromCSV.mock.inspectFuncImportTransactionsFromCSV = f

        return mmImportTransactionsFromCSV</span>
}

// Return sets up results that will be returned by TransactionUsecase.ImportTransactionsFromCSV
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) Return(err error) *TransactionUsecaseMock <span class="cov0" title="0">{
        if mmImportTransactionsFromCSV.mock.funcImportTransactionsFromCSV != nil </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.mock.t.Fatalf("TransactionUsecaseMock.ImportTransactionsFromCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmImportTransactionsFromCSV.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.defaultExpectation = &amp;TransactionUsecaseMockImportTransactionsFromCSVExpectation{mock: mmImportTransactionsFromCSV.mock}
        }</span>
        <span class="cov0" title="0">mmImportTransactionsFromCSV.defaultExpectation.results = &amp;TransactionUsecaseMockImportTransactionsFromCSVResults{err}
        mmImportTransactionsFromCSV.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmImportTransactionsFromCSV.mock</span>
}

// Set uses given function f to mock the TransactionUsecase.ImportTransactionsFromCSV method
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) Set(f func(ctx context.Context, data []byte, accountID uuid.UUID) (err error)) *TransactionUsecaseMock <span class="cov0" title="0">{
        if mmImportTransactionsFromCSV.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.mock.t.Fatalf("Default expectation is already set for the TransactionUsecase.ImportTransactionsFromCSV method")
        }</span>

        <span class="cov0" title="0">if len(mmImportTransactionsFromCSV.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.mock.t.Fatalf("Some expectations are already set for the TransactionUsecase.ImportTransactionsFromCSV method")
        }</span>

        <span class="cov0" title="0">mmImportTransactionsFromCSV.mock.funcImportTransactionsFromCSV = f
        mmImportTransactionsFromCSV.mock.funcImportTransactionsFromCSVOrigin = minimock.CallerInfo(1)
        return mmImportTransactionsFromCSV.mock</span>
}

// When sets expectation for the TransactionUsecase.ImportTransactionsFromCSV which will trigger the result defined by the following
// Then helper
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) When(ctx context.Context, data []byte, accountID uuid.UUID) *TransactionUsecaseMockImportTransactionsFromCSVExpectation <span class="cov0" title="0">{
        if mmImportTransactionsFromCSV.mock.funcImportTransactionsFromCSV != nil </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.mock.t.Fatalf("TransactionUsecaseMock.ImportTransactionsFromCSV mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TransactionUsecaseMockImportTransactionsFromCSVExpectation{
                mock:               mmImportTransactionsFromCSV.mock,
                params:             &amp;TransactionUsecaseMockImportTransactionsFromCSVParams{ctx, data, accountID},
                expectationOrigins: TransactionUsecaseMockImportTransactionsFromCSVExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmImportTransactionsFromCSV.expectations = append(mmImportTransactionsFromCSV.expectations, expectation)
        return expectation</span>
}

// Then sets up TransactionUsecase.ImportTransactionsFromCSV return parameters for the expectation previously defined by the When method
func (e *TransactionUsecaseMockImportTransactionsFromCSVExpectation) Then(err error) *TransactionUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;TransactionUsecaseMockImportTransactionsFromCSVResults{err}
        return e.mock
}</span>

// Times sets number of times TransactionUsecase.ImportTransactionsFromCSV should be invoked
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) Times(n uint64) *mTransactionUsecaseMockImportTransactionsFromCSV <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.mock.t.Fatalf("Times of TransactionUsecaseMock.ImportTransactionsFromCSV mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmImportTransactionsFromCSV.expectedInvocations, n)
        mmImportTransactionsFromCSV.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmImportTransactionsFromCSV</span>
}

func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmImportTransactionsFromCSV.expectations) == 0 &amp;&amp; mmImportTransactionsFromCSV.defaultExpectation == nil &amp;&amp; mmImportTransactionsFromCSV.mock.funcImportTransactionsFromCSV == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmImportTransactionsFromCSV.mock.afterImportTransactionsFromCSVCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmImportTransactionsFromCSV.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// ImportTransactionsFromCSV implements mm_usecase.TransactionUsecase
func (mmImportTransactionsFromCSV *TransactionUsecaseMock) ImportTransactionsFromCSV(ctx context.Context, data []byte, accountID uuid.UUID) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmImportTransactionsFromCSV.beforeImportTransactionsFromCSVCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmImportTransactionsFromCSV.afterImportTransactionsFromCSVCounter, 1)

        mmImportTransactionsFromCSV.t.Helper()

        if mmImportTransactionsFromCSV.inspectFuncImportTransactionsFromCSV != nil </span><span class="cov0" title="0">{
                mmImportTransactionsFromCSV.inspectFuncImportTransactionsFromCSV(ctx, data, accountID)
        }</span>

        <span class="cov0" title="0">mm_params := TransactionUsecaseMockImportTransactionsFromCSVParams{ctx, data, accountID}

        // Record call args
        mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.mutex.Lock()
        mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.callArgs = append(mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.callArgs, &amp;mm_params)
        mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.mutex.Unlock()

        for _, e := range mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.defaultExpectation.Counter, 1)
                mm_want := mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.defaultExpectation.params
                mm_want_ptrs := mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.defaultExpectation.paramPtrs

                mm_got := TransactionUsecaseMockImportTransactionsFromCSVParams{ctx, data, accountID}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmImportTransactionsFromCSV.t.Errorf("TransactionUsecaseMock.ImportTransactionsFromCSV got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.data != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.data, mm_got.data) </span><span class="cov0" title="0">{
                                mmImportTransactionsFromCSV.t.Errorf("TransactionUsecaseMock.ImportTransactionsFromCSV got unexpected parameter data, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.defaultExpectation.expectationOrigins.originData, *mm_want_ptrs.data, mm_got.data, minimock.Diff(*mm_want_ptrs.data, mm_got.data))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.accountID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.accountID, mm_got.accountID) </span><span class="cov0" title="0">{
                                mmImportTransactionsFromCSV.t.Errorf("TransactionUsecaseMock.ImportTransactionsFromCSV got unexpected parameter accountID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.defaultExpectation.expectationOrigins.originAccountID, *mm_want_ptrs.accountID, mm_got.accountID, minimock.Diff(*mm_want_ptrs.accountID, mm_got.accountID))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmImportTransactionsFromCSV.t.Errorf("TransactionUsecaseMock.ImportTransactionsFromCSV got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmImportTransactionsFromCSV.ImportTransactionsFromCSVMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmImportTransactionsFromCSV.t.Fatal("No results are set for the TransactionUsecaseMock.ImportTransactionsFromCSV")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmImportTransactionsFromCSV.funcImportTransactionsFromCSV != nil </span><span class="cov0" title="0">{
                return mmImportTransactionsFromCSV.funcImportTransactionsFromCSV(ctx, data, accountID)
        }</span>
        <span class="cov0" title="0">mmImportTransactionsFromCSV.t.Fatalf("Unexpected call to TransactionUsecaseMock.ImportTransactionsFromCSV. %v %v %v", ctx, data, accountID)
        return</span>
}

// ImportTransactionsFromCSVAfterCounter returns a count of finished TransactionUsecaseMock.ImportTransactionsFromCSV invocations
func (mmImportTransactionsFromCSV *TransactionUsecaseMock) ImportTransactionsFromCSVAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmImportTransactionsFromCSV.afterImportTransactionsFromCSVCounter)
}</span>

// ImportTransactionsFromCSVBeforeCounter returns a count of TransactionUsecaseMock.ImportTransactionsFromCSV invocations
func (mmImportTransactionsFromCSV *TransactionUsecaseMock) ImportTransactionsFromCSVBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmImportTransactionsFromCSV.beforeImportTransactionsFromCSVCounter)
}</span>

// Calls returns a list of arguments used in each call to TransactionUsecaseMock.ImportTransactionsFromCSV.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmImportTransactionsFromCSV *mTransactionUsecaseMockImportTransactionsFromCSV) Calls() []*TransactionUsecaseMockImportTransactionsFromCSVParams <span class="cov0" title="0">{
        mmImportTransactionsFromCSV.mutex.RLock()

        argCopy := make([]*TransactionUsecaseMockImportTransactionsFromCSVParams, len(mmImportTransactionsFromCSV.callArgs))
        copy(argCopy, mmImportTransactionsFromCSV.callArgs)

        mmImportTransactionsFromCSV.mutex.RUnlock()

        return argCopy
}</span>

// MinimockImportTransactionsFromCSVDone returns true if the count of the ImportTransactionsFromCSV invocations corresponds
// the number of defined expectations
func (m *TransactionUsecaseMock) MinimockImportTransactionsFromCSVDone() bool <span class="cov0" title="0">{
        if m.ImportTransactionsFromCSVMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.ImportTransactionsFromCSVMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.ImportTransactionsFromCSVMock.invocationsDone()</span>
}

// MinimockImportTransactionsFromCSVInspect logs each unmet expectation
func (m *TransactionUsecaseMock) MinimockImportTransactionsFromCSVInspect() <span class="cov0" title="0">{
        for _, e := range m.ImportTransactionsFromCSVMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionUsecaseMock.ImportTransactionsFromCSV at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterImportTransactionsFromCSVCounter := mm_atomic.LoadUint64(&amp;m.afterImportTransactionsFromCSVCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.ImportTransactionsFromCSVMock.defaultExpectation != nil &amp;&amp; afterImportTransactionsFromCSVCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.ImportTransactionsFromCSVMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionUsecaseMock.ImportTransactionsFromCSV at\n%s", m.ImportTransactionsFromCSVMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TransactionUsecaseMock.ImportTransactionsFromCSV at\n%s with params: %#v", m.ImportTransactionsFromCSVMock.defaultExpectation.expectationOrigins.origin, *m.ImportTransactionsFromCSVMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcImportTransactionsFromCSV != nil &amp;&amp; afterImportTransactionsFromCSVCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TransactionUsecaseMock.ImportTransactionsFromCSV at\n%s", m.funcImportTransactionsFromCSVOrigin)
        }</span>

        <span class="cov0" title="0">if !m.ImportTransactionsFromCSVMock.invocationsDone() &amp;&amp; afterImportTransactionsFromCSVCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TransactionUsecaseMock.ImportTransactionsFromCSV at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.ImportTransactionsFromCSVMock.expectedInvocations), m.ImportTransactionsFromCSVMock.expectedInvocationsOrigin, afterImportTransactionsFromCSVCounter)
        }</span>
}

type mTransactionUsecaseMockPatchTransactionByDTO struct {
        optional           bool
        mock               *TransactionUsecaseMock
        defaultExpectation *TransactionUsecaseMockPatchTransactionByDTOExpectation
        expectations       []*TransactionUsecaseMockPatchTransactionByDTOExpectation

        callArgs []*TransactionUsecaseMockPatchTransactionByDTOParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// TransactionUsecaseMockPatchTransactionByDTOExpectation specifies expectation struct of the TransactionUsecase.PatchTransactionByDTO
type TransactionUsecaseMockPatchTransactionByDTOExpectation struct {
        mock               *TransactionUsecaseMock
        params             *TransactionUsecaseMockPatchTransactionByDTOParams
        paramPtrs          *TransactionUsecaseMockPatchTransactionByDTOParamPtrs
        expectationOrigins TransactionUsecaseMockPatchTransactionByDTOExpectationOrigins
        results            *TransactionUsecaseMockPatchTransactionByDTOResults
        returnOrigin       string
        Counter            uint64
}

// TransactionUsecaseMockPatchTransactionByDTOParams contains parameters of the TransactionUsecase.PatchTransactionByDTO
type TransactionUsecaseMockPatchTransactionByDTOParams struct {
        ctx              context.Context
        id               uuid.UUID
        in               mm_usecase.PatchTransactionDataInput
        skipVersionCheck bool
}

// TransactionUsecaseMockPatchTransactionByDTOParamPtrs contains pointers to parameters of the TransactionUsecase.PatchTransactionByDTO
type TransactionUsecaseMockPatchTransactionByDTOParamPtrs struct {
        ctx              *context.Context
        id               *uuid.UUID
        in               *mm_usecase.PatchTransactionDataInput
        skipVersionCheck *bool
}

// TransactionUsecaseMockPatchTransactionByDTOResults contains results of the TransactionUsecase.PatchTransactionByDTO
type TransactionUsecaseMockPatchTransactionByDTOResults struct {
        err error
}

// TransactionUsecaseMockPatchTransactionByDTOOrigins contains origins of expectations of the TransactionUsecase.PatchTransactionByDTO
type TransactionUsecaseMockPatchTransactionByDTOExpectationOrigins struct {
        origin                 string
        originCtx              string
        originId               string
        originIn               string
        originSkipVersionCheck string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) Optional() *mTransactionUsecaseMockPatchTransactionByDTO <span class="cov0" title="0">{
        mmPatchTransactionByDTO.optional = true
        return mmPatchTransactionByDTO
}</span>

// Expect sets up expected params for TransactionUsecase.PatchTransactionByDTO
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) Expect(ctx context.Context, id uuid.UUID, in mm_usecase.PatchTransactionDataInput, skipVersionCheck bool) *mTransactionUsecaseMockPatchTransactionByDTO <span class="cov0" title="0">{
        if mmPatchTransactionByDTO.mock.funcPatchTransactionByDTO != nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmPatchTransactionByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.defaultExpectation = &amp;TransactionUsecaseMockPatchTransactionByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmPatchTransactionByDTO.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmPatchTransactionByDTO.defaultExpectation.params = &amp;TransactionUsecaseMockPatchTransactionByDTOParams{ctx, id, in, skipVersionCheck}
        mmPatchTransactionByDTO.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmPatchTransactionByDTO.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmPatchTransactionByDTO.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmPatchTransactionByDTO.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPatchTransactionByDTO.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmPatchTransactionByDTO</span>
}

// ExpectCtxParam1 sets up expected param ctx for TransactionUsecase.PatchTransactionByDTO
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) ExpectCtxParam1(ctx context.Context) *mTransactionUsecaseMockPatchTransactionByDTO <span class="cov0" title="0">{
        if mmPatchTransactionByDTO.mock.funcPatchTransactionByDTO != nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmPatchTransactionByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.defaultExpectation = &amp;TransactionUsecaseMockPatchTransactionByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmPatchTransactionByDTO.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmPatchTransactionByDTO.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockPatchTransactionByDTOParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmPatchTransactionByDTO.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmPatchTransactionByDTO.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmPatchTransactionByDTO</span>
}

// ExpectIdParam2 sets up expected param id for TransactionUsecase.PatchTransactionByDTO
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) ExpectIdParam2(id uuid.UUID) *mTransactionUsecaseMockPatchTransactionByDTO <span class="cov0" title="0">{
        if mmPatchTransactionByDTO.mock.funcPatchTransactionByDTO != nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmPatchTransactionByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.defaultExpectation = &amp;TransactionUsecaseMockPatchTransactionByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmPatchTransactionByDTO.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmPatchTransactionByDTO.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockPatchTransactionByDTOParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmPatchTransactionByDTO.defaultExpectation.paramPtrs.id = &amp;id
        mmPatchTransactionByDTO.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmPatchTransactionByDTO</span>
}

// ExpectInParam3 sets up expected param in for TransactionUsecase.PatchTransactionByDTO
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) ExpectInParam3(in mm_usecase.PatchTransactionDataInput) *mTransactionUsecaseMockPatchTransactionByDTO <span class="cov0" title="0">{
        if mmPatchTransactionByDTO.mock.funcPatchTransactionByDTO != nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmPatchTransactionByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.defaultExpectation = &amp;TransactionUsecaseMockPatchTransactionByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmPatchTransactionByDTO.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmPatchTransactionByDTO.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockPatchTransactionByDTOParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmPatchTransactionByDTO.defaultExpectation.paramPtrs.in = &amp;in
        mmPatchTransactionByDTO.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

        return mmPatchTransactionByDTO</span>
}

// ExpectSkipVersionCheckParam4 sets up expected param skipVersionCheck for TransactionUsecase.PatchTransactionByDTO
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) ExpectSkipVersionCheckParam4(skipVersionCheck bool) *mTransactionUsecaseMockPatchTransactionByDTO <span class="cov0" title="0">{
        if mmPatchTransactionByDTO.mock.funcPatchTransactionByDTO != nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmPatchTransactionByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.defaultExpectation = &amp;TransactionUsecaseMockPatchTransactionByDTOExpectation{}
        }</span>

        <span class="cov0" title="0">if mmPatchTransactionByDTO.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmPatchTransactionByDTO.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.defaultExpectation.paramPtrs = &amp;TransactionUsecaseMockPatchTransactionByDTOParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmPatchTransactionByDTO.defaultExpectation.paramPtrs.skipVersionCheck = &amp;skipVersionCheck
        mmPatchTransactionByDTO.defaultExpectation.expectationOrigins.originSkipVersionCheck = minimock.CallerInfo(1)

        return mmPatchTransactionByDTO</span>
}

// Inspect accepts an inspector function that has same arguments as the TransactionUsecase.PatchTransactionByDTO
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) Inspect(f func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchTransactionDataInput, skipVersionCheck bool)) *mTransactionUsecaseMockPatchTransactionByDTO <span class="cov0" title="0">{
        if mmPatchTransactionByDTO.mock.inspectFuncPatchTransactionByDTO != nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.mock.t.Fatalf("Inspect function is already set for TransactionUsecaseMock.PatchTransactionByDTO")
        }</span>

        <span class="cov0" title="0">mmPatchTransactionByDTO.mock.inspectFuncPatchTransactionByDTO = f

        return mmPatchTransactionByDTO</span>
}

// Return sets up results that will be returned by TransactionUsecase.PatchTransactionByDTO
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) Return(err error) *TransactionUsecaseMock <span class="cov0" title="0">{
        if mmPatchTransactionByDTO.mock.funcPatchTransactionByDTO != nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmPatchTransactionByDTO.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.defaultExpectation = &amp;TransactionUsecaseMockPatchTransactionByDTOExpectation{mock: mmPatchTransactionByDTO.mock}
        }</span>
        <span class="cov0" title="0">mmPatchTransactionByDTO.defaultExpectation.results = &amp;TransactionUsecaseMockPatchTransactionByDTOResults{err}
        mmPatchTransactionByDTO.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmPatchTransactionByDTO.mock</span>
}

// Set uses given function f to mock the TransactionUsecase.PatchTransactionByDTO method
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) Set(f func(ctx context.Context, id uuid.UUID, in mm_usecase.PatchTransactionDataInput, skipVersionCheck bool) (err error)) *TransactionUsecaseMock <span class="cov0" title="0">{
        if mmPatchTransactionByDTO.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.mock.t.Fatalf("Default expectation is already set for the TransactionUsecase.PatchTransactionByDTO method")
        }</span>

        <span class="cov0" title="0">if len(mmPatchTransactionByDTO.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.mock.t.Fatalf("Some expectations are already set for the TransactionUsecase.PatchTransactionByDTO method")
        }</span>

        <span class="cov0" title="0">mmPatchTransactionByDTO.mock.funcPatchTransactionByDTO = f
        mmPatchTransactionByDTO.mock.funcPatchTransactionByDTOOrigin = minimock.CallerInfo(1)
        return mmPatchTransactionByDTO.mock</span>
}

// When sets expectation for the TransactionUsecase.PatchTransactionByDTO which will trigger the result defined by the following
// Then helper
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) When(ctx context.Context, id uuid.UUID, in mm_usecase.PatchTransactionDataInput, skipVersionCheck bool) *TransactionUsecaseMockPatchTransactionByDTOExpectation <span class="cov0" title="0">{
        if mmPatchTransactionByDTO.mock.funcPatchTransactionByDTO != nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.mock.t.Fatalf("TransactionUsecaseMock.PatchTransactionByDTO mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;TransactionUsecaseMockPatchTransactionByDTOExpectation{
                mock:               mmPatchTransactionByDTO.mock,
                params:             &amp;TransactionUsecaseMockPatchTransactionByDTOParams{ctx, id, in, skipVersionCheck},
                expectationOrigins: TransactionUsecaseMockPatchTransactionByDTOExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmPatchTransactionByDTO.expectations = append(mmPatchTransactionByDTO.expectations, expectation)
        return expectation</span>
}

// Then sets up TransactionUsecase.PatchTransactionByDTO return parameters for the expectation previously defined by the When method
func (e *TransactionUsecaseMockPatchTransactionByDTOExpectation) Then(err error) *TransactionUsecaseMock <span class="cov0" title="0">{
        e.results = &amp;TransactionUsecaseMockPatchTransactionByDTOResults{err}
        return e.mock
}</span>

// Times sets number of times TransactionUsecase.PatchTransactionByDTO should be invoked
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) Times(n uint64) *mTransactionUsecaseMockPatchTransactionByDTO <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.mock.t.Fatalf("Times of TransactionUsecaseMock.PatchTransactionByDTO mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmPatchTransactionByDTO.expectedInvocations, n)
        mmPatchTransactionByDTO.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmPatchTransactionByDTO</span>
}

func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmPatchTransactionByDTO.expectations) == 0 &amp;&amp; mmPatchTransactionByDTO.defaultExpectation == nil &amp;&amp; mmPatchTransactionByDTO.mock.funcPatchTransactionByDTO == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmPatchTransactionByDTO.mock.afterPatchTransactionByDTOCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmPatchTransactionByDTO.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// PatchTransactionByDTO implements mm_usecase.TransactionUsecase
func (mmPatchTransactionByDTO *TransactionUsecaseMock) PatchTransactionByDTO(ctx context.Context, id uuid.UUID, in mm_usecase.PatchTransactionDataInput, skipVersionCheck bool) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmPatchTransactionByDTO.beforePatchTransactionByDTOCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmPatchTransactionByDTO.afterPatchTransactionByDTOCounter, 1)

        mmPatchTransactionByDTO.t.Helper()

        if mmPatchTransactionByDTO.inspectFuncPatchTransactionByDTO != nil </span><span class="cov0" title="0">{
                mmPatchTransactionByDTO.inspectFuncPatchTransactionByDTO(ctx, id, in, skipVersionCheck)
        }</span>

        <span class="cov0" title="0">mm_params := TransactionUsecaseMockPatchTransactionByDTOParams{ctx, id, in, skipVersionCheck}

        // Record call args
        mmPatchTransactionByDTO.PatchTransactionByDTOMock.mutex.Lock()
        mmPatchTransactionByDTO.PatchTransactionByDTOMock.callArgs = append(mmPatchTransactionByDTO.PatchTransactionByDTOMock.callArgs, &amp;mm_params)
        mmPatchTransactionByDTO.PatchTransactionByDTOMock.mutex.Unlock()

        for _, e := range mmPatchTransactionByDTO.PatchTransactionByDTOMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmPatchTransactionByDTO.PatchTransactionByDTOMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmPatchTransactionByDTO.PatchTransactionByDTOMock.defaultExpectation.Counter, 1)
                mm_want := mmPatchTransactionByDTO.PatchTransactionByDTOMock.defaultExpectation.params
                mm_want_ptrs := mmPatchTransactionByDTO.PatchTransactionByDTOMock.defaultExpectation.paramPtrs

                mm_got := TransactionUsecaseMockPatchTransactionByDTOParams{ctx, id, in, skipVersionCheck}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmPatchTransactionByDTO.t.Errorf("TransactionUsecaseMock.PatchTransactionByDTO got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmPatchTransactionByDTO.PatchTransactionByDTOMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmPatchTransactionByDTO.t.Errorf("TransactionUsecaseMock.PatchTransactionByDTO got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmPatchTransactionByDTO.PatchTransactionByDTOMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.in != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.in, mm_got.in) </span><span class="cov0" title="0">{
                                mmPatchTransactionByDTO.t.Errorf("TransactionUsecaseMock.PatchTransactionByDTO got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmPatchTransactionByDTO.PatchTransactionByDTOMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.skipVersionCheck != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.skipVersionCheck, mm_got.skipVersionCheck) </span><span class="cov0" title="0">{
                                mmPatchTransactionByDTO.t.Errorf("TransactionUsecaseMock.PatchTransactionByDTO got unexpected parameter skipVersionCheck, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmPatchTransactionByDTO.PatchTransactionByDTOMock.defaultExpectation.expectationOrigins.originSkipVersionCheck, *mm_want_ptrs.skipVersionCheck, mm_got.skipVersionCheck, minimock.Diff(*mm_want_ptrs.skipVersionCheck, mm_got.skipVersionCheck))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmPatchTransactionByDTO.t.Errorf("TransactionUsecaseMock.PatchTransactionByDTO got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmPatchTransactionByDTO.PatchTransactionByDTOMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmPatchTransactionByDTO.PatchTransactionByDTOMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmPatchTransactionByDTO.t.Fatal("No results are set for the TransactionUsecaseMock.PatchTransactionByDTO")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmPatchTransactionByDTO.funcPatchTransactionByDTO != nil </span><span class="cov0" title="0">{
                return mmPatchTransactionByDTO.funcPatchTransactionByDTO(ctx, id, in, skipVersionCheck)
        }</span>
        <span class="cov0" title="0">mmPatchTransactionByDTO.t.Fatalf("Unexpected call to TransactionUsecaseMock.PatchTransactionByDTO. %v %v %v %v", ctx, id, in, skipVersionCheck)
        return</span>
}

// PatchTransactionByDTOAfterCounter returns a count of finished TransactionUsecaseMock.PatchTransactionByDTO invocations
func (mmPatchTransactionByDTO *TransactionUsecaseMock) PatchTransactionByDTOAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmPatchTransactionByDTO.afterPatchTransactionByDTOCounter)
}</span>

// PatchTransactionByDTOBeforeCounter returns a count of TransactionUsecaseMock.PatchTransactionByDTO invocations
func (mmPatchTransactionByDTO *TransactionUsecaseMock) PatchTransactionByDTOBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmPatchTransactionByDTO.beforePatchTransactionByDTOCounter)
}</span>

// Calls returns a list of arguments used in each call to TransactionUsecaseMock.PatchTransactionByDTO.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPatchTransactionByDTO *mTransactionUsecaseMockPatchTransactionByDTO) Calls() []*TransactionUsecaseMockPatchTransactionByDTOParams <span class="cov0" title="0">{
        mmPatchTransactionByDTO.mutex.RLock()

        argCopy := make([]*TransactionUsecaseMockPatchTransactionByDTOParams, len(mmPatchTransactionByDTO.callArgs))
        copy(argCopy, mmPatchTransactionByDTO.callArgs)

        mmPatchTransactionByDTO.mutex.RUnlock()

        return argCopy
}</span>

// MinimockPatchTransactionByDTODone returns true if the count of the PatchTransactionByDTO invocations corresponds
// the number of defined expectations
func (m *TransactionUsecaseMock) MinimockPatchTransactionByDTODone() bool <span class="cov0" title="0">{
        if m.PatchTransactionByDTOMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.PatchTransactionByDTOMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.PatchTransactionByDTOMock.invocationsDone()</span>
}

// MinimockPatchTransactionByDTOInspect logs each unmet expectation
func (m *TransactionUsecaseMock) MinimockPatchTransactionByDTOInspect() <span class="cov0" title="0">{
        for _, e := range m.PatchTransactionByDTOMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionUsecaseMock.PatchTransactionByDTO at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterPatchTransactionByDTOCounter := mm_atomic.LoadUint64(&amp;m.afterPatchTransactionByDTOCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.PatchTransactionByDTOMock.defaultExpectation != nil &amp;&amp; afterPatchTransactionByDTOCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.PatchTransactionByDTOMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to TransactionUsecaseMock.PatchTransactionByDTO at\n%s", m.PatchTransactionByDTOMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to TransactionUsecaseMock.PatchTransactionByDTO at\n%s with params: %#v", m.PatchTransactionByDTOMock.defaultExpectation.expectationOrigins.origin, *m.PatchTransactionByDTOMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcPatchTransactionByDTO != nil &amp;&amp; afterPatchTransactionByDTOCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to TransactionUsecaseMock.PatchTransactionByDTO at\n%s", m.funcPatchTransactionByDTOOrigin)
        }</span>

        <span class="cov0" title="0">if !m.PatchTransactionByDTOMock.invocationsDone() &amp;&amp; afterPatchTransactionByDTOCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to TransactionUsecaseMock.PatchTransactionByDTO at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.PatchTransactionByDTOMock.expectedInvocations), m.PatchTransactionByDTOMock.expectedInvocationsOrigin, afterPatchTransactionByDTOCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TransactionUsecaseMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockCountReportItemsInspect()

                        m.MinimockCreateTransactionByDTOInspect()

                        m.MinimockDeleteTransactionByIDInspect()

                        m.MinimockFindListInspect()

                        m.MinimockFindListInMapInspect()

                        m.MinimockFindOneByIDInspect()

                        m.MinimockFindPagedListInspect()

                        m.MinimockFindPagedListAsCSVInspect()

                        m.MinimockImportTransactionsFromCSVInspect()

                        m.MinimockPatchTransactionByDTOInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TransactionUsecaseMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *TransactionUsecaseMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockCountReportItemsDone() &amp;&amp;
                m.MinimockCreateTransactionByDTODone() &amp;&amp;
                m.MinimockDeleteTransactionByIDDone() &amp;&amp;
                m.MinimockFindListDone() &amp;&amp;
                m.MinimockFindListInMapDone() &amp;&amp;
                m.MinimockFindOneByIDDone() &amp;&amp;
                m.MinimockFindPagedListDone() &amp;&amp;
                m.MinimockFindPagedListAsCSVDone() &amp;&amp;
                m.MinimockImportTransactionsFromCSVDone() &amp;&amp;
                m.MinimockPatchTransactionByDTODone()
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">package transaction

import (
        "context"
        "errors"
        "fmt"
        "time"

        "cloud.google.com/go/civil"
        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/loghandler"
        "github.com/m11ano/budget_planner/backend/ledger/pkg/pgclient"
        "github.com/samber/lo"
)

func (uc *UsecaseImpl) CreateTransactionByDTO(
        ctx context.Context,
        in usecase.CreateTransactionDataInput,
) (*usecase.TransactionDTO, error) <span class="cov10" title="2">{
        const op = "CreateTransactionByDTO"

        if auth.IsNeedToCheckRights(ctx) </span><span class="cov0" title="0">{
                authData := auth.GetAuthData(ctx)
                if authData == nil || authData.AccountID != in.AccountID </span><span class="cov0" title="0">{
                        return nil, appErrors.ErrForbidden
                }</span>
        }

        <span class="cov10" title="2">transaction, err := entity.NewTransaction(
                in.AccountID,
                in.IsIncome,
                in.Amount,
                in.OccurredOn,
                in.CategoryID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov10" title="2">err = transaction.SetDescription(in.Description)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov10" title="2">err = uc.dbMasterClient.DoWithIsoLvl(ctx, pgclient.Serializable, func(ctx context.Context) error </span><span class="cov10" title="2">{
                _, err := uc.categoryRepo.FindOneByID(ctx, transaction.CategoryID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, appErrors.ErrNotFound) </span><span class="cov0" title="0">{
                                return appErrors.Chainf(appErrors.ErrBadRequest.WithHints("category not found"), "%s.%s", uc.pkg, op)
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov10" title="2">if !in.IsIncome </span><span class="cov1" title="1">{
                        period := civil.Date{
                                Year:  transaction.OccurredOn.Year,
                                Month: transaction.OccurredOn.Month,
                                Day:   1,
                        }

                        budgetCheck, err := uc.budgetRepo.FindList(ctx, &amp;usecase.BudgetListOptions{
                                FilterAccountID:  &amp;transaction.AccountID,
                                FilterPeriod:     &amp;period,
                                FilterCategoryID: &amp;transaction.CategoryID,
                        }, &amp;uctypes.QueryGetListParams{
                                Limit: 1,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov1" title="1">if len(budgetCheck) &gt; 0 </span><span class="cov0" title="0">{
                                budget := budgetCheck[0]

                                periodEnd := period.AddMonths(1).AddDays(-1)

                                reports, err := uc.transactionRepo.CountReportItems(ctx, usecase.CountReportItemsQueryFilter{
                                        AccountID:  transaction.AccountID,
                                        DateFrom:   &amp;period,
                                        DateTo:     &amp;periodEnd,
                                        CategoryID: &amp;transaction.CategoryID,
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">balance := transaction.Amount
                                for _, report := range reports </span><span class="cov0" title="0">{
                                        if report.Sum != nil </span><span class="cov0" title="0">{
                                                balance, err = balance.Add(*report.Sum)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                        }
                                }

                                <span class="cov0" title="0">if balance.Cmp(budget.Amount.Neg()) == -1 </span><span class="cov0" title="0">{
                                        return appErrors.Chainf(appErrors.ErrBadRequest.WithHints("budget limit exceeded"), "%s.%s", uc.pkg, op)
                                }</span>
                        }
                }

                <span class="cov10" title="2">err = uc.transactionRepo.Create(ctx, transaction)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov10" title="2">return nil</span>
        })
        <span class="cov10" title="2">if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov10" title="2">transactionDTO, err := uc.entitiesToDTO(ctx, []*entity.Transaction{transaction})
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov10" title="2">if len(transactionDTO) == 0 </span><span class="cov0" title="0">{
                uc.logger.ErrorContext(loghandler.WithSource(ctx), "unpredicted empty transaction dto")
                return nil, appErrors.Chainf(appErrors.ErrInternal, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov10" title="2">return transactionDTO[0], nil</span>
}

func (uc *UsecaseImpl) PatchTransactionByDTO(
        ctx context.Context,
        id uuid.UUID,
        in usecase.PatchTransactionDataInput,
        skipVersionCheck bool,
) error <span class="cov1" title="1">{
        const op = "PatchTransactionByDTO"

        err := uc.dbMasterClient.DoWithIsoLvl(ctx, pgclient.Serializable, func(ctx context.Context) error </span><span class="cov1" title="1">{
                transaction, err := uc.transactionRepo.FindOneByID(ctx, id, &amp;uctypes.QueryGetOneParams{
                        ForUpdate: true,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">if auth.IsNeedToCheckRights(ctx) </span><span class="cov0" title="0">{
                        authData := auth.GetAuthData(ctx)
                        if authData == nil || authData.AccountID != transaction.AccountID </span><span class="cov0" title="0">{
                                return appErrors.ErrForbidden
                        }</span>
                }

                <span class="cov1" title="1">if !skipVersionCheck &amp;&amp; transaction.Version() != in.Version </span><span class="cov0" title="0">{
                        return appErrors.ErrVersionConflict.
                                WithDetail("last_version", false, transaction.Version()).
                                WithDetail("last_updated_at", false, transaction.UpdatedAt)
                }</span>

                <span class="cov1" title="1">if in.CategoryID != nil </span><span class="cov0" title="0">{
                        _, err := uc.categoryRepo.FindOneByID(ctx, *in.CategoryID, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                if errors.Is(err, appErrors.ErrNotFound) </span><span class="cov0" title="0">{
                                        return appErrors.Chainf(appErrors.ErrBadRequest.WithHints("category not found"), "%s.%s", uc.pkg, op)
                                }</span>
                                <span class="cov0" title="0">return err</span>
                        }

                        <span class="cov0" title="0">transaction.CategoryID = *in.CategoryID</span>
                }

                <span class="cov1" title="1">if in.OccurredOn != nil </span><span class="cov0" title="0">{
                        err := transaction.SetOccuredOn(*in.OccurredOn)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov1" title="1">if in.Amount != nil </span><span class="cov1" title="1">{
                        if !transaction.IsIncome </span><span class="cov0" title="0">{
                                period := civil.Date{
                                        Year:  transaction.OccurredOn.Year,
                                        Month: transaction.OccurredOn.Month,
                                        Day:   1,
                                }

                                budgetCheck, err := uc.budgetRepo.FindList(ctx, &amp;usecase.BudgetListOptions{
                                        FilterAccountID:  &amp;transaction.AccountID,
                                        FilterPeriod:     &amp;period,
                                        FilterCategoryID: &amp;transaction.CategoryID,
                                }, &amp;uctypes.QueryGetListParams{
                                        Limit: 1,
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">if len(budgetCheck) &gt; 0 </span><span class="cov0" title="0">{
                                        budget := budgetCheck[0]

                                        periodEnd := period.AddMonths(1).AddDays(-1)

                                        reports, err := uc.transactionRepo.CountReportItems(ctx, usecase.CountReportItemsQueryFilter{
                                                AccountID:  transaction.AccountID,
                                                DateFrom:   &amp;period,
                                                DateTo:     &amp;periodEnd,
                                                CategoryID: &amp;transaction.CategoryID,
                                                ExcludeIDs: []uuid.UUID{transaction.ID},
                                        })
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>

                                        <span class="cov0" title="0">balance := *in.Amount
                                        for _, report := range reports </span><span class="cov0" title="0">{
                                                if report.Sum != nil </span><span class="cov0" title="0">{
                                                        balance, err = balance.Add(*report.Sum)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                return err
                                                        }</span>
                                                }
                                        }

                                        <span class="cov0" title="0">if balance.Cmp(budget.Amount.Neg()) == -1 </span><span class="cov0" title="0">{
                                                return appErrors.Chainf(appErrors.ErrBadRequest.WithHints("budget limit exceeded"), "%s.%s", uc.pkg, op)
                                        }</span>
                                }
                        }

                        <span class="cov1" title="1">err = transaction.SetAmount(*in.Amount)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov1" title="1">if in.Description != nil </span><span class="cov1" title="1">{
                        err = transaction.SetDescription(*in.Description)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov1" title="1">err = uc.transactionRepo.Update(ctx, transaction)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">return nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (uc *UsecaseImpl) DeleteTransactionByID(ctx context.Context, id uuid.UUID) error <span class="cov1" title="1">{
        const op = "DeleteTransactionByID"

        err := uc.dbMasterClient.Do(ctx, func(ctx context.Context) error </span><span class="cov1" title="1">{
                transaction, err := uc.transactionRepo.FindOneByID(ctx, id, &amp;uctypes.QueryGetOneParams{
                        ForUpdate: true,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">if auth.IsNeedToCheckRights(ctx) </span><span class="cov0" title="0">{
                        authData := auth.GetAuthData(ctx)
                        if authData == nil || authData.AccountID != transaction.AccountID </span><span class="cov0" title="0">{
                                return appErrors.ErrForbidden
                        }</span>
                }

                <span class="cov1" title="1">transaction.DeletedAt = lo.ToPtr(time.Now())

                err = uc.transactionRepo.Update(ctx, transaction)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">return nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (uc *UsecaseImpl) ImportTransactionsFromCSV(
        ctx context.Context,
        data []byte,
        accountID uuid.UUID,
) error <span class="cov1" title="1">{
        const op = "ImportTransactionsFromCSV"

        items, err := uc.transactionCSVRepo.ItemsFromCSV(ctx, data, accountID)
        if err != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">err = uc.dbMasterClient.DoWithIsoLvl(ctx, pgclient.Serializable, func(ctx context.Context) error </span><span class="cov1" title="1">{
                for idx, item := range items </span><span class="cov0" title="0">{
                        _, err := uc.CreateTransactionByDTO(ctx, usecase.CreateTransactionDataInput{
                                AccountID:   accountID,
                                IsIncome:    item.IsIncome,
                                Amount:      item.Amount,
                                OccurredOn:  item.OccurredOn,
                                CategoryID:  item.CategoryID,
                                Description: item.Description,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                appErr, ok := appErrors.ExtractError(err)
                                if ok </span><span class="cov0" title="0">{
                                        hints := appErr.Hints()
                                        hints = append(hints, fmt.Sprintf("line %d", idx+1))

                                        return appErrors.Chainf(appErr.WithHints(hints...), "%s.%s: line %d", uc.pkg, op, idx+1)
                                }</span>
                                <span class="cov0" title="0">return appErrors.Chainf(err, "%s.%s: line %d", uc.pkg, op, idx+1)</span>
                        }
                }

                <span class="cov1" title="1">return nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package transaction

import (
        "context"
        "fmt"
        "strings"

        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        "github.com/samber/lo"
)

func (uc *UsecaseImpl) entitiesToDTO(
        ctx context.Context,
        items []*entity.Transaction,
) ([]*usecase.TransactionDTO, error) <span class="cov8" title="7">{
        out := make([]*usecase.TransactionDTO, 0, len(items))

        categoriesIDs := lo.Map(items, func(item *entity.Transaction, _ int) uint64 </span><span class="cov10" title="9">{
                return item.CategoryID
        }</span>)

        <span class="cov8" title="7">categories, err := uc.categoryRepo.FindList(ctx, &amp;usecase.CategoryListOptions{
                FilterIDs: &amp;categoriesIDs,
        }, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="7">categoriesMap := lo.SliceToMap(categories, func(item *entity.Category) (uint64, *entity.Category) </span><span class="cov10" title="9">{
                return item.ID, item
        }</span>)

        <span class="cov8" title="7">for _, item := range items </span><span class="cov10" title="9">{
                resItem := &amp;usecase.TransactionDTO{
                        Transaction: item,
                }

                if category, ok := categoriesMap[item.CategoryID]; ok </span><span class="cov10" title="9">{
                        resItem.Category = category
                }</span>

                <span class="cov10" title="9">out = append(out, resItem)</span>
        }

        <span class="cov8" title="7">return out, nil</span>
}

func buildKeyForCountReportItems(queryFilter usecase.CountReportItemsQueryFilter) string <span class="cov1" title="1">{
        var strBuilder strings.Builder

        strBuilder.WriteString("Transaction::CountReportItems::")

        strBuilder.WriteString(queryFilter.AccountID.String())

        if queryFilter.DateFrom != nil </span><span class="cov0" title="0">{
                strBuilder.WriteString("::dateFrom:")
                strBuilder.WriteString(queryFilter.DateFrom.String())
        }</span>

        <span class="cov1" title="1">if queryFilter.DateTo != nil </span><span class="cov0" title="0">{
                strBuilder.WriteString("::dateTo:")
                strBuilder.WriteString(queryFilter.DateTo.String())
        }</span>

        <span class="cov1" title="1">if queryFilter.CategoryID != nil </span><span class="cov0" title="0">{
                strBuilder.WriteString("::categoryID:")
                strBuilder.WriteString(fmt.Sprintf("%d", *queryFilter.CategoryID))
        }</span>

        <span class="cov1" title="1">return strBuilder.String()</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package transaction

import (
        "log/slog"

        "github.com/m11ano/budget_planner/backend/ledger/internal/app/config"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/db"
        "golang.org/x/sync/singleflight"
)

type UsecaseImpl struct {
        pkg                  string
        logger               *slog.Logger
        cfg                  config.Config
        dbMasterClient       db.MasterClient
        sfGroup              singleflight.Group
        transactionRepo      usecase.TransactionRepository
        transactionCacheRepo usecase.TransactionCacheRepository
        transactionCSVRepo   usecase.TransactionCSVRepository
        categoryRepo         usecase.CategoryRepository
        budgetRepo           usecase.BudgetRepository
}

func NewUsecaseImpl(
        logger *slog.Logger,
        cfg config.Config,
        dbMasterClient db.MasterClient,
        transactionRepo usecase.TransactionRepository,
        transactionCacheRepo usecase.TransactionCacheRepository,
        transactionCSVRepo usecase.TransactionCSVRepository,
        categoryRepo usecase.CategoryRepository,
        budgetRepo usecase.BudgetRepository,
) *UsecaseImpl <span class="cov10" title="11">{
        uc := &amp;UsecaseImpl{
                pkg:                  "Budget.Usecase.Transaction",
                logger:               logger,
                cfg:                  cfg,
                dbMasterClient:       dbMasterClient,
                transactionRepo:      transactionRepo,
                transactionCacheRepo: transactionCacheRepo,
                transactionCSVRepo:   transactionCSVRepo,
                categoryRepo:         categoryRepo,
                budgetRepo:           budgetRepo,
        }
        return uc
}</span>
</pre>
		
		<pre class="file" id="file86" style="display: none">package transaction

import (
        "context"
        "errors"
        "log/slog"
        "slices"
        "time"

        "cloud.google.com/go/civil"
        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/loghandler"
        "github.com/m11ano/budget_planner/backend/ledger/pkg/pgclient"
        "github.com/samber/lo"

        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
)

func (uc *UsecaseImpl) FindOneByID(
        ctx context.Context,
        id uuid.UUID,
        queryParams *uctypes.QueryGetOneParams,
) (*usecase.TransactionDTO, error) <span class="cov1" title="1">{
        const op = "FindOneByID"

        item, err := uc.transactionRepo.FindOneByID(ctx, id, queryParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">if auth.IsNeedToCheckRights(ctx) </span><span class="cov0" title="0">{
                authData := auth.GetAuthData(ctx)
                if authData == nil || authData.AccountID != item.AccountID </span><span class="cov0" title="0">{
                        return nil, appErrors.ErrForbidden
                }</span>
        }

        <span class="cov1" title="1">dto, err := uc.entitiesToDTO(ctx, []*entity.Transaction{item})
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">if len(dto) == 0 </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrInternal, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return dto[0], nil</span>
}

func (uc *UsecaseImpl) FindList(
        ctx context.Context,
        listOptions *usecase.TransactionListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]*usecase.TransactionDTO, error) <span class="cov1" title="1">{
        const op = "FindList"

        items, err := uc.transactionRepo.FindList(ctx, listOptions, queryParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">out, err := uc.entitiesToDTO(ctx, items)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return out, nil</span>
}

func (uc *UsecaseImpl) FindPagedList(
        ctx context.Context,
        listOptions *usecase.TransactionListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]*usecase.TransactionDTO, uint64, error) <span class="cov10" title="2">{
        const op = "FindPagedList"

        items, total, err := uc.transactionRepo.FindPagedList(ctx, listOptions, queryParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov10" title="2">out, err := uc.entitiesToDTO(ctx, items)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov10" title="2">return out, total, nil</span>
}

func (uc *UsecaseImpl) FindListInMap(
        ctx context.Context,
        listOptions *usecase.TransactionListOptions,
        queryParams *uctypes.QueryGetListParams,
) (map[uuid.UUID]*usecase.TransactionDTO, error) <span class="cov1" title="1">{
        const op = "FindListInMap"

        items, err := uc.transactionRepo.FindList(ctx, listOptions, queryParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">out, err := uc.entitiesToDTO(ctx, items)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">result := lo.SliceToMap(out, func(item *usecase.TransactionDTO) (uuid.UUID, *usecase.TransactionDTO) </span><span class="cov10" title="2">{
                return item.Transaction.ID, item
        }</span>)

        <span class="cov1" title="1">return result, nil</span>
}

type CountReportItemsSFResult struct {
        Items    []*entity.ReportItem
        HitCache bool
}

var reportsCacheTTL = time.Second * 30

func (uc *UsecaseImpl) CountReportItems(
        ctx context.Context,
        queryFilter usecase.CountReportItemsQueryFilter,
) ([]*entity.ReportItem, bool, error) <span class="cov1" title="1">{
        const op = "CountReportItems"

        key := buildKeyForCountReportItems(queryFilter)

        result, err, _ := uc.sfGroup.Do(key, func() (any, error) </span><span class="cov1" title="1">{
                cacheItems, err := uc.transactionCacheRepo.GetReports(ctx, key)
                if err == nil </span><span class="cov1" title="1">{
                        uc.logger.InfoContext(ctx, "CountReportItems cache hit", slog.Any("key", key))

                        return CountReportItemsSFResult{
                                Items:    cacheItems,
                                HitCache: true,
                        }, nil
                }</span> else<span class="cov0" title="0"> if !errors.Is(err, appErrors.ErrNotFound) </span><span class="cov0" title="0">{
                        uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis get err", slog.Any("error", err))
                }</span>

                <span class="cov0" title="0">uc.logger.InfoContext(ctx, "CountReportItems cache miss", slog.Any("key", key))

                items, err := uc.countReportItems(ctx, queryFilter)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">err = uc.transactionCacheRepo.SaveReports(ctx, key, items, &amp;reportsCacheTTL)
                if err != nil </span><span class="cov0" title="0">{
                        uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis save err", slog.Any("error", err))
                }</span>

                <span class="cov0" title="0">return CountReportItemsSFResult{
                        Items:    items,
                        HitCache: false,
                }, nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, false, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">sfResult, ok := result.(CountReportItemsSFResult)
        if !ok </span><span class="cov0" title="0">{
                return nil, false, appErrors.Chainf(appErrors.ErrInternal, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return sfResult.Items, sfResult.HitCache, nil</span>
}

func (uc *UsecaseImpl) countReportItems(
        ctx context.Context,
        queryFilter usecase.CountReportItemsQueryFilter,
) ([]*entity.ReportItem, error) <span class="cov0" title="0">{
        const op = "CountReportItems"

        out := make([]*entity.ReportItem, 0)

        err := uc.dbMasterClient.DoWithIsoLvl(ctx, pgclient.RepeatableRead, func(ctx context.Context) error </span><span class="cov0" title="0">{
                var err error

                categories, err := uc.categoryRepo.FindList(ctx, &amp;usecase.CategoryListOptions{
                        Sort: []uctypes.SortOption[usecase.CategoryListOptionsSortField]{
                                {
                                        Field:  usecase.CategoryListOptionsSortFieldID,
                                        IsDesc: false,
                                },
                        },
                }, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if queryFilter.CategoryID != nil </span><span class="cov0" title="0">{
                        categories = lo.Filter(categories, func(item *entity.Category, _ int) bool </span><span class="cov0" title="0">{
                                return item.ID == *queryFilter.CategoryID
                        }</span>)
                }

                <span class="cov0" title="0">txReportItems, err := uc.transactionRepo.CountReportItems(ctx, queryFilter)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">slices.SortFunc(txReportItems, func(a, b *entity.AccountTransactionReportItem) int </span><span class="cov0" title="0">{
                        return a.Period.Compare(b.Period)
                }</span>)

                <span class="cov0" title="0">var dateStart civil.Date
                if queryFilter.DateFrom != nil </span><span class="cov0" title="0">{
                        dateStart = *queryFilter.DateFrom
                }</span> else<span class="cov0" title="0"> {
                        if len(txReportItems) == 0 </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">dateStart = txReportItems[0].Period</span>
                }

                <span class="cov0" title="0">var dateEnd civil.Date
                if queryFilter.DateTo != nil </span><span class="cov0" title="0">{
                        dateEnd = *queryFilter.DateTo
                }</span> else<span class="cov0" title="0"> {
                        if len(txReportItems) == 0 </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">dateEnd = txReportItems[len(txReportItems)-1].Period.AddMonths(1).AddDays(-1)</span>
                }

                <span class="cov0" title="0">periodStart := dateStart
                periodStart.Day = 1

                periodEnd := dateEnd
                periodEnd.Day = 1

                budgets, err := uc.budgetRepo.FindList(ctx, &amp;usecase.BudgetListOptions{
                        FilterAccountID:  &amp;queryFilter.AccountID,
                        FilterPeriodFrom: &amp;periodStart,
                        FilterPeriodTo:   &amp;periodEnd,
                }, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">for p := periodStart; p.Compare(periodEnd) &lt;= 0; p = p.AddMonths(1) </span><span class="cov0" title="0">{
                        item := &amp;entity.ReportItem{
                                AccountID: queryFilter.AccountID,
                                Items:     make([]*entity.AccountTransactionReportItem, 0),
                        }

                        if p.Compare(periodStart) == 0 </span><span class="cov0" title="0">{
                                item.DateFrom = dateStart
                        }</span> else<span class="cov0" title="0"> {
                                item.DateFrom = p
                        }</span>

                        <span class="cov0" title="0">if p.Compare(periodEnd) == 0 </span><span class="cov0" title="0">{
                                item.DateTo = dateEnd
                        }</span> else<span class="cov0" title="0"> {
                                item.DateTo = p.AddMonths(1).AddDays(-1)
                        }</span>

                        <span class="cov0" title="0">for _, category := range categories </span><span class="cov0" title="0">{
                                itemInReports, ok := lo.Find(txReportItems, func(item *entity.AccountTransactionReportItem) bool </span><span class="cov0" title="0">{
                                        return item.Period.Compare(p) == 0 &amp;&amp; item.CategoryID == category.ID
                                }</span>)

                                <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                                        item.Items = append(item.Items, itemInReports)
                                }</span> else<span class="cov0" title="0"> {
                                        repItem := &amp;entity.AccountTransactionReportItem{
                                                Period:     p,
                                                CategoryID: category.ID,
                                        }

                                        budgetForItem, ok := lo.Find(budgets, func(budget *entity.Budget) bool </span><span class="cov0" title="0">{
                                                return budget.CategoryID == category.ID &amp;&amp; budget.Period.Compare(repItem.Period) == 0
                                        }</span>)
                                        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                                                repItem.BudgetID = &amp;budgetForItem.ID
                                                repItem.BudgetAmount = &amp;budgetForItem.Amount
                                        }</span>

                                        <span class="cov0" title="0">item.Items = append(item.Items, repItem)</span>
                                }
                        }

                        <span class="cov0" title="0">out = append(out, item)</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov0" title="0">return out, nil</span>
}

func (uc *UsecaseImpl) FindPagedListAsCSV(
        ctx context.Context,
        listOptions *usecase.TransactionListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]byte, uint64, error) <span class="cov1" title="1">{
        const op = "FindPagedListAsCSV"

        items, total, err := uc.FindPagedList(ctx, listOptions, queryParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">data, err := uc.transactionCSVRepo.ItemsToCSV(ctx, items)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return data, total, nil</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package db

import (
        "fmt"
        "log/slog"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/stdlib"
        "github.com/pressly/goose/v3"
)

func UpMigrations(dsn string, migrationsPath string, logger *slog.Logger) error <span class="cov0" title="0">{
        if err := goose.SetDialect("postgres"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to set dialect: %w", err)
        }</span>

        <span class="cov0" title="0">gooseLogger := &amp;migrationsLogger{logger: logger}
        goose.SetLogger(gooseLogger)

        pgxCfg, err := pgx.ParseConfig(dsn)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to parse dsn: %w", err)
        }</span>

        <span class="cov0" title="0">db := stdlib.OpenDB(*pgxCfg)
        defer func() </span><span class="cov0" title="0">{
                err := db.Close()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("unable to close db connection: %v", err))
                }</span>
        }()

        <span class="cov0" title="0">if err := goose.Up(db, migrationsPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to run up migrations: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func DownMigrations(dsn string, migrationsPath string, logger *slog.Logger) error <span class="cov0" title="0">{
        if err := goose.SetDialect("postgres"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to set dialect: %w", err)
        }</span>

        <span class="cov0" title="0">gooseLogger := &amp;migrationsLogger{logger: logger}
        goose.SetLogger(gooseLogger)

        pgxCfg, err := pgx.ParseConfig(dsn)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to parse dsn: %w", err)
        }</span>

        <span class="cov0" title="0">db := stdlib.OpenDB(*pgxCfg)
        defer func() </span><span class="cov0" title="0">{
                err := db.Close()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Sprintf("unable to close db connection: %v", err))
                }</span>
        }()

        <span class="cov0" title="0">if err := goose.DownTo(db, migrationsPath, 0); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to run down migrations: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type migrationsLogger struct {
        logger *slog.Logger
}

func (l *migrationsLogger) Fatalf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.logger.Error(fmt.Sprintf(format, v...))
}</span>

func (l *migrationsLogger) Printf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.logger.Info(fmt.Sprintf(format, v...))
}</span>
</pre>
		
		<pre class="file" id="file88" style="display: none">package loghandler

import "context"

type contextKey string

const (
        contextKeyData       contextKey = "log_context_data"
        contextKeyWithSource contextKey = "log_context_with_source"
)

type contextData map[string]any

func GetData(ctx context.Context) (contextData, bool) <span class="cov0" title="0">{
        data, ok := ctx.Value(contextKeyData).(contextData)
        return data, ok
}</span>

func SetData(ctx context.Context, key string, value any) (contextData, contextKey) <span class="cov0" title="0">{
        data, ok := GetData(ctx)
        if !ok </span><span class="cov0" title="0">{
                data = contextData{}
        }</span>

        <span class="cov0" title="0">data[key] = value

        return data, contextKeyData</span>
}

func SetContextData(ctx context.Context, key string, value any) context.Context <span class="cov0" title="0">{
        data, ctxKey := SetData(ctx, key, value)
        return context.WithValue(ctx, ctxKey, data)
}</span>

func WithSource(ctx context.Context) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, contextKeyWithSource, true)
}</span>

func IsWithSource(ctx context.Context) bool <span class="cov0" title="0">{
        is, ok := ctx.Value(contextKeyWithSource).(bool)
        return ok &amp;&amp; is
}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">package loghandler

import (
        "context"
        "log/slog"
        "runtime"
)

type handlerMiddlware struct {
        next slog.Handler
}

func NewHandlerMiddleware(next slog.Handler) *handlerMiddlware <span class="cov0" title="0">{
        return &amp;handlerMiddlware{next: next}
}</span>

func (h *handlerMiddlware) Enabled(ctx context.Context, rec slog.Level) bool <span class="cov0" title="0">{
        return h.next.Enabled(ctx, rec)
}</span>

func (h *handlerMiddlware) Handle(ctx context.Context, rec slog.Record) error <span class="cov0" title="0">{
        data, ok := GetData(ctx)
        if ok </span><span class="cov0" title="0">{
                for k, v := range data </span><span class="cov0" title="0">{
                        rec.Add(k, v)
                }</span>
        }

        <span class="cov0" title="0">if IsWithSource(ctx) </span><span class="cov0" title="0">{
                if pc, file, line, ok := runtime.Caller(3); ok </span><span class="cov0" title="0">{
                        fn := runtime.FuncForPC(pc).Name()

                        rec.AddAttrs(
                                slog.Group("source",
                                        slog.String("file", file),
                                        slog.String("function", fn),
                                        slog.Int("line", line),
                                ),
                        )
                }</span>
        }

        <span class="cov0" title="0">return h.next.Handle(ctx, rec)</span>
}

func (h *handlerMiddlware) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov0" title="0">{
        return &amp;handlerMiddlware{next: h.next.WithAttrs(attrs)}
}</span>

func (h *handlerMiddlware) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        return &amp;handlerMiddlware{next: h.next.WithGroup(name)}
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">package redis

import "github.com/redis/go-redis/v9"

type ClientConfig struct {
        Addr     string
        Password string
}

func NewRedisClient(cfg ClientConfig) *redis.Client <span class="cov0" title="0">{
        return redis.NewClient(&amp;redis.Options{
                Addr:     cfg.Addr,
                Password: cfg.Password,
        })
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">package backoff

import (
        "container/heap"
        "context"
        "sync"
        "sync/atomic"
        "time"
)

type ControllerOption func(*controllerOptions)

type SessionOption func(*sessionOptions)

const DefaultGroupID = "default"

type Controller struct {
        ctx        context.Context
        cancel     context.CancelFunc
        heapCtrl   *heapController
        sessions   map[string]*Session
        groupCfg   map[string]*sessionOptions
        mu         sync.RWMutex
        opts       *controllerOptions
        evictGoing int32
}

func NewController(ctrlOpts ...ControllerOption) *Controller <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        cOpts := defaultControllerOptions()
        for _, opt := range ctrlOpts </span><span class="cov0" title="0">{
                opt(cOpts)
        }</span>

        <span class="cov0" title="0">ctrl := &amp;Controller{
                ctx:        ctx,
                cancel:     cancel,
                heapCtrl:   newHeapController(),
                sessions:   make(map[string]*Session),
                groupCfg:   make(map[string]*sessionOptions),
                opts:       cOpts,
                evictGoing: 1,
        }

        ctrl.groupCfg[DefaultGroupID] = defaultSessionOptions()

        go ctrl.evictLoop()
        return ctrl</span>
}

func (c *Controller) SetConfigForGroup(groupID string, opts ...SessionOption) <span class="cov0" title="0">{
        cfg := defaultSessionOptions()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(cfg)
        }</span>

        <span class="cov0" title="0">c.mu.Lock()
        c.groupCfg[groupID] = cfg
        c.mu.Unlock()</span>
}

func (c *Controller) GetIfExists(sessionKey string, groupID ...string) (*Session, bool) <span class="cov0" title="0">{
        useGroup := DefaultGroupID
        if len(groupID) &gt; 0 &amp;&amp; groupID[0] != "" </span><span class="cov0" title="0">{
                useGroup = groupID[0]
        }</span>
        <span class="cov0" title="0">key := sessionKey + "_" + useGroup

        c.mu.RLock()
        sess, sessOK := c.sessions[key]
        _, cfgOK := c.groupCfg[useGroup]
        c.mu.RUnlock()

        if sessOK &amp;&amp; cfgOK &amp;&amp; !sess.isExpired() </span><span class="cov0" title="0">{
                return sess, true
        }</span>

        <span class="cov0" title="0">return nil, false</span>
}

func (c *Controller) Get(sessionKey string, groupIDs ...string) *Session <span class="cov0" title="0">{
        useGroup := DefaultGroupID
        if len(groupIDs) &gt; 0 &amp;&amp; groupIDs[0] != "" </span><span class="cov0" title="0">{
                useGroup = groupIDs[0]
        }</span>
        <span class="cov0" title="0">key := sessionKey + "_" + useGroup

        c.mu.RLock()
        sess, sessOK := c.sessions[key]
        cfg, cfgOK := c.groupCfg[useGroup]
        c.mu.RUnlock()

        if sessOK &amp;&amp; cfgOK &amp;&amp; !sess.isExpired() </span><span class="cov0" title="0">{
                return sess
        }</span>

        <span class="cov0" title="0">c.mu.Lock()
        defer c.mu.Unlock()

        if !cfgOK </span><span class="cov0" title="0">{
                cfg = defaultSessionOptions()
                c.groupCfg[useGroup] = cfg
        }</span>

        <span class="cov0" title="0">sess = newSession(c.heapCtrl, key, cfg)
        c.sessions[key] = sess

        return sess</span>
}

func (c *Controller) removeSession(s *Session) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        delete(c.sessions, s.Key())
        atomic.StoreInt32(&amp;s.expired, 1)
}</span>

func (c *Controller) evictLoop() <span class="cov0" title="0">{
        defer atomic.StoreInt32(&amp;c.evictGoing, 0)

        ticker := time.NewTicker(c.opts.ClearInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-c.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        var toRemove []*Session

                        c.heapCtrl.mu.Lock()
                        for c.heapCtrl.Len() &gt; 0 </span><span class="cov0" title="0">{
                                item := c.heapCtrl.items[0]
                                if !item.session.isExpired() </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">heap.Pop(c.heapCtrl)
                                toRemove = append(toRemove, item.session)</span>
                        }
                        <span class="cov0" title="0">c.heapCtrl.mu.Unlock()

                        for _, s := range toRemove </span><span class="cov0" title="0">{
                                c.removeSession(s)
                        }</span>
                }
        }
}

func (c *Controller) Stop(ctx context.Context) <span class="cov0" title="0">{
        c.cancel()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        if atomic.LoadInt32(&amp;c.evictGoing) == 0 </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package backoff

import (
        "container/heap"
        "sync"
        "time"
)

type heapItem struct {
        session   *Session
        expiredAt time.Time
        index     int
}

type heapController struct {
        mu    sync.Mutex
        items []*heapItem
        idx   map[string]*heapItem
}

func newHeapController() *heapController <span class="cov0" title="0">{
        h := &amp;heapController{idx: make(map[string]*heapItem)}
        heap.Init(h)
        return h
}</span>

func (h *heapController) Len() int <span class="cov0" title="0">{
        return len(h.items)
}</span>

func (h *heapController) Less(i, j int) bool <span class="cov0" title="0">{
        return h.items[i].expiredAt.Before(h.items[j].expiredAt)
}</span>

func (h *heapController) Swap(i, j int) <span class="cov0" title="0">{
        h.items[i], h.items[j] = h.items[j], h.items[i]
        h.items[i].index = i
        h.items[j].index = j
}</span>

func (h *heapController) Push(x interface{}) <span class="cov0" title="0">{
        // nolint
        item := x.(*heapItem)
        h.items = append(h.items, item)
        item.index = len(h.items) - 1
        h.idx[item.session.Key()] = item
}</span>

func (h *heapController) Pop() interface{} <span class="cov0" title="0">{
        n := len(h.items)
        item := h.items[n-1]
        h.items = h.items[:n-1]
        delete(h.idx, item.session.Key())
        return item
}</span>

func (h *heapController) add(s *Session) <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()
        h.Push(&amp;heapItem{
                session:   s,
                expiredAt: s.expiredAt,
        })
}</span>

func (h *heapController) update(s *Session) <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()
        if item, ok := h.idx[s.key]; ok </span><span class="cov0" title="0">{
                item.expiredAt = s.expiredAt
                heap.Fix(h, item.index)
        }</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package backoff

import "time"

type controllerOptions struct {
        ClearInterval time.Duration
}

func defaultControllerOptions() *controllerOptions <span class="cov0" title="0">{
        return &amp;controllerOptions{
                ClearInterval: 1 * time.Minute,
        }
}</span>

func WithControllerClearInterval(d time.Duration) ControllerOption <span class="cov0" title="0">{
        return func(o *controllerOptions) </span><span class="cov0" title="0">{
                o.ClearInterval = d
        }</span>
}

type sessionOptions struct {
        Ttl             time.Duration
        InitialInterval time.Duration
        Multiplier      float64
        MaxInterval     time.Duration
}

func defaultSessionOptions() *sessionOptions <span class="cov0" title="0">{
        return &amp;sessionOptions{
                Ttl:             1 * time.Hour,
                InitialInterval: 1 * time.Second,
                Multiplier:      2,
                MaxInterval:     60 * time.Second,
        }
}</span>

func WithTtl(d time.Duration) SessionOption <span class="cov0" title="0">{
        return func(o *sessionOptions) </span><span class="cov0" title="0">{
                o.Ttl = d
        }</span>
}

func WithInitialInterval(d time.Duration) SessionOption <span class="cov0" title="0">{
        return func(o *sessionOptions) </span><span class="cov0" title="0">{
                o.InitialInterval = d
        }</span>
}

func WithMultiplier(m float64) SessionOption <span class="cov0" title="0">{
        return func(o *sessionOptions) </span><span class="cov0" title="0">{
                o.Multiplier = m
        }</span>
}

func WithMaxInterval(d time.Duration) SessionOption <span class="cov0" title="0">{
        return func(o *sessionOptions) </span><span class="cov0" title="0">{
                o.MaxInterval = d
        }</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package backoff

import (
        "math"
        "sync"
        "sync/atomic"
        "time"
)

type Session struct {
        heapCtrl       *heapController
        key            string
        cfg            *sessionOptions
        nextAllowedAt  time.Time
        mu             sync.RWMutex
        expiredAt      time.Time
        expired        int32
        counter        int
        backoffCounter int
}

func newSession(heapCtrl *heapController, key string, opts *sessionOptions) *Session <span class="cov0" title="0">{
        s := &amp;Session{
                heapCtrl:      heapCtrl,
                key:           key,
                cfg:           opts,
                nextAllowedAt: time.Now(),
                expiredAt:     time.Now().Add(opts.Ttl),
        }

        heapCtrl.add(s)
        return s
}</span>

func (s *Session) isExpired() bool <span class="cov0" title="0">{
        return time.Now().After(s.expiredAt)
}</span>

func (s *Session) AddBackoff() bool <span class="cov0" title="0">{
        if atomic.LoadInt32(&amp;s.expired) == 1 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()

        mul := time.Duration(math.Pow(s.cfg.Multiplier, float64(s.backoffCounter)))

        s.backoffCounter++

        diffTime := time.Duration(s.cfg.InitialInterval * mul)
        if diffTime &gt; s.cfg.MaxInterval </span><span class="cov0" title="0">{
                diffTime = s.cfg.MaxInterval
        }</span>

        <span class="cov0" title="0">s.nextAllowedAt = time.Now().Add(diffTime)
        s.expiredAt = time.Now().Add(s.cfg.Ttl)
        s.heapCtrl.update(s)

        return true</span>
}

func (s *Session) Counter() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.counter
}</span>

func (s *Session) AddCounter(value ...int) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        val := 1
        if len(value) &gt; 0 </span><span class="cov0" title="0">{
                val = value[0]
        }</span>

        <span class="cov0" title="0">s.counter += val
        s.expiredAt = time.Now().Add(s.cfg.Ttl)
        s.heapCtrl.update(s)</span>
}

func (s *Session) Key() string <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.key
}</span>

func (s *Session) IsAllowed() bool <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return time.Now().After(s.nextAllowedAt) || time.Now().Equal(s.nextAllowedAt)
}</span>

func (s *Session) Reset() <span class="cov0" title="0">{
        if atomic.LoadInt32(&amp;s.expired) == 1 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()

        s.counter = 0
        s.backoffCounter = 0
        s.nextAllowedAt = time.Now()
        s.expiredAt = time.Now().Add(s.cfg.Ttl)
        s.heapCtrl.update(s)</span>
}

func (s *Session) NextAllowed() time.Time <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.nextAllowedAt
}</span>

func (s *Session) NextAllowedUntilSeconds() int64 <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        diff := time.Until(s.nextAllowedAt).Seconds()
        if diff &lt; 0 </span><span class="cov0" title="0">{
                diff = 0
        }</span>

        <span class="cov0" title="0">return int64(math.Ceil(diff))</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package dbhelper

import (
        "fmt"
        "reflect"
        "sync"
)

type ConverterFunc func(src interface{}) (interface{}, error)

var convertersMu sync.RWMutex

var converters = make(map[string]ConverterFunc)

func converterKey(srcType, dstType reflect.Type) string <span class="cov10" title="25">{
        return srcType.String() + "-&gt;" + dstType.String()
}</span>

func RegisterBidirectionalConverter(dbType, domainType reflect.Type,
        dbToDomain ConverterFunc, domainToDB ConverterFunc,
) <span class="cov4" title="4">{
        convertersMu.Lock()
        defer convertersMu.Unlock()
        converters[converterKey(dbType, domainType)] = dbToDomain
        converters[converterKey(domainType, dbType)] = domainToDB
}</span>

func getConverter(srcType, dstType reflect.Type) (ConverterFunc, bool) <span class="cov8" title="17">{
        convertersMu.RLock()
        defer convertersMu.RUnlock()
        conv, ok := converters[converterKey(srcType, dstType)]
        return conv, ok
}</span>

func safeConvert(conv ConverterFunc, src interface{}) (result interface{}, err error) <span class="cov5" title="5">{
        defer func() </span><span class="cov5" title="5">{
                if r := recover(); r != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("panic in converter: %v", r)
                }</span>
        }()
        <span class="cov5" title="5">result, err = conv(src)
        return</span>
}

func ConvertDBToDomain(dbRecord, domainModel interface{}) error <span class="cov6" title="6">{
        dbVal := reflect.ValueOf(dbRecord)
        if dbVal.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                dbVal = dbVal.Elem()
        }</span>
        <span class="cov6" title="6">if dbVal.Kind() != reflect.Struct </span><span class="cov1" title="1">{
                return fmt.Errorf("dbRecord must be a struct or pointer to a struct")
        }</span>

        <span class="cov5" title="5">dVal := reflect.ValueOf(domainModel)
        if dVal.Kind() != reflect.Ptr || dVal.Elem().Kind() != reflect.Struct </span><span class="cov1" title="1">{
                return fmt.Errorf("domainModel must be a pointer to a struct")
        }</span>
        <span class="cov4" title="4">dVal = dVal.Elem()
        dType := dVal.Type()

        dbType := dbVal.Type()
        for i := 0; i &lt; dbType.NumField(); i++ </span><span class="cov6" title="8">{
                dbField := dbType.Field(i)
                dbFieldValue := dbVal.Field(i)
                if !dbFieldValue.IsValid() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov6" title="8">fieldName := dbField.Name

                dField, found := dType.FieldByName(fieldName)
                if !found </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov6" title="7">dFieldVal := dVal.FieldByName(dField.Name)
                if !dFieldVal.CanSet() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov6" title="7">srcType := dbFieldValue.Type()
                dstType := dFieldVal.Type()

                if conv, ok := getConverter(srcType, dstType); ok </span><span class="cov1" title="1">{
                        converted, err := safeConvert(conv, dbFieldValue.Interface())
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("converter error for field %s: %v", dbField.Name, err)
                        }</span>
                        <span class="cov1" title="1">convVal := reflect.ValueOf(converted)
                        if !convVal.Type().AssignableTo(dstType) </span><span class="cov0" title="0">{
                                return fmt.Errorf("converted value for field %s is not assignable to type %s", dbField.Name, dstType)
                        }</span>
                        <span class="cov1" title="1">dFieldVal.Set(convVal)
                        continue</span>
                }

                <span class="cov6" title="6">if srcType.AssignableTo(dstType) </span><span class="cov5" title="5">{
                        dFieldVal.Set(dbFieldValue)
                        continue</span>
                }

                <span class="cov1" title="1">if srcType.ConvertibleTo(dstType) </span><span class="cov0" title="0">{
                        dFieldVal.Set(dbFieldValue.Convert(dstType))
                        continue</span>
                }

                <span class="cov1" title="1">return fmt.Errorf("no converter registered for field %s: %s -&gt; %s", dbField.Name, srcType, dstType)</span>
        }

        <span class="cov4" title="3">return nil</span>
}

func StructToDBMap(src, dbSchema interface{}) (map[string]interface{}, error) <span class="cov5" title="5">{
        result := make(map[string]interface{})

        schemaVal := reflect.ValueOf(dbSchema)
        if schemaVal.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                schemaVal = schemaVal.Elem()
        }</span>
        <span class="cov5" title="5">if schemaVal.Kind() != reflect.Struct </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("dbSchema must be a struct or pointer to a struct")
        }</span>
        <span class="cov4" title="4">schemaType := schemaVal.Type()

        srcVal := reflect.ValueOf(src)
        if srcVal.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                srcVal = srcVal.Elem()
        }</span>
        <span class="cov4" title="4">if srcVal.Kind() != reflect.Struct </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("src must be a struct or pointer to a struct")
        }</span>
        <span class="cov4" title="3">srcType := srcVal.Type()

        for i := 0; i &lt; schemaType.NumField(); i++ </span><span class="cov6" title="7">{
                schemaField := schemaType.Field(i)
                key := schemaField.Tag.Get("db")
                if key == "" </span><span class="cov0" title="0">{
                        key = schemaField.Name
                }</span>

                <span class="cov6" title="7">srcField, found := srcType.FieldByName(schemaField.Name)
                if !found </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov6" title="7">srcFieldVal := srcVal.FieldByName(srcField.Name)
                expectedType := schemaField.Type

                srcTypeVal := srcFieldVal.Type()

                if conv, ok := getConverter(srcTypeVal, expectedType); ok </span><span class="cov1" title="1">{
                        converted, err := safeConvert(conv, srcFieldVal.Interface())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cant convert field %s: %v", schemaField.Name, err)
                        }</span>
                        <span class="cov1" title="1">convVal := reflect.ValueOf(converted)
                        if !convVal.Type().AssignableTo(expectedType) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov1" title="1">result[key] = converted
                        continue</span>
                }

                <span class="cov6" title="6">if srcTypeVal.AssignableTo(expectedType) </span><span class="cov5" title="5">{
                        result[key] = srcFieldVal.Interface()
                        continue</span>
                }

                <span class="cov1" title="1">if srcTypeVal.ConvertibleTo(expectedType) </span><span class="cov0" title="0">{
                        convVal := srcFieldVal.Convert(expectedType)
                        result[key] = convVal.Interface()
                        continue</span>
                }
        }
        <span class="cov4" title="3">return result, nil</span>
}

func ExtractDBFields(dbModel interface{}) []string <span class="cov2" title="2">{
        val := reflect.ValueOf(dbModel)
        if val.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                val = val.Elem()
        }</span>
        <span class="cov2" title="2">if val.Kind() != reflect.Struct </span><span class="cov1" title="1">{
                return []string{}
        }</span>
        <span class="cov1" title="1">typ := val.Type()
        var fields []string
        for i := 0; i &lt; typ.NumField(); i++ </span><span class="cov5" title="5">{
                field := typ.Field(i)
                dbTag := field.Tag.Get("db")
                if dbTag == "" </span><span class="cov0" title="0">{
                        dbTag = field.Name
                }</span>
                <span class="cov5" title="5">fields = append(fields, dbTag)</span>
        }
        <span class="cov1" title="1">return fields</span>
}

func DBModelToMap(dbModel interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        result := make(map[string]interface{})

        val := reflect.ValueOf(dbModel)
        if val.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                val = val.Elem()
        }</span>
        <span class="cov0" title="0">if val.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dbModel must be a struct or pointer to a struct")
        }</span>

        <span class="cov0" title="0">typ := val.Type()
        for i := 0; i &lt; typ.NumField(); i++ </span><span class="cov0" title="0">{
                field := typ.Field(i)
                dbTag := field.Tag.Get("db")
                if dbTag == "" </span><span class="cov0" title="0">{
                        dbTag = field.Name
                }</span>

                <span class="cov0" title="0">fv := val.Field(i)
                if !fv.CanInterface() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">result[dbTag] = fv.Interface()</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package emailnormalize

import (
        "errors"
        "net/mail"
        "strings"
)

type Rules uint

const (
        DashAddressing Rules = 1 &lt;&lt; iota
        PlusAddressing
        LocalPartAsHostname
        StripPeriods
)

type Provider struct {
        Name      string
        Domains   []string
        Canonical string
        Flags     Rules
}

type Result struct {
        Address           string
        NormalizedAddress string
        Provider          string
}

var Providers = []Provider{
        {
                Name:      "Fastmail",
                Domains:   []string{"fastmail.com", "messagingengine.com", "fastmail.fm"},
                Canonical: "fastmail.com",
                Flags:     PlusAddressing | LocalPartAsHostname,
        },
        {
                Name:      "Apple",
                Domains:   []string{"icloud.com", "me.com", "mac.com"},
                Canonical: "icloud.com",
                Flags:     PlusAddressing,
        },
        {
                Name: "Yahoo",
                Domains: []string{
                        "yahoo.com.ar", "yahoo.com.au", "yahoo.at", "yahoo.be", "yahoo.com.br",
                        "ca.yahoo.com", "qc.yahoo.com", "yahoo.com.co", "yahoo.com.hr", "yahoo.cz",
                        "yahoo.dk", "yahoo.fi", "yahoo.fr", "yahoo.de", "yahoo.gr",
                        "yahoo.com.hk", "yahoo.hu", "yahoo.co.in", "yahoo.in", "yahoo.co.id",
                        "yahoo.ie", "yahoo.co.il", "yahoo.it", "yahoo.co.jp", "yahoo.com.my",
                        "yahoo.com.mx", "yahoo.ae", "yahoo.nl", "yahoo.co.nz", "yahoo.no",
                        "yahoo.com.ph", "yahoo.pl", "yahoo.pt", "yahoo.ro", "yahoo.ru",
                        "yahoo.com.sg", "yahoo.co.za", "yahoo.es", "yahoo.se", "yahoo.ch/fr",
                        "yahoo.ch/de", "yahoo.com.tw", "yahoo.co.th", "yahoo.com.tr", "yahoo.co.uk",
                        "yahoo.com", "yahoo.com.vn", "ymail.com", "yahoodns.net",
                },
                Canonical: "yahoo.com",
                Flags:     DashAddressing,
        },
        {
                Name:      "Google",
                Domains:   []string{"gmail.com", "googlemail.com", "google.com"},
                Canonical: "gmail.com",
                Flags:     PlusAddressing | StripPeriods,
        },
        {
                Name:      "Rambler",
                Domains:   []string{"rambler.ru", "lenta.ru", "autorambler.ru", "myrambler.ru", "ro.ru"},
                Canonical: "rambler.ru",
                Flags:     0,
        },
        {
                Name: "Microsoft",
                Domains: []string{
                        "hotmail.com", "hotmail.at", "hotmail.be", "hotmail.ca", "hotmail.cl",
                        "hotmail.co.il", "hotmail.co.nz", "hotmail.co.th", "hotmail.co.uk",
                        "hotmail.com.ar", "hotmail.com.au", "hotmail.com.br", "hotmail.com.gr",
                        "hotmail.com.mx", "hotmail.com.pe", "hotmail.com.tr", "hotmail.com.vn",
                        "hotmail.cz", "hotmail.de", "hotmail.dk", "hotmail.es", "hotmail.fr",
                        "hotmail.hu", "hotmail.id", "hotmail.ie", "hotmail.in", "hotmail.it",
                        "hotmail.jp", "hotmail.kr", "hotmail.lv", "hotmail.my", "hotmail.ph",
                        "hotmail.pt", "hotmail.sa", "hotmail.sg", "hotmail.sk", "live.com",
                        "live.be", "live.co.uk", "live.com.ar", "live.com.mx", "live.de",
                        "live.es", "live.eu", "live.fr", "live.it", "live.nl", "msn.com",
                        "outlook.com", "outlook.at", "outlook.be", "outlook.cl", "outlook.co.il",
                        "outlook.co.nz", "outlook.co.th", "outlook.com.ar", "outlook.com.au",
                        "outlook.com.br", "outlook.com.gr", "outlook.com.pe", "outlook.com.tr",
                        "outlook.com.vn", "outlook.cz", "outlook.de", "outlook.dk", "outlook.es",
                        "outlook.fr", "outlook.hu", "outlook.id", "outlook.ie", "outlook.in",
                        "outlook.it", "outlook.jp", "outlook.kr", "outlook.lv", "outlook.my",
                        "outlook.ph", "outlook.pt", "outlook.sa", "outlook.sg", "outlook.sk",
                        "passport.com",
                },
                Canonical: "outlook.com",
                Flags:     PlusAddressing,
        },
        {
                Name: "Yandex",
                Domains: []string{
                        "narod.ru", "yandex.ru", "yandex.org", "yandex.net", "yandex.net.ru",
                        "yandex.com.ru", "yandex.ua", "yandex.com.ua", "yandex.by", "yandex.eu",
                        "yandex.ee", "yandex.lt", "yandex.lv", "yandex.md", "yandex.uz",
                        "yandex.mx", "yandex.do", "yandex.tm", "yandex.de", "yandex.ie",
                        "yandex.in", "yandex.qa", "yandex.so", "yandex.nu", "yandex.tj",
                        "yandex.dk", "yandex.es", "yandex.pt", "yandex.kz", "yandex.pl",
                        "yandex.lu", "yandex.it", "yandex.az", "yandex.ro", "yandex.rs",
                        "yandex.sk", "yandex.no", "ya.ru", "yandex.com", "yandex.asia",
                        "yandex.mobi",
                },
                Canonical: "yandex.ru",
                Flags:     PlusAddressing,
        },
        {
                Name:      "ProtonMail",
                Domains:   []string{"protonmail.ch", "protonmail.com", "proton.me", "pm.me"},
                Canonical: "protonmail.ch",
                Flags:     PlusAddressing,
        },
}

func Normalize(email string) (*Result, error) <span class="cov0" title="0">{
        addr, err := mail.ParseAddress(email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">raw := strings.ToLower(addr.Address)
        parts := strings.SplitN(raw, "@", 2)
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid email address")
        }</span>
        <span class="cov0" title="0">local, domain := parts[0], parts[1]

        provider := lookupProvider(domain)
        if provider != nil </span><span class="cov0" title="0">{
                if provider.Flags&amp;LocalPartAsHostname != 0 </span><span class="cov0" title="0">{
                        if i := strings.Index(domain, "."); i != -1 </span><span class="cov0" title="0">{
                                local = domain[:i]
                        }</span>
                }

                <span class="cov0" title="0">domain = provider.Canonical

                if provider.Flags&amp;StripPeriods != 0 </span><span class="cov0" title="0">{
                        local = strings.ReplaceAll(local, ".", "")
                }</span>

                <span class="cov0" title="0">if provider.Flags&amp;PlusAddressing != 0 </span><span class="cov0" title="0">{
                        if i := strings.Index(local, "+"); i != -1 </span><span class="cov0" title="0">{
                                local = local[:i]
                        }</span>
                }

                <span class="cov0" title="0">if provider.Flags&amp;DashAddressing != 0 </span><span class="cov0" title="0">{
                        if i := strings.Index(local, "-"); i != -1 </span><span class="cov0" title="0">{
                                local = local[:i]
                        }</span>
                }
        }

        <span class="cov0" title="0">return &amp;Result{
                Address:           addr.Address,
                NormalizedAddress: local + "@" + domain,
                Provider: func() string </span><span class="cov0" title="0">{
                        if provider != nil </span><span class="cov0" title="0">{
                                return provider.Name
                        }</span>
                        <span class="cov0" title="0">return ""</span>
                }(),
        }, nil
}

func lookupProvider(domain string) *Provider <span class="cov0" title="0">{
        for i := range Providers </span><span class="cov0" title="0">{
                p := &amp;Providers[i]
                for _, d := range p.Domains </span><span class="cov0" title="0">{
                        if domain == d </span><span class="cov0" title="0">{
                                return p
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package pgclient

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
)

type (
        txKey      struct{}
        txDepthKey struct{}
)

type clientImpl struct {
        serverID        string
        pool            Pool
        readOnly        bool
        defaultIsoLevel TxIsoLevel
        txKey           txKey
        txDepthKey      txDepthKey
        logger          *slog.Logger
}

// NewClientOpts - options for constructing pg client
type NewClientOpts struct {
        ReadOnly        bool
        DefaultIsoLevel TxIsoLevel
        Logger          *slog.Logger
        LogQueries      bool
}

// NewClient - create new pg client
func NewClient(ctx context.Context, serverID string, dsn string, opts NewClientOpts) (*clientImpl, error) <span class="cov4" title="3">{
        pgxCfg, err := pgxpool.ParseConfig(dsn)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("unable to parse dsn: %w", err)
        }</span>

        <span class="cov3" title="2">if opts.ReadOnly </span><span class="cov1" title="1">{
                pgxCfg.ConnConfig.RuntimeParams["default_transaction_read_only"] = "true"
        }</span>

        <span class="cov3" title="2">if opts.LogQueries </span><span class="cov1" title="1">{
                pgxCfg.ConnConfig.Tracer = &amp;pgxTracer{logger: opts.Logger}
        }</span>

        <span class="cov3" title="2">dbpool, err := pgxpool.NewWithConfig(ctx, pgxCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to create pg connection pool: %w", err)
        }</span>

        <span class="cov3" title="2">client := &amp;clientImpl{
                serverID:        serverID,
                pool:            dbpool,
                readOnly:        opts.ReadOnly,
                defaultIsoLevel: ReadCommitted,
        }

        if opts.DefaultIsoLevel != "" </span><span class="cov1" title="1">{
                client.defaultIsoLevel = opts.DefaultIsoLevel
        }</span>

        <span class="cov3" title="2">if opts.Logger != nil </span><span class="cov1" title="1">{
                client.logger = opts.Logger
        }</span>

        <span class="cov3" title="2">return client, nil</span>
}

var _ Client = (*clientImpl)(nil)

// ServerID - get server id
func (c *clientImpl) ServerID() string <span class="cov5" title="5">{
        return c.serverID
}</span>

// Pool - get pool connection
func (c *clientImpl) Pool() Pool <span class="cov6" title="7">{
        return c.pool
}</span>

// GetConn - get pg connection: pool or tx
func (c *clientImpl) GetConn(ctx context.Context) Conn <span class="cov3" title="2">{
        tx, ok := ctx.Value(c.txKey).(pgx.Tx)
        if ok &amp;&amp; tx != nil </span><span class="cov1" title="1">{
                return tx
        }</span>

        <span class="cov1" title="1">return c.pool</span>
}

// Do - execute tx with default iso level
func (c *clientImpl) Do(ctx context.Context, fn func(context.Context) error) error <span class="cov7" title="10">{
        return c.DoWithIsoLvl(ctx, c.defaultIsoLevel, fn)
}</span>

// DoWithIsoLvl - execute tx with iso level
func (c *clientImpl) DoWithIsoLvl(ctx context.Context, isoLvl TxIsoLevel, fn func(context.Context) error) error <span class="cov10" title="21">{
        tx, ok := ctx.Value(c.txKey).(pgx.Tx)
        if ok &amp;&amp; tx != nil </span><span class="cov6" title="7">{
                depth, ok := ctx.Value(c.txKey).(int)
                if !ok </span><span class="cov6" title="7">{
                        depth = 0
                }</span>

                <span class="cov6" title="7">spName := fmt.Sprintf("sp_%d", depth+1)

                if _, err := tx.Exec(ctx, "SAVEPOINT "+spName); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov6" title="6">ctx = context.WithValue(ctx, c.txDepthKey, depth+1)

                err := fn(ctx)
                if err != nil </span><span class="cov3" title="2">{
                        _, rbErr := tx.Exec(ctx, "ROLLBACK TO SAVEPOINT "+spName)
                        if rbErr != nil </span><span class="cov1" title="1">{
                                if c.logger != nil </span><span class="cov1" title="1">{
                                        c.logger.ErrorContext(ctx, "rollback to savepoint failed", slog.Any("error", rbErr.Error()))
                                }</span>
                        }

                        <span class="cov3" title="2">return err</span>
                }

                <span class="cov5" title="4">if _, err := tx.Exec(ctx, "RELEASE SAVEPOINT "+spName); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov4" title="3">return nil</span>
        }

        <span class="cov8" title="14">tx, err := c.pool.BeginTx(ctx, pgx.TxOptions{IsoLevel: pgx.TxIsoLevel(isoLvl)})
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov8" title="13">ctx = context.WithValue(ctx, c.txKey, tx)
        ctx = context.WithValue(ctx, c.txDepthKey, 0)

        defer func() </span><span class="cov8" title="13">{
                if p := recover(); p != nil </span><span class="cov3" title="2">{
                        rbErr := tx.Rollback(ctx)
                        if rbErr != nil </span><span class="cov1" title="1">{
                                if c.logger != nil </span><span class="cov1" title="1">{
                                        c.logger.ErrorContext(ctx, "rollback on panic failed", slog.Any("error", rbErr.Error()))
                                }</span>
                        }

                        <span class="cov3" title="2">panic(p)</span>
                }
        }()

        <span class="cov8" title="13">err = fn(ctx)
        if err != nil </span><span class="cov5" title="5">{
                rbErr := tx.Rollback(ctx)
                if rbErr != nil </span><span class="cov1" title="1">{
                        if c.logger != nil </span><span class="cov1" title="1">{
                                c.logger.ErrorContext(ctx, "rollback failed", slog.Any("error", rbErr.Error()))
                        }</span>
                }

                <span class="cov5" title="5">return err</span>
        }

        <span class="cov6" title="6">if commitErr := tx.Commit(ctx); commitErr != nil </span><span class="cov1" title="1">{
                return commitErr
        }</span>

        <span class="cov5" title="5">return nil</span>
}

// Close - close pool
func (c *clientImpl) Close() <span class="cov1" title="1">{
        c.pool.Close()
}</span>
</pre>
		
		<pre class="file" id="file98" style="display: none">package pgclient

import "context"

type mockImpl struct{}

func NewMock() *mockImpl <span class="cov0" title="0">{
        return &amp;mockImpl{}
}</span>

var _ Client = (*mockImpl)(nil)

func (m *mockImpl) ServerID() string <span class="cov0" title="0">{
        return "sid"
}</span>

func (m *mockImpl) Pool() Pool <span class="cov0" title="0">{
        return nil
}</span>

func (m *mockImpl) GetConn(ctx context.Context) Conn <span class="cov0" title="0">{
        return nil
}</span>

func (m *mockImpl) Do(ctx context.Context, fn func(context.Context) error) error <span class="cov0" title="0">{
        fn(ctx)
        return nil
}</span>

func (m *mockImpl) DoWithIsoLvl(ctx context.Context, isoLvl TxIsoLevel, fn func(context.Context) error) error <span class="cov0" title="0">{
        fn(ctx)
        return nil
}</span>

func (m *mockImpl) Close() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file99" style="display: none">package pgclient

import (
        "context"
        "log/slog"
        "time"
)

// TestConnection - test connection with postgres
func TestConnection(
        ctx context.Context,
        client Client,
        logger *slog.Logger,
        maxAttempt int,
        attemptSleepSeconds int,
) error <span class="cov7" title="4">{
        attemp := 1
        var err error
        for attemp &lt;= maxAttempt </span><span class="cov10" title="6">{
                err = client.Pool().Ping(ctx)
                if err != nil </span><span class="cov7" title="4">{
                        logger.Info(
                                "failed to connect to Postgress",
                                slog.String("serverID", client.ServerID()),
                                slog.Int("attemp", attemp),
                        )
                        time.Sleep(time.Duration(attemptSleepSeconds) * time.Second)
                        attemp++
                        continue</span>
                }
                <span class="cov4" title="2">break</span>
        }
        <span class="cov7" title="4">if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package pgclient

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/jackc/pgx/v5"
)

type pgxTracer struct {
        logger *slog.Logger
}

func (t *pgxTracer) TraceQueryStart(ctx context.Context, _ *pgx.Conn, data pgx.TraceQueryStartData) context.Context <span class="cov0" title="0">{
        t.logger.InfoContext(
                ctx, "start of query",
                slog.String("sql.query", data.SQL),
                slog.Any("sql.args", data.Args),
        )

        return ctx
}</span>

func (t *pgxTracer) TraceQueryEnd(ctx context.Context, _ *pgx.Conn, data pgx.TraceQueryEndData) <span class="cov0" title="0">{
        t.logger.InfoContext(
                ctx,
                "end of query",
                slog.String("sql.query.ctag", fmt.Sprintf("%v", data.CommandTag)),
                slog.Any("sql.query.error", data.Err),
        )
}</span>
</pre>
		
		<pre class="file" id="file101" style="display: none">package prettylog

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log/slog"
        "os"
        "strconv"
        "strings"
        "sync"
)

const (
        timeFormat = "[15:04:05.000]"

        reset = "\033[0m"

        black        = 30
        red          = 31
        green        = 32
        yellow       = 33
        blue         = 34
        magenta      = 35
        cyan         = 36
        lightGray    = 37
        darkGray     = 90
        lightRed     = 91
        lightGreen   = 92
        lightYellow  = 93
        lightBlue    = 94
        lightMagenta = 95
        lightCyan    = 96
        white        = 97
)

func colorizer(colorCode int, v string) string <span class="cov0" title="0">{
        return fmt.Sprintf("\033[%sm%s%s", strconv.Itoa(colorCode), v, reset)
}</span>

type Handler struct {
        h                slog.Handler
        r                func([]string, slog.Attr) slog.Attr
        b                *bytes.Buffer
        m                *sync.Mutex
        writer           io.Writer
        colorize         bool
        outputEmptyAttrs bool
}

func (h *Handler) Enabled(ctx context.Context, level slog.Level) bool <span class="cov4" title="2">{
        return h.h.Enabled(ctx, level)
}</span>

func (h *Handler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov0" title="0">{
        return &amp;Handler{
                h:        h.h.WithAttrs(attrs),
                b:        h.b,
                r:        h.r,
                m:        h.m,
                writer:   h.writer,
                colorize: h.colorize,
        }
}</span>

func (h *Handler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        return &amp;Handler{
                h:        h.h.WithGroup(name),
                b:        h.b,
                r:        h.r,
                m:        h.m,
                writer:   h.writer,
                colorize: h.colorize,
        }
}</span>

func (h *Handler) computeAttrs(
        ctx context.Context,
        r slog.Record,
) (map[string]any, error) <span class="cov4" title="2">{
        h.m.Lock()
        defer func() </span><span class="cov4" title="2">{
                h.b.Reset()
                h.m.Unlock()
        }</span>()
        <span class="cov4" title="2">if err := h.h.Handle(ctx, r); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(
                        "error when calling inner handler's Handle: %w",
                        err,
                )
        }</span>

        <span class="cov4" title="2">var attrs map[string]any
        err := json.Unmarshal(h.b.Bytes(), &amp;attrs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(
                        "error when unmarshaling inner handler's Handle result: %w",
                        err,
                )
        }</span>
        <span class="cov4" title="2">return attrs, nil</span>
}

func (h *Handler) Handle(ctx context.Context, r slog.Record) error <span class="cov4" title="2">{
        colorize := func(code int, value string) string </span><span class="cov10" title="7">{
                return value
        }</span>
        <span class="cov4" title="2">if h.colorize </span><span class="cov0" title="0">{
                colorize = colorizer
        }</span>

        <span class="cov4" title="2">var level string
        levelAttr := slog.Attr{
                Key:   slog.LevelKey,
                Value: slog.AnyValue(r.Level),
        }
        if h.r != nil </span><span class="cov0" title="0">{
                levelAttr = h.r([]string{}, levelAttr)
        }</span>

        <span class="cov4" title="2">if !levelAttr.Equal(slog.Attr{}) </span><span class="cov4" title="2">{
                level = levelAttr.Value.String() + ":"

                if r.Level &lt;= slog.LevelDebug </span><span class="cov0" title="0">{
                        level = colorize(lightGray, level)
                }</span> else<span class="cov4" title="2"> if r.Level &lt;= slog.LevelInfo </span><span class="cov4" title="2">{
                        level = colorize(cyan, level)
                }</span> else<span class="cov0" title="0"> if r.Level &lt; slog.LevelWarn </span><span class="cov0" title="0">{
                        level = colorize(lightBlue, level)
                }</span> else<span class="cov0" title="0"> if r.Level &lt; slog.LevelError </span><span class="cov0" title="0">{
                        level = colorize(lightYellow, level)
                }</span> else<span class="cov0" title="0"> if r.Level &lt;= slog.LevelError+1 </span><span class="cov0" title="0">{
                        level = colorize(lightRed, level)
                }</span> else<span class="cov0" title="0"> if r.Level &gt; slog.LevelError+1 </span><span class="cov0" title="0">{
                        level = colorize(lightMagenta, level)
                }</span>
        }

        <span class="cov4" title="2">var timestamp string
        timeAttr := slog.Attr{
                Key:   slog.TimeKey,
                Value: slog.StringValue(r.Time.Format(timeFormat)),
        }
        if h.r != nil </span><span class="cov0" title="0">{
                timeAttr = h.r([]string{}, timeAttr)
        }</span>
        <span class="cov4" title="2">if !timeAttr.Equal(slog.Attr{}) </span><span class="cov4" title="2">{
                timestamp = colorize(lightGray, timeAttr.Value.String())
        }</span>

        <span class="cov4" title="2">var msg string
        msgAttr := slog.Attr{
                Key:   slog.MessageKey,
                Value: slog.StringValue(r.Message),
        }
        if h.r != nil </span><span class="cov0" title="0">{
                msgAttr = h.r([]string{}, msgAttr)
        }</span>
        <span class="cov4" title="2">if !msgAttr.Equal(slog.Attr{}) </span><span class="cov4" title="2">{
                msg = colorize(white, msgAttr.Value.String())
        }</span>

        <span class="cov4" title="2">attrs, err := h.computeAttrs(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">var attrsAsBytes []byte
        if h.outputEmptyAttrs || len(attrs) &gt; 0 </span><span class="cov1" title="1">{
                attrsAsBytes, err = json.MarshalIndent(attrs, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error when marshaling attrs: %w", err)
                }</span>
        }

        <span class="cov4" title="2">out := strings.Builder{}
        if len(timestamp) &gt; 0 </span><span class="cov4" title="2">{
                out.WriteString(timestamp)
                out.WriteString(" ")
        }</span>
        <span class="cov4" title="2">if len(level) &gt; 0 </span><span class="cov4" title="2">{
                out.WriteString(level)
                out.WriteString(" ")
        }</span>
        <span class="cov4" title="2">if len(msg) &gt; 0 </span><span class="cov4" title="2">{
                out.WriteString(msg)
                out.WriteString(" ")
        }</span>
        <span class="cov4" title="2">if len(attrsAsBytes) &gt; 0 </span><span class="cov1" title="1">{
                out.WriteString(colorize(darkGray, string(attrsAsBytes)))
        }</span>

        <span class="cov4" title="2">_, err = io.WriteString(h.writer, out.String()+"\n")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">return nil</span>
}

func suppressDefaults(
        next func([]string, slog.Attr) slog.Attr,
) func([]string, slog.Attr) slog.Attr <span class="cov4" title="2">{
        return func(groups []string, a slog.Attr) slog.Attr </span><span class="cov9" title="6">{
                if a.Key == slog.TimeKey ||
                        a.Key == slog.LevelKey ||
                        a.Key == slog.MessageKey </span><span class="cov9" title="6">{
                        return slog.Attr{}
                }</span>
                <span class="cov0" title="0">if next == nil </span><span class="cov0" title="0">{
                        return a
                }</span>
                <span class="cov0" title="0">return next(groups, a)</span>
        }
}

func New(handlerOptions *slog.HandlerOptions, options ...Option) *Handler <span class="cov4" title="2">{
        if handlerOptions == nil </span><span class="cov4" title="2">{
                handlerOptions = &amp;slog.HandlerOptions{}
        }</span>

        <span class="cov4" title="2">buf := &amp;bytes.Buffer{}
        handler := &amp;Handler{
                b: buf,
                h: slog.NewJSONHandler(buf, &amp;slog.HandlerOptions{
                        Level:       handlerOptions.Level,
                        AddSource:   handlerOptions.AddSource,
                        ReplaceAttr: suppressDefaults(handlerOptions.ReplaceAttr),
                }),
                r: handlerOptions.ReplaceAttr,
                m: &amp;sync.Mutex{},
        }

        for _, opt := range options </span><span class="cov6" title="3">{
                opt(handler)
        }</span>

        <span class="cov4" title="2">return handler</span>
}

func NewHandler(opts *slog.HandlerOptions) *Handler <span class="cov0" title="0">{
        return New(opts, WithDestinationWriter(os.Stdout), WithColor(), WithOutputEmptyAttrs())
}</span>

type Option func(h *Handler)

func WithDestinationWriter(writer io.Writer) Option <span class="cov4" title="2">{
        return func(h *Handler) </span><span class="cov4" title="2">{
                h.writer = writer
        }</span>
}

func WithColor() Option <span class="cov0" title="0">{
        return func(h *Handler) </span><span class="cov0" title="0">{
                h.colorize = true
        }</span>
}

func WithOutputEmptyAttrs() Option <span class="cov1" title="1">{
        return func(h *Handler) </span><span class="cov1" title="1">{
                h.outputEmptyAttrs = true
        }</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        (unknown)
// source: ledger_service/service.proto

package ledger_servicev1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Category struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            int64                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Title         string                 `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Category) Reset() <span class="cov0" title="0">{
        *x = Category{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Category) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Category) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Category) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Category.ProtoReflect.Descriptor instead.
func (*Category) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Category) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Category) GetTitle() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Date struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Year          int32                  `protobuf:"varint,1,opt,name=year,proto3" json:"year,omitempty"`
        Month         int32                  `protobuf:"varint,2,opt,name=month,proto3" json:"month,omitempty"`
        Day           int32                  `protobuf:"varint,3,opt,name=day,proto3" json:"day,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Date) Reset() <span class="cov0" title="0">{
        *x = Date{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Date) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Date) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Date) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Date.ProtoReflect.Descriptor instead.
func (*Date) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{1}
}</span>

func (x *Date) GetYear() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Year
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Date) GetMonth() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Month
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Date) GetDay() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Day
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type DateMonth struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Year          int32                  `protobuf:"varint,1,opt,name=year,proto3" json:"year,omitempty"`
        Month         int32                  `protobuf:"varint,2,opt,name=month,proto3" json:"month,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DateMonth) Reset() <span class="cov0" title="0">{
        *x = DateMonth{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DateMonth) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DateMonth) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DateMonth) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DateMonth.ProtoReflect.Descriptor instead.
func (*DateMonth) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{2}
}</span>

func (x *DateMonth) GetYear() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Year
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DateMonth) GetMonth() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Month
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type Transaction struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        AccountId     string                 `protobuf:"bytes,2,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
        IsIncome      bool                   `protobuf:"varint,3,opt,name=is_income,json=isIncome,proto3" json:"is_income,omitempty"`
        Amount        string                 `protobuf:"bytes,4,opt,name=amount,proto3" json:"amount,omitempty"`
        OccurredOn    *Date                  `protobuf:"bytes,5,opt,name=occurred_on,json=occurredOn,proto3" json:"occurred_on,omitempty"`
        CategoryId    int64                  `protobuf:"varint,6,opt,name=category_id,json=categoryId,proto3" json:"category_id,omitempty"`
        Description   string                 `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`
        CreatedAt     *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        UpdatedAt     *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Transaction) Reset() <span class="cov0" title="0">{
        *x = Transaction{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Transaction) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Transaction) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Transaction) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Transaction.ProtoReflect.Descriptor instead.
func (*Transaction) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{3}
}</span>

func (x *Transaction) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Transaction) GetAccountId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccountId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Transaction) GetIsIncome() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsIncome
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Transaction) GetAmount() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Amount
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Transaction) GetOccurredOn() *Date <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OccurredOn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Transaction) GetCategoryId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CategoryId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Transaction) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Transaction) GetCreatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Transaction) GetUpdatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UpdatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Budget struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        AccountId     string                 `protobuf:"bytes,2,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
        Period        *DateMonth             `protobuf:"bytes,3,opt,name=period,proto3" json:"period,omitempty"`
        CategoryId    int64                  `protobuf:"varint,4,opt,name=category_id,json=categoryId,proto3" json:"category_id,omitempty"`
        Amount        string                 `protobuf:"bytes,5,opt,name=amount,proto3" json:"amount,omitempty"`
        CreatedAt     *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        UpdatedAt     *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Budget) Reset() <span class="cov0" title="0">{
        *x = Budget{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Budget) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Budget) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Budget) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Budget.ProtoReflect.Descriptor instead.
func (*Budget) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{4}
}</span>

func (x *Budget) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Budget) GetAccountId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccountId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Budget) GetPeriod() *DateMonth <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Period
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Budget) GetCategoryId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CategoryId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Budget) GetAmount() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Amount
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Budget) GetCreatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Budget) GetUpdatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UpdatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ReportItem struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        CategoryId    int64                  `protobuf:"varint,1,opt,name=category_id,json=categoryId,proto3" json:"category_id,omitempty"`
        Sum           *string                `protobuf:"bytes,2,opt,name=sum,proto3,oneof" json:"sum,omitempty"`
        SpentBudget   *string                `protobuf:"bytes,3,opt,name=spent_budget,json=spentBudget,proto3,oneof" json:"spent_budget,omitempty"`
        ItemBudget    *string                `protobuf:"bytes,4,opt,name=item_budget,json=itemBudget,proto3,oneof" json:"item_budget,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ReportItem) Reset() <span class="cov0" title="0">{
        *x = ReportItem{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ReportItem) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ReportItem) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ReportItem) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ReportItem.ProtoReflect.Descriptor instead.
func (*ReportItem) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{5}
}</span>

func (x *ReportItem) GetCategoryId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CategoryId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ReportItem) GetSum() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Sum != nil </span><span class="cov0" title="0">{
                return *x.Sum
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ReportItem) GetSpentBudget() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.SpentBudget != nil </span><span class="cov0" title="0">{
                return *x.SpentBudget
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ReportItem) GetItemBudget() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.ItemBudget != nil </span><span class="cov0" title="0">{
                return *x.ItemBudget
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type PeriodReport struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        PeriodStart   *Date                  `protobuf:"bytes,1,opt,name=period_start,json=periodStart,proto3" json:"period_start,omitempty"`
        PeriodEnd     *Date                  `protobuf:"bytes,2,opt,name=period_end,json=periodEnd,proto3" json:"period_end,omitempty"`
        Items         []*ReportItem          `protobuf:"bytes,3,rep,name=items,proto3" json:"items,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PeriodReport) Reset() <span class="cov0" title="0">{
        *x = PeriodReport{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PeriodReport) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PeriodReport) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PeriodReport) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PeriodReport.ProtoReflect.Descriptor instead.
func (*PeriodReport) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{6}
}</span>

func (x *PeriodReport) GetPeriodStart() *Date <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PeriodStart
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *PeriodReport) GetPeriodEnd() *Date <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PeriodEnd
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *PeriodReport) GetItems() []*ReportItem <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListCategoriesRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListCategoriesRequest) Reset() <span class="cov0" title="0">{
        *x = ListCategoriesRequest{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListCategoriesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListCategoriesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListCategoriesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListCategoriesRequest.ProtoReflect.Descriptor instead.
func (*ListCategoriesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{7}
}</span>

type ListCategoriesResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Items         []*Category            `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListCategoriesResponse) Reset() <span class="cov0" title="0">{
        *x = ListCategoriesResponse{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListCategoriesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListCategoriesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListCategoriesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListCategoriesResponse.ProtoReflect.Descriptor instead.
func (*ListCategoriesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{8}
}</span>

func (x *ListCategoriesResponse) GetItems() []*Category <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListTransactionsRequest struct {
        state                protoimpl.MessageState `protogen:"open.v1"`
        Limit                int32                  `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
        Offset               int64                  `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
        FilterOccurredOnFrom *Date                  `protobuf:"bytes,3,opt,name=filter_occurred_on_from,json=filterOccurredOnFrom,proto3,oneof" json:"filter_occurred_on_from,omitempty"`
        FilterOccurredOnTo   *Date                  `protobuf:"bytes,4,opt,name=filter_occurred_on_to,json=filterOccurredOnTo,proto3,oneof" json:"filter_occurred_on_to,omitempty"`
        unknownFields        protoimpl.UnknownFields
        sizeCache            protoimpl.SizeCache
}

func (x *ListTransactionsRequest) Reset() <span class="cov0" title="0">{
        *x = ListTransactionsRequest{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListTransactionsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListTransactionsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListTransactionsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListTransactionsRequest.ProtoReflect.Descriptor instead.
func (*ListTransactionsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{9}
}</span>

func (x *ListTransactionsRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListTransactionsRequest) GetOffset() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListTransactionsRequest) GetFilterOccurredOnFrom() *Date <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FilterOccurredOnFrom
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListTransactionsRequest) GetFilterOccurredOnTo() *Date <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FilterOccurredOnTo
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListTransactionsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Items         []*Transaction         `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
        Total         int64                  `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListTransactionsResponse) Reset() <span class="cov0" title="0">{
        *x = ListTransactionsResponse{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListTransactionsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListTransactionsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListTransactionsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListTransactionsResponse.ProtoReflect.Descriptor instead.
func (*ListTransactionsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{10}
}</span>

func (x *ListTransactionsResponse) GetItems() []*Transaction <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListTransactionsResponse) GetTotal() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Total
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetTransactionRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetTransactionRequest) Reset() <span class="cov0" title="0">{
        *x = GetTransactionRequest{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetTransactionRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTransactionRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTransactionRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTransactionRequest.ProtoReflect.Descriptor instead.
func (*GetTransactionRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{11}
}</span>

func (x *GetTransactionRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetTransactionResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Item          *Transaction           `protobuf:"bytes,1,opt,name=item,proto3" json:"item,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetTransactionResponse) Reset() <span class="cov0" title="0">{
        *x = GetTransactionResponse{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetTransactionResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTransactionResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTransactionResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTransactionResponse.ProtoReflect.Descriptor instead.
func (*GetTransactionResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{12}
}</span>

func (x *GetTransactionResponse) GetItem() *Transaction <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AddTransactionRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        IsIncome      bool                   `protobuf:"varint,1,opt,name=is_income,json=isIncome,proto3" json:"is_income,omitempty"`
        Amount        string                 `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
        OccurredOn    *Date                  `protobuf:"bytes,3,opt,name=occurred_on,json=occurredOn,proto3" json:"occurred_on,omitempty"`
        CategoryId    int64                  `protobuf:"varint,4,opt,name=category_id,json=categoryId,proto3" json:"category_id,omitempty"`
        Description   string                 `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *AddTransactionRequest) Reset() <span class="cov0" title="0">{
        *x = AddTransactionRequest{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AddTransactionRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddTransactionRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddTransactionRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddTransactionRequest.ProtoReflect.Descriptor instead.
func (*AddTransactionRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{13}
}</span>

func (x *AddTransactionRequest) GetIsIncome() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsIncome
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *AddTransactionRequest) GetAmount() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Amount
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AddTransactionRequest) GetOccurredOn() *Date <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OccurredOn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *AddTransactionRequest) GetCategoryId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CategoryId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *AddTransactionRequest) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type AddTransactionResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Item          *Transaction           `protobuf:"bytes,1,opt,name=item,proto3" json:"item,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *AddTransactionResponse) Reset() <span class="cov0" title="0">{
        *x = AddTransactionResponse{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AddTransactionResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddTransactionResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddTransactionResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddTransactionResponse.ProtoReflect.Descriptor instead.
func (*AddTransactionResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{14}
}</span>

func (x *AddTransactionResponse) GetItem() *Transaction <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type PatchTransactionRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Amount        *string                `protobuf:"bytes,2,opt,name=amount,proto3,oneof" json:"amount,omitempty"`
        OccurredOn    *Date                  `protobuf:"bytes,3,opt,name=occurred_on,json=occurredOn,proto3,oneof" json:"occurred_on,omitempty"`
        CategoryId    *int64                 `protobuf:"varint,4,opt,name=category_id,json=categoryId,proto3,oneof" json:"category_id,omitempty"`
        Description   *string                `protobuf:"bytes,5,opt,name=description,proto3,oneof" json:"description,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PatchTransactionRequest) Reset() <span class="cov0" title="0">{
        *x = PatchTransactionRequest{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PatchTransactionRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PatchTransactionRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PatchTransactionRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PatchTransactionRequest.ProtoReflect.Descriptor instead.
func (*PatchTransactionRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{15}
}</span>

func (x *PatchTransactionRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PatchTransactionRequest) GetAmount() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Amount != nil </span><span class="cov0" title="0">{
                return *x.Amount
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PatchTransactionRequest) GetOccurredOn() *Date <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OccurredOn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *PatchTransactionRequest) GetCategoryId() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.CategoryId != nil </span><span class="cov0" title="0">{
                return *x.CategoryId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PatchTransactionRequest) GetDescription() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Description != nil </span><span class="cov0" title="0">{
                return *x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type PatchTransactionResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Item          *Transaction           `protobuf:"bytes,1,opt,name=item,proto3" json:"item,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PatchTransactionResponse) Reset() <span class="cov0" title="0">{
        *x = PatchTransactionResponse{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PatchTransactionResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PatchTransactionResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PatchTransactionResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PatchTransactionResponse.ProtoReflect.Descriptor instead.
func (*PatchTransactionResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{16}
}</span>

func (x *PatchTransactionResponse) GetItem() *Transaction <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DeleteTransactionRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteTransactionRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteTransactionRequest{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[17]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteTransactionRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteTransactionRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteTransactionRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[17]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteTransactionRequest.ProtoReflect.Descriptor instead.
func (*DeleteTransactionRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{17}
}</span>

func (x *DeleteTransactionRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeleteTransactionResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteTransactionResponse) Reset() <span class="cov0" title="0">{
        *x = DeleteTransactionResponse{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[18]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteTransactionResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteTransactionResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteTransactionResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[18]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteTransactionResponse.ProtoReflect.Descriptor instead.
func (*DeleteTransactionResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{18}
}</span>

type ListBudgetsRequest struct {
        state            protoimpl.MessageState `protogen:"open.v1"`
        Limit            int32                  `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
        Offset           int64                  `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
        FilterPeriodFrom *DateMonth             `protobuf:"bytes,3,opt,name=filter_period_from,json=filterPeriodFrom,proto3,oneof" json:"filter_period_from,omitempty"`
        FilterPeriodTo   *DateMonth             `protobuf:"bytes,4,opt,name=filter_period_to,json=filterPeriodTo,proto3,oneof" json:"filter_period_to,omitempty"`
        unknownFields    protoimpl.UnknownFields
        sizeCache        protoimpl.SizeCache
}

func (x *ListBudgetsRequest) Reset() <span class="cov0" title="0">{
        *x = ListBudgetsRequest{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[19]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListBudgetsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListBudgetsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListBudgetsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[19]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListBudgetsRequest.ProtoReflect.Descriptor instead.
func (*ListBudgetsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{19}
}</span>

func (x *ListBudgetsRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListBudgetsRequest) GetOffset() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListBudgetsRequest) GetFilterPeriodFrom() *DateMonth <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FilterPeriodFrom
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListBudgetsRequest) GetFilterPeriodTo() *DateMonth <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FilterPeriodTo
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListBudgetsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Items         []*Budget              `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
        Total         int64                  `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
        HitCache      bool                   `protobuf:"varint,3,opt,name=hit_cache,json=hitCache,proto3" json:"hit_cache,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListBudgetsResponse) Reset() <span class="cov0" title="0">{
        *x = ListBudgetsResponse{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[20]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListBudgetsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListBudgetsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListBudgetsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[20]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListBudgetsResponse.ProtoReflect.Descriptor instead.
func (*ListBudgetsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{20}
}</span>

func (x *ListBudgetsResponse) GetItems() []*Budget <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListBudgetsResponse) GetTotal() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Total
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListBudgetsResponse) GetHitCache() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.HitCache
        }</span>
        <span class="cov0" title="0">return false</span>
}

type GetBudgetRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetBudgetRequest) Reset() <span class="cov0" title="0">{
        *x = GetBudgetRequest{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[21]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetBudgetRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetBudgetRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetBudgetRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[21]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetBudgetRequest.ProtoReflect.Descriptor instead.
func (*GetBudgetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{21}
}</span>

func (x *GetBudgetRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetBudgetResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Item          *Budget                `protobuf:"bytes,1,opt,name=item,proto3" json:"item,omitempty"`
        HitCache      bool                   `protobuf:"varint,2,opt,name=hit_cache,json=hitCache,proto3" json:"hit_cache,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetBudgetResponse) Reset() <span class="cov0" title="0">{
        *x = GetBudgetResponse{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[22]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetBudgetResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetBudgetResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetBudgetResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[22]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetBudgetResponse.ProtoReflect.Descriptor instead.
func (*GetBudgetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{22}
}</span>

func (x *GetBudgetResponse) GetItem() *Budget <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetBudgetResponse) GetHitCache() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.HitCache
        }</span>
        <span class="cov0" title="0">return false</span>
}

type AddBudgetRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Period        *DateMonth             `protobuf:"bytes,1,opt,name=period,proto3" json:"period,omitempty"`
        CategoryId    int64                  `protobuf:"varint,2,opt,name=category_id,json=categoryId,proto3" json:"category_id,omitempty"`
        Amount        string                 `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *AddBudgetRequest) Reset() <span class="cov0" title="0">{
        *x = AddBudgetRequest{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[23]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AddBudgetRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddBudgetRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddBudgetRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[23]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddBudgetRequest.ProtoReflect.Descriptor instead.
func (*AddBudgetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{23}
}</span>

func (x *AddBudgetRequest) GetPeriod() *DateMonth <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Period
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *AddBudgetRequest) GetCategoryId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CategoryId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *AddBudgetRequest) GetAmount() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Amount
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type AddBudgetResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Item          *Budget                `protobuf:"bytes,1,opt,name=item,proto3" json:"item,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *AddBudgetResponse) Reset() <span class="cov0" title="0">{
        *x = AddBudgetResponse{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[24]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AddBudgetResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddBudgetResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddBudgetResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[24]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddBudgetResponse.ProtoReflect.Descriptor instead.
func (*AddBudgetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{24}
}</span>

func (x *AddBudgetResponse) GetItem() *Budget <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type PatchBudgetRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Period        *DateMonth             `protobuf:"bytes,2,opt,name=period,proto3,oneof" json:"period,omitempty"`
        CategoryId    *int64                 `protobuf:"varint,3,opt,name=category_id,json=categoryId,proto3,oneof" json:"category_id,omitempty"`
        Amount        *string                `protobuf:"bytes,4,opt,name=amount,proto3,oneof" json:"amount,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PatchBudgetRequest) Reset() <span class="cov0" title="0">{
        *x = PatchBudgetRequest{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[25]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PatchBudgetRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PatchBudgetRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PatchBudgetRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[25]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PatchBudgetRequest.ProtoReflect.Descriptor instead.
func (*PatchBudgetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{25}
}</span>

func (x *PatchBudgetRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PatchBudgetRequest) GetPeriod() *DateMonth <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Period
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *PatchBudgetRequest) GetCategoryId() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.CategoryId != nil </span><span class="cov0" title="0">{
                return *x.CategoryId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PatchBudgetRequest) GetAmount() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Amount != nil </span><span class="cov0" title="0">{
                return *x.Amount
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type PatchBudgetResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Item          *Budget                `protobuf:"bytes,1,opt,name=item,proto3" json:"item,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PatchBudgetResponse) Reset() <span class="cov0" title="0">{
        *x = PatchBudgetResponse{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[26]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PatchBudgetResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PatchBudgetResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PatchBudgetResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[26]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PatchBudgetResponse.ProtoReflect.Descriptor instead.
func (*PatchBudgetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{26}
}</span>

func (x *PatchBudgetResponse) GetItem() *Budget <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DeleteBudgetRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteBudgetRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteBudgetRequest{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[27]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteBudgetRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteBudgetRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteBudgetRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[27]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteBudgetRequest.ProtoReflect.Descriptor instead.
func (*DeleteBudgetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{27}
}</span>

func (x *DeleteBudgetRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeleteBudgetResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteBudgetResponse) Reset() <span class="cov0" title="0">{
        *x = DeleteBudgetResponse{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[28]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteBudgetResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteBudgetResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteBudgetResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[28]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteBudgetResponse.ProtoReflect.Descriptor instead.
func (*DeleteBudgetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{28}
}</span>

type ListReportsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        DateFrom      *Date                  `protobuf:"bytes,1,opt,name=date_from,json=dateFrom,proto3" json:"date_from,omitempty"`
        DateTo        *Date                  `protobuf:"bytes,2,opt,name=date_to,json=dateTo,proto3" json:"date_to,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListReportsRequest) Reset() <span class="cov0" title="0">{
        *x = ListReportsRequest{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[29]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListReportsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListReportsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListReportsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[29]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListReportsRequest.ProtoReflect.Descriptor instead.
func (*ListReportsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{29}
}</span>

func (x *ListReportsRequest) GetDateFrom() *Date <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DateFrom
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListReportsRequest) GetDateTo() *Date <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DateTo
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListReportsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Reports       []*PeriodReport        `protobuf:"bytes,1,rep,name=reports,proto3" json:"reports,omitempty"`
        HitCache      bool                   `protobuf:"varint,2,opt,name=hit_cache,json=hitCache,proto3" json:"hit_cache,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListReportsResponse) Reset() <span class="cov0" title="0">{
        *x = ListReportsResponse{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[30]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListReportsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListReportsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListReportsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[30]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListReportsResponse.ProtoReflect.Descriptor instead.
func (*ListReportsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{30}
}</span>

func (x *ListReportsResponse) GetReports() []*PeriodReport <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Reports
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListReportsResponse) GetHitCache() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.HitCache
        }</span>
        <span class="cov0" title="0">return false</span>
}

type CSVExportTransactionsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Data          []byte                 `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
        Total         int64                  `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
        HitCache      bool                   `protobuf:"varint,3,opt,name=hit_cache,json=hitCache,proto3" json:"hit_cache,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CSVExportTransactionsResponse) Reset() <span class="cov0" title="0">{
        *x = CSVExportTransactionsResponse{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[31]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CSVExportTransactionsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CSVExportTransactionsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CSVExportTransactionsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[31]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CSVExportTransactionsResponse.ProtoReflect.Descriptor instead.
func (*CSVExportTransactionsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{31}
}</span>

func (x *CSVExportTransactionsResponse) GetData() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Data
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CSVExportTransactionsResponse) GetTotal() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Total
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *CSVExportTransactionsResponse) GetHitCache() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.HitCache
        }</span>
        <span class="cov0" title="0">return false</span>
}

type CSVImportTransactionsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Data          []byte                 `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CSVImportTransactionsRequest) Reset() <span class="cov0" title="0">{
        *x = CSVImportTransactionsRequest{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[32]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CSVImportTransactionsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CSVImportTransactionsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CSVImportTransactionsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[32]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CSVImportTransactionsRequest.ProtoReflect.Descriptor instead.
func (*CSVImportTransactionsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{32}
}</span>

func (x *CSVImportTransactionsRequest) GetData() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Data
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CSVImportTransactionsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CSVImportTransactionsResponse) Reset() <span class="cov0" title="0">{
        *x = CSVImportTransactionsResponse{}
        mi := &amp;file_ledger_service_service_proto_msgTypes[33]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CSVImportTransactionsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CSVImportTransactionsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CSVImportTransactionsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_ledger_service_service_proto_msgTypes[33]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CSVImportTransactionsResponse.ProtoReflect.Descriptor instead.
func (*CSVImportTransactionsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_ledger_service_service_proto_rawDescGZIP(), []int{33}
}</span>

var File_ledger_service_service_proto protoreflect.FileDescriptor

const file_ledger_service_service_proto_rawDesc = "" +
        "\n" +
        "\x1cledger_service/service.proto\x12\x11ledger_service.v1\x1a\x1fgoogle/protobuf/timestamp.proto\"0\n" +
        "\bCategory\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\x03R\x02id\x12\x14\n" +
        "\x05title\x18\x02 \x01(\tR\x05title\"B\n" +
        "\x04Date\x12\x12\n" +
        "\x04year\x18\x01 \x01(\x05R\x04year\x12\x14\n" +
        "\x05month\x18\x02 \x01(\x05R\x05month\x12\x10\n" +
        "\x03day\x18\x03 \x01(\x05R\x03day\"5\n" +
        "\tDateMonth\x12\x12\n" +
        "\x04year\x18\x01 \x01(\x05R\x04year\x12\x14\n" +
        "\x05month\x18\x02 \x01(\x05R\x05month\"\xe4\x02\n" +
        "\vTransaction\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x1d\n" +
        "\n" +
        "account_id\x18\x02 \x01(\tR\taccountId\x12\x1b\n" +
        "\tis_income\x18\x03 \x01(\bR\bisIncome\x12\x16\n" +
        "\x06amount\x18\x04 \x01(\tR\x06amount\x128\n" +
        "\voccurred_on\x18\x05 \x01(\v2\x17.ledger_service.v1.DateR\n" +
        "occurredOn\x12\x1f\n" +
        "\vcategory_id\x18\x06 \x01(\x03R\n" +
        "categoryId\x12 \n" +
        "\vdescription\x18\a \x01(\tR\vdescription\x129\n" +
        "\n" +
        "created_at\x18\b \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n" +
        "\n" +
        "updated_at\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\tupdatedAt\"\x9c\x02\n" +
        "\x06Budget\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x1d\n" +
        "\n" +
        "account_id\x18\x02 \x01(\tR\taccountId\x124\n" +
        "\x06period\x18\x03 \x01(\v2\x1c.ledger_service.v1.DateMonthR\x06period\x12\x1f\n" +
        "\vcategory_id\x18\x04 \x01(\x03R\n" +
        "categoryId\x12\x16\n" +
        "\x06amount\x18\x05 \x01(\tR\x06amount\x129\n" +
        "\n" +
        "created_at\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n" +
        "\n" +
        "updated_at\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\tupdatedAt\"\xbb\x01\n" +
        "\n" +
        "ReportItem\x12\x1f\n" +
        "\vcategory_id\x18\x01 \x01(\x03R\n" +
        "categoryId\x12\x15\n" +
        "\x03sum\x18\x02 \x01(\tH\x00R\x03sum\x88\x01\x01\x12&amp;\n" +
        "\fspent_budget\x18\x03 \x01(\tH\x01R\vspentBudget\x88\x01\x01\x12$\n" +
        "\vitem_budget\x18\x04 \x01(\tH\x02R\n" +
        "itemBudget\x88\x01\x01B\x06\n" +
        "\x04_sumB\x0f\n" +
        "\r_spent_budgetB\x0e\n" +
        "\f_item_budget\"\xb7\x01\n" +
        "\fPeriodReport\x12:\n" +
        "\fperiod_start\x18\x01 \x01(\v2\x17.ledger_service.v1.DateR\vperiodStart\x126\n" +
        "\n" +
        "period_end\x18\x02 \x01(\v2\x17.ledger_service.v1.DateR\tperiodEnd\x123\n" +
        "\x05items\x18\x03 \x03(\v2\x1d.ledger_service.v1.ReportItemR\x05items\"\x17\n" +
        "\x15ListCategoriesRequest\"K\n" +
        "\x16ListCategoriesResponse\x121\n" +
        "\x05items\x18\x01 \x03(\v2\x1b.ledger_service.v1.CategoryR\x05items\"\xa3\x02\n" +
        "\x17ListTransactionsRequest\x12\x14\n" +
        "\x05limit\x18\x01 \x01(\x05R\x05limit\x12\x16\n" +
        "\x06offset\x18\x02 \x01(\x03R\x06offset\x12S\n" +
        "\x17filter_occurred_on_from\x18\x03 \x01(\v2\x17.ledger_service.v1.DateH\x00R\x14filterOccurredOnFrom\x88\x01\x01\x12O\n" +
        "\x15filter_occurred_on_to\x18\x04 \x01(\v2\x17.ledger_service.v1.DateH\x01R\x12filterOccurredOnTo\x88\x01\x01B\x1a\n" +
        "\x18_filter_occurred_on_fromB\x18\n" +
        "\x16_filter_occurred_on_to\"f\n" +
        "\x18ListTransactionsResponse\x124\n" +
        "\x05items\x18\x01 \x03(\v2\x1e.ledger_service.v1.TransactionR\x05items\x12\x14\n" +
        "\x05total\x18\x02 \x01(\x03R\x05total\"'\n" +
        "\x15GetTransactionRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\"L\n" +
        "\x16GetTransactionResponse\x122\n" +
        "\x04item\x18\x01 \x01(\v2\x1e.ledger_service.v1.TransactionR\x04item\"\xc9\x01\n" +
        "\x15AddTransactionRequest\x12\x1b\n" +
        "\tis_income\x18\x01 \x01(\bR\bisIncome\x12\x16\n" +
        "\x06amount\x18\x02 \x01(\tR\x06amount\x128\n" +
        "\voccurred_on\x18\x03 \x01(\v2\x17.ledger_service.v1.DateR\n" +
        "occurredOn\x12\x1f\n" +
        "\vcategory_id\x18\x04 \x01(\x03R\n" +
        "categoryId\x12 \n" +
        "\vdescription\x18\x05 \x01(\tR\vdescription\"L\n" +
        "\x16AddTransactionResponse\x122\n" +
        "\x04item\x18\x01 \x01(\v2\x1e.ledger_service.v1.TransactionR\x04item\"\x8d\x02\n" +
        "\x17PatchTransactionRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x1b\n" +
        "\x06amount\x18\x02 \x01(\tH\x00R\x06amount\x88\x01\x01\x12=\n" +
        "\voccurred_on\x18\x03 \x01(\v2\x17.ledger_service.v1.DateH\x01R\n" +
        "occurredOn\x88\x01\x01\x12$\n" +
        "\vcategory_id\x18\x04 \x01(\x03H\x02R\n" +
        "categoryId\x88\x01\x01\x12%\n" +
        "\vdescription\x18\x05 \x01(\tH\x03R\vdescription\x88\x01\x01B\t\n" +
        "\a_amountB\x0e\n" +
        "\f_occurred_onB\x0e\n" +
        "\f_category_idB\x0e\n" +
        "\f_description\"N\n" +
        "\x18PatchTransactionResponse\x122\n" +
        "\x04item\x18\x01 \x01(\v2\x1e.ledger_service.v1.TransactionR\x04item\"*\n" +
        "\x18DeleteTransactionRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\"\x1b\n" +
        "\x19DeleteTransactionResponse\"\x8c\x02\n" +
        "\x12ListBudgetsRequest\x12\x14\n" +
        "\x05limit\x18\x01 \x01(\x05R\x05limit\x12\x16\n" +
        "\x06offset\x18\x02 \x01(\x03R\x06offset\x12O\n" +
        "\x12filter_period_from\x18\x03 \x01(\v2\x1c.ledger_service.v1.DateMonthH\x00R\x10filterPeriodFrom\x88\x01\x01\x12K\n" +
        "\x10filter_period_to\x18\x04 \x01(\v2\x1c.ledger_service.v1.DateMonthH\x01R\x0efilterPeriodTo\x88\x01\x01B\x15\n" +
        "\x13_filter_period_fromB\x13\n" +
        "\x11_filter_period_to\"y\n" +
        "\x13ListBudgetsResponse\x12/\n" +
        "\x05items\x18\x01 \x03(\v2\x19.ledger_service.v1.BudgetR\x05items\x12\x14\n" +
        "\x05total\x18\x02 \x01(\x03R\x05total\x12\x1b\n" +
        "\thit_cache\x18\x03 \x01(\bR\bhitCache\"\"\n" +
        "\x10GetBudgetRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\"_\n" +
        "\x11GetBudgetResponse\x12-\n" +
        "\x04item\x18\x01 \x01(\v2\x19.ledger_service.v1.BudgetR\x04item\x12\x1b\n" +
        "\thit_cache\x18\x02 \x01(\bR\bhitCache\"\x81\x01\n" +
        "\x10AddBudgetRequest\x124\n" +
        "\x06period\x18\x01 \x01(\v2\x1c.ledger_service.v1.DateMonthR\x06period\x12\x1f\n" +
        "\vcategory_id\x18\x02 \x01(\x03R\n" +
        "categoryId\x12\x16\n" +
        "\x06amount\x18\x03 \x01(\tR\x06amount\"B\n" +
        "\x11AddBudgetResponse\x12-\n" +
        "\x04item\x18\x01 \x01(\v2\x19.ledger_service.v1.BudgetR\x04item\"\xc8\x01\n" +
        "\x12PatchBudgetRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x129\n" +
        "\x06period\x18\x02 \x01(\v2\x1c.ledger_service.v1.DateMonthH\x00R\x06period\x88\x01\x01\x12$\n" +
        "\vcategory_id\x18\x03 \x01(\x03H\x01R\n" +
        "categoryId\x88\x01\x01\x12\x1b\n" +
        "\x06amount\x18\x04 \x01(\tH\x02R\x06amount\x88\x01\x01B\t\n" +
        "\a_periodB\x0e\n" +
        "\f_category_idB\t\n" +
        "\a_amount\"D\n" +
        "\x13PatchBudgetResponse\x12-\n" +
        "\x04item\x18\x01 \x01(\v2\x19.ledger_service.v1.BudgetR\x04item\"%\n" +
        "\x13DeleteBudgetRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\"\x16\n" +
        "\x14DeleteBudgetResponse\"|\n" +
        "\x12ListReportsRequest\x124\n" +
        "\tdate_from\x18\x01 \x01(\v2\x17.ledger_service.v1.DateR\bdateFrom\x120\n" +
        "\adate_to\x18\x02 \x01(\v2\x17.ledger_service.v1.DateR\x06dateTo\"m\n" +
        "\x13ListReportsResponse\x129\n" +
        "\areports\x18\x01 \x03(\v2\x1f.ledger_service.v1.PeriodReportR\areports\x12\x1b\n" +
        "\thit_cache\x18\x02 \x01(\bR\bhitCache\"f\n" +
        "\x1dCSVExportTransactionsResponse\x12\x12\n" +
        "\x04data\x18\x01 \x01(\fR\x04data\x12\x14\n" +
        "\x05total\x18\x02 \x01(\x03R\x05total\x12\x1b\n" +
        "\thit_cache\x18\x03 \x01(\bR\bhitCache\"2\n" +
        "\x1cCSVImportTransactionsRequest\x12\x12\n" +
        "\x04data\x18\x01 \x01(\fR\x04data\"\x1f\n" +
        "\x1dCSVImportTransactionsResponse2\xa5\v\n" +
        "\x06Ledger\x12e\n" +
        "\x0eListCategories\x12(.ledger_service.v1.ListCategoriesRequest\x1a).ledger_service.v1.ListCategoriesResponse\x12k\n" +
        "\x10ListTransactions\x12*.ledger_service.v1.ListTransactionsRequest\x1a+.ledger_service.v1.ListTransactionsResponse\x12e\n" +
        "\x0eGetTransaction\x12(.ledger_service.v1.GetTransactionRequest\x1a).ledger_service.v1.GetTransactionResponse\x12e\n" +
        "\x0eAddTransaction\x12(.ledger_service.v1.AddTransactionRequest\x1a).ledger_service.v1.AddTransactionResponse\x12k\n" +
        "\x10PatchTransaction\x12*.ledger_service.v1.PatchTransactionRequest\x1a+.ledger_service.v1.PatchTransactionResponse\x12n\n" +
        "\x11DeleteTransaction\x12+.ledger_service.v1.DeleteTransactionRequest\x1a,.ledger_service.v1.DeleteTransactionResponse\x12\\\n" +
        "\vListBudgets\x12%.ledger_service.v1.ListBudgetsRequest\x1a&amp;.ledger_service.v1.ListBudgetsResponse\x12V\n" +
        "\tGetBudget\x12#.ledger_service.v1.GetBudgetRequest\x1a$.ledger_service.v1.GetBudgetResponse\x12V\n" +
        "\tAddBudget\x12#.ledger_service.v1.AddBudgetRequest\x1a$.ledger_service.v1.AddBudgetResponse\x12\\\n" +
        "\vPatchBudget\x12%.ledger_service.v1.PatchBudgetRequest\x1a&amp;.ledger_service.v1.PatchBudgetResponse\x12_\n" +
        "\fDeleteBudget\x12&amp;.ledger_service.v1.DeleteBudgetRequest\x1a'.ledger_service.v1.DeleteBudgetResponse\x12\\\n" +
        "\vListReports\x12%.ledger_service.v1.ListReportsRequest\x1a&amp;.ledger_service.v1.ListReportsResponse\x12u\n" +
        "\x15CSVExportTransactions\x12*.ledger_service.v1.ListTransactionsRequest\x1a0.ledger_service.v1.CSVExportTransactionsResponse\x12z\n" +
        "\x15CSVImportTransactions\x12/.ledger_service.v1.CSVImportTransactionsRequest\x1a0.ledger_service.v1.CSVImportTransactionsResponseB\xe4\x01\n" +
        "\x15com.ledger_service.v1B\fServiceProtoP\x01Z\\github.com/m11ano/budget_planner/backend/ledger/pkg/proto_pb/ledger_service;ledger_servicev1\xa2\x02\x03LXX\xaa\x02\x10LedgerService.V1\xca\x02\x10LedgerService\\V1\xe2\x02\x1cLedgerService\\V1\\GPBMetadata\xea\x02\x11LedgerService::V1b\x06proto3"

var (
        file_ledger_service_service_proto_rawDescOnce sync.Once
        file_ledger_service_service_proto_rawDescData []byte
)

func file_ledger_service_service_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_ledger_service_service_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_ledger_service_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_ledger_service_service_proto_rawDesc), len(file_ledger_service_service_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_ledger_service_service_proto_rawDescData</span>
}

var file_ledger_service_service_proto_msgTypes = make([]protoimpl.MessageInfo, 34)
var file_ledger_service_service_proto_goTypes = []any{
        (*Category)(nil),                      // 0: ledger_service.v1.Category
        (*Date)(nil),                          // 1: ledger_service.v1.Date
        (*DateMonth)(nil),                     // 2: ledger_service.v1.DateMonth
        (*Transaction)(nil),                   // 3: ledger_service.v1.Transaction
        (*Budget)(nil),                        // 4: ledger_service.v1.Budget
        (*ReportItem)(nil),                    // 5: ledger_service.v1.ReportItem
        (*PeriodReport)(nil),                  // 6: ledger_service.v1.PeriodReport
        (*ListCategoriesRequest)(nil),         // 7: ledger_service.v1.ListCategoriesRequest
        (*ListCategoriesResponse)(nil),        // 8: ledger_service.v1.ListCategoriesResponse
        (*ListTransactionsRequest)(nil),       // 9: ledger_service.v1.ListTransactionsRequest
        (*ListTransactionsResponse)(nil),      // 10: ledger_service.v1.ListTransactionsResponse
        (*GetTransactionRequest)(nil),         // 11: ledger_service.v1.GetTransactionRequest
        (*GetTransactionResponse)(nil),        // 12: ledger_service.v1.GetTransactionResponse
        (*AddTransactionRequest)(nil),         // 13: ledger_service.v1.AddTransactionRequest
        (*AddTransactionResponse)(nil),        // 14: ledger_service.v1.AddTransactionResponse
        (*PatchTransactionRequest)(nil),       // 15: ledger_service.v1.PatchTransactionRequest
        (*PatchTransactionResponse)(nil),      // 16: ledger_service.v1.PatchTransactionResponse
        (*DeleteTransactionRequest)(nil),      // 17: ledger_service.v1.DeleteTransactionRequest
        (*DeleteTransactionResponse)(nil),     // 18: ledger_service.v1.DeleteTransactionResponse
        (*ListBudgetsRequest)(nil),            // 19: ledger_service.v1.ListBudgetsRequest
        (*ListBudgetsResponse)(nil),           // 20: ledger_service.v1.ListBudgetsResponse
        (*GetBudgetRequest)(nil),              // 21: ledger_service.v1.GetBudgetRequest
        (*GetBudgetResponse)(nil),             // 22: ledger_service.v1.GetBudgetResponse
        (*AddBudgetRequest)(nil),              // 23: ledger_service.v1.AddBudgetRequest
        (*AddBudgetResponse)(nil),             // 24: ledger_service.v1.AddBudgetResponse
        (*PatchBudgetRequest)(nil),            // 25: ledger_service.v1.PatchBudgetRequest
        (*PatchBudgetResponse)(nil),           // 26: ledger_service.v1.PatchBudgetResponse
        (*DeleteBudgetRequest)(nil),           // 27: ledger_service.v1.DeleteBudgetRequest
        (*DeleteBudgetResponse)(nil),          // 28: ledger_service.v1.DeleteBudgetResponse
        (*ListReportsRequest)(nil),            // 29: ledger_service.v1.ListReportsRequest
        (*ListReportsResponse)(nil),           // 30: ledger_service.v1.ListReportsResponse
        (*CSVExportTransactionsResponse)(nil), // 31: ledger_service.v1.CSVExportTransactionsResponse
        (*CSVImportTransactionsRequest)(nil),  // 32: ledger_service.v1.CSVImportTransactionsRequest
        (*CSVImportTransactionsResponse)(nil), // 33: ledger_service.v1.CSVImportTransactionsResponse
        (*timestamppb.Timestamp)(nil),         // 34: google.protobuf.Timestamp
}
var file_ledger_service_service_proto_depIdxs = []int32{
        1,  // 0: ledger_service.v1.Transaction.occurred_on:type_name -&gt; ledger_service.v1.Date
        34, // 1: ledger_service.v1.Transaction.created_at:type_name -&gt; google.protobuf.Timestamp
        34, // 2: ledger_service.v1.Transaction.updated_at:type_name -&gt; google.protobuf.Timestamp
        2,  // 3: ledger_service.v1.Budget.period:type_name -&gt; ledger_service.v1.DateMonth
        34, // 4: ledger_service.v1.Budget.created_at:type_name -&gt; google.protobuf.Timestamp
        34, // 5: ledger_service.v1.Budget.updated_at:type_name -&gt; google.protobuf.Timestamp
        1,  // 6: ledger_service.v1.PeriodReport.period_start:type_name -&gt; ledger_service.v1.Date
        1,  // 7: ledger_service.v1.PeriodReport.period_end:type_name -&gt; ledger_service.v1.Date
        5,  // 8: ledger_service.v1.PeriodReport.items:type_name -&gt; ledger_service.v1.ReportItem
        0,  // 9: ledger_service.v1.ListCategoriesResponse.items:type_name -&gt; ledger_service.v1.Category
        1,  // 10: ledger_service.v1.ListTransactionsRequest.filter_occurred_on_from:type_name -&gt; ledger_service.v1.Date
        1,  // 11: ledger_service.v1.ListTransactionsRequest.filter_occurred_on_to:type_name -&gt; ledger_service.v1.Date
        3,  // 12: ledger_service.v1.ListTransactionsResponse.items:type_name -&gt; ledger_service.v1.Transaction
        3,  // 13: ledger_service.v1.GetTransactionResponse.item:type_name -&gt; ledger_service.v1.Transaction
        1,  // 14: ledger_service.v1.AddTransactionRequest.occurred_on:type_name -&gt; ledger_service.v1.Date
        3,  // 15: ledger_service.v1.AddTransactionResponse.item:type_name -&gt; ledger_service.v1.Transaction
        1,  // 16: ledger_service.v1.PatchTransactionRequest.occurred_on:type_name -&gt; ledger_service.v1.Date
        3,  // 17: ledger_service.v1.PatchTransactionResponse.item:type_name -&gt; ledger_service.v1.Transaction
        2,  // 18: ledger_service.v1.ListBudgetsRequest.filter_period_from:type_name -&gt; ledger_service.v1.DateMonth
        2,  // 19: ledger_service.v1.ListBudgetsRequest.filter_period_to:type_name -&gt; ledger_service.v1.DateMonth
        4,  // 20: ledger_service.v1.ListBudgetsResponse.items:type_name -&gt; ledger_service.v1.Budget
        4,  // 21: ledger_service.v1.GetBudgetResponse.item:type_name -&gt; ledger_service.v1.Budget
        2,  // 22: ledger_service.v1.AddBudgetRequest.period:type_name -&gt; ledger_service.v1.DateMonth
        4,  // 23: ledger_service.v1.AddBudgetResponse.item:type_name -&gt; ledger_service.v1.Budget
        2,  // 24: ledger_service.v1.PatchBudgetRequest.period:type_name -&gt; ledger_service.v1.DateMonth
        4,  // 25: ledger_service.v1.PatchBudgetResponse.item:type_name -&gt; ledger_service.v1.Budget
        1,  // 26: ledger_service.v1.ListReportsRequest.date_from:type_name -&gt; ledger_service.v1.Date
        1,  // 27: ledger_service.v1.ListReportsRequest.date_to:type_name -&gt; ledger_service.v1.Date
        6,  // 28: ledger_service.v1.ListReportsResponse.reports:type_name -&gt; ledger_service.v1.PeriodReport
        7,  // 29: ledger_service.v1.Ledger.ListCategories:input_type -&gt; ledger_service.v1.ListCategoriesRequest
        9,  // 30: ledger_service.v1.Ledger.ListTransactions:input_type -&gt; ledger_service.v1.ListTransactionsRequest
        11, // 31: ledger_service.v1.Ledger.GetTransaction:input_type -&gt; ledger_service.v1.GetTransactionRequest
        13, // 32: ledger_service.v1.Ledger.AddTransaction:input_type -&gt; ledger_service.v1.AddTransactionRequest
        15, // 33: ledger_service.v1.Ledger.PatchTransaction:input_type -&gt; ledger_service.v1.PatchTransactionRequest
        17, // 34: ledger_service.v1.Ledger.DeleteTransaction:input_type -&gt; ledger_service.v1.DeleteTransactionRequest
        19, // 35: ledger_service.v1.Ledger.ListBudgets:input_type -&gt; ledger_service.v1.ListBudgetsRequest
        21, // 36: ledger_service.v1.Ledger.GetBudget:input_type -&gt; ledger_service.v1.GetBudgetRequest
        23, // 37: ledger_service.v1.Ledger.AddBudget:input_type -&gt; ledger_service.v1.AddBudgetRequest
        25, // 38: ledger_service.v1.Ledger.PatchBudget:input_type -&gt; ledger_service.v1.PatchBudgetRequest
        27, // 39: ledger_service.v1.Ledger.DeleteBudget:input_type -&gt; ledger_service.v1.DeleteBudgetRequest
        29, // 40: ledger_service.v1.Ledger.ListReports:input_type -&gt; ledger_service.v1.ListReportsRequest
        9,  // 41: ledger_service.v1.Ledger.CSVExportTransactions:input_type -&gt; ledger_service.v1.ListTransactionsRequest
        32, // 42: ledger_service.v1.Ledger.CSVImportTransactions:input_type -&gt; ledger_service.v1.CSVImportTransactionsRequest
        8,  // 43: ledger_service.v1.Ledger.ListCategories:output_type -&gt; ledger_service.v1.ListCategoriesResponse
        10, // 44: ledger_service.v1.Ledger.ListTransactions:output_type -&gt; ledger_service.v1.ListTransactionsResponse
        12, // 45: ledger_service.v1.Ledger.GetTransaction:output_type -&gt; ledger_service.v1.GetTransactionResponse
        14, // 46: ledger_service.v1.Ledger.AddTransaction:output_type -&gt; ledger_service.v1.AddTransactionResponse
        16, // 47: ledger_service.v1.Ledger.PatchTransaction:output_type -&gt; ledger_service.v1.PatchTransactionResponse
        18, // 48: ledger_service.v1.Ledger.DeleteTransaction:output_type -&gt; ledger_service.v1.DeleteTransactionResponse
        20, // 49: ledger_service.v1.Ledger.ListBudgets:output_type -&gt; ledger_service.v1.ListBudgetsResponse
        22, // 50: ledger_service.v1.Ledger.GetBudget:output_type -&gt; ledger_service.v1.GetBudgetResponse
        24, // 51: ledger_service.v1.Ledger.AddBudget:output_type -&gt; ledger_service.v1.AddBudgetResponse
        26, // 52: ledger_service.v1.Ledger.PatchBudget:output_type -&gt; ledger_service.v1.PatchBudgetResponse
        28, // 53: ledger_service.v1.Ledger.DeleteBudget:output_type -&gt; ledger_service.v1.DeleteBudgetResponse
        30, // 54: ledger_service.v1.Ledger.ListReports:output_type -&gt; ledger_service.v1.ListReportsResponse
        31, // 55: ledger_service.v1.Ledger.CSVExportTransactions:output_type -&gt; ledger_service.v1.CSVExportTransactionsResponse
        33, // 56: ledger_service.v1.Ledger.CSVImportTransactions:output_type -&gt; ledger_service.v1.CSVImportTransactionsResponse
        43, // [43:57] is the sub-list for method output_type
        29, // [29:43] is the sub-list for method input_type
        29, // [29:29] is the sub-list for extension type_name
        29, // [29:29] is the sub-list for extension extendee
        0,  // [0:29] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_ledger_service_service_proto_init() }</span>
func file_ledger_service_service_proto_init() <span class="cov0" title="0">{
        if File_ledger_service_service_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">file_ledger_service_service_proto_msgTypes[5].OneofWrappers = []any{}
        file_ledger_service_service_proto_msgTypes[9].OneofWrappers = []any{}
        file_ledger_service_service_proto_msgTypes[15].OneofWrappers = []any{}
        file_ledger_service_service_proto_msgTypes[19].OneofWrappers = []any{}
        file_ledger_service_service_proto_msgTypes[25].OneofWrappers = []any{}
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_ledger_service_service_proto_rawDesc), len(file_ledger_service_service_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   34,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_ledger_service_service_proto_goTypes,
                DependencyIndexes: file_ledger_service_service_proto_depIdxs,
                MessageInfos:      file_ledger_service_service_proto_msgTypes,
        }.Build()
        File_ledger_service_service_proto = out.File
        file_ledger_service_service_proto_goTypes = nil
        file_ledger_service_service_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: ledger_service/service.proto

package ledger_servicev1

import (
        "bytes"
        "errors"
        "fmt"
        "net"
        "net/mail"
        "net/url"
        "regexp"
        "sort"
        "strings"
        "time"
        "unicode/utf8"

        "google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
        _ = bytes.MinRead
        _ = errors.New("")
        _ = fmt.Print
        _ = utf8.UTFMax
        _ = (*regexp.Regexp)(nil)
        _ = (*strings.Reader)(nil)
        _ = net.IPv4len
        _ = time.Duration(0)
        _ = (*url.URL)(nil)
        _ = (*mail.Address)(nil)
        _ = anypb.Any{}
        _ = sort.Sort
)

// Validate checks the field values on Category with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Category) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on Category with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CategoryMultiError, or nil
// if none found.
func (m *Category) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *Category) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Id

        // no validation rules for Title

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return CategoryMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CategoryMultiError is an error wrapping multiple validation errors returned
// by Category.ValidateAll() if the designated constraints aren't met.
type CategoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CategoryMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m CategoryMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// CategoryValidationError is the validation error returned by
// Category.Validate if the designated constraints aren't met.
type CategoryValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e CategoryValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e CategoryValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e CategoryValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e CategoryValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e CategoryValidationError) ErrorName() string <span class="cov0" title="0">{ return "CategoryValidationError" }</span>

// Error satisfies the builtin error interface
func (e CategoryValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sCategory.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = CategoryValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = CategoryValidationError{}

// Validate checks the field values on Date with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Date) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on Date with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DateMultiError, or nil if none found.
func (m *Date) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *Date) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Year

        // no validation rules for Month

        // no validation rules for Day

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return DateMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DateMultiError is an error wrapping multiple validation errors returned by
// Date.ValidateAll() if the designated constraints aren't met.
type DateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DateMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m DateMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// DateValidationError is the validation error returned by Date.Validate if the
// designated constraints aren't met.
type DateValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e DateValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e DateValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e DateValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e DateValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e DateValidationError) ErrorName() string <span class="cov0" title="0">{ return "DateValidationError" }</span>

// Error satisfies the builtin error interface
func (e DateValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sDate.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = DateValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = DateValidationError{}

// Validate checks the field values on DateMonth with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DateMonth) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on DateMonth with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DateMonthMultiError, or nil
// if none found.
func (m *DateMonth) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *DateMonth) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Year

        // no validation rules for Month

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return DateMonthMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DateMonthMultiError is an error wrapping multiple validation errors returned
// by DateMonth.ValidateAll() if the designated constraints aren't met.
type DateMonthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DateMonthMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m DateMonthMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// DateMonthValidationError is the validation error returned by
// DateMonth.Validate if the designated constraints aren't met.
type DateMonthValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e DateMonthValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e DateMonthValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e DateMonthValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e DateMonthValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e DateMonthValidationError) ErrorName() string <span class="cov0" title="0">{ return "DateMonthValidationError" }</span>

// Error satisfies the builtin error interface
func (e DateMonthValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sDateMonth.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = DateMonthValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = DateMonthValidationError{}

// Validate checks the field values on Transaction with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transaction) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on Transaction with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransactionMultiError, or
// nil if none found.
func (m *Transaction) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *Transaction) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Id

        // no validation rules for AccountId

        // no validation rules for IsIncome

        // no validation rules for Amount

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetOccurredOn()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, TransactionValidationError{
                                        field:  "OccurredOn",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, TransactionValidationError{
                                        field:  "OccurredOn",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetOccurredOn()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return TransactionValidationError{
                                field:  "OccurredOn",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        // no validation rules for CategoryId

        // no validation rules for Description

        <span class="cov0" title="0">if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetCreatedAt()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, TransactionValidationError{
                                        field:  "CreatedAt",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, TransactionValidationError{
                                        field:  "CreatedAt",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return TransactionValidationError{
                                field:  "CreatedAt",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetUpdatedAt()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, TransactionValidationError{
                                        field:  "UpdatedAt",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, TransactionValidationError{
                                        field:  "UpdatedAt",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return TransactionValidationError{
                                field:  "UpdatedAt",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return TransactionMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// TransactionMultiError is an error wrapping multiple validation errors
// returned by Transaction.ValidateAll() if the designated constraints aren't met.
type TransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m TransactionMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// TransactionValidationError is the validation error returned by
// Transaction.Validate if the designated constraints aren't met.
type TransactionValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e TransactionValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e TransactionValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e TransactionValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e TransactionValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e TransactionValidationError) ErrorName() string <span class="cov0" title="0">{ return "TransactionValidationError" }</span>

// Error satisfies the builtin error interface
func (e TransactionValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sTransaction.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = TransactionValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = TransactionValidationError{}

// Validate checks the field values on Budget with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Budget) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on Budget with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BudgetMultiError, or nil if none found.
func (m *Budget) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *Budget) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Id

        // no validation rules for AccountId

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetPeriod()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, BudgetValidationError{
                                        field:  "Period",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, BudgetValidationError{
                                        field:  "Period",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetPeriod()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return BudgetValidationError{
                                field:  "Period",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        // no validation rules for CategoryId

        // no validation rules for Amount

        <span class="cov0" title="0">if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetCreatedAt()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, BudgetValidationError{
                                        field:  "CreatedAt",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, BudgetValidationError{
                                        field:  "CreatedAt",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return BudgetValidationError{
                                field:  "CreatedAt",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetUpdatedAt()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, BudgetValidationError{
                                        field:  "UpdatedAt",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, BudgetValidationError{
                                        field:  "UpdatedAt",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return BudgetValidationError{
                                field:  "UpdatedAt",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return BudgetMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// BudgetMultiError is an error wrapping multiple validation errors returned by
// Budget.ValidateAll() if the designated constraints aren't met.
type BudgetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BudgetMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m BudgetMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// BudgetValidationError is the validation error returned by Budget.Validate if
// the designated constraints aren't met.
type BudgetValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e BudgetValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e BudgetValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e BudgetValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e BudgetValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e BudgetValidationError) ErrorName() string <span class="cov0" title="0">{ return "BudgetValidationError" }</span>

// Error satisfies the builtin error interface
func (e BudgetValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sBudget.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = BudgetValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = BudgetValidationError{}

// Validate checks the field values on ReportItem with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReportItem) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ReportItem with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReportItemMultiError, or
// nil if none found.
func (m *ReportItem) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ReportItem) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for CategoryId

        if m.Sum != nil </span>{<span class="cov0" title="0">
                // no validation rules for Sum
        }</span>

        <span class="cov0" title="0">if m.SpentBudget != nil </span>{<span class="cov0" title="0">
                // no validation rules for SpentBudget
        }</span>

        <span class="cov0" title="0">if m.ItemBudget != nil </span>{<span class="cov0" title="0">
                // no validation rules for ItemBudget
        }</span>

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ReportItemMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ReportItemMultiError is an error wrapping multiple validation errors
// returned by ReportItem.ValidateAll() if the designated constraints aren't met.
type ReportItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportItemMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ReportItemMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ReportItemValidationError is the validation error returned by
// ReportItem.Validate if the designated constraints aren't met.
type ReportItemValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ReportItemValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ReportItemValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ReportItemValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ReportItemValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ReportItemValidationError) ErrorName() string <span class="cov0" title="0">{ return "ReportItemValidationError" }</span>

// Error satisfies the builtin error interface
func (e ReportItemValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sReportItem.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ReportItemValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ReportItemValidationError{}

// Validate checks the field values on PeriodReport with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PeriodReport) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on PeriodReport with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PeriodReportMultiError, or
// nil if none found.
func (m *PeriodReport) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *PeriodReport) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetPeriodStart()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, PeriodReportValidationError{
                                        field:  "PeriodStart",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, PeriodReportValidationError{
                                        field:  "PeriodStart",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetPeriodStart()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return PeriodReportValidationError{
                                field:  "PeriodStart",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetPeriodEnd()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, PeriodReportValidationError{
                                        field:  "PeriodEnd",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, PeriodReportValidationError{
                                        field:  "PeriodEnd",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetPeriodEnd()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return PeriodReportValidationError{
                                field:  "PeriodEnd",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">for idx, item := range m.GetItems() </span><span class="cov0" title="0">{
                _, _ = idx, item

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(item).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, PeriodReportValidationError{
                                                field:  fmt.Sprintf("Items[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, PeriodReportValidationError{
                                                field:  fmt.Sprintf("Items[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(item).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return PeriodReportValidationError{
                                        field:  fmt.Sprintf("Items[%v]", idx),
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return PeriodReportMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PeriodReportMultiError is an error wrapping multiple validation errors
// returned by PeriodReport.ValidateAll() if the designated constraints aren't met.
type PeriodReportMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PeriodReportMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m PeriodReportMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// PeriodReportValidationError is the validation error returned by
// PeriodReport.Validate if the designated constraints aren't met.
type PeriodReportValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e PeriodReportValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e PeriodReportValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e PeriodReportValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e PeriodReportValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e PeriodReportValidationError) ErrorName() string <span class="cov0" title="0">{ return "PeriodReportValidationError" }</span>

// Error satisfies the builtin error interface
func (e PeriodReportValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sPeriodReport.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = PeriodReportValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = PeriodReportValidationError{}

// Validate checks the field values on ListCategoriesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCategoriesRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ListCategoriesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCategoriesRequestMultiError, or nil if none found.
func (m *ListCategoriesRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ListCategoriesRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ListCategoriesRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListCategoriesRequestMultiError is an error wrapping multiple validation
// errors returned by ListCategoriesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListCategoriesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCategoriesRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ListCategoriesRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ListCategoriesRequestValidationError is the validation error returned by
// ListCategoriesRequest.Validate if the designated constraints aren't met.
type ListCategoriesRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ListCategoriesRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ListCategoriesRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ListCategoriesRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ListCategoriesRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ListCategoriesRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "ListCategoriesRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e ListCategoriesRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sListCategoriesRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ListCategoriesRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ListCategoriesRequestValidationError{}

// Validate checks the field values on ListCategoriesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCategoriesResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ListCategoriesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCategoriesResponseMultiError, or nil if none found.
func (m *ListCategoriesResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ListCategoriesResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        for idx, item := range m.GetItems() </span><span class="cov0" title="0">{
                _, _ = idx, item

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(item).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListCategoriesResponseValidationError{
                                                field:  fmt.Sprintf("Items[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListCategoriesResponseValidationError{
                                                field:  fmt.Sprintf("Items[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(item).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return ListCategoriesResponseValidationError{
                                        field:  fmt.Sprintf("Items[%v]", idx),
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ListCategoriesResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListCategoriesResponseMultiError is an error wrapping multiple validation
// errors returned by ListCategoriesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListCategoriesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCategoriesResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ListCategoriesResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ListCategoriesResponseValidationError is the validation error returned by
// ListCategoriesResponse.Validate if the designated constraints aren't met.
type ListCategoriesResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ListCategoriesResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ListCategoriesResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ListCategoriesResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ListCategoriesResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ListCategoriesResponseValidationError) ErrorName() string <span class="cov0" title="0">{
        return "ListCategoriesResponseValidationError"
}</span>

// Error satisfies the builtin error interface
func (e ListCategoriesResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sListCategoriesResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ListCategoriesResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ListCategoriesResponseValidationError{}

// Validate checks the field values on ListTransactionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTransactionsRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ListTransactionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTransactionsRequestMultiError, or nil if none found.
func (m *ListTransactionsRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ListTransactionsRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Limit

        // no validation rules for Offset

        if m.FilterOccurredOnFrom != nil </span><span class="cov0" title="0">{

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(m.GetFilterOccurredOnFrom()).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListTransactionsRequestValidationError{
                                                field:  "FilterOccurredOnFrom",
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListTransactionsRequestValidationError{
                                                field:  "FilterOccurredOnFrom",
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetFilterOccurredOnFrom()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return ListTransactionsRequestValidationError{
                                        field:  "FilterOccurredOnFrom",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        <span class="cov0" title="0">if m.FilterOccurredOnTo != nil </span><span class="cov0" title="0">{

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(m.GetFilterOccurredOnTo()).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListTransactionsRequestValidationError{
                                                field:  "FilterOccurredOnTo",
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListTransactionsRequestValidationError{
                                                field:  "FilterOccurredOnTo",
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetFilterOccurredOnTo()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return ListTransactionsRequestValidationError{
                                        field:  "FilterOccurredOnTo",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ListTransactionsRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListTransactionsRequestMultiError is an error wrapping multiple validation
// errors returned by ListTransactionsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransactionsRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ListTransactionsRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ListTransactionsRequestValidationError is the validation error returned by
// ListTransactionsRequest.Validate if the designated constraints aren't met.
type ListTransactionsRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ListTransactionsRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ListTransactionsRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ListTransactionsRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ListTransactionsRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ListTransactionsRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "ListTransactionsRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e ListTransactionsRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sListTransactionsRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ListTransactionsRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ListTransactionsRequestValidationError{}

// Validate checks the field values on ListTransactionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTransactionsResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ListTransactionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTransactionsResponseMultiError, or nil if none found.
func (m *ListTransactionsResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ListTransactionsResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        for idx, item := range m.GetItems() </span><span class="cov0" title="0">{
                _, _ = idx, item

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(item).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListTransactionsResponseValidationError{
                                                field:  fmt.Sprintf("Items[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListTransactionsResponseValidationError{
                                                field:  fmt.Sprintf("Items[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(item).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return ListTransactionsResponseValidationError{
                                        field:  fmt.Sprintf("Items[%v]", idx),
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        // no validation rules for Total

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ListTransactionsResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListTransactionsResponseMultiError is an error wrapping multiple validation
// errors returned by ListTransactionsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransactionsResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ListTransactionsResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ListTransactionsResponseValidationError is the validation error returned by
// ListTransactionsResponse.Validate if the designated constraints aren't met.
type ListTransactionsResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ListTransactionsResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ListTransactionsResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ListTransactionsResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ListTransactionsResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ListTransactionsResponseValidationError) ErrorName() string <span class="cov0" title="0">{
        return "ListTransactionsResponseValidationError"
}</span>

// Error satisfies the builtin error interface
func (e ListTransactionsResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sListTransactionsResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ListTransactionsResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ListTransactionsResponseValidationError{}

// Validate checks the field values on GetTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransactionRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on GetTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransactionRequestMultiError, or nil if none found.
func (m *GetTransactionRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *GetTransactionRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Id

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return GetTransactionRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by GetTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// GetTransactionRequestValidationError is the validation error returned by
// GetTransactionRequest.Validate if the designated constraints aren't met.
type GetTransactionRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e GetTransactionRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e GetTransactionRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e GetTransactionRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e GetTransactionRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e GetTransactionRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "GetTransactionRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e GetTransactionRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sGetTransactionRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = GetTransactionRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = GetTransactionRequestValidationError{}

// Validate checks the field values on GetTransactionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransactionResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on GetTransactionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransactionResponseMultiError, or nil if none found.
func (m *GetTransactionResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *GetTransactionResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetItem()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, GetTransactionResponseValidationError{
                                        field:  "Item",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, GetTransactionResponseValidationError{
                                        field:  "Item",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return GetTransactionResponseValidationError{
                                field:  "Item",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return GetTransactionResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetTransactionResponseMultiError is an error wrapping multiple validation
// errors returned by GetTransactionResponse.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// GetTransactionResponseValidationError is the validation error returned by
// GetTransactionResponse.Validate if the designated constraints aren't met.
type GetTransactionResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e GetTransactionResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e GetTransactionResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e GetTransactionResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e GetTransactionResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e GetTransactionResponseValidationError) ErrorName() string <span class="cov0" title="0">{
        return "GetTransactionResponseValidationError"
}</span>

// Error satisfies the builtin error interface
func (e GetTransactionResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sGetTransactionResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = GetTransactionResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = GetTransactionResponseValidationError{}

// Validate checks the field values on AddTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddTransactionRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on AddTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddTransactionRequestMultiError, or nil if none found.
func (m *AddTransactionRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *AddTransactionRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for IsIncome

        // no validation rules for Amount

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetOccurredOn()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, AddTransactionRequestValidationError{
                                        field:  "OccurredOn",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, AddTransactionRequestValidationError{
                                        field:  "OccurredOn",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetOccurredOn()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return AddTransactionRequestValidationError{
                                field:  "OccurredOn",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        // no validation rules for CategoryId

        // no validation rules for Description

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return AddTransactionRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AddTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by AddTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type AddTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddTransactionRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m AddTransactionRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// AddTransactionRequestValidationError is the validation error returned by
// AddTransactionRequest.Validate if the designated constraints aren't met.
type AddTransactionRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e AddTransactionRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e AddTransactionRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e AddTransactionRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e AddTransactionRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e AddTransactionRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "AddTransactionRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e AddTransactionRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sAddTransactionRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = AddTransactionRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = AddTransactionRequestValidationError{}

// Validate checks the field values on AddTransactionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddTransactionResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on AddTransactionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddTransactionResponseMultiError, or nil if none found.
func (m *AddTransactionResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *AddTransactionResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetItem()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, AddTransactionResponseValidationError{
                                        field:  "Item",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, AddTransactionResponseValidationError{
                                        field:  "Item",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return AddTransactionResponseValidationError{
                                field:  "Item",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return AddTransactionResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AddTransactionResponseMultiError is an error wrapping multiple validation
// errors returned by AddTransactionResponse.ValidateAll() if the designated
// constraints aren't met.
type AddTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddTransactionResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m AddTransactionResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// AddTransactionResponseValidationError is the validation error returned by
// AddTransactionResponse.Validate if the designated constraints aren't met.
type AddTransactionResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e AddTransactionResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e AddTransactionResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e AddTransactionResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e AddTransactionResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e AddTransactionResponseValidationError) ErrorName() string <span class="cov0" title="0">{
        return "AddTransactionResponseValidationError"
}</span>

// Error satisfies the builtin error interface
func (e AddTransactionResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sAddTransactionResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = AddTransactionResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = AddTransactionResponseValidationError{}

// Validate checks the field values on PatchTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PatchTransactionRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on PatchTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PatchTransactionRequestMultiError, or nil if none found.
func (m *PatchTransactionRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *PatchTransactionRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Id

        if m.Amount != nil </span>{<span class="cov0" title="0">
                // no validation rules for Amount
        }</span>

        <span class="cov0" title="0">if m.OccurredOn != nil </span><span class="cov0" title="0">{

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(m.GetOccurredOn()).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, PatchTransactionRequestValidationError{
                                                field:  "OccurredOn",
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, PatchTransactionRequestValidationError{
                                                field:  "OccurredOn",
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetOccurredOn()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return PatchTransactionRequestValidationError{
                                        field:  "OccurredOn",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        <span class="cov0" title="0">if m.CategoryId != nil </span>{<span class="cov0" title="0">
                // no validation rules for CategoryId
        }</span>

        <span class="cov0" title="0">if m.Description != nil </span>{<span class="cov0" title="0">
                // no validation rules for Description
        }</span>

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return PatchTransactionRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PatchTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by PatchTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type PatchTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PatchTransactionRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m PatchTransactionRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// PatchTransactionRequestValidationError is the validation error returned by
// PatchTransactionRequest.Validate if the designated constraints aren't met.
type PatchTransactionRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e PatchTransactionRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e PatchTransactionRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e PatchTransactionRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e PatchTransactionRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e PatchTransactionRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "PatchTransactionRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e PatchTransactionRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sPatchTransactionRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = PatchTransactionRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = PatchTransactionRequestValidationError{}

// Validate checks the field values on PatchTransactionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PatchTransactionResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on PatchTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PatchTransactionResponseMultiError, or nil if none found.
func (m *PatchTransactionResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *PatchTransactionResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetItem()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, PatchTransactionResponseValidationError{
                                        field:  "Item",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, PatchTransactionResponseValidationError{
                                        field:  "Item",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return PatchTransactionResponseValidationError{
                                field:  "Item",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return PatchTransactionResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PatchTransactionResponseMultiError is an error wrapping multiple validation
// errors returned by PatchTransactionResponse.ValidateAll() if the designated
// constraints aren't met.
type PatchTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PatchTransactionResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m PatchTransactionResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// PatchTransactionResponseValidationError is the validation error returned by
// PatchTransactionResponse.Validate if the designated constraints aren't met.
type PatchTransactionResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e PatchTransactionResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e PatchTransactionResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e PatchTransactionResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e PatchTransactionResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e PatchTransactionResponseValidationError) ErrorName() string <span class="cov0" title="0">{
        return "PatchTransactionResponseValidationError"
}</span>

// Error satisfies the builtin error interface
func (e PatchTransactionResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sPatchTransactionResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = PatchTransactionResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = PatchTransactionResponseValidationError{}

// Validate checks the field values on DeleteTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteTransactionRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on DeleteTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteTransactionRequestMultiError, or nil if none found.
func (m *DeleteTransactionRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *DeleteTransactionRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Id

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return DeleteTransactionRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTransactionRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTransactionRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// DeleteTransactionRequestValidationError is the validation error returned by
// DeleteTransactionRequest.Validate if the designated constraints aren't met.
type DeleteTransactionRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e DeleteTransactionRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e DeleteTransactionRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e DeleteTransactionRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e DeleteTransactionRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e DeleteTransactionRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "DeleteTransactionRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e DeleteTransactionRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sDeleteTransactionRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = DeleteTransactionRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = DeleteTransactionRequestValidationError{}

// Validate checks the field values on DeleteTransactionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteTransactionResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on DeleteTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteTransactionResponseMultiError, or nil if none found.
func (m *DeleteTransactionResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *DeleteTransactionResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return DeleteTransactionResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteTransactionResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteTransactionResponse.ValidateAll() if the
// designated constraints aren't met.
type DeleteTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTransactionResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTransactionResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// DeleteTransactionResponseValidationError is the validation error returned by
// DeleteTransactionResponse.Validate if the designated constraints aren't met.
type DeleteTransactionResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e DeleteTransactionResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e DeleteTransactionResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e DeleteTransactionResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e DeleteTransactionResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e DeleteTransactionResponseValidationError) ErrorName() string <span class="cov0" title="0">{
        return "DeleteTransactionResponseValidationError"
}</span>

// Error satisfies the builtin error interface
func (e DeleteTransactionResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sDeleteTransactionResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = DeleteTransactionResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = DeleteTransactionResponseValidationError{}

// Validate checks the field values on ListBudgetsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListBudgetsRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ListBudgetsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListBudgetsRequestMultiError, or nil if none found.
func (m *ListBudgetsRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ListBudgetsRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Limit

        // no validation rules for Offset

        if m.FilterPeriodFrom != nil </span><span class="cov0" title="0">{

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(m.GetFilterPeriodFrom()).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListBudgetsRequestValidationError{
                                                field:  "FilterPeriodFrom",
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListBudgetsRequestValidationError{
                                                field:  "FilterPeriodFrom",
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetFilterPeriodFrom()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return ListBudgetsRequestValidationError{
                                        field:  "FilterPeriodFrom",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        <span class="cov0" title="0">if m.FilterPeriodTo != nil </span><span class="cov0" title="0">{

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(m.GetFilterPeriodTo()).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListBudgetsRequestValidationError{
                                                field:  "FilterPeriodTo",
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListBudgetsRequestValidationError{
                                                field:  "FilterPeriodTo",
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetFilterPeriodTo()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return ListBudgetsRequestValidationError{
                                        field:  "FilterPeriodTo",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ListBudgetsRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListBudgetsRequestMultiError is an error wrapping multiple validation errors
// returned by ListBudgetsRequest.ValidateAll() if the designated constraints
// aren't met.
type ListBudgetsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBudgetsRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ListBudgetsRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ListBudgetsRequestValidationError is the validation error returned by
// ListBudgetsRequest.Validate if the designated constraints aren't met.
type ListBudgetsRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ListBudgetsRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ListBudgetsRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ListBudgetsRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ListBudgetsRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ListBudgetsRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "ListBudgetsRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e ListBudgetsRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sListBudgetsRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ListBudgetsRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ListBudgetsRequestValidationError{}

// Validate checks the field values on ListBudgetsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListBudgetsResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ListBudgetsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListBudgetsResponseMultiError, or nil if none found.
func (m *ListBudgetsResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ListBudgetsResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        for idx, item := range m.GetItems() </span><span class="cov0" title="0">{
                _, _ = idx, item

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(item).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListBudgetsResponseValidationError{
                                                field:  fmt.Sprintf("Items[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListBudgetsResponseValidationError{
                                                field:  fmt.Sprintf("Items[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(item).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return ListBudgetsResponseValidationError{
                                        field:  fmt.Sprintf("Items[%v]", idx),
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        // no validation rules for Total

        // no validation rules for HitCache

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ListBudgetsResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListBudgetsResponseMultiError is an error wrapping multiple validation
// errors returned by ListBudgetsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListBudgetsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBudgetsResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ListBudgetsResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ListBudgetsResponseValidationError is the validation error returned by
// ListBudgetsResponse.Validate if the designated constraints aren't met.
type ListBudgetsResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ListBudgetsResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ListBudgetsResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ListBudgetsResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ListBudgetsResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ListBudgetsResponseValidationError) ErrorName() string <span class="cov0" title="0">{
        return "ListBudgetsResponseValidationError"
}</span>

// Error satisfies the builtin error interface
func (e ListBudgetsResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sListBudgetsResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ListBudgetsResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ListBudgetsResponseValidationError{}

// Validate checks the field values on GetBudgetRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetBudgetRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on GetBudgetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBudgetRequestMultiError, or nil if none found.
func (m *GetBudgetRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *GetBudgetRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Id

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return GetBudgetRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetBudgetRequestMultiError is an error wrapping multiple validation errors
// returned by GetBudgetRequest.ValidateAll() if the designated constraints
// aren't met.
type GetBudgetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBudgetRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m GetBudgetRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// GetBudgetRequestValidationError is the validation error returned by
// GetBudgetRequest.Validate if the designated constraints aren't met.
type GetBudgetRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e GetBudgetRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e GetBudgetRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e GetBudgetRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e GetBudgetRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e GetBudgetRequestValidationError) ErrorName() string <span class="cov0" title="0">{ return "GetBudgetRequestValidationError" }</span>

// Error satisfies the builtin error interface
func (e GetBudgetRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sGetBudgetRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = GetBudgetRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = GetBudgetRequestValidationError{}

// Validate checks the field values on GetBudgetResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetBudgetResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on GetBudgetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBudgetResponseMultiError, or nil if none found.
func (m *GetBudgetResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *GetBudgetResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetItem()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, GetBudgetResponseValidationError{
                                        field:  "Item",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, GetBudgetResponseValidationError{
                                        field:  "Item",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return GetBudgetResponseValidationError{
                                field:  "Item",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        // no validation rules for HitCache

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return GetBudgetResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetBudgetResponseMultiError is an error wrapping multiple validation errors
// returned by GetBudgetResponse.ValidateAll() if the designated constraints
// aren't met.
type GetBudgetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBudgetResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m GetBudgetResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// GetBudgetResponseValidationError is the validation error returned by
// GetBudgetResponse.Validate if the designated constraints aren't met.
type GetBudgetResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e GetBudgetResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e GetBudgetResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e GetBudgetResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e GetBudgetResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e GetBudgetResponseValidationError) ErrorName() string <span class="cov0" title="0">{
        return "GetBudgetResponseValidationError"
}</span>

// Error satisfies the builtin error interface
func (e GetBudgetResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sGetBudgetResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = GetBudgetResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = GetBudgetResponseValidationError{}

// Validate checks the field values on AddBudgetRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddBudgetRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on AddBudgetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddBudgetRequestMultiError, or nil if none found.
func (m *AddBudgetRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *AddBudgetRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetPeriod()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, AddBudgetRequestValidationError{
                                        field:  "Period",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, AddBudgetRequestValidationError{
                                        field:  "Period",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetPeriod()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return AddBudgetRequestValidationError{
                                field:  "Period",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        // no validation rules for CategoryId

        // no validation rules for Amount

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return AddBudgetRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AddBudgetRequestMultiError is an error wrapping multiple validation errors
// returned by AddBudgetRequest.ValidateAll() if the designated constraints
// aren't met.
type AddBudgetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddBudgetRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m AddBudgetRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// AddBudgetRequestValidationError is the validation error returned by
// AddBudgetRequest.Validate if the designated constraints aren't met.
type AddBudgetRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e AddBudgetRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e AddBudgetRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e AddBudgetRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e AddBudgetRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e AddBudgetRequestValidationError) ErrorName() string <span class="cov0" title="0">{ return "AddBudgetRequestValidationError" }</span>

// Error satisfies the builtin error interface
func (e AddBudgetRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sAddBudgetRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = AddBudgetRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = AddBudgetRequestValidationError{}

// Validate checks the field values on AddBudgetResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddBudgetResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on AddBudgetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddBudgetResponseMultiError, or nil if none found.
func (m *AddBudgetResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *AddBudgetResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetItem()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, AddBudgetResponseValidationError{
                                        field:  "Item",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, AddBudgetResponseValidationError{
                                        field:  "Item",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return AddBudgetResponseValidationError{
                                field:  "Item",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return AddBudgetResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AddBudgetResponseMultiError is an error wrapping multiple validation errors
// returned by AddBudgetResponse.ValidateAll() if the designated constraints
// aren't met.
type AddBudgetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddBudgetResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m AddBudgetResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// AddBudgetResponseValidationError is the validation error returned by
// AddBudgetResponse.Validate if the designated constraints aren't met.
type AddBudgetResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e AddBudgetResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e AddBudgetResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e AddBudgetResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e AddBudgetResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e AddBudgetResponseValidationError) ErrorName() string <span class="cov0" title="0">{
        return "AddBudgetResponseValidationError"
}</span>

// Error satisfies the builtin error interface
func (e AddBudgetResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sAddBudgetResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = AddBudgetResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = AddBudgetResponseValidationError{}

// Validate checks the field values on PatchBudgetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PatchBudgetRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on PatchBudgetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PatchBudgetRequestMultiError, or nil if none found.
func (m *PatchBudgetRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *PatchBudgetRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Id

        if m.Period != nil </span><span class="cov0" title="0">{

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(m.GetPeriod()).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, PatchBudgetRequestValidationError{
                                                field:  "Period",
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, PatchBudgetRequestValidationError{
                                                field:  "Period",
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetPeriod()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return PatchBudgetRequestValidationError{
                                        field:  "Period",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        <span class="cov0" title="0">if m.CategoryId != nil </span>{<span class="cov0" title="0">
                // no validation rules for CategoryId
        }</span>

        <span class="cov0" title="0">if m.Amount != nil </span>{<span class="cov0" title="0">
                // no validation rules for Amount
        }</span>

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return PatchBudgetRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PatchBudgetRequestMultiError is an error wrapping multiple validation errors
// returned by PatchBudgetRequest.ValidateAll() if the designated constraints
// aren't met.
type PatchBudgetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PatchBudgetRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m PatchBudgetRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// PatchBudgetRequestValidationError is the validation error returned by
// PatchBudgetRequest.Validate if the designated constraints aren't met.
type PatchBudgetRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e PatchBudgetRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e PatchBudgetRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e PatchBudgetRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e PatchBudgetRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e PatchBudgetRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "PatchBudgetRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e PatchBudgetRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sPatchBudgetRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = PatchBudgetRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = PatchBudgetRequestValidationError{}

// Validate checks the field values on PatchBudgetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PatchBudgetResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on PatchBudgetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PatchBudgetResponseMultiError, or nil if none found.
func (m *PatchBudgetResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *PatchBudgetResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetItem()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, PatchBudgetResponseValidationError{
                                        field:  "Item",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, PatchBudgetResponseValidationError{
                                        field:  "Item",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return PatchBudgetResponseValidationError{
                                field:  "Item",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return PatchBudgetResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PatchBudgetResponseMultiError is an error wrapping multiple validation
// errors returned by PatchBudgetResponse.ValidateAll() if the designated
// constraints aren't met.
type PatchBudgetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PatchBudgetResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m PatchBudgetResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// PatchBudgetResponseValidationError is the validation error returned by
// PatchBudgetResponse.Validate if the designated constraints aren't met.
type PatchBudgetResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e PatchBudgetResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e PatchBudgetResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e PatchBudgetResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e PatchBudgetResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e PatchBudgetResponseValidationError) ErrorName() string <span class="cov0" title="0">{
        return "PatchBudgetResponseValidationError"
}</span>

// Error satisfies the builtin error interface
func (e PatchBudgetResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sPatchBudgetResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = PatchBudgetResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = PatchBudgetResponseValidationError{}

// Validate checks the field values on DeleteBudgetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteBudgetRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on DeleteBudgetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteBudgetRequestMultiError, or nil if none found.
func (m *DeleteBudgetRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *DeleteBudgetRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Id

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return DeleteBudgetRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteBudgetRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteBudgetRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteBudgetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteBudgetRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m DeleteBudgetRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// DeleteBudgetRequestValidationError is the validation error returned by
// DeleteBudgetRequest.Validate if the designated constraints aren't met.
type DeleteBudgetRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e DeleteBudgetRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e DeleteBudgetRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e DeleteBudgetRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e DeleteBudgetRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e DeleteBudgetRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "DeleteBudgetRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e DeleteBudgetRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sDeleteBudgetRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = DeleteBudgetRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = DeleteBudgetRequestValidationError{}

// Validate checks the field values on DeleteBudgetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteBudgetResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on DeleteBudgetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteBudgetResponseMultiError, or nil if none found.
func (m *DeleteBudgetResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *DeleteBudgetResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return DeleteBudgetResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteBudgetResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteBudgetResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteBudgetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteBudgetResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m DeleteBudgetResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// DeleteBudgetResponseValidationError is the validation error returned by
// DeleteBudgetResponse.Validate if the designated constraints aren't met.
type DeleteBudgetResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e DeleteBudgetResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e DeleteBudgetResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e DeleteBudgetResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e DeleteBudgetResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e DeleteBudgetResponseValidationError) ErrorName() string <span class="cov0" title="0">{
        return "DeleteBudgetResponseValidationError"
}</span>

// Error satisfies the builtin error interface
func (e DeleteBudgetResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sDeleteBudgetResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = DeleteBudgetResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = DeleteBudgetResponseValidationError{}

// Validate checks the field values on ListReportsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListReportsRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ListReportsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListReportsRequestMultiError, or nil if none found.
func (m *ListReportsRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ListReportsRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetDateFrom()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, ListReportsRequestValidationError{
                                        field:  "DateFrom",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, ListReportsRequestValidationError{
                                        field:  "DateFrom",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetDateFrom()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return ListReportsRequestValidationError{
                                field:  "DateFrom",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetDateTo()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, ListReportsRequestValidationError{
                                        field:  "DateTo",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, ListReportsRequestValidationError{
                                        field:  "DateTo",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetDateTo()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return ListReportsRequestValidationError{
                                field:  "DateTo",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ListReportsRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListReportsRequestMultiError is an error wrapping multiple validation errors
// returned by ListReportsRequest.ValidateAll() if the designated constraints
// aren't met.
type ListReportsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReportsRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ListReportsRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ListReportsRequestValidationError is the validation error returned by
// ListReportsRequest.Validate if the designated constraints aren't met.
type ListReportsRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ListReportsRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ListReportsRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ListReportsRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ListReportsRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ListReportsRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "ListReportsRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e ListReportsRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sListReportsRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ListReportsRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ListReportsRequestValidationError{}

// Validate checks the field values on ListReportsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListReportsResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ListReportsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListReportsResponseMultiError, or nil if none found.
func (m *ListReportsResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ListReportsResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        for idx, item := range m.GetReports() </span><span class="cov0" title="0">{
                _, _ = idx, item

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(item).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListReportsResponseValidationError{
                                                field:  fmt.Sprintf("Reports[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListReportsResponseValidationError{
                                                field:  fmt.Sprintf("Reports[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(item).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return ListReportsResponseValidationError{
                                        field:  fmt.Sprintf("Reports[%v]", idx),
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        // no validation rules for HitCache

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ListReportsResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListReportsResponseMultiError is an error wrapping multiple validation
// errors returned by ListReportsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListReportsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReportsResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ListReportsResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ListReportsResponseValidationError is the validation error returned by
// ListReportsResponse.Validate if the designated constraints aren't met.
type ListReportsResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ListReportsResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ListReportsResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ListReportsResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ListReportsResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ListReportsResponseValidationError) ErrorName() string <span class="cov0" title="0">{
        return "ListReportsResponseValidationError"
}</span>

// Error satisfies the builtin error interface
func (e ListReportsResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sListReportsResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ListReportsResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ListReportsResponseValidationError{}

// Validate checks the field values on CSVExportTransactionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CSVExportTransactionsResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on CSVExportTransactionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CSVExportTransactionsResponseMultiError, or nil if none found.
func (m *CSVExportTransactionsResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *CSVExportTransactionsResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Data

        // no validation rules for Total

        // no validation rules for HitCache

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return CSVExportTransactionsResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CSVExportTransactionsResponseMultiError is an error wrapping multiple
// validation errors returned by CSVExportTransactionsResponse.ValidateAll()
// if the designated constraints aren't met.
type CSVExportTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CSVExportTransactionsResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m CSVExportTransactionsResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// CSVExportTransactionsResponseValidationError is the validation error
// returned by CSVExportTransactionsResponse.Validate if the designated
// constraints aren't met.
type CSVExportTransactionsResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e CSVExportTransactionsResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e CSVExportTransactionsResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e CSVExportTransactionsResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e CSVExportTransactionsResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e CSVExportTransactionsResponseValidationError) ErrorName() string <span class="cov0" title="0">{
        return "CSVExportTransactionsResponseValidationError"
}</span>

// Error satisfies the builtin error interface
func (e CSVExportTransactionsResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sCSVExportTransactionsResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = CSVExportTransactionsResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = CSVExportTransactionsResponseValidationError{}

// Validate checks the field values on CSVImportTransactionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CSVImportTransactionsRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on CSVImportTransactionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CSVImportTransactionsRequestMultiError, or nil if none found.
func (m *CSVImportTransactionsRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *CSVImportTransactionsRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Data

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return CSVImportTransactionsRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CSVImportTransactionsRequestMultiError is an error wrapping multiple
// validation errors returned by CSVImportTransactionsRequest.ValidateAll() if
// the designated constraints aren't met.
type CSVImportTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CSVImportTransactionsRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m CSVImportTransactionsRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// CSVImportTransactionsRequestValidationError is the validation error returned
// by CSVImportTransactionsRequest.Validate if the designated constraints
// aren't met.
type CSVImportTransactionsRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e CSVImportTransactionsRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e CSVImportTransactionsRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e CSVImportTransactionsRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e CSVImportTransactionsRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e CSVImportTransactionsRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "CSVImportTransactionsRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e CSVImportTransactionsRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sCSVImportTransactionsRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = CSVImportTransactionsRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = CSVImportTransactionsRequestValidationError{}

// Validate checks the field values on CSVImportTransactionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CSVImportTransactionsResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on CSVImportTransactionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CSVImportTransactionsResponseMultiError, or nil if none found.
func (m *CSVImportTransactionsResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *CSVImportTransactionsResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return CSVImportTransactionsResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CSVImportTransactionsResponseMultiError is an error wrapping multiple
// validation errors returned by CSVImportTransactionsResponse.ValidateAll()
// if the designated constraints aren't met.
type CSVImportTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CSVImportTransactionsResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m CSVImportTransactionsResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// CSVImportTransactionsResponseValidationError is the validation error
// returned by CSVImportTransactionsResponse.Validate if the designated
// constraints aren't met.
type CSVImportTransactionsResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e CSVImportTransactionsResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e CSVImportTransactionsResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e CSVImportTransactionsResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e CSVImportTransactionsResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e CSVImportTransactionsResponseValidationError) ErrorName() string <span class="cov0" title="0">{
        return "CSVImportTransactionsResponseValidationError"
}</span>

// Error satisfies the builtin error interface
func (e CSVImportTransactionsResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sCSVImportTransactionsResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = CSVImportTransactionsResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = CSVImportTransactionsResponseValidationError{}
</pre>
		
		<pre class="file" id="file104" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: ledger_service/service.proto

package ledger_servicev1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Ledger_ListCategories_FullMethodName        = "/ledger_service.v1.Ledger/ListCategories"
        Ledger_ListTransactions_FullMethodName      = "/ledger_service.v1.Ledger/ListTransactions"
        Ledger_GetTransaction_FullMethodName        = "/ledger_service.v1.Ledger/GetTransaction"
        Ledger_AddTransaction_FullMethodName        = "/ledger_service.v1.Ledger/AddTransaction"
        Ledger_PatchTransaction_FullMethodName      = "/ledger_service.v1.Ledger/PatchTransaction"
        Ledger_DeleteTransaction_FullMethodName     = "/ledger_service.v1.Ledger/DeleteTransaction"
        Ledger_ListBudgets_FullMethodName           = "/ledger_service.v1.Ledger/ListBudgets"
        Ledger_GetBudget_FullMethodName             = "/ledger_service.v1.Ledger/GetBudget"
        Ledger_AddBudget_FullMethodName             = "/ledger_service.v1.Ledger/AddBudget"
        Ledger_PatchBudget_FullMethodName           = "/ledger_service.v1.Ledger/PatchBudget"
        Ledger_DeleteBudget_FullMethodName          = "/ledger_service.v1.Ledger/DeleteBudget"
        Ledger_ListReports_FullMethodName           = "/ledger_service.v1.Ledger/ListReports"
        Ledger_CSVExportTransactions_FullMethodName = "/ledger_service.v1.Ledger/CSVExportTransactions"
        Ledger_CSVImportTransactions_FullMethodName = "/ledger_service.v1.Ledger/CSVImportTransactions"
)

// LedgerClient is the client API for Ledger service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LedgerClient interface {
        ListCategories(ctx context.Context, in *ListCategoriesRequest, opts ...grpc.CallOption) (*ListCategoriesResponse, error)
        ListTransactions(ctx context.Context, in *ListTransactionsRequest, opts ...grpc.CallOption) (*ListTransactionsResponse, error)
        GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error)
        AddTransaction(ctx context.Context, in *AddTransactionRequest, opts ...grpc.CallOption) (*AddTransactionResponse, error)
        PatchTransaction(ctx context.Context, in *PatchTransactionRequest, opts ...grpc.CallOption) (*PatchTransactionResponse, error)
        DeleteTransaction(ctx context.Context, in *DeleteTransactionRequest, opts ...grpc.CallOption) (*DeleteTransactionResponse, error)
        ListBudgets(ctx context.Context, in *ListBudgetsRequest, opts ...grpc.CallOption) (*ListBudgetsResponse, error)
        GetBudget(ctx context.Context, in *GetBudgetRequest, opts ...grpc.CallOption) (*GetBudgetResponse, error)
        AddBudget(ctx context.Context, in *AddBudgetRequest, opts ...grpc.CallOption) (*AddBudgetResponse, error)
        PatchBudget(ctx context.Context, in *PatchBudgetRequest, opts ...grpc.CallOption) (*PatchBudgetResponse, error)
        DeleteBudget(ctx context.Context, in *DeleteBudgetRequest, opts ...grpc.CallOption) (*DeleteBudgetResponse, error)
        ListReports(ctx context.Context, in *ListReportsRequest, opts ...grpc.CallOption) (*ListReportsResponse, error)
        CSVExportTransactions(ctx context.Context, in *ListTransactionsRequest, opts ...grpc.CallOption) (*CSVExportTransactionsResponse, error)
        CSVImportTransactions(ctx context.Context, in *CSVImportTransactionsRequest, opts ...grpc.CallOption) (*CSVImportTransactionsResponse, error)
}

type ledgerClient struct {
        cc grpc.ClientConnInterface
}

func NewLedgerClient(cc grpc.ClientConnInterface) LedgerClient <span class="cov0" title="0">{
        return &amp;ledgerClient{cc}
}</span>

func (c *ledgerClient) ListCategories(ctx context.Context, in *ListCategoriesRequest, opts ...grpc.CallOption) (*ListCategoriesResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ListCategoriesResponse)
        err := c.cc.Invoke(ctx, Ledger_ListCategories_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ledgerClient) ListTransactions(ctx context.Context, in *ListTransactionsRequest, opts ...grpc.CallOption) (*ListTransactionsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ListTransactionsResponse)
        err := c.cc.Invoke(ctx, Ledger_ListTransactions_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ledgerClient) GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetTransactionResponse)
        err := c.cc.Invoke(ctx, Ledger_GetTransaction_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ledgerClient) AddTransaction(ctx context.Context, in *AddTransactionRequest, opts ...grpc.CallOption) (*AddTransactionResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(AddTransactionResponse)
        err := c.cc.Invoke(ctx, Ledger_AddTransaction_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ledgerClient) PatchTransaction(ctx context.Context, in *PatchTransactionRequest, opts ...grpc.CallOption) (*PatchTransactionResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(PatchTransactionResponse)
        err := c.cc.Invoke(ctx, Ledger_PatchTransaction_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ledgerClient) DeleteTransaction(ctx context.Context, in *DeleteTransactionRequest, opts ...grpc.CallOption) (*DeleteTransactionResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(DeleteTransactionResponse)
        err := c.cc.Invoke(ctx, Ledger_DeleteTransaction_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ledgerClient) ListBudgets(ctx context.Context, in *ListBudgetsRequest, opts ...grpc.CallOption) (*ListBudgetsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ListBudgetsResponse)
        err := c.cc.Invoke(ctx, Ledger_ListBudgets_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ledgerClient) GetBudget(ctx context.Context, in *GetBudgetRequest, opts ...grpc.CallOption) (*GetBudgetResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetBudgetResponse)
        err := c.cc.Invoke(ctx, Ledger_GetBudget_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ledgerClient) AddBudget(ctx context.Context, in *AddBudgetRequest, opts ...grpc.CallOption) (*AddBudgetResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(AddBudgetResponse)
        err := c.cc.Invoke(ctx, Ledger_AddBudget_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ledgerClient) PatchBudget(ctx context.Context, in *PatchBudgetRequest, opts ...grpc.CallOption) (*PatchBudgetResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(PatchBudgetResponse)
        err := c.cc.Invoke(ctx, Ledger_PatchBudget_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ledgerClient) DeleteBudget(ctx context.Context, in *DeleteBudgetRequest, opts ...grpc.CallOption) (*DeleteBudgetResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(DeleteBudgetResponse)
        err := c.cc.Invoke(ctx, Ledger_DeleteBudget_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ledgerClient) ListReports(ctx context.Context, in *ListReportsRequest, opts ...grpc.CallOption) (*ListReportsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ListReportsResponse)
        err := c.cc.Invoke(ctx, Ledger_ListReports_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ledgerClient) CSVExportTransactions(ctx context.Context, in *ListTransactionsRequest, opts ...grpc.CallOption) (*CSVExportTransactionsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CSVExportTransactionsResponse)
        err := c.cc.Invoke(ctx, Ledger_CSVExportTransactions_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ledgerClient) CSVImportTransactions(ctx context.Context, in *CSVImportTransactionsRequest, opts ...grpc.CallOption) (*CSVImportTransactionsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CSVImportTransactionsResponse)
        err := c.cc.Invoke(ctx, Ledger_CSVImportTransactions_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// LedgerServer is the server API for Ledger service.
// All implementations must embed UnimplementedLedgerServer
// for forward compatibility.
type LedgerServer interface {
        ListCategories(context.Context, *ListCategoriesRequest) (*ListCategoriesResponse, error)
        ListTransactions(context.Context, *ListTransactionsRequest) (*ListTransactionsResponse, error)
        GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionResponse, error)
        AddTransaction(context.Context, *AddTransactionRequest) (*AddTransactionResponse, error)
        PatchTransaction(context.Context, *PatchTransactionRequest) (*PatchTransactionResponse, error)
        DeleteTransaction(context.Context, *DeleteTransactionRequest) (*DeleteTransactionResponse, error)
        ListBudgets(context.Context, *ListBudgetsRequest) (*ListBudgetsResponse, error)
        GetBudget(context.Context, *GetBudgetRequest) (*GetBudgetResponse, error)
        AddBudget(context.Context, *AddBudgetRequest) (*AddBudgetResponse, error)
        PatchBudget(context.Context, *PatchBudgetRequest) (*PatchBudgetResponse, error)
        DeleteBudget(context.Context, *DeleteBudgetRequest) (*DeleteBudgetResponse, error)
        ListReports(context.Context, *ListReportsRequest) (*ListReportsResponse, error)
        CSVExportTransactions(context.Context, *ListTransactionsRequest) (*CSVExportTransactionsResponse, error)
        CSVImportTransactions(context.Context, *CSVImportTransactionsRequest) (*CSVImportTransactionsResponse, error)
        mustEmbedUnimplementedLedgerServer()
}

// UnimplementedLedgerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLedgerServer struct{}

func (UnimplementedLedgerServer) ListCategories(context.Context, *ListCategoriesRequest) (*ListCategoriesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListCategories not implemented")
}</span>
func (UnimplementedLedgerServer) ListTransactions(context.Context, *ListTransactionsRequest) (*ListTransactionsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListTransactions not implemented")
}</span>
func (UnimplementedLedgerServer) GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetTransaction not implemented")
}</span>
func (UnimplementedLedgerServer) AddTransaction(context.Context, *AddTransactionRequest) (*AddTransactionResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AddTransaction not implemented")
}</span>
func (UnimplementedLedgerServer) PatchTransaction(context.Context, *PatchTransactionRequest) (*PatchTransactionResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method PatchTransaction not implemented")
}</span>
func (UnimplementedLedgerServer) DeleteTransaction(context.Context, *DeleteTransactionRequest) (*DeleteTransactionResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteTransaction not implemented")
}</span>
func (UnimplementedLedgerServer) ListBudgets(context.Context, *ListBudgetsRequest) (*ListBudgetsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListBudgets not implemented")
}</span>
func (UnimplementedLedgerServer) GetBudget(context.Context, *GetBudgetRequest) (*GetBudgetResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetBudget not implemented")
}</span>
func (UnimplementedLedgerServer) AddBudget(context.Context, *AddBudgetRequest) (*AddBudgetResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AddBudget not implemented")
}</span>
func (UnimplementedLedgerServer) PatchBudget(context.Context, *PatchBudgetRequest) (*PatchBudgetResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method PatchBudget not implemented")
}</span>
func (UnimplementedLedgerServer) DeleteBudget(context.Context, *DeleteBudgetRequest) (*DeleteBudgetResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteBudget not implemented")
}</span>
func (UnimplementedLedgerServer) ListReports(context.Context, *ListReportsRequest) (*ListReportsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListReports not implemented")
}</span>
func (UnimplementedLedgerServer) CSVExportTransactions(context.Context, *ListTransactionsRequest) (*CSVExportTransactionsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CSVExportTransactions not implemented")
}</span>
func (UnimplementedLedgerServer) CSVImportTransactions(context.Context, *CSVImportTransactionsRequest) (*CSVImportTransactionsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CSVImportTransactions not implemented")
}</span>
func (UnimplementedLedgerServer) mustEmbedUnimplementedLedgerServer() {<span class="cov0" title="0">}</span>
func (UnimplementedLedgerServer) testEmbeddedByValue()                {<span class="cov0" title="0">}</span>

// UnsafeLedgerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LedgerServer will
// result in compilation errors.
type UnsafeLedgerServer interface {
        mustEmbedUnimplementedLedgerServer()
}

func RegisterLedgerServer(s grpc.ServiceRegistrar, srv LedgerServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedLedgerServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Ledger_ServiceDesc, srv)</span>
}

func _Ledger_ListCategories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListCategoriesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServer).ListCategories(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Ledger_ListCategories_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServer).ListCategories(ctx, req.(*ListCategoriesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Ledger_ListTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListTransactionsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServer).ListTransactions(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Ledger_ListTransactions_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServer).ListTransactions(ctx, req.(*ListTransactionsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Ledger_GetTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetTransactionRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServer).GetTransaction(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Ledger_GetTransaction_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServer).GetTransaction(ctx, req.(*GetTransactionRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Ledger_AddTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AddTransactionRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServer).AddTransaction(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Ledger_AddTransaction_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServer).AddTransaction(ctx, req.(*AddTransactionRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Ledger_PatchTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(PatchTransactionRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServer).PatchTransaction(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Ledger_PatchTransaction_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServer).PatchTransaction(ctx, req.(*PatchTransactionRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Ledger_DeleteTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteTransactionRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServer).DeleteTransaction(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Ledger_DeleteTransaction_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServer).DeleteTransaction(ctx, req.(*DeleteTransactionRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Ledger_ListBudgets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListBudgetsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServer).ListBudgets(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Ledger_ListBudgets_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServer).ListBudgets(ctx, req.(*ListBudgetsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Ledger_GetBudget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetBudgetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServer).GetBudget(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Ledger_GetBudget_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServer).GetBudget(ctx, req.(*GetBudgetRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Ledger_AddBudget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AddBudgetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServer).AddBudget(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Ledger_AddBudget_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServer).AddBudget(ctx, req.(*AddBudgetRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Ledger_PatchBudget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(PatchBudgetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServer).PatchBudget(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Ledger_PatchBudget_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServer).PatchBudget(ctx, req.(*PatchBudgetRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Ledger_DeleteBudget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteBudgetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServer).DeleteBudget(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Ledger_DeleteBudget_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServer).DeleteBudget(ctx, req.(*DeleteBudgetRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Ledger_ListReports_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListReportsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServer).ListReports(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Ledger_ListReports_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServer).ListReports(ctx, req.(*ListReportsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Ledger_CSVExportTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListTransactionsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServer).CSVExportTransactions(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Ledger_CSVExportTransactions_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServer).CSVExportTransactions(ctx, req.(*ListTransactionsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Ledger_CSVImportTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CSVImportTransactionsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LedgerServer).CSVImportTransactions(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Ledger_CSVImportTransactions_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LedgerServer).CSVImportTransactions(ctx, req.(*CSVImportTransactionsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Ledger_ServiceDesc is the grpc.ServiceDesc for Ledger service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Ledger_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "ledger_service.v1.Ledger",
        HandlerType: (*LedgerServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "ListCategories",
                        Handler:    _Ledger_ListCategories_Handler,
                },
                {
                        MethodName: "ListTransactions",
                        Handler:    _Ledger_ListTransactions_Handler,
                },
                {
                        MethodName: "GetTransaction",
                        Handler:    _Ledger_GetTransaction_Handler,
                },
                {
                        MethodName: "AddTransaction",
                        Handler:    _Ledger_AddTransaction_Handler,
                },
                {
                        MethodName: "PatchTransaction",
                        Handler:    _Ledger_PatchTransaction_Handler,
                },
                {
                        MethodName: "DeleteTransaction",
                        Handler:    _Ledger_DeleteTransaction_Handler,
                },
                {
                        MethodName: "ListBudgets",
                        Handler:    _Ledger_ListBudgets_Handler,
                },
                {
                        MethodName: "GetBudget",
                        Handler:    _Ledger_GetBudget_Handler,
                },
                {
                        MethodName: "AddBudget",
                        Handler:    _Ledger_AddBudget_Handler,
                },
                {
                        MethodName: "PatchBudget",
                        Handler:    _Ledger_PatchBudget_Handler,
                },
                {
                        MethodName: "DeleteBudget",
                        Handler:    _Ledger_DeleteBudget_Handler,
                },
                {
                        MethodName: "ListReports",
                        Handler:    _Ledger_ListReports_Handler,
                },
                {
                        MethodName: "CSVExportTransactions",
                        Handler:    _Ledger_CSVExportTransactions_Handler,
                },
                {
                        MethodName: "CSVImportTransactions",
                        Handler:    _Ledger_CSVImportTransactions_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "ledger_service/service.proto",
}
</pre>
		
		<pre class="file" id="file105" style="display: none">package validation

import (
        "reflect"
        "regexp"
        "strings"

        "github.com/go-playground/validator/v10"
)

func FormatErrors(err error, subjects ...any) []string <span class="cov0" title="0">{
        hints := make([]string, 0)

        ve, ok := err.(validator.ValidationErrors)
        if !ok </span><span class="cov0" title="0">{
                return hints
        }</span>

        <span class="cov0" title="0">var root reflect.Value
        if len(subjects) &gt; 0 &amp;&amp; subjects[0] != nil </span><span class="cov0" title="0">{
                root = reflect.ValueOf(subjects[0])
                for root.Kind() == reflect.Ptr &amp;&amp; !root.IsNil() </span><span class="cov0" title="0">{
                        root = root.Elem()
                }</span>
        }

        <span class="cov0" title="0">for _, fe := range ve </span><span class="cov0" title="0">{
                if root.IsValid() </span><span class="cov0" title="0">{
                        if msg, ok := lookupErrMsgTag(root, fe); ok &amp;&amp; msg != "" </span><span class="cov0" title="0">{
                                hints = append(hints, msg)
                                continue</span>
                        }
                }
                <span class="cov0" title="0">hints = append(hints, fe.Error())</span>
        }

        <span class="cov0" title="0">return hints</span>
}

func lookupErrMsgTag(root reflect.Value, fe validator.FieldError) (string, bool) <span class="cov0" title="0">{
        if !root.IsValid() || root.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">path := fe.StructNamespace()
        if path == "" </span><span class="cov0" title="0">{
                path = fe.StructField()
        }</span>
        <span class="cov0" title="0">segments := strings.Split(path, ".")
        if len(segments) &gt; 1 &amp;&amp; segments[0] == root.Type().Name() </span><span class="cov0" title="0">{
                segments = segments[1:]
        }</span>

        <span class="cov0" title="0">indexRe := regexp.MustCompile(`\[[0-9]+\]`)
        rt := root.Type()
        current := root
        var sf reflect.StructField
        found := false

        for _, seg := range segments </span><span class="cov0" title="0">{
                seg = indexRe.ReplaceAllString(seg, "")
                f, ok := findField(rt, seg)
                if !ok </span><span class="cov0" title="0">{
                        return "", false
                }</span>
                <span class="cov0" title="0">sf = f
                found = true

                if current.IsValid() &amp;&amp; current.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                        fieldVal := current.FieldByIndex(sf.Index)
                        for fieldVal.Kind() == reflect.Ptr &amp;&amp; !fieldVal.IsNil() </span><span class="cov0" title="0">{
                                fieldVal = fieldVal.Elem()
                        }</span>
                        <span class="cov0" title="0">current = fieldVal
                        rt = current.Type()</span>
                }
        }

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov0" title="0">if v, ok := sf.Tag.Lookup("errmsg"); ok </span><span class="cov0" title="0">{
                return v, true
        }</span>
        <span class="cov0" title="0">return "", false</span>
}

func findField(t reflect.Type, name string) (reflect.StructField, bool) <span class="cov0" title="0">{
        if f, ok := t.FieldByName(name); ok </span><span class="cov0" title="0">{
                return f, true
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; t.NumField(); i++ </span><span class="cov0" title="0">{
                f := t.Field(i)
                if f.Anonymous </span><span class="cov0" title="0">{
                        ft := f.Type
                        for ft.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                                ft = ft.Elem()
                        }</span>
                        <span class="cov0" title="0">if ft.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                                if ff, ok := findField(ft, name); ok </span><span class="cov0" title="0">{
                                        return combineIndex(f, ff), true
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return reflect.StructField{}, false</span>
}

func combineIndex(parent reflect.StructField, child reflect.StructField) reflect.StructField <span class="cov0" title="0">{
        idx := make([]int, 0, len(parent.Index)+len(child.Index))
        idx = append(idx, parent.Index...)
        idx = append(idx, child.Index...)
        child.Index = idx
        return child
}</span>
</pre>
		
		<pre class="file" id="file106" style="display: none">package validation

import (
        "github.com/go-playground/validator/v10"
)

func New() *validator.Validate <span class="cov0" title="0">{
        validate := validator.New()
        return validate
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
