
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>budget: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/budget/commands.go (61.4%)</option>
				
				<option value="file1">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/budget/helpers.go (67.6%)</option>
				
				<option value="file2">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/budget/impl.go (100.0%)</option>
				
				<option value="file3">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/budget/queries.go (77.0%)</option>
				
				<option value="file4">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/category/helpers.go (100.0%)</option>
				
				<option value="file5">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/category/impl.go (100.0%)</option>
				
				<option value="file6">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/category/queries.go (83.3%)</option>
				
				<option value="file7">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/transaction/commands.go (43.6%)</option>
				
				<option value="file8">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/transaction/helpers.go (74.1%)</option>
				
				<option value="file9">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/transaction/impl.go (100.0%)</option>
				
				<option value="file10">github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase/transaction/queries.go (34.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package budget

import (
        "context"
        "errors"
        "log/slog"
        "time"

        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/loghandler"
        "github.com/m11ano/budget_planner/backend/ledger/pkg/pgclient"
        "github.com/samber/lo"
)

func (uc *UsecaseImpl) CreateBudgetByDTO(
        ctx context.Context,
        in usecase.CreateBudgetDataInput,
) (*usecase.BudgetDTO, error) <span class="cov8" title="1">{
        const op = "CreateBudgetByDTO"

        if auth.IsNeedToCheckRights(ctx) </span><span class="cov0" title="0">{
                authData := auth.GetAuthData(ctx)
                if authData == nil || authData.AccountID != in.AccountID </span><span class="cov0" title="0">{
                        return nil, appErrors.ErrForbidden
                }</span>
        }

        <span class="cov8" title="1">budget, err := entity.NewBudget(
                in.AccountID,
                in.Amount,
                in.Period,
                in.CategoryID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="1">err = uc.dbMasterClient.DoWithIsoLvl(ctx, pgclient.Serializable, func(ctx context.Context) error </span><span class="cov8" title="1">{
                _, err := uc.categoryRepo.FindOneByID(ctx, budget.CategoryID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, appErrors.ErrNotFound) </span><span class="cov0" title="0">{
                                return appErrors.Chainf(appErrors.ErrBadRequest.WithHints("category not found"), "%s.%s", uc.pkg, op)
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov8" title="1">check, err := uc.budgetRepo.FindList(ctx, &amp;usecase.BudgetListOptions{
                        FilterAccountID:  &amp;budget.AccountID,
                        FilterPeriod:     &amp;budget.Period,
                        FilterCategoryID: &amp;budget.CategoryID,
                }, &amp;uctypes.QueryGetListParams{
                        Limit: 1,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if len(check) &gt; 0 </span><span class="cov0" title="0">{
                        return appErrors.Chainf(
                                appErrors.ErrBadRequest.WithHints("budget for period and category already exists"),
                                "%s.%s", uc.pkg, op)
                }</span>

                <span class="cov8" title="1">err = uc.budgetRepo.Create(ctx, budget)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="1">budgetDTO, err := uc.entitiesToDTO(ctx, []*entity.Budget{budget})
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="1">if len(budgetDTO) == 0 </span><span class="cov0" title="0">{
                uc.logger.ErrorContext(loghandler.WithSource(ctx), "unpredicted empty budget dto")
                return nil, appErrors.Chainf(appErrors.ErrInternal, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="1">base := context.WithoutCancel(ctx)
        clrCtx, cancel := context.WithTimeout(base, time.Second*10)
        go func(ctx context.Context) </span><span class="cov8" title="1">{
                defer cancel()
                err := uc.budgetCacheRepo.ClearForPrefixes(ctx, "Budget::FindList::AccountID:"+budget.AccountID.String())
                if err != nil </span><span class="cov0" title="0">{
                        uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis clear err", slog.Any("error", err))
                }</span>
        }(clrCtx)

        <span class="cov8" title="1">return budgetDTO[0], nil</span>
}

func (uc *UsecaseImpl) PatchBudgetByDTO(
        ctx context.Context,
        id uuid.UUID,
        in usecase.PatchBudgetDataInput,
        skipVersionCheck bool,
) error <span class="cov8" title="1">{
        const op = "PatchBudgetByDTO"

        var accountID uuid.UUID

        err := uc.dbMasterClient.DoWithIsoLvl(ctx, pgclient.Serializable, func(ctx context.Context) error </span><span class="cov8" title="1">{
                budget, err := uc.budgetRepo.FindOneByID(ctx, id, &amp;uctypes.QueryGetOneParams{
                        ForUpdate: true,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">accountID = budget.AccountID

                if auth.IsNeedToCheckRights(ctx) </span><span class="cov0" title="0">{
                        authData := auth.GetAuthData(ctx)
                        if authData == nil || authData.AccountID != budget.AccountID </span><span class="cov0" title="0">{
                                return appErrors.ErrForbidden
                        }</span>
                }

                <span class="cov8" title="1">if !skipVersionCheck &amp;&amp; budget.Version() != in.Version </span><span class="cov0" title="0">{
                        return appErrors.ErrVersionConflict.
                                WithDetail("last_version", false, budget.Version()).
                                WithDetail("last_updated_at", false, budget.UpdatedAt)
                }</span>

                <span class="cov8" title="1">if in.Amount != nil </span><span class="cov8" title="1">{
                        err = budget.SetAmount(*in.Amount)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">checkFilter := &amp;usecase.BudgetListOptions{
                        FilterAccountID:  &amp;budget.AccountID,
                        FilterPeriod:     &amp;budget.Period,
                        FilterCategoryID: &amp;budget.CategoryID,
                }
                needCheck := false

                if in.CategoryID != nil &amp;&amp; *in.CategoryID != budget.CategoryID </span><span class="cov0" title="0">{
                        budget.CategoryID = *in.CategoryID

                        needCheck = true
                        checkFilter.FilterCategoryID = &amp;budget.CategoryID
                }</span>

                <span class="cov8" title="1">if in.Period != nil &amp;&amp;
                        (in.Period.Day != budget.Period.Day ||
                                in.Period.Month != budget.Period.Month ||
                                in.Period.Year != budget.Period.Year) </span><span class="cov0" title="0">{

                        err := budget.SetPeriod(*in.Period)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">needCheck = true
                        checkFilter.FilterPeriod = &amp;budget.Period</span>
                }

                <span class="cov8" title="1">if needCheck </span><span class="cov0" title="0">{
                        check, err := uc.budgetRepo.FindList(ctx, checkFilter, &amp;uctypes.QueryGetListParams{
                                Limit: 1,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if len(check) &gt; 0 </span><span class="cov0" title="0">{
                                return appErrors.Chainf(
                                        appErrors.ErrBadRequest.WithHints("budget for period and category already exists"),
                                        "%s.%s", uc.pkg, op)
                        }</span>
                }

                <span class="cov8" title="1">err = uc.budgetRepo.Update(ctx, budget)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="1">base := context.WithoutCancel(ctx)
        clrCtx, cancel := context.WithTimeout(base, time.Second*10)
        go func(ctx context.Context) </span><span class="cov8" title="1">{
                defer cancel()
                err := uc.budgetCacheRepo.ClearForPrefixes(
                        ctx,
                        buildKeyForFindOneByID(id),
                        "Budget::FindList::AccountID:"+accountID.String(),
                )
                if err != nil </span><span class="cov0" title="0">{
                        uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis clear err", slog.Any("error", err))
                }</span>
        }(clrCtx)

        <span class="cov8" title="1">return nil</span>
}

func (uc *UsecaseImpl) DeleteBudgetByID(ctx context.Context, id uuid.UUID) error <span class="cov8" title="1">{
        const op = "DeleteBudgetByID"

        var accountID uuid.UUID

        err := uc.dbMasterClient.Do(ctx, func(ctx context.Context) error </span><span class="cov8" title="1">{
                budget, err := uc.budgetRepo.FindOneByID(ctx, id, &amp;uctypes.QueryGetOneParams{
                        ForUpdate: true,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">accountID = budget.AccountID

                if auth.IsNeedToCheckRights(ctx) </span><span class="cov0" title="0">{
                        authData := auth.GetAuthData(ctx)
                        if authData == nil || authData.AccountID != budget.AccountID </span><span class="cov0" title="0">{
                                return appErrors.ErrForbidden
                        }</span>
                }

                <span class="cov8" title="1">budget.DeletedAt = lo.ToPtr(time.Now())

                err = uc.budgetRepo.Update(ctx, budget)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="1">base := context.WithoutCancel(ctx)
        clrCtx, cancel := context.WithTimeout(base, time.Second*10)
        go func(ctx context.Context) </span><span class="cov8" title="1">{
                defer cancel()
                err := uc.budgetCacheRepo.ClearForPrefixes(ctx, "Budget::FindList::AccountID:"+accountID.String())
                if err != nil </span><span class="cov0" title="0">{
                        uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis clear err", slog.Any("error", err))
                }</span>
        }(clrCtx)

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package budget

import (
        "context"
        "fmt"
        "strings"

        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
)

func (uc *UsecaseImpl) entitiesToDTO(
        _ context.Context,
        items []*entity.Budget,
) ([]*usecase.BudgetDTO, error) <span class="cov9" title="10">{
        out := make([]*usecase.BudgetDTO, 0, len(items))

        for _, item := range items </span><span class="cov10" title="13">{
                resItem := &amp;usecase.BudgetDTO{
                        Budget: item,
                }

                out = append(out, resItem)
        }</span>

        <span class="cov9" title="10">return out, nil</span>
}

func buildKeyForFindOneByID(id uuid.UUID) string <span class="cov8" title="9">{
        return fmt.Sprintf("Budget::FindOneByID::%s", id.String())
}</span>

func buildKeyForFindList(
        listOptions *usecase.BudgetListOptions,
        queryParams *uctypes.QueryGetListParams,
) string <span class="cov9" title="12">{
        var strBuilder strings.Builder

        strBuilder.WriteString("Budget::FindList")

        if listOptions.FilterAccountID != nil </span><span class="cov9" title="12">{
                strBuilder.WriteString("::AccountID:")
                strBuilder.WriteString(listOptions.FilterAccountID.String())
        }</span>

        <span class="cov9" title="12">if listOptions.FilterPeriod != nil </span><span class="cov0" title="0">{
                strBuilder.WriteString("::Period:")
                strBuilder.WriteString(listOptions.FilterPeriod.String())
        }</span>

        <span class="cov9" title="12">if listOptions.FilterPeriodFrom != nil </span><span class="cov0" title="0">{
                strBuilder.WriteString("::PeriodFrom:")
                strBuilder.WriteString(listOptions.FilterPeriodFrom.String())
        }</span>

        <span class="cov9" title="12">if listOptions.FilterPeriodTo != nil </span><span class="cov0" title="0">{
                strBuilder.WriteString("::PeriodTo:")
                strBuilder.WriteString(listOptions.FilterPeriodTo.String())
        }</span>

        <span class="cov9" title="12">if listOptions.FilterCategoryID != nil </span><span class="cov0" title="0">{
                strBuilder.WriteString("::CategoryID:")
                strBuilder.WriteString(fmt.Sprintf("%d", *listOptions.FilterCategoryID))
        }</span>

        <span class="cov9" title="12">if listOptions.Sort != nil </span><span class="cov0" title="0">{
                strBuilder.WriteString("::Sort:")
                for _, sort := range listOptions.Sort </span><span class="cov0" title="0">{
                        strBuilder.WriteString(fmt.Sprintf("%s:%t", sort.Field, sort.IsDesc))
                }</span>
        }

        <span class="cov9" title="12">if queryParams != nil </span><span class="cov9" title="12">{
                strBuilder.WriteString("::Offset:")
                strBuilder.WriteString(fmt.Sprintf("%d", queryParams.Offset))
                strBuilder.WriteString("::Limit:")
                strBuilder.WriteString(fmt.Sprintf("%d", queryParams.Limit))
        }</span>

        <span class="cov9" title="12">return strBuilder.String()</span>
}

func buildKeyForFindPagedList(
        listOptions *usecase.BudgetListOptions,
        queryParams *uctypes.QueryGetListParams,
) string <span class="cov7" title="6">{
        return fmt.Sprintf("%s::Paged", buildKeyForFindList(listOptions, queryParams))
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package budget

import (
        "log/slog"

        "github.com/m11ano/budget_planner/backend/ledger/internal/app/config"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/db"
        "golang.org/x/sync/singleflight"
)

type UsecaseImpl struct {
        pkg             string
        logger          *slog.Logger
        cfg             config.Config
        dbMasterClient  db.MasterClient
        sfGroup         singleflight.Group
        budgetRepo      usecase.BudgetRepository
        budgetCacheRepo usecase.BudgetCacheRepository
        categoryRepo    usecase.CategoryRepository
}

func NewUsecaseImpl(
        logger *slog.Logger,
        cfg config.Config,
        dbMasterClient db.MasterClient,
        budgetRepo usecase.BudgetRepository,
        budgetCacheRepo usecase.BudgetCacheRepository,
        categoryRepo usecase.CategoryRepository,
) *UsecaseImpl <span class="cov10" title="13">{
        uc := &amp;UsecaseImpl{
                pkg:             "Budget.Usecase.Budget",
                logger:          logger,
                cfg:             cfg,
                dbMasterClient:  dbMasterClient,
                budgetRepo:      budgetRepo,
                budgetCacheRepo: budgetCacheRepo,
                categoryRepo:    categoryRepo,
        }
        return uc
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package budget

import (
        "context"
        "errors"
        "log/slog"
        "time"

        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/loghandler"

        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
)

type FindOneByIDSFResult struct {
        Item     *entity.Budget
        HitCache bool
}

var budgetCacheTTL = time.Second * 30

func (uc *UsecaseImpl) FindOneByID(
        ctx context.Context,
        id uuid.UUID,
        queryParams *uctypes.QueryGetOneParams,
) (*usecase.BudgetDTO, bool, error) <span class="cov10" title="4">{
        const op = "FindOneByID"

        key := buildKeyForFindOneByID(id)

        result, err, _ := uc.sfGroup.Do(key, func() (any, error) </span><span class="cov10" title="4">{
                if queryParams == nil || !queryParams.SkipCache </span><span class="cov5" title="2">{
                        cacheItem, err := uc.budgetCacheRepo.GetBudget(ctx, key)
                        if err == nil </span><span class="cov1" title="1">{
                                uc.logger.InfoContext(ctx, "Budget::FindOneByID cache hit", slog.Any("key", key))

                                return FindOneByIDSFResult{
                                        Item:     cacheItem,
                                        HitCache: true,
                                }, nil
                        }</span> else<span class="cov1" title="1"> if !errors.Is(err, appErrors.ErrNotFound) </span><span class="cov0" title="0">{
                                uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis get err", slog.Any("error", err))
                        }</span>

                        <span class="cov1" title="1">uc.logger.InfoContext(ctx, "Budget::FindOneByID cache miss", slog.Any("key", key))</span>
                }

                <span class="cov8" title="3">item, err := uc.budgetRepo.FindOneByID(ctx, id, queryParams)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
                }</span>

                <span class="cov5" title="2">err = uc.budgetCacheRepo.SaveBudget(ctx, key, item, &amp;budgetCacheTTL)
                if err != nil </span><span class="cov0" title="0">{
                        uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis save err", slog.Any("error", err))
                }</span>

                <span class="cov5" title="2">return FindOneByIDSFResult{
                        Item:     item,
                        HitCache: false,
                }, nil</span>
        })
        <span class="cov10" title="4">if err != nil </span><span class="cov1" title="1">{
                return nil, false, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="3">sfResult, ok := result.(FindOneByIDSFResult)
        if !ok </span><span class="cov0" title="0">{
                return nil, false, appErrors.Chainf(appErrors.ErrInternal, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="3">if auth.IsNeedToCheckRights(ctx) </span><span class="cov0" title="0">{
                authData := auth.GetAuthData(ctx)
                if authData == nil || authData.AccountID != sfResult.Item.AccountID </span><span class="cov0" title="0">{
                        return nil, sfResult.HitCache, appErrors.ErrForbidden
                }</span>
        }

        <span class="cov8" title="3">dto, err := uc.entitiesToDTO(ctx, []*entity.Budget{sfResult.Item})
        if err != nil </span><span class="cov0" title="0">{
                return nil, sfResult.HitCache, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="3">if len(dto) == 0 </span><span class="cov0" title="0">{
                return nil, sfResult.HitCache, appErrors.Chainf(appErrors.ErrInternal, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="3">return dto[0], sfResult.HitCache, nil</span>
}

type FindListSFResult struct {
        Items    []*entity.Budget
        HitCache bool
}

func (uc *UsecaseImpl) FindList(
        ctx context.Context,
        listOptions *usecase.BudgetListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]*usecase.BudgetDTO, bool, error) <span class="cov8" title="3">{
        const op = "FindList"

        key := buildKeyForFindList(listOptions, queryParams)

        result, err, _ := uc.sfGroup.Do(key, func() (any, error) </span><span class="cov8" title="3">{
                if queryParams == nil || !queryParams.SkipCache </span><span class="cov5" title="2">{
                        cacheItems, err := uc.budgetCacheRepo.GetBudgetsList(ctx, key)
                        if err == nil </span><span class="cov1" title="1">{
                                uc.logger.InfoContext(ctx, "Budget::GetBudgetsList cache hit", slog.Any("key", key))

                                return FindListSFResult{
                                        Items:    cacheItems,
                                        HitCache: true,
                                }, nil
                        }</span> else<span class="cov1" title="1"> if !errors.Is(err, appErrors.ErrNotFound) </span><span class="cov0" title="0">{
                                uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis get err", slog.Any("error", err))
                        }</span>

                        <span class="cov1" title="1">uc.logger.InfoContext(ctx, "Budget::GetBudgetsList cache miss", slog.Any("key", key))</span>
                }

                <span class="cov5" title="2">items, err := uc.budgetRepo.FindList(ctx, listOptions, queryParams)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
                }</span>

                <span class="cov5" title="2">err = uc.budgetCacheRepo.SaveBudgetsList(ctx, key, items, &amp;budgetCacheTTL)
                if err != nil </span><span class="cov0" title="0">{
                        uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis save err", slog.Any("error", err))
                }</span>

                <span class="cov5" title="2">return FindListSFResult{
                        Items:    items,
                        HitCache: false,
                }, nil</span>
        })
        <span class="cov8" title="3">if err != nil </span><span class="cov0" title="0">{
                return nil, false, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="3">sfResult, ok := result.(FindListSFResult)
        if !ok </span><span class="cov0" title="0">{
                return nil, false, appErrors.Chainf(appErrors.ErrInternal, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="3">out, err := uc.entitiesToDTO(ctx, sfResult.Items)
        if err != nil </span><span class="cov0" title="0">{
                return nil, sfResult.HitCache, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="3">return out, sfResult.HitCache, nil</span>
}

type FindPagedListSFResult struct {
        Items    []*entity.Budget
        Total    uint64
        HitCache bool
}

func (uc *UsecaseImpl) FindPagedList(
        ctx context.Context,
        listOptions *usecase.BudgetListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]*usecase.BudgetDTO, uint64, bool, error) <span class="cov8" title="3">{
        const op = "FindPagedList"

        key := buildKeyForFindPagedList(listOptions, queryParams)

        result, err, _ := uc.sfGroup.Do(key, func() (any, error) </span><span class="cov8" title="3">{
                if queryParams == nil || !queryParams.SkipCache </span><span class="cov5" title="2">{
                        cacheItems, total, err := uc.budgetCacheRepo.GetBudgetsPagedList(ctx, key)
                        if err == nil </span><span class="cov1" title="1">{
                                uc.logger.InfoContext(ctx, "Budget::GetBudgetsPagedList cache hit", slog.Any("key", key))

                                return FindPagedListSFResult{
                                        Items:    cacheItems,
                                        Total:    total,
                                        HitCache: true,
                                }, nil
                        }</span> else<span class="cov1" title="1"> if !errors.Is(err, appErrors.ErrNotFound) </span><span class="cov0" title="0">{
                                uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis get err", slog.Any("error", err))
                        }</span>

                        <span class="cov1" title="1">uc.logger.InfoContext(ctx, "Budget::GetBudgetsPagedList cache miss", slog.Any("key", key))</span>
                }

                <span class="cov5" title="2">items, total, err := uc.budgetRepo.FindPagedList(ctx, listOptions, queryParams)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
                }</span>

                <span class="cov5" title="2">err = uc.budgetCacheRepo.SaveBudgetsPagedList(ctx, key, items, total, &amp;budgetCacheTTL)
                if err != nil </span><span class="cov0" title="0">{
                        uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis save err", slog.Any("error", err))
                }</span>

                <span class="cov5" title="2">return FindPagedListSFResult{
                        Items:    items,
                        Total:    total,
                        HitCache: false,
                }, nil</span>
        })
        <span class="cov8" title="3">if err != nil </span><span class="cov0" title="0">{
                return nil, 0, false, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="3">sfResult, ok := result.(FindPagedListSFResult)
        if !ok </span><span class="cov0" title="0">{
                return nil, 0, false, appErrors.Chainf(appErrors.ErrInternal, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="3">out, err := uc.entitiesToDTO(ctx, sfResult.Items)
        if err != nil </span><span class="cov0" title="0">{
                return nil, sfResult.Total, sfResult.HitCache, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov8" title="3">return out, sfResult.Total, sfResult.HitCache, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package category

import (
        "context"

        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
)

func (uc *UsecaseImpl) entitiesToDTO(
        _ context.Context,
        items []*entity.Category,
) ([]*usecase.CategoryDTO, error) <span class="cov10" title="3">{
        out := make([]*usecase.CategoryDTO, 0, len(items))

        for _, item := range items </span><span class="cov10" title="3">{
                resItem := &amp;usecase.CategoryDTO{
                        Category: item,
                }

                out = append(out, resItem)
        }</span>

        <span class="cov10" title="3">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package category

import (
        "log/slog"

        "github.com/m11ano/budget_planner/backend/ledger/internal/app/config"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/db"
)

type UsecaseImpl struct {
        pkg            string
        logger         *slog.Logger
        cfg            config.Config
        dbMasterClient db.MasterClient
        categoryRepo   usecase.CategoryRepository
}

func NewUsecaseImpl(
        logger *slog.Logger,
        cfg config.Config,
        dbMasterClient db.MasterClient,
        categoryRepo usecase.CategoryRepository,
) *UsecaseImpl <span class="cov10" title="5">{
        uc := &amp;UsecaseImpl{
                pkg:            "Budget.Usecase.Category",
                logger:         logger,
                cfg:            cfg,
                dbMasterClient: dbMasterClient,
                categoryRepo:   categoryRepo,
        }
        return uc
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package category

import (
        "context"

        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"

        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
)

func (uc *UsecaseImpl) FindOneByID(
        ctx context.Context,
        id uint64,
        queryParams *uctypes.QueryGetOneParams,
) (*usecase.CategoryDTO, error) <span class="cov6" title="2">{
        const op = "FindOneByID"

        item, err := uc.categoryRepo.FindOneByID(ctx, id, queryParams)
        if err != nil </span><span class="cov1" title="1">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">dto, err := uc.entitiesToDTO(ctx, []*entity.Category{item})
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">if len(dto) == 0 </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrInternal, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return dto[0], nil</span>
}

func (uc *UsecaseImpl) FindList(
        ctx context.Context,
        listOptions *usecase.CategoryListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]*usecase.CategoryDTO, error) <span class="cov10" title="3">{
        const op = "FindList"

        items, err := uc.categoryRepo.FindList(ctx, listOptions, queryParams)
        if err != nil </span><span class="cov1" title="1">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov6" title="2">out, err := uc.entitiesToDTO(ctx, items)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov6" title="2">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package transaction

import (
        "context"
        "errors"
        "fmt"
        "time"

        "cloud.google.com/go/civil"
        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/loghandler"
        "github.com/m11ano/budget_planner/backend/ledger/pkg/pgclient"
        "github.com/samber/lo"
)

func (uc *UsecaseImpl) CreateTransactionByDTO(
        ctx context.Context,
        in usecase.CreateTransactionDataInput,
) (*usecase.TransactionDTO, error) <span class="cov10" title="2">{
        const op = "CreateTransactionByDTO"

        if auth.IsNeedToCheckRights(ctx) </span><span class="cov0" title="0">{
                authData := auth.GetAuthData(ctx)
                if authData == nil || authData.AccountID != in.AccountID </span><span class="cov0" title="0">{
                        return nil, appErrors.ErrForbidden
                }</span>
        }

        <span class="cov10" title="2">transaction, err := entity.NewTransaction(
                in.AccountID,
                in.IsIncome,
                in.Amount,
                in.OccurredOn,
                in.CategoryID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov10" title="2">err = transaction.SetDescription(in.Description)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov10" title="2">err = uc.dbMasterClient.DoWithIsoLvl(ctx, pgclient.Serializable, func(ctx context.Context) error </span><span class="cov10" title="2">{
                _, err := uc.categoryRepo.FindOneByID(ctx, transaction.CategoryID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, appErrors.ErrNotFound) </span><span class="cov0" title="0">{
                                return appErrors.Chainf(appErrors.ErrBadRequest.WithHints("category not found"), "%s.%s", uc.pkg, op)
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov10" title="2">if !in.IsIncome </span><span class="cov1" title="1">{
                        period := civil.Date{
                                Year:  transaction.OccurredOn.Year,
                                Month: transaction.OccurredOn.Month,
                                Day:   1,
                        }

                        budgetCheck, err := uc.budgetRepo.FindList(ctx, &amp;usecase.BudgetListOptions{
                                FilterAccountID:  &amp;transaction.AccountID,
                                FilterPeriod:     &amp;period,
                                FilterCategoryID: &amp;transaction.CategoryID,
                        }, &amp;uctypes.QueryGetListParams{
                                Limit: 1,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov1" title="1">if len(budgetCheck) &gt; 0 </span><span class="cov0" title="0">{
                                budget := budgetCheck[0]

                                periodEnd := period.AddMonths(1).AddDays(-1)

                                reports, err := uc.transactionRepo.CountReportItems(ctx, usecase.CountReportItemsQueryFilter{
                                        AccountID:  transaction.AccountID,
                                        DateFrom:   &amp;period,
                                        DateTo:     &amp;periodEnd,
                                        CategoryID: &amp;transaction.CategoryID,
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">balance := transaction.Amount
                                for _, report := range reports </span><span class="cov0" title="0">{
                                        if report.Sum != nil </span><span class="cov0" title="0">{
                                                balance, err = balance.Add(*report.Sum)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                        }
                                }

                                <span class="cov0" title="0">if balance.Cmp(budget.Amount.Neg()) == -1 </span><span class="cov0" title="0">{
                                        return appErrors.Chainf(appErrors.ErrBadRequest.WithHints("budget limit exceeded"), "%s.%s", uc.pkg, op)
                                }</span>
                        }
                }

                <span class="cov10" title="2">err = uc.transactionRepo.Create(ctx, transaction)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov10" title="2">return nil</span>
        })
        <span class="cov10" title="2">if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov10" title="2">transactionDTO, err := uc.entitiesToDTO(ctx, []*entity.Transaction{transaction})
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov10" title="2">if len(transactionDTO) == 0 </span><span class="cov0" title="0">{
                uc.logger.ErrorContext(loghandler.WithSource(ctx), "unpredicted empty transaction dto")
                return nil, appErrors.Chainf(appErrors.ErrInternal, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov10" title="2">return transactionDTO[0], nil</span>
}

func (uc *UsecaseImpl) PatchTransactionByDTO(
        ctx context.Context,
        id uuid.UUID,
        in usecase.PatchTransactionDataInput,
        skipVersionCheck bool,
) error <span class="cov1" title="1">{
        const op = "PatchTransactionByDTO"

        err := uc.dbMasterClient.DoWithIsoLvl(ctx, pgclient.Serializable, func(ctx context.Context) error </span><span class="cov1" title="1">{
                transaction, err := uc.transactionRepo.FindOneByID(ctx, id, &amp;uctypes.QueryGetOneParams{
                        ForUpdate: true,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">if auth.IsNeedToCheckRights(ctx) </span><span class="cov0" title="0">{
                        authData := auth.GetAuthData(ctx)
                        if authData == nil || authData.AccountID != transaction.AccountID </span><span class="cov0" title="0">{
                                return appErrors.ErrForbidden
                        }</span>
                }

                <span class="cov1" title="1">if !skipVersionCheck &amp;&amp; transaction.Version() != in.Version </span><span class="cov0" title="0">{
                        return appErrors.ErrVersionConflict.
                                WithDetail("last_version", false, transaction.Version()).
                                WithDetail("last_updated_at", false, transaction.UpdatedAt)
                }</span>

                <span class="cov1" title="1">if in.CategoryID != nil </span><span class="cov0" title="0">{
                        _, err := uc.categoryRepo.FindOneByID(ctx, *in.CategoryID, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                if errors.Is(err, appErrors.ErrNotFound) </span><span class="cov0" title="0">{
                                        return appErrors.Chainf(appErrors.ErrBadRequest.WithHints("category not found"), "%s.%s", uc.pkg, op)
                                }</span>
                                <span class="cov0" title="0">return err</span>
                        }

                        <span class="cov0" title="0">transaction.CategoryID = *in.CategoryID</span>
                }

                <span class="cov1" title="1">if in.OccurredOn != nil </span><span class="cov0" title="0">{
                        err := transaction.SetOccuredOn(*in.OccurredOn)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov1" title="1">if in.Amount != nil </span><span class="cov1" title="1">{
                        if !transaction.IsIncome </span><span class="cov0" title="0">{
                                period := civil.Date{
                                        Year:  transaction.OccurredOn.Year,
                                        Month: transaction.OccurredOn.Month,
                                        Day:   1,
                                }

                                budgetCheck, err := uc.budgetRepo.FindList(ctx, &amp;usecase.BudgetListOptions{
                                        FilterAccountID:  &amp;transaction.AccountID,
                                        FilterPeriod:     &amp;period,
                                        FilterCategoryID: &amp;transaction.CategoryID,
                                }, &amp;uctypes.QueryGetListParams{
                                        Limit: 1,
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">if len(budgetCheck) &gt; 0 </span><span class="cov0" title="0">{
                                        budget := budgetCheck[0]

                                        periodEnd := period.AddMonths(1).AddDays(-1)

                                        reports, err := uc.transactionRepo.CountReportItems(ctx, usecase.CountReportItemsQueryFilter{
                                                AccountID:  transaction.AccountID,
                                                DateFrom:   &amp;period,
                                                DateTo:     &amp;periodEnd,
                                                CategoryID: &amp;transaction.CategoryID,
                                                ExcludeIDs: []uuid.UUID{transaction.ID},
                                        })
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>

                                        <span class="cov0" title="0">balance := *in.Amount
                                        for _, report := range reports </span><span class="cov0" title="0">{
                                                if report.Sum != nil </span><span class="cov0" title="0">{
                                                        balance, err = balance.Add(*report.Sum)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                return err
                                                        }</span>
                                                }
                                        }

                                        <span class="cov0" title="0">if balance.Cmp(budget.Amount.Neg()) == -1 </span><span class="cov0" title="0">{
                                                return appErrors.Chainf(appErrors.ErrBadRequest.WithHints("budget limit exceeded"), "%s.%s", uc.pkg, op)
                                        }</span>
                                }
                        }

                        <span class="cov1" title="1">err = transaction.SetAmount(*in.Amount)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov1" title="1">if in.Description != nil </span><span class="cov1" title="1">{
                        err = transaction.SetDescription(*in.Description)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov1" title="1">err = uc.transactionRepo.Update(ctx, transaction)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">return nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (uc *UsecaseImpl) DeleteTransactionByID(ctx context.Context, id uuid.UUID) error <span class="cov1" title="1">{
        const op = "DeleteTransactionByID"

        err := uc.dbMasterClient.Do(ctx, func(ctx context.Context) error </span><span class="cov1" title="1">{
                transaction, err := uc.transactionRepo.FindOneByID(ctx, id, &amp;uctypes.QueryGetOneParams{
                        ForUpdate: true,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">if auth.IsNeedToCheckRights(ctx) </span><span class="cov0" title="0">{
                        authData := auth.GetAuthData(ctx)
                        if authData == nil || authData.AccountID != transaction.AccountID </span><span class="cov0" title="0">{
                                return appErrors.ErrForbidden
                        }</span>
                }

                <span class="cov1" title="1">transaction.DeletedAt = lo.ToPtr(time.Now())

                err = uc.transactionRepo.Update(ctx, transaction)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">return nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (uc *UsecaseImpl) ImportTransactionsFromCSV(
        ctx context.Context,
        data []byte,
        accountID uuid.UUID,
) error <span class="cov1" title="1">{
        const op = "ImportTransactionsFromCSV"

        items, err := uc.transactionCSVRepo.ItemsFromCSV(ctx, data, accountID)
        if err != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">err = uc.dbMasterClient.DoWithIsoLvl(ctx, pgclient.Serializable, func(ctx context.Context) error </span><span class="cov1" title="1">{
                for idx, item := range items </span><span class="cov0" title="0">{
                        _, err := uc.CreateTransactionByDTO(ctx, usecase.CreateTransactionDataInput{
                                AccountID:   accountID,
                                IsIncome:    item.IsIncome,
                                Amount:      item.Amount,
                                OccurredOn:  item.OccurredOn,
                                CategoryID:  item.CategoryID,
                                Description: item.Description,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                appErr, ok := appErrors.ExtractError(err)
                                if ok </span><span class="cov0" title="0">{
                                        hints := appErr.Hints()
                                        hints = append(hints, fmt.Sprintf("line %d", idx+1))

                                        return appErrors.Chainf(appErr.WithHints(hints...), "%s.%s: line %d", uc.pkg, op, idx+1)
                                }</span>
                                <span class="cov0" title="0">return appErrors.Chainf(err, "%s.%s: line %d", uc.pkg, op, idx+1)</span>
                        }
                }

                <span class="cov1" title="1">return nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package transaction

import (
        "context"
        "fmt"
        "strings"

        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        "github.com/samber/lo"
)

func (uc *UsecaseImpl) entitiesToDTO(
        ctx context.Context,
        items []*entity.Transaction,
) ([]*usecase.TransactionDTO, error) <span class="cov8" title="7">{
        out := make([]*usecase.TransactionDTO, 0, len(items))

        categoriesIDs := lo.Map(items, func(item *entity.Transaction, _ int) uint64 </span><span class="cov10" title="9">{
                return item.CategoryID
        }</span>)

        <span class="cov8" title="7">categories, err := uc.categoryRepo.FindList(ctx, &amp;usecase.CategoryListOptions{
                FilterIDs: &amp;categoriesIDs,
        }, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="7">categoriesMap := lo.SliceToMap(categories, func(item *entity.Category) (uint64, *entity.Category) </span><span class="cov10" title="9">{
                return item.ID, item
        }</span>)

        <span class="cov8" title="7">for _, item := range items </span><span class="cov10" title="9">{
                resItem := &amp;usecase.TransactionDTO{
                        Transaction: item,
                }

                if category, ok := categoriesMap[item.CategoryID]; ok </span><span class="cov10" title="9">{
                        resItem.Category = category
                }</span>

                <span class="cov10" title="9">out = append(out, resItem)</span>
        }

        <span class="cov8" title="7">return out, nil</span>
}

func buildKeyForCountReportItems(queryFilter usecase.CountReportItemsQueryFilter) string <span class="cov1" title="1">{
        var strBuilder strings.Builder

        strBuilder.WriteString("Transaction::CountReportItems::")

        strBuilder.WriteString(queryFilter.AccountID.String())

        if queryFilter.DateFrom != nil </span><span class="cov0" title="0">{
                strBuilder.WriteString("::dateFrom:")
                strBuilder.WriteString(queryFilter.DateFrom.String())
        }</span>

        <span class="cov1" title="1">if queryFilter.DateTo != nil </span><span class="cov0" title="0">{
                strBuilder.WriteString("::dateTo:")
                strBuilder.WriteString(queryFilter.DateTo.String())
        }</span>

        <span class="cov1" title="1">if queryFilter.CategoryID != nil </span><span class="cov0" title="0">{
                strBuilder.WriteString("::categoryID:")
                strBuilder.WriteString(fmt.Sprintf("%d", *queryFilter.CategoryID))
        }</span>

        <span class="cov1" title="1">return strBuilder.String()</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package transaction

import (
        "log/slog"

        "github.com/m11ano/budget_planner/backend/ledger/internal/app/config"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/db"
        "golang.org/x/sync/singleflight"
)

type UsecaseImpl struct {
        pkg                  string
        logger               *slog.Logger
        cfg                  config.Config
        dbMasterClient       db.MasterClient
        sfGroup              singleflight.Group
        transactionRepo      usecase.TransactionRepository
        transactionCacheRepo usecase.TransactionCacheRepository
        transactionCSVRepo   usecase.TransactionCSVRepository
        categoryRepo         usecase.CategoryRepository
        budgetRepo           usecase.BudgetRepository
}

func NewUsecaseImpl(
        logger *slog.Logger,
        cfg config.Config,
        dbMasterClient db.MasterClient,
        transactionRepo usecase.TransactionRepository,
        transactionCacheRepo usecase.TransactionCacheRepository,
        transactionCSVRepo usecase.TransactionCSVRepository,
        categoryRepo usecase.CategoryRepository,
        budgetRepo usecase.BudgetRepository,
) *UsecaseImpl <span class="cov10" title="11">{
        uc := &amp;UsecaseImpl{
                pkg:                  "Budget.Usecase.Transaction",
                logger:               logger,
                cfg:                  cfg,
                dbMasterClient:       dbMasterClient,
                transactionRepo:      transactionRepo,
                transactionCacheRepo: transactionCacheRepo,
                transactionCSVRepo:   transactionCSVRepo,
                categoryRepo:         categoryRepo,
                budgetRepo:           budgetRepo,
        }
        return uc
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package transaction

import (
        "context"
        "errors"
        "log/slog"
        "slices"
        "time"

        "cloud.google.com/go/civil"
        "github.com/google/uuid"
        "github.com/m11ano/budget_planner/backend/auth/pkg/auth"
        "github.com/m11ano/budget_planner/backend/ledger/internal/common/uctypes"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/entity"
        "github.com/m11ano/budget_planner/backend/ledger/internal/domain/budget/usecase"
        "github.com/m11ano/budget_planner/backend/ledger/internal/infra/loghandler"
        "github.com/m11ano/budget_planner/backend/ledger/pkg/pgclient"
        "github.com/samber/lo"

        appErrors "github.com/m11ano/budget_planner/backend/ledger/internal/app/errors"
)

func (uc *UsecaseImpl) FindOneByID(
        ctx context.Context,
        id uuid.UUID,
        queryParams *uctypes.QueryGetOneParams,
) (*usecase.TransactionDTO, error) <span class="cov1" title="1">{
        const op = "FindOneByID"

        item, err := uc.transactionRepo.FindOneByID(ctx, id, queryParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">if auth.IsNeedToCheckRights(ctx) </span><span class="cov0" title="0">{
                authData := auth.GetAuthData(ctx)
                if authData == nil || authData.AccountID != item.AccountID </span><span class="cov0" title="0">{
                        return nil, appErrors.ErrForbidden
                }</span>
        }

        <span class="cov1" title="1">dto, err := uc.entitiesToDTO(ctx, []*entity.Transaction{item})
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">if len(dto) == 0 </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(appErrors.ErrInternal, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return dto[0], nil</span>
}

func (uc *UsecaseImpl) FindList(
        ctx context.Context,
        listOptions *usecase.TransactionListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]*usecase.TransactionDTO, error) <span class="cov1" title="1">{
        const op = "FindList"

        items, err := uc.transactionRepo.FindList(ctx, listOptions, queryParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">out, err := uc.entitiesToDTO(ctx, items)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return out, nil</span>
}

func (uc *UsecaseImpl) FindPagedList(
        ctx context.Context,
        listOptions *usecase.TransactionListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]*usecase.TransactionDTO, uint64, error) <span class="cov10" title="2">{
        const op = "FindPagedList"

        items, total, err := uc.transactionRepo.FindPagedList(ctx, listOptions, queryParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov10" title="2">out, err := uc.entitiesToDTO(ctx, items)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov10" title="2">return out, total, nil</span>
}

func (uc *UsecaseImpl) FindListInMap(
        ctx context.Context,
        listOptions *usecase.TransactionListOptions,
        queryParams *uctypes.QueryGetListParams,
) (map[uuid.UUID]*usecase.TransactionDTO, error) <span class="cov1" title="1">{
        const op = "FindListInMap"

        items, err := uc.transactionRepo.FindList(ctx, listOptions, queryParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">out, err := uc.entitiesToDTO(ctx, items)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">result := lo.SliceToMap(out, func(item *usecase.TransactionDTO) (uuid.UUID, *usecase.TransactionDTO) </span><span class="cov10" title="2">{
                return item.Transaction.ID, item
        }</span>)

        <span class="cov1" title="1">return result, nil</span>
}

type CountReportItemsSFResult struct {
        Items    []*entity.ReportItem
        HitCache bool
}

var reportsCacheTTL = time.Second * 30

func (uc *UsecaseImpl) CountReportItems(
        ctx context.Context,
        queryFilter usecase.CountReportItemsQueryFilter,
) ([]*entity.ReportItem, bool, error) <span class="cov1" title="1">{
        const op = "CountReportItems"

        key := buildKeyForCountReportItems(queryFilter)

        result, err, _ := uc.sfGroup.Do(key, func() (any, error) </span><span class="cov1" title="1">{
                cacheItems, err := uc.transactionCacheRepo.GetReports(ctx, key)
                if err == nil </span><span class="cov1" title="1">{
                        uc.logger.InfoContext(ctx, "CountReportItems cache hit", slog.Any("key", key))

                        return CountReportItemsSFResult{
                                Items:    cacheItems,
                                HitCache: true,
                        }, nil
                }</span> else<span class="cov0" title="0"> if !errors.Is(err, appErrors.ErrNotFound) </span><span class="cov0" title="0">{
                        uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis get err", slog.Any("error", err))
                }</span>

                <span class="cov0" title="0">uc.logger.InfoContext(ctx, "CountReportItems cache miss", slog.Any("key", key))

                items, err := uc.countReportItems(ctx, queryFilter)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">err = uc.transactionCacheRepo.SaveReports(ctx, key, items, &amp;reportsCacheTTL)
                if err != nil </span><span class="cov0" title="0">{
                        uc.logger.ErrorContext(loghandler.WithSource(ctx), "redis save err", slog.Any("error", err))
                }</span>

                <span class="cov0" title="0">return CountReportItemsSFResult{
                        Items:    items,
                        HitCache: false,
                }, nil</span>
        })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, false, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">sfResult, ok := result.(CountReportItemsSFResult)
        if !ok </span><span class="cov0" title="0">{
                return nil, false, appErrors.Chainf(appErrors.ErrInternal, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return sfResult.Items, sfResult.HitCache, nil</span>
}

func (uc *UsecaseImpl) countReportItems(
        ctx context.Context,
        queryFilter usecase.CountReportItemsQueryFilter,
) ([]*entity.ReportItem, error) <span class="cov0" title="0">{
        const op = "CountReportItems"

        out := make([]*entity.ReportItem, 0)

        err := uc.dbMasterClient.DoWithIsoLvl(ctx, pgclient.RepeatableRead, func(ctx context.Context) error </span><span class="cov0" title="0">{
                var err error

                categories, err := uc.categoryRepo.FindList(ctx, &amp;usecase.CategoryListOptions{
                        Sort: []uctypes.SortOption[usecase.CategoryListOptionsSortField]{
                                {
                                        Field:  usecase.CategoryListOptionsSortFieldID,
                                        IsDesc: false,
                                },
                        },
                }, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if queryFilter.CategoryID != nil </span><span class="cov0" title="0">{
                        categories = lo.Filter(categories, func(item *entity.Category, _ int) bool </span><span class="cov0" title="0">{
                                return item.ID == *queryFilter.CategoryID
                        }</span>)
                }

                <span class="cov0" title="0">txReportItems, err := uc.transactionRepo.CountReportItems(ctx, queryFilter)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">slices.SortFunc(txReportItems, func(a, b *entity.AccountTransactionReportItem) int </span><span class="cov0" title="0">{
                        return a.Period.Compare(b.Period)
                }</span>)

                <span class="cov0" title="0">var dateStart civil.Date
                if queryFilter.DateFrom != nil </span><span class="cov0" title="0">{
                        dateStart = *queryFilter.DateFrom
                }</span> else<span class="cov0" title="0"> {
                        if len(txReportItems) == 0 </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">dateStart = txReportItems[0].Period</span>
                }

                <span class="cov0" title="0">var dateEnd civil.Date
                if queryFilter.DateTo != nil </span><span class="cov0" title="0">{
                        dateEnd = *queryFilter.DateTo
                }</span> else<span class="cov0" title="0"> {
                        if len(txReportItems) == 0 </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">dateEnd = txReportItems[len(txReportItems)-1].Period.AddMonths(1).AddDays(-1)</span>
                }

                <span class="cov0" title="0">periodStart := dateStart
                periodStart.Day = 1

                periodEnd := dateEnd
                periodEnd.Day = 1

                budgets, err := uc.budgetRepo.FindList(ctx, &amp;usecase.BudgetListOptions{
                        FilterAccountID:  &amp;queryFilter.AccountID,
                        FilterPeriodFrom: &amp;periodStart,
                        FilterPeriodTo:   &amp;periodEnd,
                }, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">for p := periodStart; p.Compare(periodEnd) &lt;= 0; p = p.AddMonths(1) </span><span class="cov0" title="0">{
                        item := &amp;entity.ReportItem{
                                AccountID: queryFilter.AccountID,
                                Items:     make([]*entity.AccountTransactionReportItem, 0),
                        }

                        if p.Compare(periodStart) == 0 </span><span class="cov0" title="0">{
                                item.DateFrom = dateStart
                        }</span> else<span class="cov0" title="0"> {
                                item.DateFrom = p
                        }</span>

                        <span class="cov0" title="0">if p.Compare(periodEnd) == 0 </span><span class="cov0" title="0">{
                                item.DateTo = dateEnd
                        }</span> else<span class="cov0" title="0"> {
                                item.DateTo = p.AddMonths(1).AddDays(-1)
                        }</span>

                        <span class="cov0" title="0">for _, category := range categories </span><span class="cov0" title="0">{
                                itemInReports, ok := lo.Find(txReportItems, func(item *entity.AccountTransactionReportItem) bool </span><span class="cov0" title="0">{
                                        return item.Period.Compare(p) == 0 &amp;&amp; item.CategoryID == category.ID
                                }</span>)

                                <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                                        item.Items = append(item.Items, itemInReports)
                                }</span> else<span class="cov0" title="0"> {
                                        repItem := &amp;entity.AccountTransactionReportItem{
                                                Period:     p,
                                                CategoryID: category.ID,
                                        }

                                        budgetForItem, ok := lo.Find(budgets, func(budget *entity.Budget) bool </span><span class="cov0" title="0">{
                                                return budget.CategoryID == category.ID &amp;&amp; budget.Period.Compare(repItem.Period) == 0
                                        }</span>)
                                        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                                                repItem.BudgetID = &amp;budgetForItem.ID
                                                repItem.BudgetAmount = &amp;budgetForItem.Amount
                                        }</span>

                                        <span class="cov0" title="0">item.Items = append(item.Items, repItem)</span>
                                }
                        }

                        <span class="cov0" title="0">out = append(out, item)</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov0" title="0">return out, nil</span>
}

func (uc *UsecaseImpl) FindPagedListAsCSV(
        ctx context.Context,
        listOptions *usecase.TransactionListOptions,
        queryParams *uctypes.QueryGetListParams,
) ([]byte, uint64, error) <span class="cov1" title="1">{
        const op = "FindPagedListAsCSV"

        items, total, err := uc.FindPagedList(ctx, listOptions, queryParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">data, err := uc.transactionCSVRepo.ItemsToCSV(ctx, items)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, appErrors.Chainf(err, "%s.%s", uc.pkg, op)
        }</span>

        <span class="cov1" title="1">return data, total, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
